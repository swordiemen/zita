@relation test

@attribute text string
@attribute ClassArff {correct,PixelHardcodeIgnoranceRule,LongMethodRule,SimplifyBooleanExpressions,IfElseStmtsMustUseBraces,VariableNamingConventions,DecentralizedEventHandlingRule,DrawingStateChangeRule,ShortVariable,TooManyFields,DecentralizedDrawingRule,EmptyIfStmt,AtLeastOneConstructor,LongParameterListRule,IfStmtsMustUseBraces,AvoidFieldNameMatchingMethodName,StdCyclomaticComplexity,AvoidFieldNameMatchingTypeName,EmptyStatementNotInLoop,StatelessClassRule,UncommentedEmptyConstructor,MethodNamingConventions,ForLoopsMustUseBraces,FieldDeclarationsShouldBeAtStartOfClass,UnusedFormalParameter,AvoidReassigningParameters,AvoidDeeplyNestedIfStmts,IdempotentOperations}

@data
'randomY - 3',correct
'vertex(randomX, randomY + 3)',correct
'randomY - 4',correct
'vertex(randomX, randomY - 12)',correct
'// Create lowest part of characterbeginShape();',correct
'randomY - 2',correct
'text("Hint: Try pressing the mouse to see what it can do", 500, 530);',PixelHardcodeIgnoranceRule
'randomY - 5',correct
'randomY - 6',correct
'bezierVertex(characterX - 5, characterY - 5, characterX - 10, characterY + 20, characterX - 20, characterY + 15);',correct
'{    colorMode(HSB);}',correct
'{    randomX = randomX - 2;}',correct
'arrayBigStar[i].move()',correct
'ellipse(characterX + 52, characterY + 5, 7, 9)',correct
'// If a key has been pressed, start drawing the creature, background and objectsif (stage == 1) {    background(0);    // Display and move the backgroundstars (Draw them on random positions)    for (int i = 0; i < 30; i++) {        arrayBigStar[i].display();        arrayBigStar[i].move();    }    for (int i = 0; i < 30; i++) {        arraySmallStar[i].display();        arraySmallStar[i].move();    }    // Display objects    body1.display();    eyes.display();    eyes.update();    beam1.display();}',correct
'"PRESS ANY KEY TO SEE THE MAJESTIC BEAST"',correct
'stroke(0);',correct
'stroke(0)',correct
'bezierVertex(characterX - 5, characterY - 5, characterX - 10, characterY + 20, characterX - 20, characterY + 15)',correct
'{    noStroke();    fill(255);    // Create eye when closed    arc(characterX + 50, characterY + 11, 14, 30, PI, TWO_PI);    arc(characterX + 28, characterY + 11, 14, 30, PI, TWO_PI);    strokeWeight(3);    stroke(0);    line(characterX + 55, characterY + 5, characterX + 44, characterY + 5);    line(characterX + 22, characterY + 5, characterX + 33, characterY + 5);}',correct
'arraySmallStar[i] = new smallStar(random(0, 1000), random(0, 1000));',correct
'void display() {    // Display the beam when the mouse is pressed    if (!newBeam) {        noStroke();        colorMode(HSB);        // Color changes over time to create a rainbow effect        if (rainbowcolor >= 255)            rainbowcolor = 0;        else            rainbowcolor++;        rainbowcolor++;        {            fill(rainbowcolor, 255, 255);        }        triangle(characterX + 100, characterY + 48, width + random(0, 300), characterY + 48 + 20, width + random(0, 300), characterY + 48 - 20);    }    colorMode(RGB);}',correct
'{    characterX = initX;    characterY = initY;    timer = 0;    rainbow = false;}',correct
'// Create eye when openarc(characterX + 50, characterY + 11, 14, 30, PI, TWO_PI);',correct
'{    arraySmallStar[i] = new smallStar(random(0, 1000), random(0, 1000));}',correct
'beam1.display()',correct
'bigStar[]',correct
'PFont',correct
'characterY = initY',correct
'Beam(float initX, float initY) {    characterX = initX;    characterY = initY;    timer = 0;    rainbow = false;}',correct
'if (blinkCounter >= 180 && blinkCounter < 190) {    isOpen = false;    blinkCounter++;} else if (blinkCounter >= 190) {    blinkCounter = 0;}',correct
'void move() {    // Make the stars move to the left at a constant speed    if (starmovement >= 255)        starmovement = 0;    else        starmovement++;    starmovement++;    {        randomX = randomX - 2;    }    if (randomX <= -8) {        randomX = width;    }}',correct
'bezierVertex(characterX + 125, characterY + 14, characterX + 100, characterY + 63, characterX + 50, characterY + 65)',correct
'fill(0);',correct
'void move(float mouseX_, float mouseY_) {    // Move object    characterX = mouseX_;    characterY = mouseY_;}',correct
'eyes',correct
'smallStar[] arraySmallStar = new smallStar[30];',correct
'vertex(randomX - 12, randomY - 4);',correct
'textAlign(CENTER)',correct
'fill(rainbowcolor, 255, 255)',correct
'vertex(randomX, randomY + 3);',correct
'ellipse(characterX + 20, characterY + 70, 50, 30)',correct
'characterY',correct
'{    if (isOpen) {        noStroke();        fill(255);        // Create eye when open        arc(characterX + 50, characterY + 11, 14, 30, PI, TWO_PI);        arc(characterX + 28, characterY + 11, 14, 30, PI, TWO_PI);        fill(0);        ellipse(characterX + 52, characterY + 5, 7, 9);        ellipse(characterX + 30, characterY + 5, 7, 9);    } else {        noStroke();        fill(255);        // Create eye when closed        arc(characterX + 50, characterY + 11, 14, 30, PI, TWO_PI);        arc(characterX + 28, characterY + 11, 14, 30, PI, TWO_PI);        strokeWeight(3);        stroke(0);        line(characterX + 55, characterY + 5, characterX + 44, characterY + 5);        line(characterX + 22, characterY + 5, characterX + 33, characterY + 5);    }}',correct
'randomY + 10',correct
'characterX',correct
'blinkCounter >= 180 && blinkCounter < 190',correct
'vertex(randomX + 6, randomY - 2)',correct
'quadraticVertex(characterX + 20, characterY - 33, characterX + 65, characterY - 13)',correct
'noCursor();',correct
'quadraticVertex(characterX + 105, characterY + 45, characterX + 95, characterY + 54);',correct
'void draw() {    // If no key has been pressed show a start screen    if (stage == 0) {        background(3, 16, 38);        textAlign(CENTER);        textSize(35);        text("PRESS ANY KEY TO SEE THE MAJESTIC BEAST", 500, 500);        textSize(15);        text("Hint: Try pressing the mouse to see what it can do", 500, 530);        if (keyPressed == true) {            stage = 1;        }    }    // If a key has been pressed, start drawing the creature, background and objects    if (stage == 1) {        background(0);        // Display and move the backgroundstars (Draw them on random positions)        for (int i = 0; i < 30; i++) {            arrayBigStar[i].display();            arrayBigStar[i].move();        }        for (int i = 0; i < 30; i++) {            arraySmallStar[i].display();            arraySmallStar[i].move();        }        // Display objects        body1.display();        eyes.display();        eyes.update();        beam1.display();    }}',correct
'colorMode(HSB)',correct
'new Body(300, 300)',correct
'// Move objectcharacterX = mouseX_;',correct
'eyes.update()',correct
'vertex(randomX + 12, randomY - 4);',correct
'blinkCounter >= 180',correct
'newBeam',correct
'characterY + 118',correct
'vertex(randomX - 3, randomY + 1)',correct
'eyes.move(mouseX, mouseY)',correct
'// Create eye when closedarc(characterX + 50, characterY + 11, 14, 30, PI, TWO_PI);',correct
'vertex(randomX, randomY + 6)',correct
'fill(255, 190, 127)',correct
'randomY - 12',correct
'characterX = initX;',correct
'vertex(characterX + 17, characterY + 90);',correct
'vertex(characterX - 20, characterY)',correct
'starmovement = 0',correct
'arc(characterX + 51, characterY + 37, 7, 15, 0, PI, CHORD)',correct
'vertex(randomX + 6, randomY - 2);',correct
'stage == 0',correct
'quadraticVertex(characterX - 26, characterY + 37, characterX - 44, characterY + 37)',correct
'stage == 1',correct
'bezierVertex(characterX + 104, characterY + 47, characterX + 81, characterY + 81, characterX + 71, characterY + 68);',correct
'{    // Move objects when mouse is dragged    body1.move(mouseX, mouseY);    eyes.move(mouseX, mouseY);    beam1.move(mouseX, mouseY);}',correct
'arraySmallStar = new smallStar[30]',correct
'arraySmallStar[i]',correct
'smallStar',correct
'rainbowcolor++;',correct
'noCursor()',correct
'arrayBigStar[i].display();',correct
'{    blinkCounter++;    isOpen = true;}',correct
'Processing',correct
'void mousePressed() {    // When mousepressed newBeam should be false    newBeam = false;}',correct
'new smallStar[30]',correct
'vertex(characterX + 48, characterY + 63)',correct
'{    blinkCounter = 0;}',correct
'new Eye(300, 300)',correct
'arc(characterX + 25, characterY + 35, 7, 15, 0, PI + 0.3f, CHORD)',correct
'for (int i = 0; i < 30; i++) {    arraySmallStar[i] = new smallStar(random(0, 1000), random(0, 1000));}',correct
'line(characterX + 22, characterY + 5, characterX + 33, characterY + 5)',correct
'{    noStroke();    fill(149, 156, 168);    // Create head    beginShape();    vertex(characterX, characterY);    quadraticVertex(characterX + 20, characterY - 33, characterX + 65, characterY - 13);    bezierVertex(characterX + 68, characterY + 55, characterX + 63, characterY + 35, characterX - 8, characterY + 25);    endShape(CLOSE);    // Create object left next to head    beginShape();    vertex(characterX - 20, characterY);    quadraticVertex(characterX - 20, characterY - 18, characterX, characterY - 20);    bezierVertex(characterX - 5, characterY - 5, characterX - 10, characterY + 20, characterX - 20, characterY + 15);    endShape(CLOSE);    // Create jaw    beginShape();    vertex(characterX + 10, characterY + 50);    quadraticVertex(characterX - 15, characterY + 50, characterX, characterY + 30);    bezierVertex(characterX + 50, characterY + 63, characterX + 45, characterY + 40, characterX + 45, characterY + 54);    endShape(CLOSE);    // Draw torso    ellipse(characterX + 20, characterY + 70, 50, 30);    // Create lowest part of character    beginShape();    vertex(characterX + 17, characterY + 90);    quadraticVertex(characterX - 45, characterY + 77, characterX + 30, characterY + 91);    bezierVertex(characterX - 14, characterY + 109, characterX - 16, characterY + 105, characterX - 17, characterY + 78);    endShape(CLOSE);    if (newBeam == false) {        fill(149, 156, 168);        // Create left arm in active position        beginShape();        vertex(characterX + 50, characterY + 65);        quadraticVertex(characterX + 114, characterY + 45, characterX + 50, characterY + 65);        bezierVertex(characterX + 125, characterY + 14, characterX + 100, characterY + 63, characterX + 50, characterY + 65);        endShape(CLOSE);        // Create right arm in active position        beginShape();        vertex(characterX + 85, characterY + 60);        quadraticVertex(characterX + 105, characterY + 45, characterX + 95, characterY + 54);        bezierVertex(characterX + 104, characterY + 47, characterX + 81, characterY + 81, characterX + 71, characterY + 68);        endShape(CLOSE);    }    if (newBeam == true) {        fill(149, 156, 168);        // Create right arm in resting position        beginShape();        vertex(characterX + 48, characterY + 63);        quadraticVertex(characterX + 57, characterY + 75, characterX + 67, characterY + 102);        bezierVertex(characterX + 73, characterY + 118, characterX + 56, characterY + 131, characterX + 48, characterY + 63);        endShape(CLOSE);        // Create left arm in resting position        beginShape();        vertex(characterX - 5, characterY + 55);        quadraticVertex(characterX - 26, characterY + 37, characterX - 44, characterY + 37);        bezierVertex(characterX - 61, characterY + 29, characterX - 41, characterY + 53, characterX - 9, characterY + 58);        endShape(CLOSE);    }    noStroke();    fill(255);    // Create teeth    arc(characterX + 25, characterY + 35, 7, 15, 0, PI + 0.3f, CHORD);    arc(characterX + 51, characterY + 37, 7, 15, 0, PI, CHORD);    arc(characterX + 38, characterY + 45, 9, 17, PI, TWO_PI + 0.2f, CHORD);}',LongMethodRule
'characterY + 102',correct
'vertex(randomX - 12, randomY - 4)',correct
'0.2f',correct
'false',correct
'bezierVertex(characterX - 14, characterY + 109, characterX - 16, characterY + 105, characterX - 17, characterY + 78)',correct
'endShape(CLOSE);',correct
'bezierVertex(characterX + 68, characterY + 55, characterX + 63, characterY + 35, characterX - 8, characterY + 25)',correct
'line(characterX + 22, characterY + 5, characterX + 33, characterY + 5);',correct
'arraySmallStar[i].display()',correct
'// Display the beam when the mouse is pressedif (!newBeam) {    noStroke();    colorMode(HSB);    // Color changes over time to create a rainbow effect    if (rainbowcolor >= 255)        rainbowcolor = 0;    else        rainbowcolor++;    rainbowcolor++;    {        fill(rainbowcolor, 255, 255);    }    triangle(characterX + 100, characterY + 48, width + random(0, 300), characterY + 48 + 20, width + random(0, 300), characterY + 48 - 20);}',correct
'// Move object when mouse movesbody1.move(mouseX, mouseY);',correct
'blinkCounter >= 190',correct
'int blinkCounter;',correct
'void display() {    if (isOpen) {        noStroke();        fill(255);        // Create eye when open        arc(characterX + 50, characterY + 11, 14, 30, PI, TWO_PI);        arc(characterX + 28, characterY + 11, 14, 30, PI, TWO_PI);        fill(0);        ellipse(characterX + 52, characterY + 5, 7, 9);        ellipse(characterX + 30, characterY + 5, 7, 9);    } else {        noStroke();        fill(255);        // Create eye when closed        arc(characterX + 50, characterY + 11, 14, 30, PI, TWO_PI);        arc(characterX + 28, characterY + 11, 14, 30, PI, TWO_PI);        strokeWeight(3);        stroke(0);        line(characterX + 55, characterY + 5, characterX + 44, characterY + 5);        line(characterX + 22, characterY + 5, characterX + 33, characterY + 5);    }}',correct
'setup',correct
'characterY + 109',correct
'arc(characterX + 38, characterY + 45, 9, 17, PI, TWO_PI + 0.2f, CHORD)',correct
'characterY + 105',correct
'i = 0',correct
'{    // Move object    characterX = mouseX_;    characterY = mouseY_;}',correct
'// Color changes over time to create a rainbow effectif (rainbowcolor >= 255)    rainbowcolor = 0;else    rainbowcolor++;',correct
'characterX - 14',correct
'characterX + 71',correct
'characterX - 10',correct
'characterX + 73',correct
'0.3f',correct
'bezierVertex(characterX - 14, characterY + 109, characterX - 16, characterY + 105, characterX - 17, characterY + 78);',correct
'characterX - 16',correct
'random(0, 300)',correct
'characterX - 15',correct
'characterX - 17',correct
'{    // Make the stars move to the left at a constant speed    if (starmovement >= 255)        starmovement = 0;    else        starmovement++;    starmovement++;    {        randomX = randomX - 1;    }    if (randomX <= -8) {        randomX = width;    }}',correct
'beam1.move(mouseX, mouseY);',correct
'colorMode(HSB);',correct
'vertex(randomX, randomY - 6)',correct
'vertex(characterX + 48, characterY + 63);',correct
'vertex(randomX - 2, randomY - 3);',correct
'characterX + 81',correct
'bezierVertex(characterX - 61, characterY + 29, characterX - 41, characterY + 53, characterX - 9, characterY + 58);',correct
'void move(float mouseX_, float mouseY_) {    // Make the eyes move with the object    characterX = mouseX_;    characterY = mouseY_;}',correct
'characterX + 65',correct
'characterX + 67',correct
'vertex(randomX, randomY + 6);',correct
'arrayBigStar[i] = new bigStar(random(0, 1000), random(0, 1000))',correct
'characterX + 63',correct
'Body(float initX, float initY) {    characterX = initX;    characterY = initY;}',correct
'characterX + 68',correct
'float starmovement;',correct
'line(characterX + 55, characterY + 5, characterX + 44, characterY + 5);',correct
'// If no key has been pressed show a start screenif (stage == 0) {    background(3, 16, 38);    textAlign(CENTER);    textSize(35);    text("PRESS ANY KEY TO SEE THE MAJESTIC BEAST", 500, 500);    textSize(15);    text("Hint: Try pressing the mouse to see what it can do", 500, 530);    if (keyPressed == true) {        stage = 1;    }}',correct
'noStroke();',correct
'randomX + 12',correct
'beginShape()',correct
'arc(characterX + 50, characterY + 11, 14, 30, PI, TWO_PI)',correct
'randomY = initY',correct
'quadraticVertex(characterX + 105, characterY + 45, characterX + 95, characterY + 54)',correct
'blinkCounter = 0',correct
'isOpen = true',correct
'characterY + 131',correct
'characterX + 95',correct
'bezierVertex(characterX + 50, characterY + 63, characterX + 45, characterY + 40, characterX + 45, characterY + 54);',correct
'newBeam = true',correct
'bezierVertex(characterX + 125, characterY + 14, characterX + 100, characterY + 63, characterX + 50, characterY + 65);',correct
'quadraticVertex(characterX + 20, characterY - 33, characterX + 65, characterY - 13);',correct
'{    fill(149, 156, 168);    // Create left arm in active position    beginShape();    vertex(characterX + 50, characterY + 65);    quadraticVertex(characterX + 114, characterY + 45, characterX + 50, characterY + 65);    bezierVertex(characterX + 125, characterY + 14, characterX + 100, characterY + 63, characterX + 50, characterY + 65);    endShape(CLOSE);    // Create right arm in active position    beginShape();    vertex(characterX + 85, characterY + 60);    quadraticVertex(characterX + 105, characterY + 45, characterX + 95, characterY + 54);    bezierVertex(characterX + 104, characterY + 47, characterX + 81, characterY + 81, characterX + 71, characterY + 68);    endShape(CLOSE);}',SimplifyBooleanExpressions
'smallStar[]',correct
'{    arraySmallStar[i].display();    arraySmallStar[i].move();}',correct
'// Create teetharc(characterX + 25, characterY + 35, 7, 15, 0, PI + 0.3f, CHORD);',correct
'starmovement++',correct
'{    characterX = initX;    characterY = initY;    isOpen = true;    blinkCounter = 0;}',correct
'characterX - 20',correct
'characterX + 85',correct
'vertex(randomX - 8, randomY + 10)',correct
'Text',correct
'{    randomX = randomX - 1;}',IfElseStmtsMustUseBraces
'draw',correct
'characterX - 26',correct
'blinkCounter++;',correct
'quadraticVertex(characterX - 20, characterY - 18, characterX, characterY - 20);',correct
'vertex(randomX - 6, randomY + 2);',correct
'quadraticVertex(characterX - 45, characterY + 77, characterX + 30, characterY + 91);',correct
'bezierVertex(characterX - 61, characterY + 29, characterX - 41, characterY + 53, characterX - 9, characterY + 58)',correct
'rainbowcolor = 0',correct
'vertex(randomX - 2, randomY - 3)',correct
'characterX = mouseX_',correct
'vertex(characterX + 85, characterY + 60)',correct
'randomX = initX',correct
'void setup() {    // Set up arrays and objects    for (int i = 0; i < 30; i++) {        arrayBigStar[i] = new bigStar(random(0, 1000), random(0, 1000));    }    for (int i = 0; i < 30; i++) {        arraySmallStar[i] = new smallStar(random(0, 1000), random(0, 1000));    }    body1 = new Body(300, 300);    eyes = new Eye(300, 300);    beam1 = new Beam(300, 300);    noCursor();    newBeam = true;}',correct
'stage = 1',correct
'starmovement',correct
'mousePressed',correct
'stage = 0',correct
'vertex(randomX, randomY - 12);',correct
'boolean isOpen;',correct
'{    // Move object when mouse moves    body1.move(mouseX, mouseY);    eyes.move(mouseX, mouseY);    beam1.move(mouseX, mouseY);}',correct
'strokeWeight(3)',correct
'quadraticVertex(characterX + 114, characterY + 45, characterX + 50, characterY + 65)',correct
'beam1 = new Beam(300, 300);',correct
'{    noStroke();    fill(255, 190, 127);    // Create the star    beginShape();    vertex(randomX, randomY - 6);    vertex(randomX + 2, randomY - 3);    vertex(randomX + 6, randomY - 2);    vertex(randomX + 3, randomY + 1);    vertex(randomX + 4, randomY + 5);    vertex(randomX, randomY + 3);    vertex(randomX - 4, randomY + 5);    vertex(randomX - 3, randomY + 1);    vertex(randomX - 6, randomY - 2);    vertex(randomX - 2, randomY - 3);    endShape(CLOSE);}',correct
'characterX - 61',correct
'{    // Timer to change eye from open to closed and back    if (blinkCounter < 180) {        blinkCounter++;        isOpen = true;    } else if (blinkCounter >= 180 && blinkCounter < 190) {        isOpen = false;        blinkCounter++;    } else if (blinkCounter >= 190) {        blinkCounter = 0;    }}',correct
'quadraticVertex(characterX + 57, characterY + 75, characterX + 67, characterY + 102)',correct
'starmovement >= 255',correct
'characterX - 45',correct
'characterX - 44',correct
'rainbowcolor = 0;',correct
'// Set up arrays and objectsfor (int i = 0; i < 30; i++) {    arrayBigStar[i] = new bigStar(random(0, 1000), random(0, 1000));}',correct
'void',correct
'characterX - 41',correct
'vertex(randomX - 6, randomY - 2)',correct
'{    randomX = width;}',correct
'-8',correct
'beam1.display();',correct
'// Display objectsbody1.display();',correct
'starmovement = 0;',correct
'true',correct
'characterY = mouseY_',correct
'if (randomX <= -8) {    randomX = width;}',correct
'randomX',correct
'class Eye {    float characterX;    float characterY;    boolean isOpen;    int blinkCounter;    Eye(float initX, float initY) {        characterX = initX;        characterY = initY;        isOpen = true;        blinkCounter = 0;    }    void display() {        if (isOpen) {            noStroke();            fill(255);            // Create eye when open            arc(characterX + 50, characterY + 11, 14, 30, PI, TWO_PI);            arc(characterX + 28, characterY + 11, 14, 30, PI, TWO_PI);            fill(0);            ellipse(characterX + 52, characterY + 5, 7, 9);            ellipse(characterX + 30, characterY + 5, 7, 9);        } else {            noStroke();            fill(255);            // Create eye when closed            arc(characterX + 50, characterY + 11, 14, 30, PI, TWO_PI);            arc(characterX + 28, characterY + 11, 14, 30, PI, TWO_PI);            strokeWeight(3);            stroke(0);            line(characterX + 55, characterY + 5, characterX + 44, characterY + 5);            line(characterX + 22, characterY + 5, characterX + 33, characterY + 5);        }    }    void update() {        // Timer to change eye from open to closed and back        if (blinkCounter < 180) {            blinkCounter++;            isOpen = true;        } else if (blinkCounter >= 180 && blinkCounter < 190) {            isOpen = false;            blinkCounter++;        } else if (blinkCounter >= 190) {            blinkCounter = 0;        }    }    void move(float mouseX_, float mouseY_) {        // Make the eyes move with the object        characterX = mouseX_;        characterY = mouseY_;    }}',correct
'randomY',correct
'arraySmallStar[i].move();',correct
'{    noStroke();    fill(255);    // Create eye when open    arc(characterX + 50, characterY + 11, 14, 30, PI, TWO_PI);    arc(characterX + 28, characterY + 11, 14, 30, PI, TWO_PI);    fill(0);    ellipse(characterX + 52, characterY + 5, 7, 9);    ellipse(characterX + 30, characterY + 5, 7, 9);}',correct
'fill(149, 156, 168);',correct
'{    background(3, 16, 38);    textAlign(CENTER);    textSize(35);    text("PRESS ANY KEY TO SEE THE MAJESTIC BEAST", 500, 500);    textSize(15);    text("Hint: Try pressing the mouse to see what it can do", 500, 530);    if (keyPressed == true) {        stage = 1;    }}',correct
'// Create left arm in active positionbeginShape();',correct
'vertex(randomX - 4, randomY - 5)',correct
'vertex(randomX + 3, randomY + 1);',correct
'characterY + 48 - 20',correct
'quadraticVertex(characterX - 15, characterY + 50, characterX, characterY + 30)',correct
'timer',correct
'randomY = initY;',correct
'Body',correct
'vertex(randomX - 4, randomY + 5);',correct
'isOpen = false;',correct
'bigStar(float initX, float initY) {    randomX = initX;    randomY = initY;}',correct
'{    isOpen = false;    blinkCounter++;}',correct
'// Create left arm in resting positionbeginShape();',correct
'{    // When mousepressed newBeam should be false    newBeam = false;}',correct
'{    fill(149, 156, 168);    // Create right arm in resting position    beginShape();    vertex(characterX + 48, characterY + 63);    quadraticVertex(characterX + 57, characterY + 75, characterX + 67, characterY + 102);    bezierVertex(characterX + 73, characterY + 118, characterX + 56, characterY + 131, characterX + 48, characterY + 63);    endShape(CLOSE);    // Create left arm in resting position    beginShape();    vertex(characterX - 5, characterY + 55);    quadraticVertex(characterX - 26, characterY + 37, characterX - 44, characterY + 37);    bezierVertex(characterX - 61, characterY + 29, characterX - 41, characterY + 53, characterX - 9, characterY + 58);    endShape(CLOSE);}',SimplifyBooleanExpressions
'void move() {    // Make the stars move to the left at a constant speed    if (starmovement >= 255)        starmovement = 0;    else        starmovement++;    starmovement++;    {        randomX = randomX - 1;    }    if (randomX <= -8) {        randomX = width;    }}',correct
'background(3, 16, 38)',correct
'blinkCounter < 180',correct
'{    characterX = initX;    characterY = initY;}',correct
'fill(149, 156, 168)',correct
'random(0, 1000)',correct
'Beam beam1;',correct
'"Hint: Try pressing the mouse to see what it can do"',correct
'class Body {    float characterX;    float characterY;    Body(float initX, float initY) {        characterX = initX;        characterY = initY;    }    void display() {        noStroke();        fill(149, 156, 168);        // Create head        beginShape();        vertex(characterX, characterY);        quadraticVertex(characterX + 20, characterY - 33, characterX + 65, characterY - 13);        bezierVertex(characterX + 68, characterY + 55, characterX + 63, characterY + 35, characterX - 8, characterY + 25);        endShape(CLOSE);        // Create object left next to head        beginShape();        vertex(characterX - 20, characterY);        quadraticVertex(characterX - 20, characterY - 18, characterX, characterY - 20);        bezierVertex(characterX - 5, characterY - 5, characterX - 10, characterY + 20, characterX - 20, characterY + 15);        endShape(CLOSE);        // Create jaw        beginShape();        vertex(characterX + 10, characterY + 50);        quadraticVertex(characterX - 15, characterY + 50, characterX, characterY + 30);        bezierVertex(characterX + 50, characterY + 63, characterX + 45, characterY + 40, characterX + 45, characterY + 54);        endShape(CLOSE);        // Draw torso        ellipse(characterX + 20, characterY + 70, 50, 30);        // Create lowest part of character        beginShape();        vertex(characterX + 17, characterY + 90);        quadraticVertex(characterX - 45, characterY + 77, characterX + 30, characterY + 91);        bezierVertex(characterX - 14, characterY + 109, characterX - 16, characterY + 105, characterX - 17, characterY + 78);        endShape(CLOSE);        if (newBeam == false) {            fill(149, 156, 168);            // Create left arm in active position            beginShape();            vertex(characterX + 50, characterY + 65);            quadraticVertex(characterX + 114, characterY + 45, characterX + 50, characterY + 65);            bezierVertex(characterX + 125, characterY + 14, characterX + 100, characterY + 63, characterX + 50, characterY + 65);            endShape(CLOSE);            // Create right arm in active position            beginShape();            vertex(characterX + 85, characterY + 60);            quadraticVertex(characterX + 105, characterY + 45, characterX + 95, characterY + 54);            bezierVertex(characterX + 104, characterY + 47, characterX + 81, characterY + 81, characterX + 71, characterY + 68);            endShape(CLOSE);        }        if (newBeam == true) {            fill(149, 156, 168);            // Create right arm in resting position            beginShape();            vertex(characterX + 48, characterY + 63);            quadraticVertex(characterX + 57, characterY + 75, characterX + 67, characterY + 102);            bezierVertex(characterX + 73, characterY + 118, characterX + 56, characterY + 131, characterX + 48, characterY + 63);            endShape(CLOSE);            // Create left arm in resting position            beginShape();            vertex(characterX - 5, characterY + 55);            quadraticVertex(characterX - 26, characterY + 37, characterX - 44, characterY + 37);            bezierVertex(characterX - 61, characterY + 29, characterX - 41, characterY + 53, characterX - 9, characterY + 58);            endShape(CLOSE);        }        noStroke();        fill(255);        // Create teeth        arc(characterX + 25, characterY + 35, 7, 15, 0, PI + 0.3f, CHORD);        arc(characterX + 51, characterY + 37, 7, 15, 0, PI, CHORD);        arc(characterX + 38, characterY + 45, 9, 17, PI, TWO_PI + 0.2f, CHORD);    }    void move(float mouseX_, float mouseY_) {        // Move object        characterX = mouseX_;        characterY = mouseY_;    }}',correct
'characterX + 100',correct
'mouseDragged',correct
'vertex(randomX + 8, randomY + 10)',correct
'{    fill(rainbowcolor, 255, 255);}',correct
'characterY + 81',correct
'bezierVertex(characterX + 73, characterY + 118, characterX + 56, characterY + 131, characterX + 48, characterY + 63);',correct
'characterX + 104',correct
'void mouseReleased() {    // When mouse is not pressed newBeam should be true    newBeam = true;}',correct
'vertex(characterX, characterY)',correct
'characterY + 48 + 20',correct
'blinkCounter < 190',correct
'characterY - 18',correct
'Eye',correct
'// Classes for objectsBody body1;',correct
'characterX + 105',correct
'characterY + 75',correct
'fill(rainbowcolor, 255, 255);',correct
'mouseMoved',correct
'float timer;',correct
'characterY + 77',correct
'eyes.display();',correct
'vertex(characterX - 20, characterY);',correct
'width + random(0, 300)',correct
'characterY + 78',correct
'characterY - 13',correct
'eyes.update();',correct
'characterY + 91',correct
'characterY + 90',correct
'vertex(characterX + 10, characterY + 50)',correct
'arrayBigStar = new bigStar[30]',correct
'vertex(randomX - 8, randomY + 10);',correct
'void mouseMoved() {    // Move object when mouse moves    body1.move(mouseX, mouseY);    eyes.move(mouseX, mouseY);    beam1.move(mouseX, mouseY);}',correct
'new bigStar[30]',correct
'{    // When mouse is not pressed newBeam should be true    newBeam = true;}',correct
'vertex(randomX + 3, randomY + 1)',correct
'starmovement++;',IfElseStmtsMustUseBraces
'class bigStar {    float randomX;    float randomY;    float starmovement;    bigStar(float initX, float initY) {        randomX = initX;        randomY = initY;    }    void display() {        noStroke();        fill(255, 190, 127);        // Create the star        beginShape();        vertex(randomX, randomY - 12);        vertex(randomX + 3, randomY - 5);        vertex(randomX + 12, randomY - 4);        vertex(randomX + 6, randomY + 2);        vertex(randomX + 8, randomY + 10);        vertex(randomX, randomY + 6);        vertex(randomX - 8, randomY + 10);        vertex(randomX - 6, randomY + 2);        vertex(randomX - 12, randomY - 4);        vertex(randomX - 4, randomY - 5);        endShape(CLOSE);    }    void move() {        // Make the stars move to the left at a constant speed        if (starmovement >= 255)            starmovement = 0;        else            starmovement++;        starmovement++;        {            randomX = randomX - 2;        }        if (randomX <= -8) {            randomX = width;        }    }}',correct
'float rainbowcolor;',correct
'characterY - 20',correct
'vertex(randomX + 2, randomY - 3);',correct
'characterX + 10',correct
'{    arrayBigStar[i].display();    arrayBigStar[i].move();}',correct
'characterY + 60',correct
'randomX = width',correct
'vertex(characterX + 17, characterY + 90)',correct
'characterX + 17',correct
'{    // Set up arrays and objects    for (int i = 0; i < 30; i++) {        arrayBigStar[i] = new bigStar(random(0, 1000), random(0, 1000));    }    for (int i = 0; i < 30; i++) {        arraySmallStar[i] = new smallStar(random(0, 1000), random(0, 1000));    }    body1 = new Body(300, 300);    eyes = new Eye(300, 300);    beam1 = new Beam(300, 300);    noCursor();    newBeam = true;}',correct
'bigStar',correct
'mouseReleased',correct
'characterY + 58',correct
'Eye eyes;',correct
'quadraticVertex(characterX + 114, characterY + 45, characterX + 50, characterY + 65);',correct
'new smallStar(random(0, 1000), random(0, 1000))',correct
'characterY + 50',correct
'PFont Text;',VariableNamingConventions
'characterY + 53',correct
'characterY + 55',correct
'vertex(randomX - 6, randomY - 2);',correct
'{    noStroke();    fill(255, 190, 127);    // Create the star    beginShape();    vertex(randomX, randomY - 12);    vertex(randomX + 3, randomY - 5);    vertex(randomX + 12, randomY - 4);    vertex(randomX + 6, randomY + 2);    vertex(randomX + 8, randomY + 10);    vertex(randomX, randomY + 6);    vertex(randomX - 8, randomY + 10);    vertex(randomX - 6, randomY + 2);    vertex(randomX - 12, randomY - 4);    vertex(randomX - 4, randomY - 5);    endShape(CLOSE);}',correct
'characterY + 54',correct
'arc(characterX + 51, characterY + 37, 7, 15, 0, PI, CHORD);',correct
'characterY + 70',correct
'arrayBigStar[i].display()',correct
'blinkCounter',correct
'text("Hint: Try pressing the mouse to see what it can do", 500, 530)',correct
'isOpen = true;',correct
'eyes = new Eye(300, 300);',correct
'background(3, 16, 38);',correct
'vertex(randomX + 8, randomY + 10);',correct
'characterY + 63',correct
'rainbow = false',correct
'characterY + 65',correct
'characterY + 68',correct
'noStroke()',correct
'characterX + 33',correct
'eyes.display()',correct
'beam1.move(mouseX, mouseY)',correct
'characterY = initY;',correct
'randomX - 12',correct
'characterX + 30',correct
'void setup() {    colorMode(HSB);}',correct
'vertex(randomX - 4, randomY + 5)',correct
'characterX + 38',correct
'characterY + 37',correct
'beam1 = new Beam(300, 300)',correct
'bezierVertex(characterX + 104, characterY + 47, characterX + 81, characterY + 81, characterX + 71, characterY + 68)',correct
'characterY + 30',correct
'if (keyPressed == true) {    stage = 1;}',DecentralizedEventHandlingRule
'triangle(characterX + 100, characterY + 48, width + random(0, 300), characterY + 48 + 20, width + random(0, 300), characterY + 48 - 20)',correct
'characterY + 35',correct
'Eye(float initX, float initY) {    characterX = initX;    characterY = initY;    isOpen = true;    blinkCounter = 0;}',correct
'characterX + 20',correct
'characterX + 22',correct
'randomX = initX;',correct
'timer = 0',correct
'characterX + 28',correct
'textSize(15);',correct
'strokeWeight(3);',correct
'if (blinkCounter >= 190) {    blinkCounter = 0;}',correct
'characterX + 25',correct
'characterY + 48',correct
'characterY + 47',correct
'fill(0)',correct
'vertex(characterX + 50, characterY + 65);',correct
'bezierVertex(characterX + 68, characterY + 55, characterX + 63, characterY + 35, characterX - 8, characterY + 25);',correct
'{    noStroke();    colorMode(HSB);    // Color changes over time to create a rainbow effect    if (rainbowcolor >= 255)        rainbowcolor = 0;    else        rainbowcolor++;    rainbowcolor++;    {        fill(rainbowcolor, 255, 255);    }    triangle(characterX + 100, characterY + 48, width + random(0, 300), characterY + 48 + 20, width + random(0, 300), characterY + 48 - 20);}',correct
'characterY + 40',correct
'arrayBigStar[i].move();',correct
'void display() {    noStroke();    fill(149, 156, 168);    // Create head    beginShape();    vertex(characterX, characterY);    quadraticVertex(characterX + 20, characterY - 33, characterX + 65, characterY - 13);    bezierVertex(characterX + 68, characterY + 55, characterX + 63, characterY + 35, characterX - 8, characterY + 25);    endShape(CLOSE);    // Create object left next to head    beginShape();    vertex(characterX - 20, characterY);    quadraticVertex(characterX - 20, characterY - 18, characterX, characterY - 20);    bezierVertex(characterX - 5, characterY - 5, characterX - 10, characterY + 20, characterX - 20, characterY + 15);    endShape(CLOSE);    // Create jaw    beginShape();    vertex(characterX + 10, characterY + 50);    quadraticVertex(characterX - 15, characterY + 50, characterX, characterY + 30);    bezierVertex(characterX + 50, characterY + 63, characterX + 45, characterY + 40, characterX + 45, characterY + 54);    endShape(CLOSE);    // Draw torso    ellipse(characterX + 20, characterY + 70, 50, 30);    // Create lowest part of character    beginShape();    vertex(characterX + 17, characterY + 90);    quadraticVertex(characterX - 45, characterY + 77, characterX + 30, characterY + 91);    bezierVertex(characterX - 14, characterY + 109, characterX - 16, characterY + 105, characterX - 17, characterY + 78);    endShape(CLOSE);    if (newBeam == false) {        fill(149, 156, 168);        // Create left arm in active position        beginShape();        vertex(characterX + 50, characterY + 65);        quadraticVertex(characterX + 114, characterY + 45, characterX + 50, characterY + 65);        bezierVertex(characterX + 125, characterY + 14, characterX + 100, characterY + 63, characterX + 50, characterY + 65);        endShape(CLOSE);        // Create right arm in active position        beginShape();        vertex(characterX + 85, characterY + 60);        quadraticVertex(characterX + 105, characterY + 45, characterX + 95, characterY + 54);        bezierVertex(characterX + 104, characterY + 47, characterX + 81, characterY + 81, characterX + 71, characterY + 68);        endShape(CLOSE);    }    if (newBeam == true) {        fill(149, 156, 168);        // Create right arm in resting position        beginShape();        vertex(characterX + 48, characterY + 63);        quadraticVertex(characterX + 57, characterY + 75, characterX + 67, characterY + 102);        bezierVertex(characterX + 73, characterY + 118, characterX + 56, characterY + 131, characterX + 48, characterY + 63);        endShape(CLOSE);        // Create left arm in resting position        beginShape();        vertex(characterX - 5, characterY + 55);        quadraticVertex(characterX - 26, characterY + 37, characterX - 44, characterY + 37);        bezierVertex(characterX - 61, characterY + 29, characterX - 41, characterY + 53, characterX - 9, characterY + 58);        endShape(CLOSE);    }    noStroke();    fill(255);    // Create teeth    arc(characterX + 25, characterY + 35, 7, 15, 0, PI + 0.3f, CHORD);    arc(characterX + 51, characterY + 37, 7, 15, 0, PI, CHORD);    arc(characterX + 38, characterY + 45, 9, 17, PI, TWO_PI + 0.2f, CHORD);}',correct
'// Arrays for backgroundstarsbigStar[] arrayBigStar = new bigStar[30];',correct
'// Draw torsoellipse(characterX + 20, characterY + 70, 50, 30);',correct
'characterY + 45',correct
'characterX + 55',correct
'characterX + 56',correct
'characterX + 50',correct
'vertex(randomX, randomY - 6);',correct
'body1 = new Body(300, 300);',correct
'characterX + 125',correct
'characterX + 51',correct
'characterX + 52',correct
'textSize(35)',correct
'smallStar(float initX, float initY) {    randomX = initX;    randomY = initY;}',correct
'update',correct
'fill(255)',correct
'characterX + 57',correct
'{    // If no key has been pressed show a start screen    if (stage == 0) {        background(3, 16, 38);        textAlign(CENTER);        textSize(35);        text("PRESS ANY KEY TO SEE THE MAJESTIC BEAST", 500, 500);        textSize(15);        text("Hint: Try pressing the mouse to see what it can do", 500, 530);        if (keyPressed == true) {            stage = 1;        }    }    // If a key has been pressed, start drawing the creature, background and objects    if (stage == 1) {        background(0);        // Display and move the backgroundstars (Draw them on random positions)        for (int i = 0; i < 30; i++) {            arrayBigStar[i].display();            arrayBigStar[i].move();        }        for (int i = 0; i < 30; i++) {            arraySmallStar[i].display();            arraySmallStar[i].move();        }        // Display objects        body1.display();        eyes.display();        eyes.update();        beam1.display();    }}',correct
'text("PRESS ANY KEY TO SEE THE MAJESTIC BEAST", 500, 500)',correct
'eyes = new Eye(300, 300)',correct
'new bigStar(random(0, 1000), random(0, 1000))',correct
'characterY + 15',correct
'fill(255, 190, 127);',correct
'characterY + 14',correct
'arraySmallStar[i] = new smallStar(random(0, 1000), random(0, 1000))',correct
'characterY + 11',correct
'vertex(characterX, characterY);',correct
'characterY = mouseY_;',correct
'arc(characterX + 38, characterY + 45, 9, 17, PI, TWO_PI + 0.2f, CHORD);',correct
'characterX + 44',correct
'characterX + 45',correct
'characterX + 114',correct
'{    background(0);    // Display and move the backgroundstars (Draw them on random positions)    for (int i = 0; i < 30; i++) {        arrayBigStar[i].display();        arrayBigStar[i].move();    }    for (int i = 0; i < 30; i++) {        arraySmallStar[i].display();        arraySmallStar[i].move();    }    // Display objects    body1.display();    eyes.display();    eyes.update();    beam1.display();}',correct
'vertex(randomX - 6, randomY + 2)',correct
'characterX + 48',correct
'textAlign(CENTER);',correct
'characterY + 25',correct
'int i = 0',correct
'// Display and move the backgroundstars (Draw them on random positions)for (int i = 0; i < 30; i++) {    arrayBigStar[i].display();    arrayBigStar[i].move();}',correct
'characterY + 29',correct
'keyPressed == true',correct
'endShape(CLOSE)',correct
'characterY + 20',correct
'vertex(randomX - 4, randomY - 5);',correct
'// Create right arm in active positionbeginShape();',correct
'text("PRESS ANY KEY TO SEE THE MAJESTIC BEAST", 500, 500);',PixelHardcodeIgnoranceRule
'colorMode(RGB);',correct
'characterX - 9',correct
'characterX - 8',correct
'boolean rainbow;',correct
'quadraticVertex(characterX - 45, characterY + 77, characterX + 30, characterY + 91)',correct
'body1.move(mouseX, mouseY)',correct
'characterX - 5',correct
'randomX + 3',correct
'randomX + 2',correct
'background(0)',correct
'i < 30',correct
'rainbowcolor++',correct
'randomX + 6',correct
'float characterY;',correct
'randomX + 4',correct
'boolean newBeam;',correct
'randomX + 8',correct
'vertex(characterX - 5, characterY + 55);',correct
'// Create right arm in resting positionbeginShape();',correct
'void display() {    noStroke();    fill(255, 190, 127);    // Create the star    beginShape();    vertex(randomX, randomY - 12);    vertex(randomX + 3, randomY - 5);    vertex(randomX + 12, randomY - 4);    vertex(randomX + 6, randomY + 2);    vertex(randomX + 8, randomY + 10);    vertex(randomX, randomY + 6);    vertex(randomX - 8, randomY + 10);    vertex(randomX - 6, randomY + 2);    vertex(randomX - 12, randomY - 4);    vertex(randomX - 4, randomY - 5);    endShape(CLOSE);}',correct
'isOpen',correct
'vertex(characterX + 85, characterY + 60);',correct
'float stage = 0;',correct
'float characterX;',correct
'vertex(randomX + 6, randomY + 2)',correct
'float randomX;',correct
'textSize(15)',correct
'void update() {    // Timer to change eye from open to closed and back    if (blinkCounter < 180) {        blinkCounter++;        isOpen = true;    } else if (blinkCounter >= 180 && blinkCounter < 190) {        isOpen = false;        blinkCounter++;    } else if (blinkCounter >= 190) {        blinkCounter = 0;    }}',correct
'randomX = randomX - 2;',correct
'// Create object left next to headbeginShape();',correct
'ellipse(characterX + 30, characterY + 5, 7, 9);',correct
'{    stage = 1;}',correct
'vertex(randomX + 12, randomY - 4)',correct
'vertex(randomX - 3, randomY + 1);',correct
'[30]',correct
'vertex(characterX + 10, characterY + 50);',correct
'arrayBigStar[i]',correct
'quadraticVertex(characterX + 57, characterY + 75, characterX + 67, characterY + 102);',correct
'body1 = new Body(300, 300)',correct
'body1',correct
'float randomY;',correct
'colorMode(RGB)',correct
'void move(float mouseX_, float mouseY_) {    // Beam moves with the object    characterX = mouseX_;    characterY = mouseY_;}',correct
'rainbowcolor',correct
'randomX = randomX - 1;',correct
'display',correct
'background(0);',correct
'{    // Display the beam when the mouse is pressed    if (!newBeam) {        noStroke();        colorMode(HSB);        // Color changes over time to create a rainbow effect        if (rainbowcolor >= 255)            rainbowcolor = 0;        else            rainbowcolor++;        rainbowcolor++;        {            fill(rainbowcolor, 255, 255);        }        triangle(characterX + 100, characterY + 48, width + random(0, 300), characterY + 48 + 20, width + random(0, 300), characterY + 48 - 20);    }    colorMode(RGB);}',correct
'blinkCounter = 0;',correct
'// Make the stars move to the left at a constant speedif (starmovement >= 255)    starmovement = 0;else    starmovement++;',correct
'arrayBigStar[i] = new bigStar(random(0, 1000), random(0, 1000));',correct
'blinkCounter++',correct
'line(characterX + 55, characterY + 5, characterX + 44, characterY + 5)',correct
'characterX = initX',correct
'PI + 0.3f',correct
'// Create the starbeginShape();',correct
'bezierVertex(characterX + 50, characterY + 63, characterX + 45, characterY + 40, characterX + 45, characterY + 54)',correct
'// Move objects when mouse is draggedbody1.move(mouseX, mouseY);',correct
'vertex(randomX + 3, randomY - 5)',correct
'vertex(randomX + 4, randomY + 5);',correct
'characterY + 5',correct
'vertex(characterX - 5, characterY + 55)',correct
'triangle(characterX + 100, characterY + 48, width + random(0, 300), characterY + 48 + 20, width + random(0, 300), characterY + 48 - 20);',correct
'randomX = width;',correct
'// Create jawbeginShape();',correct
'quadraticVertex(characterX - 15, characterY + 50, characterX, characterY + 30);',correct
'vertex(randomX + 2, randomY - 3)',correct
'randomY + 2',correct
'// Create headbeginShape();',correct
'randomY + 1',correct
'randomY + 3',correct
'float initX',correct
'randomY + 6',correct
'float initY',correct
'randomY + 5',correct
'i++',correct
'isOpen = false',correct
'vertex(characterX + 50, characterY + 65)',correct
'class smallStar {    float randomX;    float randomY;    float starmovement;    smallStar(float initX, float initY) {        randomX = initX;        randomY = initY;    }    void display() {        noStroke();        fill(255, 190, 127);        // Create the star        beginShape();        vertex(randomX, randomY - 6);        vertex(randomX + 2, randomY - 3);        vertex(randomX + 6, randomY - 2);        vertex(randomX + 3, randomY + 1);        vertex(randomX + 4, randomY + 5);        vertex(randomX, randomY + 3);        vertex(randomX - 4, randomY + 5);        vertex(randomX - 3, randomY + 1);        vertex(randomX - 6, randomY - 2);        vertex(randomX - 2, randomY - 3);        endShape(CLOSE);    }    void move() {        // Make the stars move to the left at a constant speed        if (starmovement >= 255)            starmovement = 0;        else            starmovement++;        starmovement++;        {            randomX = randomX - 1;        }        if (randomX <= -8) {            randomX = width;        }    }}',correct
'{    randomX = initX;    randomY = initY;}',correct
'randomX - 1',correct
'fill(255);',correct
'for (int i = 0; i < 30; i++) {    arraySmallStar[i].display();    arraySmallStar[i].move();}',correct
'randomX - 4',correct
'// Beam moves with the objectcharacterX = mouseX_;',correct
'randomX - 3',correct
'randomX - 2',correct
'quadraticVertex(characterX - 26, characterY + 37, characterX - 44, characterY + 37);',correct
'randomX - 8',correct
'randomX - 6',correct
'newBeam == true',SimplifyBooleanExpressions
'float mouseY_',correct
'if (newBeam == true) {    fill(149, 156, 168);    // Create right arm in resting position    beginShape();    vertex(characterX + 48, characterY + 63);    quadraticVertex(characterX + 57, characterY + 75, characterX + 67, characterY + 102);    bezierVertex(characterX + 73, characterY + 118, characterX + 56, characterY + 131, characterX + 48, characterY + 63);    endShape(CLOSE);    // Create left arm in resting position    beginShape();    vertex(characterX - 5, characterY + 55);    quadraticVertex(characterX - 26, characterY + 37, characterX - 44, characterY + 37);    bezierVertex(characterX - 61, characterY + 29, characterX - 41, characterY + 53, characterX - 9, characterY + 58);    endShape(CLOSE);}',correct
'arraySmallStar[i].display();',correct
'ellipse(characterX + 30, characterY + 5, 7, 9)',correct
'newBeam == false',SimplifyBooleanExpressions
'vertex(randomX + 3, randomY - 5);',correct
'TWO_PI + 0.2f',correct
'rainbow',correct
'class Beam {    float characterX;    float characterY;    float timer;    boolean rainbow;    float rainbowcolor;    Beam(float initX, float initY) {        characterX = initX;        characterY = initY;        timer = 0;        rainbow = false;    }    void setup() {        colorMode(HSB);    }    void display() {        // Display the beam when the mouse is pressed        if (!newBeam) {            noStroke();            colorMode(HSB);            // Color changes over time to create a rainbow effect            if (rainbowcolor >= 255)                rainbowcolor = 0;            else                rainbowcolor++;            rainbowcolor++;            {                fill(rainbowcolor, 255, 255);            }            triangle(characterX + 100, characterY + 48, width + random(0, 300), characterY + 48 + 20, width + random(0, 300), characterY + 48 - 20);        }        colorMode(RGB);    }    void move(float mouseX_, float mouseY_) {        // Beam moves with the object        characterX = mouseX_;        characterY = mouseY_;    }}',correct
'{    arrayBigStar[i] = new bigStar(random(0, 1000), random(0, 1000));}',correct
'void display() {    noStroke();    fill(255, 190, 127);    // Create the star    beginShape();    vertex(randomX, randomY - 6);    vertex(randomX + 2, randomY - 3);    vertex(randomX + 6, randomY - 2);    vertex(randomX + 3, randomY + 1);    vertex(randomX + 4, randomY + 5);    vertex(randomX, randomY + 3);    vertex(randomX - 4, randomY + 5);    vertex(randomX - 3, randomY + 1);    vertex(randomX - 6, randomY - 2);    vertex(randomX - 2, randomY - 3);    endShape(CLOSE);}',correct
'void mouseDragged() {    // Move objects when mouse is dragged    body1.move(mouseX, mouseY);    eyes.move(mouseX, mouseY);    beam1.move(mouseX, mouseY);}',correct
'timer = 0;',correct
'ellipse(characterX + 52, characterY + 5, 7, 9);',correct
'randomX = randomX - 2',correct
'randomX = randomX - 1',correct
'if (newBeam == false) {    fill(149, 156, 168);    // Create left arm in active position    beginShape();    vertex(characterX + 50, characterY + 65);    quadraticVertex(characterX + 114, characterY + 45, characterX + 50, characterY + 65);    bezierVertex(characterX + 125, characterY + 14, characterX + 100, characterY + 63, characterX + 50, characterY + 65);    endShape(CLOSE);    // Create right arm in active position    beginShape();    vertex(characterX + 85, characterY + 60);    quadraticVertex(characterX + 105, characterY + 45, characterX + 95, characterY + 54);    bezierVertex(characterX + 104, characterY + 47, characterX + 81, characterY + 81, characterX + 71, characterY + 68);    endShape(CLOSE);}',correct
'new Beam(300, 300)',correct
'arraySmallStar[i].move()',correct
'float mouseX_',correct
'// Make the eyes move with the objectcharacterX = mouseX_;',correct
'bezierVertex(characterX + 73, characterY + 118, characterX + 56, characterY + 131, characterX + 48, characterY + 63)',correct
'Beam',correct
'!newBeam',correct
'characterY - 33',correct
'newBeam = false',correct
'arc(characterX + 28, characterY + 11, 14, 30, PI, TWO_PI)',correct
'rainbow = false;',correct
'vertex(randomX + 6, randomY + 2);',correct
'eyes.move(mouseX, mouseY);',correct
'rainbowcolor >= 255',correct
'vertex(randomX + 4, randomY + 5)',correct
'move',correct
'{    // Beam moves with the object    characterX = mouseX_;    characterY = mouseY_;}',correct
'stage = 1;',DrawingStateChangeRule
'quadraticVertex(characterX - 20, characterY - 18, characterX, characterY - 20)',correct
'body1.display()',correct
'randomX <= -8',correct
'{    // Make the eyes move with the object    characterX = mouseX_;    characterY = mouseY_;}',correct
'arc(characterX + 28, characterY + 11, 14, 30, PI, TWO_PI);',correct
'{    // Make the stars move to the left at a constant speed    if (starmovement >= 255)        starmovement = 0;    else        starmovement++;    starmovement++;    {        randomX = randomX - 2;    }    if (randomX <= -8) {        randomX = width;    }}',correct
'beam1',correct
'textSize(35);',correct
'newBeam = true;',correct
'characterY - 5',correct
'0 + 87 + c',correct
'EyesSmall = color(0, 0, 0);',correct
'i < rupsA.length',correct
'text("Click to make your rups Angry!!", 50, 50);',PixelHardcodeIgnoranceRule
'{    leafX = initX;    leafY = initY;    img = loadImage("Blad goede.png");}',correct
'50 * 0.45f',correct
'theta',correct
'loadImage("Blad goede.png")',correct
'a = 800',correct
'LeafD = new Leaf(width - 1500, random(0, 800));',correct
'leafX = width + img.width / 5',correct
'// ////////////////////////////////////////////////Rods headfill(0);',correct
'LeafB = new Leaf(width - 500, random(0, 800))',correct
'0 * PI',correct
'if (leafX < 0 - img.width / 5) {    leafX = width + img.width / 5;}',correct
'theta_vel = 0.1f',correct
'LeafD.display();',correct
'{    Yspeed = Yspeed * -1;}',correct
'PImage img;',correct
'translate(bodyX, bodyY);',correct
'new Leaf(width - 10, random(0, 800))',correct
'width + 800',correct
'if (pressed == true) {    d += PI / 3;    fill(255, 0, 0);    text("AAAAAAAAAAAAAAAAAH", 0 - 50, 0 - 200);} else {    d += PI / 2;}',SimplifyBooleanExpressions
'color(255, 0, 0)',correct
'void mousePressed() {    current.mvmtpressed(mouseX, mouseY);}',correct
'{    stroke(0, 0, 0);}',correct
'fill(0);',correct
'leafX = leafX - speed;',correct
'stroke(random(255), random(255), random(255));',correct
'void mvmtdragged(int a, int b) {    bodyX = a;    bodyY = b;}',ShortVariable
'LeafB.move();',correct
'd',correct
'img = loadImage("Blad goede.png");',correct
'bodyColor = color(255, 0, 0);',correct
'current.mvmtreleased()',correct
'bodyY > height - 90',correct
'r',correct
'class Leaf {    PImage img;    float leafX;    float leafY;    float speed = 2;    Leaf(float initX, float initY) {        leafX = initX;        leafY = initY;        img = loadImage("Blad goede.png");    }    void display() {        image(img, leafX, leafY, img.width / 5, img.height / 5);    }    void move() {        leafX = leafX - speed;        if (leafX < 0 - img.width / 5) {            leafX = width + img.width / 5;        }    }}',correct
'width - 500',correct
'x',correct
'y',correct
'line(0 + 25 + b, 0 + 87 + c, 0 + 25 + b, 0 + 110 + c)',correct
'(0.99f * theta_vel) + theta_acc',correct
'random(0, width * 2)',correct
'{    image(img, leafX, leafY, img.width / 5, img.height / 5);}',correct
'leafX = initX;',correct
'{    current.mvmtreleased();}',correct
'fill(random(255), random(255), random(255));',correct
'x = r * cos(theta * 2)',correct
'{    d += PI / 2;}',correct
'new Leaf(width - 9000, random(0, 800))',correct
'Yspeed = Yspeed * -1',correct
'line(45, -75, 40 + x, -150);',correct
'backgroundImg',correct
'int EyesSmall;',VariableNamingConventions
'pressed = false',correct
'0 + 110',correct
'{    leafX = width + img.width / 5;}',correct
'fill(bodyColor)',correct
'// zorgt ervoor dat de translate alleen tussen een bepaald gebied blijftpushMatrix();',correct
'img = loadImage("Blad goede.png")',correct
'LeafB.display()',correct
'sin(d)',correct
'stroke(0, 0, 0)',correct
'rupsA[i] = new Rups();',correct
'int EyesBig;',VariableNamingConventions
'LeafE.move()',correct
'pressed = true',correct
'Leaf(float initX, float initY) {    leafX = initX;    leafY = initY;    img = loadImage("Blad goede.png");}',correct
'width * 2',correct
'fill(bodyColor);',correct
'b = b - 100;',correct
'ellipse(0, 0, 180, 180);',correct
'leafX - speed',correct
'width - 10',correct
'0.1f',correct
'cos(theta * 2)',correct
'float x;',correct
'i < 8',correct
'{    fill(random(255), random(255), random(255));    strokeCap(ROUND);    stroke(random(255), random(255), random(255));    // rechts    line(+20, -43, +45, -70);    // links    line(-20, -48, -45, -70);}',SimplifyBooleanExpressions
'Processing',correct
'pressed = false;',correct
'pushMatrix()',correct
'LeafF',correct
'LeafG',correct
'LeafD',correct
'LeafE',correct
'line(-20, -48, -45, -70)',correct
'LeafB',correct
'LeafC',correct
'LeafA',correct
'LeafG = new Leaf(width + 300, random(0, 800));',correct
'// poothes rechts verticaalline(0 + 25 + b, 0 + 110 + c, 0 + 15 + b, 0 + 110 + c);',correct
'float moveBack;',correct
'void move() {    leafX = leafX - speed;    if (leafX < 0 - img.width / 5) {        leafX = width + img.width / 5;    }}',correct
'backgroundWhole',correct
'float y;',correct
'false',correct
'background(backgroundImg)',correct
'theta_vel = 0.1f;',correct
'{    stroke(random(255), random(255), random(255));}',correct
'LeafE = new Leaf(width - 9000, random(0, 800))',correct
'width - 9000',correct
'if (bodyY > height - 90) {    Yspeed = Yspeed * -1;}',correct
'setup',correct
'i = 0',correct
'{    bodyX = a;    bodyY = b;}',correct
'img.height / 5',correct
'{    // ///////////////lijf//////////////////////////////////////////////////////////////////////////////////////////    bodyX -= 4;    bodyY += Yspeed;    if (bodyX <= -1440) {        bodyX = random(width, width * 2);    }    if (bodyY > height - 90) {        Yspeed = Yspeed * -1;    }    if (bodyY < 90) {        Yspeed = Yspeed * -1;    }    if (pressed == true) {        stroke(random(255), random(255), random(255));    } else {        stroke(0, 0, 0);    }    fill(bodyColor);    int b = 800;    int a = 800;    int c = 0;    d = d + PI / 5;    for (int i = 0; i < 8; i++) {        // zorgt ervoor dat de translate alleen tussen een bepaald gebied blijft        pushMatrix();        strokeWeight(5);        translate(bodyX, bodyY);        ellipse(a, c, 180, 180);        if (pressed == true) {            d += PI / 3;            fill(255, 0, 0);            text("AAAAAAAAAAAAAAAAAH", 0 - 50, 0 - 200);        } else {            d += PI / 2;        }        // Pootje links horizontaal        line(0 - 25 + b, 0 + 87 + c, 0 - 25 + b, 0 + 110 + c);        // Pootjes links verticaal        line(0 - 25 + b, 0 + 110 + c, 0 - 35 + b, 0 + 110 + c);        // pootje rechts horizontaal        line(0 + 25 + b, 0 + 87 + c, 0 + 25 + b, 0 + 110 + c);        // poothes rechts verticaal        line(0 + 25 + b, 0 + 110 + c, 0 + 15 + b, 0 + 110 + c);        // pootje bewegen naar boven en onder        a = a - 100;        b = b - 100;        c += 40 * sin(d);        popMatrix();    }    // ///////////////////////////////////////////////////Head    fill(bodyColor);    pushMatrix();    translate(bodyX, bodyY);    ellipse(0, 0, 180, 180);    fill(EyesBig);    ellipse(-30, 0 - 30, 40, 40);    ellipse(35, 0 - 30, 40, 40);    fill(EyesSmall);    arc(-25, -30, 20, 20, 1 / 3f, 2 * PI - 1 / 3f, PIE);    arc(40, -30, 20, 20, 1 / 3f, 2 * PI - 1 / 3f, PIE);    noFill();    fill(0);    arc(0, 20, 60, 70, 0 * PI, PI, PIE);    if (pressed == true) {        fill(random(255), random(255), random(255));        strokeCap(ROUND);        stroke(random(255), random(255), random(255));        // rechts        line(+20, -43, +45, -70);        // links        line(-20, -48, -45, -70);    }    stroke(0, 0, 0);    // ////////////////////////////////////////////////Rods head    fill(0);    strokeWeight(5);    line(-45, -75, -45 + x, -150);    line(45, -75, 40 + x, -150);    popMatrix();    x = r * cos(theta * 2);    theta_vel = (0.99f * theta_vel) + theta_acc;    theta += theta_vel;}',LongMethodRule
'new Leaf(width - 1500, random(0, 800))',correct
'// pootje bewegen naar boven en ondera = a - 100;',correct
'new Leaf(width + 800, random(0, 800))',correct
'float bodyX;',correct
'new Leaf(width - 500, random(0, 800))',correct
'theta_acc = 0.0001f;',correct
'void mvmtpressed(int a, int b) {    bodyX = a;    bodyY = b;    pressed = true;    bodyColor = color(255, 0, 0);    EyesBig = color(random(255), random(255), random(255));    theta_acc = 0.01f;}',ShortVariable
'0.0001f',correct
'c += 40 * sin(d)',correct
'pressed',correct
'// ///////////////////////////////////////////////////// BEGIN LEAFLeafA.display();',correct
'width - 1500',correct
'void display() {    image(img, leafX, leafY, img.width / 5, img.height / 5);}',correct
'LeafG.display();',correct
'pressed = true;',correct
'strokeWeight(5);',correct
'// rechtsline(+20, -43, +45, -70);',correct
'float bodyY;',correct
'void mvmtreleased() {    bodyColor = color(0, 255, 0);    EyesBig = color(255, 255, 255);    pressed = false;    theta_acc = 0.001f;}',correct
'LeafF.display();',correct
'theta_acc = 0.01f;',correct
'current = rupsA[rupsA.length - 1]',correct
'textSize(60)',correct
'theta += theta_vel;',correct
'// ///////////////////////////////////////////////////Headfill(bodyColor);',correct
'line(0 - 25 + b, 0 + 110 + c, 0 - 35 + b, 0 + 110 + c)',correct
'theta += 1;',correct
'float theta_vel;',TooManyFields
'PI / 5',correct
'bodyY < 90',correct
'PI / 3',correct
'PI / 2',correct
'd = d + PI / 5;',correct
'line(+20, -43, +45, -70)',correct
'r * cos(theta * 2)',correct
'random(100, 600)',correct
'width + img.width / 5',correct
'angle',correct
'fill(EyesBig)',correct
'leafX = initX',correct
'textSize(60);',correct
'leafX = leafX - speed',correct
'prevMil = millis();',DrawingStateChangeRule
'fill(EyesSmall)',correct
'b = b - 100',correct
'LeafD.move()',correct
'draw',correct
'EyesBig = color(random(255), random(255), random(255))',correct
'arc(40, -30, 20, 20, 1 / 3f, 2 * PI - 1 / 3f, PIE)',correct
'float jitter;',correct
'LeafE.move();',correct
'float Yspeed = 5;',VariableNamingConventions
'40 + x',correct
'int b = 800;',correct
'theta_acc = 0.0001f',correct
'// Pootje links horizontaalline(0 - 25 + b, 0 + 87 + c, 0 - 25 + b, 0 + 110 + c);',correct
'LeafB.display();',correct
'0.01f',correct
'ellipse(-30, 0 - 30, 40, 40);',correct
'// ///////////////lijf//////////////////////////////////////////////////////////////////////////////////////////bodyX -= 4;',correct
'float r;',TooManyFields
'fill(255, 0, 0)',correct
'EyesBig = color(255, 255, 255)',correct
'int b',correct
'int a',correct
'// /////////////////////////////////////////////////// BEGIN RUPSfor (int i = 0; i < rupsA.length; i++) {    rupsA[i].display();}',correct
'LeafA.display()',correct
'theta * 2',correct
'float angle;',correct
'LeafA = new Leaf(width + 100, random(0, 800))',correct
'c += 40 * sin(d);',correct
'height - 90',correct
'void',correct
'-1',correct
'r = 50 * 0.45f',correct
'theta_vel = (0.99f * theta_vel) + theta_acc',correct
'LeafC.move()',correct
'0 + 15 + b',correct
'LeafF.move();',correct
'int a = 800;',correct
'a = a - 100',correct
'true',correct
'noFill();',correct
'popMatrix()',correct
'{    bodyColor = color(0, 255, 0);    EyesBig = color(255, 255, 255);    EyesSmall = color(0, 0, 0);    // niet 0 of 600 want dan blijft de rups steken    bodyY = random(100, 600);    bodyX = random(0, width * 2);    d = 0;    r = 50 * 0.45f;    theta += 1;    theta_vel = 0.1f;    theta_acc = 0.0001f;}',correct
'bodyY += Yspeed;',correct
'void mouseReleased() {    current.mvmtreleased();}',correct
'Rups() {    bodyColor = color(0, 255, 0);    EyesBig = color(255, 255, 255);    EyesSmall = color(0, 0, 0);    // niet 0 of 600 want dan blijft de rups steken    bodyY = random(100, 600);    bodyX = random(0, width * 2);    d = 0;    r = 50 * 0.45f;    theta += 1;    theta_vel = 0.1f;    theta_acc = 0.0001f;}',TooManyFields
'0 - img.width / 5',correct
'PImage backgroundImg;',correct
'"Click to make your rups Angry!!"',correct
'strokeWeight(5)',correct
'arc(0, 20, 60, 70, 0 * PI, PI, PIE)',correct
'{    bodyColor = color(0, 255, 0);    EyesBig = color(255, 255, 255);    pressed = false;    theta_acc = 0.001f;}',correct
'stroke(0, 0, 0);',correct
'theta_acc = 0.01f',correct
'theta += 1',correct
'float theta_acc;',correct
'image(img, leafX, leafY, img.width / 5, img.height / 5)',correct
'moveBack',correct
'line(-45, -75, -45 + x, -150);',correct
'image(img, leafX, leafY, img.width / 5, img.height / 5);',correct
'Rups[] rupsA;',correct
'rupsA[i].display();',correct
'line(0 - 25 + b, 0 + 87 + c, 0 - 25 + b, 0 + 110 + c)',correct
'0.45f',correct
'{    leafX = leafX - speed;    if (leafX < 0 - img.width / 5) {        leafX = width + img.width / 5;    }}',correct
'background(backgroundImg);',correct
'Yspeed = 5',correct
'arc(-25, -30, 20, 20, 1 / 3f, 2 * PI - 1 / 3f, PIE);',correct
'ellipse(a, c, 180, 180);',correct
'void draw() {    background(backgroundImg);    // ///////////////////////////////////////////////////// BEGIN LEAF    LeafA.display();    LeafA.move();    LeafB.display();    LeafB.move();    LeafC.display();    LeafC.move();    LeafD.display();    LeafD.move();    LeafE.display();    LeafE.move();    LeafF.display();    LeafF.move();    LeafG.display();    LeafG.move();    // /////////////////////////////////////////////////// BEGIN RUPS    for (int i = 0; i < rupsA.length; i++) {        rupsA[i].display();    }    // /////////////////////////////////////////////////// HOW MANY FRAMES/s    println(millis() - prevMil);    prevMil = millis();    // text linksboven    fill(255, 0, 0);    textSize(60);    text("Click to make your rups Angry!!", 50, 50);}',correct
'EyesSmall',correct
'float theta;',TooManyFields
'fill(EyesSmall);',correct
'prevMil',correct
'// niet 0 of 600 want dan blijft de rups stekenbodyY = random(100, 600);',correct
'{    backgroundImg = loadImage("dollarclubtree[1].jpg");    backgroundImg.resize(width, height);    // //////////////////////////////////////////////////// BEGIN LEAF    LeafA = new Leaf(width + 100, random(0, 800));    LeafB = new Leaf(width - 500, random(0, 800));    LeafC = new Leaf(width + 800, random(0, 800));    LeafD = new Leaf(width - 1500, random(0, 800));    LeafE = new Leaf(width - 9000, random(0, 800));    LeafF = new Leaf(width - 10, random(0, 800));    LeafG = new Leaf(width + 300, random(0, 800));    // /////////////////////////////////////////////////// Begin RUPS    rupsA = new Rups[10];    for (int i = 0; i < rupsA.length; i++) {        rupsA[i] = new Rups();    }    current = rupsA[rupsA.length - 1];}',correct
'int bodyWidth;',correct
'if (pressed == true) {    fill(random(255), random(255), random(255));    strokeCap(ROUND);    stroke(random(255), random(255), random(255));    // rechts    line(+20, -43, +45, -70);    // links    line(-20, -48, -45, -70);}',correct
'LeafD.move();',correct
'pushMatrix();',correct
'bodyY = b;',correct
'{    bodyX = random(width, width * 2);}',correct
'// /////////////////////////////////////////////////// Begin RUPSrupsA = new Rups[10];',correct
'int prevMil;',correct
'new Rups()',correct
'{    current.mvmtpressed(mouseX, mouseY);}',correct
'jitter',correct
'{    // zorgt ervoor dat de translate alleen tussen een bepaald gebied blijft    pushMatrix();    strokeWeight(5);    translate(bodyX, bodyY);    ellipse(a, c, 180, 180);    if (pressed == true) {        d += PI / 3;        fill(255, 0, 0);        text("AAAAAAAAAAAAAAAAAH", 0 - 50, 0 - 200);    } else {        d += PI / 2;    }    // Pootje links horizontaal    line(0 - 25 + b, 0 + 87 + c, 0 - 25 + b, 0 + 110 + c);    // Pootjes links verticaal    line(0 - 25 + b, 0 + 110 + c, 0 - 35 + b, 0 + 110 + c);    // pootje rechts horizontaal    line(0 + 25 + b, 0 + 87 + c, 0 + 25 + b, 0 + 110 + c);    // poothes rechts verticaal    line(0 + 25 + b, 0 + 110 + c, 0 + 15 + b, 0 + 110 + c);    // pootje bewegen naar boven en onder    a = a - 100;    b = b - 100;    c += 40 * sin(d);    popMatrix();}',correct
'LeafE = new Leaf(width - 9000, random(0, 800));',correct
'bodyX -= 4',correct
'-45 + x',correct
'fill(255, 0, 0);',correct
'// text linksbovenfill(255, 0, 0);',correct
'rupsA[i]',correct
'text("AAAAAAAAAAAAAAAAAH", 0 - 50, 0 - 200)',correct
'color(random(255), random(255), random(255))',correct
'random(width, width * 2)',correct
'new Leaf(width + 100, random(0, 800))',correct
'theta_vel = (0.99f * theta_vel) + theta_acc;',correct
'LeafC.display();',correct
'PImage',correct
'current',correct
'c = 0',correct
'theta += theta_vel',correct
'color(0, 255, 0)',correct
'width + 100',correct
'LeafF = new Leaf(width - 10, random(0, 800))',correct
'LeafC = new Leaf(width + 800, random(0, 800))',correct
'bodyX = random(0, width * 2)',correct
'0 - 25 + b',correct
'popMatrix();',correct
'millis() - prevMil',correct
'if (bodyX <= -1440) {    bodyX = random(width, width * 2);}',correct
'millis()',correct
'random(255)',correct
'line(0 + 25 + b, 0 + 110 + c, 0 + 15 + b, 0 + 110 + c)',correct
'if (bodyY < 90) {    Yspeed = Yspeed * -1;}',correct
'bodyX = random(0, width * 2);',correct
'LeafE.display();',correct
'void setup() {    backgroundImg = loadImage("dollarclubtree[1].jpg");    backgroundImg.resize(width, height);    // //////////////////////////////////////////////////// BEGIN LEAF    LeafA = new Leaf(width + 100, random(0, 800));    LeafB = new Leaf(width - 500, random(0, 800));    LeafC = new Leaf(width + 800, random(0, 800));    LeafD = new Leaf(width - 1500, random(0, 800));    LeafE = new Leaf(width - 9000, random(0, 800));    LeafF = new Leaf(width - 10, random(0, 800));    LeafG = new Leaf(width + 300, random(0, 800));    // /////////////////////////////////////////////////// Begin RUPS    rupsA = new Rups[10];    for (int i = 0; i < rupsA.length; i++) {        rupsA[i] = new Rups();    }    current = rupsA[rupsA.length - 1];}',correct
'current.mvmtpressed(mouseX, mouseY)',correct
'3f',correct
'{    rupsA[i] = new Rups();}',correct
'backgroundImg.resize(width, height);',correct
'int c = 0;',ShortVariable
'leafY',correct
'leafX',correct
'0 - 50',correct
'ellipse(a, c, 180, 180)',correct
'a - 100',correct
'ellipse(0, 0, 180, 180)',correct
'rupsA.length',correct
'bodyY = b',correct
'LeafG.move()',correct
'fill(EyesBig);',correct
'LeafA.move();',correct
'current = rupsA[rupsA.length - 1];',correct
'{    d += PI / 3;    fill(255, 0, 0);    text("AAAAAAAAAAAAAAAAAH", 0 - 50, 0 - 200);}',correct
'bodyColor = color(255, 0, 0)',correct
'x = r * cos(theta * 2);',correct
'0 + 110 + c',correct
'text("AAAAAAAAAAAAAAAAAH", 0 - 50, 0 - 200);',correct
'fill(0)',correct
'leafY = initY;',correct
'0 + 87',correct
'theta_vel',correct
'b = 800',correct
'img.height',correct
'prevMil = millis()',correct
'd = 0',correct
'd + PI / 5',correct
'int bodyColor;',correct
'float leafY;',correct
'0 - 25',correct
'void display() {    // ///////////////lijf//////////////////////////////////////////////////////////////////////////////////////////    bodyX -= 4;    bodyY += Yspeed;    if (bodyX <= -1440) {        bodyX = random(width, width * 2);    }    if (bodyY > height - 90) {        Yspeed = Yspeed * -1;    }    if (bodyY < 90) {        Yspeed = Yspeed * -1;    }    if (pressed == true) {        stroke(random(255), random(255), random(255));    } else {        stroke(0, 0, 0);    }    fill(bodyColor);    int b = 800;    int a = 800;    int c = 0;    d = d + PI / 5;    for (int i = 0; i < 8; i++) {        // zorgt ervoor dat de translate alleen tussen een bepaald gebied blijft        pushMatrix();        strokeWeight(5);        translate(bodyX, bodyY);        ellipse(a, c, 180, 180);        if (pressed == true) {            d += PI / 3;            fill(255, 0, 0);            text("AAAAAAAAAAAAAAAAAH", 0 - 50, 0 - 200);        } else {            d += PI / 2;        }        // Pootje links horizontaal        line(0 - 25 + b, 0 + 87 + c, 0 - 25 + b, 0 + 110 + c);        // Pootjes links verticaal        line(0 - 25 + b, 0 + 110 + c, 0 - 35 + b, 0 + 110 + c);        // pootje rechts horizontaal        line(0 + 25 + b, 0 + 87 + c, 0 + 25 + b, 0 + 110 + c);        // poothes rechts verticaal        line(0 + 25 + b, 0 + 110 + c, 0 + 15 + b, 0 + 110 + c);        // pootje bewegen naar boven en onder        a = a - 100;        b = b - 100;        c += 40 * sin(d);        popMatrix();    }    // ///////////////////////////////////////////////////Head    fill(bodyColor);    pushMatrix();    translate(bodyX, bodyY);    ellipse(0, 0, 180, 180);    fill(EyesBig);    ellipse(-30, 0 - 30, 40, 40);    ellipse(35, 0 - 30, 40, 40);    fill(EyesSmall);    arc(-25, -30, 20, 20, 1 / 3f, 2 * PI - 1 / 3f, PIE);    arc(40, -30, 20, 20, 1 / 3f, 2 * PI - 1 / 3f, PIE);    noFill();    fill(0);    arc(0, 20, 60, 70, 0 * PI, PI, PIE);    if (pressed == true) {        fill(random(255), random(255), random(255));        strokeCap(ROUND);        stroke(random(255), random(255), random(255));        // rechts        line(+20, -43, +45, -70);        // links        line(-20, -48, -45, -70);    }    stroke(0, 0, 0);    // ////////////////////////////////////////////////Rods head    fill(0);    strokeWeight(5);    line(-45, -75, -45 + x, -150);    line(45, -75, 40 + x, -150);    popMatrix();    x = r * cos(theta * 2);    theta_vel = (0.99f * theta_vel) + theta_acc;    theta += theta_vel;}',TooManyFields
'"AAAAAAAAAAAAAAAAAH"',correct
'bodyX = random(width, width * 2)',correct
'rupsA[rupsA.length - 1]',correct
'img.width / 5',correct
'pressed == true',SimplifyBooleanExpressions
'40 * sin(d)',correct
'EyesSmall = color(0, 0, 0)',correct
'class Rups {    int bodyWidth;    int bodyColor;    int EyesBig;    int EyesSmall;    float bodyY;    float bodyX;    float angle;    float jitter;    float move;    float moveBack;    float r;    float theta;    float theta_vel;    float theta_acc;    float x;    float y;    float d;    float Yspeed = 5;    boolean pressed;    Rups() {        bodyColor = color(0, 255, 0);        EyesBig = color(255, 255, 255);        EyesSmall = color(0, 0, 0);        // niet 0 of 600 want dan blijft de rups steken        bodyY = random(100, 600);        bodyX = random(0, width * 2);        d = 0;        r = 50 * 0.45f;        theta += 1;        theta_vel = 0.1f;        theta_acc = 0.0001f;    }    void display() {        // ///////////////lijf//////////////////////////////////////////////////////////////////////////////////////////        bodyX -= 4;        bodyY += Yspeed;        if (bodyX <= -1440) {            bodyX = random(width, width * 2);        }        if (bodyY > height - 90) {            Yspeed = Yspeed * -1;        }        if (bodyY < 90) {            Yspeed = Yspeed * -1;        }        if (pressed == true) {            stroke(random(255), random(255), random(255));        } else {            stroke(0, 0, 0);        }        fill(bodyColor);        int b = 800;        int a = 800;        int c = 0;        d = d + PI / 5;        for (int i = 0; i < 8; i++) {            // zorgt ervoor dat de translate alleen tussen een bepaald gebied blijft            pushMatrix();            strokeWeight(5);            translate(bodyX, bodyY);            ellipse(a, c, 180, 180);            if (pressed == true) {                d += PI / 3;                fill(255, 0, 0);                text("AAAAAAAAAAAAAAAAAH", 0 - 50, 0 - 200);            } else {                d += PI / 2;            }            // Pootje links horizontaal            line(0 - 25 + b, 0 + 87 + c, 0 - 25 + b, 0 + 110 + c);            // Pootjes links verticaal            line(0 - 25 + b, 0 + 110 + c, 0 - 35 + b, 0 + 110 + c);            // pootje rechts horizontaal            line(0 + 25 + b, 0 + 87 + c, 0 + 25 + b, 0 + 110 + c);            // poothes rechts verticaal            line(0 + 25 + b, 0 + 110 + c, 0 + 15 + b, 0 + 110 + c);            // pootje bewegen naar boven en onder            a = a - 100;            b = b - 100;            c += 40 * sin(d);            popMatrix();        }        // ///////////////////////////////////////////////////Head        fill(bodyColor);        pushMatrix();        translate(bodyX, bodyY);        ellipse(0, 0, 180, 180);        fill(EyesBig);        ellipse(-30, 0 - 30, 40, 40);        ellipse(35, 0 - 30, 40, 40);        fill(EyesSmall);        arc(-25, -30, 20, 20, 1 / 3f, 2 * PI - 1 / 3f, PIE);        arc(40, -30, 20, 20, 1 / 3f, 2 * PI - 1 / 3f, PIE);        noFill();        fill(0);        arc(0, 20, 60, 70, 0 * PI, PI, PIE);        if (pressed == true) {            fill(random(255), random(255), random(255));            strokeCap(ROUND);            stroke(random(255), random(255), random(255));            // rechts            line(+20, -43, +45, -70);            // links            line(-20, -48, -45, -70);        }        stroke(0, 0, 0);        // ////////////////////////////////////////////////Rods head        fill(0);        strokeWeight(5);        line(-45, -75, -45 + x, -150);        line(45, -75, 40 + x, -150);        popMatrix();        x = r * cos(theta * 2);        theta_vel = (0.99f * theta_vel) + theta_acc;        theta += theta_vel;    }    void mvmtpressed(int a, int b) {        bodyX = a;        bodyY = b;        pressed = true;        bodyColor = color(255, 0, 0);        EyesBig = color(random(255), random(255), random(255));        theta_acc = 0.01f;    }    void mvmtreleased() {        bodyColor = color(0, 255, 0);        EyesBig = color(255, 255, 255);        pressed = false;        theta_acc = 0.001f;    }    void mvmtdragged(int a, int b) {        bodyX = a;        bodyY = b;    }}',correct
'ellipse(35, 0 - 30, 40, 40)',correct
'0 - 30',correct
'// ///////////////////////////////////////////////////Head',correct
'Yspeed = Yspeed * -1;',correct
'float leafX;',correct
'0 - 35',correct
'width + 300',correct
'noFill()',correct
'leafY = initY',correct
'arc(0, 20, 60, 70, 0 * PI, PI, PIE);',correct
'bodyY = random(100, 600)',correct
'LeafF = new Leaf(width - 10, random(0, 800));',correct
'int i = 0',correct
'LeafG.move();',correct
'LeafB.move()',correct
'LeafC.display()',correct
'leafX = width + img.width / 5;',correct
'float move;',correct
'backgroundImg = loadImage("dollarclubtree[1].jpg");',correct
'0 - 200',correct
'// linksline(-20, -48, -45, -70);',correct
'rupsA',correct
'b - 100',correct
'leafX < 0 - img.width / 5',correct
'img.width',correct
'd += PI / 2;',correct
'color(255, 255, 255)',correct
'Rups current;',correct
'{    background(backgroundImg);    // ///////////////////////////////////////////////////// BEGIN LEAF    LeafA.display();    LeafA.move();    LeafB.display();    LeafB.move();    LeafC.display();    LeafC.move();    LeafD.display();    LeafD.move();    LeafE.display();    LeafE.move();    LeafF.display();    LeafF.move();    LeafG.display();    LeafG.move();    // /////////////////////////////////////////////////// BEGIN RUPS    for (int i = 0; i < rupsA.length; i++) {        rupsA[i].display();    }    // /////////////////////////////////////////////////// HOW MANY FRAMES/s    println(millis() - prevMil);    prevMil = millis();    // text linksboven    fill(255, 0, 0);    textSize(60);    text("Click to make your rups Angry!!", 50, 50);}',correct
'r = 50 * 0.45f;',correct
'Rups[]',correct
'int c = 0',correct
'-1440',correct
'LeafD.display()',correct
'rupsA[i] = new Rups()',correct
'LeafD = new Leaf(width - 1500, random(0, 800))',correct
'-150',correct
'current.mvmtpressed(mouseX, mouseY);',correct
'"dollarclubtree[1].jpg"',correct
'-20',correct
'translate(bodyX, bodyY)',correct
'-25',correct
'bodyX = a',correct
'for (int i = 0; i < 8; i++) {    // zorgt ervoor dat de translate alleen tussen een bepaald gebied blijft    pushMatrix();    strokeWeight(5);    translate(bodyX, bodyY);    ellipse(a, c, 180, 180);    if (pressed == true) {        d += PI / 3;        fill(255, 0, 0);        text("AAAAAAAAAAAAAAAAAH", 0 - 50, 0 - 200);    } else {        d += PI / 2;    }    // Pootje links horizontaal    line(0 - 25 + b, 0 + 87 + c, 0 - 25 + b, 0 + 110 + c);    // Pootjes links verticaal    line(0 - 25 + b, 0 + 110 + c, 0 - 35 + b, 0 + 110 + c);    // pootje rechts horizontaal    line(0 + 25 + b, 0 + 87 + c, 0 + 25 + b, 0 + 110 + c);    // poothes rechts verticaal    line(0 + 25 + b, 0 + 110 + c, 0 + 15 + b, 0 + 110 + c);    // pootje bewegen naar boven en onder    a = a - 100;    b = b - 100;    c += 40 * sin(d);    popMatrix();}',correct
'if (pressed == true) {    stroke(random(255), random(255), random(255));} else {    stroke(0, 0, 0);}',correct
'LeafE.display()',correct
'// Pootjes links verticaalline(0 - 25 + b, 0 + 110 + c, 0 - 35 + b, 0 + 110 + c);',correct
'float speed = 2;',correct
'Yspeed * -1',correct
'theta_acc = 0.001f',correct
'strokeCap(ROUND);',correct
'bodyX = a;',correct
'new Rups[10]',correct
'line(45, -75, 40 + x, -150)',correct
'ellipse(-30, 0 - 30, 40, 40)',correct
'LeafC = new Leaf(width + 800, random(0, 800));',correct
'new Leaf(width + 300, random(0, 800))',correct
'bodyY += Yspeed',correct
'current.mvmtreleased();',correct
'-30',correct
'EyesBig',correct
'float d;',ShortVariable
'arc(-25, -30, 20, 20, 1 / 3f, 2 * PI - 1 / 3f, PIE)',correct
'bodyX = random(width, width * 2);',correct
'Leaf',correct
'// /////////////////////////////////////////////////// HOW MANY FRAMES/sprintln(millis() - prevMil);',correct
'boolean pressed;',correct
'// pootje rechts horizontaalline(0 + 25 + b, 0 + 87 + c, 0 + 25 + b, 0 + 110 + c);',correct
'bodyColor = color(0, 255, 0)',correct
'display',LongMethodRule
'{    bodyX = a;    bodyY = b;    pressed = true;    bodyColor = color(255, 0, 0);    EyesBig = color(random(255), random(255), random(255));    theta_acc = 0.01f;}',correct
'random(0, 800)',correct
'd += PI / 3;',correct
'-43',correct
'LeafG.display()',correct
'-45',correct
'bodyX',correct
'backgroundImg.resize(width, height)',correct
'bodyY',correct
'-48',correct
'theta_acc = 0.001f;',correct
'LeafB = new Leaf(width - 500, random(0, 800));',correct
'loadImage("dollarclubtree[1].jpg")',correct
'rupsA.length - 1',correct
'bodyWidth',correct
'Rups',correct
'0 - 35 + b',correct
'd += PI / 3',correct
'd += PI / 2',correct
'float initX',correct
'float initY',correct
'i++',correct
'd = 0;',correct
'{    rupsA[i].display();}',correct
'Leaf LeafA, LeafB, LeafC, LeafD, LeafE, LeafF, LeafG;',VariableNamingConventions
'0 + 15',correct
'ellipse(35, 0 - 30, 40, 40);',correct
'text("Click to make your rups Angry!!", 50, 50)',correct
'backgroundImg = loadImage("dollarclubtree[1].jpg")',correct
'theta_acc',correct
'+20',correct
'color(0, 0, 0)',correct
'println(millis() - prevMil)',correct
'rupsA = new Rups[10]',correct
'int backgroundWhole;',correct
'LeafA.move()',correct
'speed = 2',correct
'bodyColor = color(0, 255, 0);',correct
'img',correct
'bodyColor',correct
'1 / 3f',correct
'-70',correct
'[10]',correct
'int b = 800',correct
'-75',correct
'line(-45, -75, -45 + x, -150)',correct
'EyesBig = color(random(255), random(255), random(255));',correct
'EyesBig = color(255, 255, 255);',correct
'LeafF.display()',correct
'0.001f',correct
'bodyX <= -1440',correct
'// //////////////////////////////////////////////////// BEGIN LEAFLeafA = new Leaf(width + 100, random(0, 800));',correct
'move',correct
'int a = 800',correct
'LeafC.move();',correct
'fill(random(255), random(255), random(255))',correct
'0 + 25 + b',correct
'+45',correct
'LeafF.move()',correct
'"Blad goede.png"',correct
'rupsA[i].display()',correct
'for (int i = 0; i < rupsA.length; i++) {    rupsA[i] = new Rups();}',correct
'd = d + PI / 5',correct
'stroke(random(255), random(255), random(255))',correct
'2 * PI',correct
'LeafG = new Leaf(width + 300, random(0, 800))',correct
'0 + 25',correct
'arc(40, -30, 20, 20, 1 / 3f, 2 * PI - 1 / 3f, PIE);',correct
'2 * PI - 1 / 3f',correct
'strokeCap(ROUND)',correct
'xcord = xcord - speed;',correct
'strokeWeight(7)',correct
'void draw() {    background(255);    creature.display();    creature.control();}',correct
'xcord + 275',correct
'ellipse(xcord + 10, ycord, 30, 30)',correct
'moveLeft == true',correct
'ycord - 455',correct
'{    creature.moveLeft = true;    creature.moveRight = false;}',correct
'4.0f',correct
'vertex(shoulderx, shouldery);',correct
'creature = new Figure(500, 800, 20)',correct
'creature.control()',correct
'strokeWeight(6)',correct
'background(255);',correct
'moveRight',correct
'frameRate(30);',correct
'creature.display()',correct
'vertex(xcord + 245, ycord - 20);',correct
'moveRight == true',correct
'moveLeft = false;',correct
'shoulderx + xd',correct
'vertex(xcord + 245, ycord - 20)',correct
'vertex(xcord + 200, ycord - 23);',correct
'ycord = y;',correct
'// stickman headstrokeWeight(7);',correct
'xcord = 1300',correct
'xcord = x',correct
'ellipse(xcord + 200, ycord, 30, 30)',correct
'{    background(255);    creature.display();    creature.control();}',correct
'vertex(xcord + 120, ycord - 300);',correct
'creature.moveLeft = true',correct
'Figure[] figures = new Figure[10];',correct
'xcord = -250;',correct
'line(xcord + 120, ycord - 300, xcord + 120, ycord - 405)',correct
'Figure',correct
'strokeWeight(8)',correct
'// STICKMAN',correct
'0 + 200 * sin(frameCount / 4.0f)',correct
'xcord = xcord + speed;',correct
'if (moveLeft == true) {    xcord = xcord - speed;}',correct
'creature.moveRight = false',correct
'// stickman torsostrokeWeight(8);',correct
'vertex(shoulderx - xd, shouldery + yd)',correct
'int shouldery = ycord - 400',correct
'void keyPressed() {    if (keyCode == RIGHT) {        creature.moveRight = true;        creature.moveLeft = false;    } else if (keyCode == LEFT) {        creature.moveLeft = true;        creature.moveRight = false;    }}',correct
'shouldery = ycord - 400',correct
'creature.moveRight = true;',correct
'creature.display();',correct
'// STICKMAN// stickman inner legsbeginShape();',correct
'creature.control();',correct
'frameRate(30)',correct
'int shoulderx = xcord + 120',correct
'ellipse(xcord + 120, ycord - 455, 65, 95)',correct
'// create class object   // xcord , ycord, speedcreature = new Figure(500, 800, 20);',correct
'xcord + 240',correct
'int ycord;',correct
'strokeJoin(ROUND)',correct
'xcord + 245',correct
'ycord - 300',correct
'xcord + 120',correct
'vertex(shoulderx - xd, shouldery + yd);',correct
'// BOARD',correct
'moveLeft',correct
'float yd = 0 + 200 * cos(frameCount / 4.0f)',correct
'creature',correct
'{    // BOARD    // lefl    strokeWeight(4);    ellipse(xcord + 10, ycord, 30, 30);    // right wheel    strokeWeight(4);    ellipse(xcord + 200, ycord, 30, 30);    // board horizontal    strokeWeight(6);    line(xcord - 45, ycord - 20, xcord + 240, ycord - 20);    // board backlip    beginShape();    noFill();    strokeWeight(6);    strokeJoin(ROUND);    vertex(xcord + 275, ycord - 35);    vertex(xcord + 245, ycord - 20);    vertex(xcord + 240, ycord - 20);    endShape();    // STICKMAN    // stickman inner legs    beginShape();    noFill();    strokeWeight(8);    strokeJoin(ROUND);    vertex(xcord + 40, ycord - 23);    vertex(xcord + 120, ycord - 300);    vertex(xcord + 200, ycord - 23);    endShape();    // stickman torso    strokeWeight(8);    line(xcord + 120, ycord - 300, xcord + 120, ycord - 405);    // stickman outerlegs    noFill();    strokeWeight(8);    strokeJoin(ROUND);    beginShape();    vertex(xcord + 40, ycord - 23);    vertex(xcord + 120, ycord - 200);    vertex(xcord + 200, ycord - 23);    endShape();    // stickman arms    noFill();    strokeWeight(8);    strokeJoin(ROUND);    beginShape();    int shoulderx = xcord + 120;    int shouldery = ycord - 400;    float xd = 0 + 200 * sin(frameCount / 4.0f);    float yd = 0 + 200 * cos(frameCount / 4.0f);    vertex(shoulderx - xd, shouldery + yd);    vertex(shoulderx, shouldery);    vertex(shoulderx + xd, shouldery + yd);    endShape();    // stickman head    strokeWeight(7);    ellipse(xcord + 120, ycord - 455, 65, 95);    strokeWeight(4);    ellipse(xcord + 10, ycord, 30, 30);}',LongMethodRule
'boolean moveLeft;',correct
'{    frameRate(30);    // create class object   // xcord , ycord, speed    creature = new Figure(500, 800, 20);    // use creature. ... to acces data and functions in the class    creature.display();}',correct
'vertex(xcord + 240, ycord - 20);',correct
'shoulderx = xcord + 120',correct
'int speed;',correct
'shouldery + yd',correct
'ycord - 35',correct
'speed',correct
'Processing',correct
'background(255)',correct
'{    xcord = 1300;}',correct
'xcord + 40',correct
'vertex(xcord + 275, ycord - 35);',correct
'figures = new Figure[10]',correct
'vertex(shoulderx + xd, shouldery + yd)',correct
'float yd = 0 + 200 * cos(frameCount / 4.0f);',correct
'xcord',correct
'// stickman outerlegsnoFill();',correct
'noFill()',correct
'false',correct
'line(xcord - 45, ycord - 20, xcord + 240, ycord - 20);',correct
'strokeJoin(ROUND);',correct
'// load classFigure creature;',correct
'strokeWeight(4);',correct
'int shouldery = ycord - 400;',correct
'ycord - 200',correct
'int xcord;',correct
'endShape()',correct
'xcord = -250',correct
'setup',correct
'Figure(int x, int y, int s) {    xcord = x;    ycord = y;    speed = s;    moveRight = false;    moveLeft = false;}',correct
'creature.moveLeft = false',correct
'new Figure[10]',correct
'vertex(xcord + 40, ycord - 23)',correct
'if (keyCode == RIGHT) {    creature.moveRight = true;    creature.moveLeft = false;} else if (keyCode == LEFT) {    creature.moveLeft = true;    creature.moveRight = false;}',correct
'Figure[]',correct
'boolean moveRight;',correct
'ycord = y',correct
'-250',correct
'ellipse(xcord + 120, ycord - 455, 65, 95);',DecentralizedDrawingRule
'moveLeft = false',correct
'200 * cos(frameCount / 4.0f)',correct
'// stickman armsnoFill();',correct
'shoulderx - xd',correct
'xcord > 1400',correct
'ycord - 20',correct
'keyCode == LEFT',correct
'if (moveRight == true) {    xcord = xcord + speed;}',correct
'ycord - 23',correct
'{    xcord = x;    ycord = y;    speed = s;    moveRight = false;    moveLeft = false;}',correct
'float xd = 0 + 200 * sin(frameCount / 4.0f)',correct
'xcord = 1300;',correct
'float xd = 0 + 200 * sin(frameCount / 4.0f);',correct
'// BOARD// leflstrokeWeight(4);',correct
'xcord + 200',correct
'cos(frameCount / 4.0f)',correct
'beginShape()',correct
'speed = s;',correct
'xcord = xcord + speed',correct
'creature.moveRight',correct
'ycord',correct
'vertex(xcord + 40, ycord - 23);',correct
'xd = 0 + 200 * sin(frameCount / 4.0f)',correct
'xcord < -250',correct
'creature.moveLeft = false;',correct
'ellipse(xcord + 200, ycord, 30, 30);',DecentralizedDrawingRule
'{    creature.moveRight = true;    creature.moveLeft = false;}',correct
'// Off screen -> On screenif (xcord < -250) {    xcord = 1300;}',correct
'keyCode == RIGHT',correct
'moveRight = false',correct
'display',LongMethodRule
'200 * sin(frameCount / 4.0f)',correct
'ellipse(xcord + 10, ycord, 30, 30);',DecentralizedDrawingRule
'{    if (keyCode == RIGHT) {        creature.moveRight = true;        creature.moveLeft = false;    } else if (keyCode == LEFT) {        creature.moveLeft = true;        creature.moveRight = false;    }}',correct
'{    xcord = xcord - speed;}',correct
'// board backlipbeginShape();',correct
'{    if (moveRight == true) {        xcord = xcord + speed;    }    if (moveLeft == true) {        xcord = xcord - speed;    }    // Off screen -> On screen    if (xcord < -250) {        xcord = 1300;    }    if (xcord > 1400) {        xcord = -250;    }}',correct
'strokeWeight(6);',correct
'int y',correct
'class Figure {    int xcord;    int ycord;    int speed;    boolean moveRight;    boolean moveLeft;    Figure(int x, int y, int s) {        xcord = x;        ycord = y;        speed = s;        moveRight = false;        moveLeft = false;    }    void control() {        if (moveRight == true) {            xcord = xcord + speed;        }        if (moveLeft == true) {            xcord = xcord - speed;        }        // Off screen -> On screen        if (xcord < -250) {            xcord = 1300;        }        if (xcord > 1400) {            xcord = -250;        }    }    // FIGURE DRAWN    void display() {        // BOARD        // lefl        strokeWeight(4);        ellipse(xcord + 10, ycord, 30, 30);        // right wheel        strokeWeight(4);        ellipse(xcord + 200, ycord, 30, 30);        // board horizontal        strokeWeight(6);        line(xcord - 45, ycord - 20, xcord + 240, ycord - 20);        // board backlip        beginShape();        noFill();        strokeWeight(6);        strokeJoin(ROUND);        vertex(xcord + 275, ycord - 35);        vertex(xcord + 245, ycord - 20);        vertex(xcord + 240, ycord - 20);        endShape();        // STICKMAN        // stickman inner legs        beginShape();        noFill();        strokeWeight(8);        strokeJoin(ROUND);        vertex(xcord + 40, ycord - 23);        vertex(xcord + 120, ycord - 300);        vertex(xcord + 200, ycord - 23);        endShape();        // stickman torso        strokeWeight(8);        line(xcord + 120, ycord - 300, xcord + 120, ycord - 405);        // stickman outerlegs        noFill();        strokeWeight(8);        strokeJoin(ROUND);        beginShape();        vertex(xcord + 40, ycord - 23);        vertex(xcord + 120, ycord - 200);        vertex(xcord + 200, ycord - 23);        endShape();        // stickman arms        noFill();        strokeWeight(8);        strokeJoin(ROUND);        beginShape();        int shoulderx = xcord + 120;        int shouldery = ycord - 400;        float xd = 0 + 200 * sin(frameCount / 4.0f);        float yd = 0 + 200 * cos(frameCount / 4.0f);        vertex(shoulderx - xd, shouldery + yd);        vertex(shoulderx, shouldery);        vertex(shoulderx + xd, shouldery + yd);        endShape();        // stickman head        strokeWeight(7);        ellipse(xcord + 120, ycord - 455, 65, 95);        strokeWeight(4);        ellipse(xcord + 10, ycord, 30, 30);    }}',correct
'void setup() {    frameRate(30);    // create class object   // xcord , ycord, speed    creature = new Figure(500, 800, 20);    // use creature. ... to acces data and functions in the class    creature.display();}',correct
'xcord + 10',correct
'ycord - 405',correct
'int s',correct
'vertex(shoulderx + xd, shouldery + yd);',correct
'new Figure(500, 800, 20)',correct
'int x',correct
'ycord - 400',correct
'creature.moveLeft = true;',correct
'int shoulderx = xcord + 120;',correct
'vertex(xcord + 120, ycord - 300)',correct
'{    xcord = -250;}',correct
'if (keyCode == LEFT) {    creature.moveLeft = true;    creature.moveRight = false;}',correct
'xcord - 45',correct
'void',correct
'xcord + speed',correct
'creature.moveRight = true',correct
'line(xcord + 120, ycord - 300, xcord + 120, ycord - 405);',correct
'// use creature. ... to acces data and functions in the classcreature.display();',correct
'0 + 200 * cos(frameCount / 4.0f)',correct
'true',correct
'noFill();',correct
'if (xcord > 1400) {    xcord = -250;}',correct
'xcord = x;',correct
'vertex(xcord + 275, ycord - 35)',correct
'line(xcord - 45, ycord - 20, xcord + 240, ycord - 20)',correct
'[10]',correct
'vertex(shoulderx, shouldery)',correct
'beginShape();',correct
'yd = 0 + 200 * cos(frameCount / 4.0f)',correct
'sin(frameCount / 4.0f)',correct
'{    xcord = xcord + speed;}',correct
'vertex(xcord + 120, ycord - 200);',correct
'frameCount / 4.0f',correct
'// right wheelstrokeWeight(4);',correct
'vertex(xcord + 200, ycord - 23)',correct
'// FIGURE DRAWNvoid display() {    // BOARD    // lefl    strokeWeight(4);    ellipse(xcord + 10, ycord, 30, 30);    // right wheel    strokeWeight(4);    ellipse(xcord + 200, ycord, 30, 30);    // board horizontal    strokeWeight(6);    line(xcord - 45, ycord - 20, xcord + 240, ycord - 20);    // board backlip    beginShape();    noFill();    strokeWeight(6);    strokeJoin(ROUND);    vertex(xcord + 275, ycord - 35);    vertex(xcord + 245, ycord - 20);    vertex(xcord + 240, ycord - 20);    endShape();    // STICKMAN    // stickman inner legs    beginShape();    noFill();    strokeWeight(8);    strokeJoin(ROUND);    vertex(xcord + 40, ycord - 23);    vertex(xcord + 120, ycord - 300);    vertex(xcord + 200, ycord - 23);    endShape();    // stickman torso    strokeWeight(8);    line(xcord + 120, ycord - 300, xcord + 120, ycord - 405);    // stickman outerlegs    noFill();    strokeWeight(8);    strokeJoin(ROUND);    beginShape();    vertex(xcord + 40, ycord - 23);    vertex(xcord + 120, ycord - 200);    vertex(xcord + 200, ycord - 23);    endShape();    // stickman arms    noFill();    strokeWeight(8);    strokeJoin(ROUND);    beginShape();    int shoulderx = xcord + 120;    int shouldery = ycord - 400;    float xd = 0 + 200 * sin(frameCount / 4.0f);    float yd = 0 + 200 * cos(frameCount / 4.0f);    vertex(shoulderx - xd, shouldery + yd);    vertex(shoulderx, shouldery);    vertex(shoulderx + xd, shouldery + yd);    endShape();    // stickman head    strokeWeight(7);    ellipse(xcord + 120, ycord - 455, 65, 95);    strokeWeight(4);    ellipse(xcord + 10, ycord, 30, 30);}',correct
'moveRight = false;',correct
'creature.moveLeft',correct
'vertex(xcord + 120, ycord - 200)',correct
'control',correct
'xcord = xcord - speed',correct
'// board horizontalstrokeWeight(6);',correct
'void control() {    if (moveRight == true) {        xcord = xcord + speed;    }    if (moveLeft == true) {        xcord = xcord - speed;    }    // Off screen -> On screen    if (xcord < -250) {        xcord = 1300;    }    if (xcord > 1400) {        xcord = -250;    }}',correct
'strokeWeight(8);',correct
'xcord - speed',correct
'vertex(xcord + 240, ycord - 20)',correct
'strokeWeight(4)',correct
'creature.moveRight = false;',correct
'speed = s',correct
'endShape();',correct
'{    if (mousePressed) {        dinoX = mouseX + random(-100, 100);        dinoY = mouseY + random(-100, 100);    }}',correct
'i < amountOfDinos',correct
'void bounceOfWalls() {    if (((dinoX < 110) || (dinoX > width - 88)) || ((dinoY < 70) || (dinoY > height - 66))) {        speed = speed * -1;    }}',correct
'dinoY - 22',correct
'dinoX = mouseX + random(-100, 100)',correct
'triangle(dinoX + 50, dinoY - 32, dinoX + 50, dinoY - 64, dinoX + 88, dinoY - 58)',correct
'dinoY - 2',correct
'dinoY - 32',correct
'dinoY = initY;',correct
'dinoY = initY',correct
'if (keyCode == LEFT) {    dinoX = dinoX - speed;}',DecentralizedEventHandlingRule
'// creature made by: Jelise Schokker',correct
'triangle(dinoX + 38, dinoY - 14, dinoX + 38, dinoY - 32, dinoX + 60, dinoY - 32)',correct
'if (keyCode == DOWN) {    dinoY = dinoY + speed;}',DecentralizedEventHandlingRule
'dinos[i].display()',correct
'frameRate(100)',correct
'dinoY = dinoY + speed;',correct
'dinoY = dinoY - speed;',correct
'triangle(dinoX + 38, dinoY - 14, dinoX + 56, dinoY - 14, dinoX + 44, dinoY - 22)',correct
'dinoY - 40',correct
'triangle(dinoX + 14, dinoY + 28, dinoX - 16, dinoY + 28, dinoX - 24, dinoY + 4);',correct
'triangle(dinoX + 46, dinoY - 14, dinoX + 56, dinoY - 14, dinoX + 54, dinoY - 2)',correct
'changeColor',correct
'dinoY = mouseY + random(-100, 100);',DecentralizedEventHandlingRule
'dinoY - 48',correct
'for (int i = 0; i < amountOfDinos; i++) {    dinos[i] = new Dino(color(0, 200, 40), color(255), random(114, width - 94), random(74, height - 72), random(1, 30));}',correct
'dinoY = dinoY - speed',correct
'// headtriangle(dinoX + 50, dinoY - 32, dinoX + 38, dinoY - 32, dinoX + 50, dinoY - 64);',correct
'{    if (key == c) {        colorMode(HSB, 100);        bodyColor = color(random(1, 100), 100, 100, 80);    }}',correct
'dinoY - 50',correct
'// creature made by: Jelise Schokkerint amountOfDinos = 20;',correct
'if (key == c) {    colorMode(HSB, 100);    bodyColor = color(random(1, 100), 100, 100, 80);}',DecentralizedEventHandlingRule
'triangle(dinoX + 14, dinoY + 28, dinoX + 14, dinoY - 32, dinoX - 24, dinoY + 4)',correct
'triangle(dinoX, dinoY + 48, dinoX + 14, dinoY + 28, dinoX - 16, dinoY + 28)',correct
'{    dinoY = dinoY - speed;}',correct
'mouseIsPressed',correct
'c',correct
'{    if (((dinoX < 110) || (dinoX > width - 88)) || ((dinoY < 70) || (dinoY > height - 66))) {        speed = speed * -1;    }}',correct
'{    colorMode(HSB, 100);    bodyColor = color(random(1, 100), 100, 100, 80);}',correct
'bodyColor = color(random(1, 100), 100, 100, 80);',correct
'dinoY - 58',correct
'{    dinoX = mouseX + random(-100, 100);    dinoY = mouseY + random(-100, 100);}',correct
'dinoY - 64',correct
'void setup() {    frameRate(100);    for (int i = 0; i < amountOfDinos; i++) {        dinos[i] = new Dino(color(0, 200, 40), color(255), random(114, width - 94), random(74, height - 72), random(1, 30));    }}',correct
'speed = speed * -1',correct
'int initBodyColor',correct
'dinoX = dinoX - speed',correct
'dinoY = mouseY + random(-100, 100)',correct
'for (int i = 0; i < amountOfDinos; i++) {    dinos[i].display();    dinos[i].mouseIsPressed();    dinos[i].move();    dinos[i].bounceOfWalls();    dinos[i].changeColor();}',correct
'triangle(dinoX + 14, dinoY + 28, dinoX - 16, dinoY + 28, dinoX - 24, dinoY + 4)',correct
'triangle(dinoX + 14, dinoY + 28, dinoX + 14, dinoY - 32, dinoX + 38, dinoY - 14)',correct
'triangle(dinoX, dinoY + 70, dinoX + 14, dinoY + 70, dinoX, dinoY + 60);',correct
'// armstriangle(dinoX + 36, dinoY - 14, dinoX + 44, dinoY, dinoX + 26, dinoY);',correct
'triangle(dinoX + 74, dinoY - 48, dinoX + 60, dinoY - 32, dinoX + 88, dinoY - 40)',correct
'{    dinoX = dinoX - speed;}',correct
'dinoY - 66',correct
'dinoX = dinoX + speed',correct
'stroke(strokeColor);',correct
'dinoX + 38',correct
'dinoY + 4',correct
'dinoX = dinoX - speed;',correct
'dinoX = dinoX + speed;',correct
'colorMode(HSB, 100);',correct
'dinoX + 34',correct
'dinoY = dinoY + speed',correct
'dinoX + 36',correct
'fill(bodyColor)',correct
'dinoX + speed',correct
'dinoX + 50',correct
'random(-100, 100)',correct
'-100',correct
'{    dinos[i].display();    dinos[i].mouseIsPressed();    dinos[i].move();    dinos[i].bounceOfWalls();    dinos[i].changeColor();}',correct
'// bodytriangle(dinoX + 14, dinoY + 28, dinoX + 14, dinoY - 32, dinoX - 24, dinoY + 4);',correct
'dinos[i].mouseIsPressed()',correct
'float dinoY;',correct
'float initSpeed',correct
'triangle(dinoX + 88, dinoY - 58, dinoX + 50, dinoY - 64, dinoX + 86, dinoY - 66);',correct
'fill(bodyColor);',correct
'dinos[i].changeColor()',correct
'dinoX + 42',correct
'{    dinos[i] = new Dino(color(0, 200, 40), color(255), random(114, width - 94), random(74, height - 72), random(1, 30));}',correct
'dinoX + 44',correct
'dinoX + 46',correct
'{    speed = speed * -1;}',correct
'{    bodyColor = initBodyColor;    strokeColor = initStrokeColor;    dinoX = initX;    dinoY = initY;    speed = initSpeed;}',correct
'int bodyColor;',correct
'triangle(dinoX + 50, dinoY - 32, dinoX + 50, dinoY - 64, dinoX + 88, dinoY - 58);',correct
'dinoX = mouseX + random(-100, 100);',DecentralizedEventHandlingRule
'background(100);',correct
'if (keyCode == RIGHT) {    dinoX = dinoX + speed;}',DecentralizedEventHandlingRule
'colorMode(HSB, 100)',correct
'speed',correct
'triangle(dinoX + 88, dinoY - 58, dinoX + 50, dinoY - 64, dinoX + 86, dinoY - 66)',correct
'Processing',correct
'dinoX + 16',correct
'triangle(dinoX + 38, dinoY - 14, dinoX + 38, dinoY - 32, dinoX + 14, dinoY - 32);',correct
'triangle(dinoX, dinoY + 70, dinoX, dinoY + 48, dinoX - 18, dinoY + 48)',correct
'float dinoX;',correct
'triangle(dinoX + 50, dinoY - 32, dinoX + 60, dinoY - 32, dinoX + 74, dinoY - 48)',correct
'dinoX + 14',correct
'{    dinoY = dinoY + speed;}',correct
'strokeColor = initStrokeColor',correct
'dinos[i].move();',correct
'int initStrokeColor',correct
'triangle(dinoX + 46, dinoY - 14, dinoX + 56, dinoY - 14, dinoX + 54, dinoY - 2);',correct
'if (mousePressed) {    dinoX = mouseX + random(-100, 100);    dinoY = mouseY + random(-100, 100);}',DecentralizedEventHandlingRule
'random(1, 100)',correct
'triangle(dinoX, dinoY + 60, dinoX + 14, dinoY + 28, dinoX, dinoY + 48)',correct
'{    fill(bodyColor);    stroke(strokeColor);    strokeJoin(BEVEL);    // legs    triangle(dinoX, dinoY + 70, dinoX, dinoY + 48, dinoX - 18, dinoY + 48);    triangle(dinoX, dinoY + 70, dinoX + 14, dinoY + 70, dinoX, dinoY + 60);    triangle(dinoX, dinoY + 60, dinoX + 16, dinoY + 60, dinoX, dinoY + 44);    triangle(dinoX, dinoY + 48, dinoX - 18, dinoY + 48, dinoX - 16, dinoY + 28);    triangle(dinoX, dinoY + 48, dinoX + 14, dinoY + 28, dinoX - 16, dinoY + 28);    triangle(dinoX + 14, dinoY + 28, dinoX - 16, dinoY + 28, dinoX - 24, dinoY + 4);    triangle(dinoX, dinoY + 60, dinoX + 14, dinoY + 28, dinoX, dinoY + 48);    // arms    triangle(dinoX + 36, dinoY - 14, dinoX + 44, dinoY, dinoX + 26, dinoY);    triangle(dinoX + 44, dinoY, dinoX + 34, dinoY, dinoX + 42, dinoY + 12);    triangle(dinoX + 38, dinoY - 14, dinoX + 56, dinoY - 14, dinoX + 44, dinoY - 22);    triangle(dinoX + 46, dinoY - 14, dinoX + 56, dinoY - 14, dinoX + 54, dinoY - 2);    // head    triangle(dinoX + 50, dinoY - 32, dinoX + 38, dinoY - 32, dinoX + 50, dinoY - 64);    triangle(dinoX + 88, dinoY - 58, dinoX + 50, dinoY - 64, dinoX + 86, dinoY - 66);    triangle(dinoX + 50, dinoY - 32, dinoX + 60, dinoY - 32, dinoX + 74, dinoY - 48);    triangle(dinoX + 74, dinoY - 48, dinoX + 60, dinoY - 32, dinoX + 88, dinoY - 40);    // mouth    triangle(dinoX + 88, dinoY - 40, dinoX + 74, dinoY - 48, dinoX + 88, dinoY - 50);    triangle(dinoX + 50, dinoY - 32, dinoX + 50, dinoY - 64, dinoX + 88, dinoY - 58);    // body    triangle(dinoX + 14, dinoY + 28, dinoX + 14, dinoY - 32, dinoX - 24, dinoY + 4);    triangle(dinoX - 24, dinoY + 4, dinoX + 14, dinoY - 32, dinoX - 110, dinoY - 32);    triangle(dinoX + 14, dinoY + 28, dinoX + 14, dinoY - 32, dinoX + 38, dinoY - 14);    triangle(dinoX + 38, dinoY - 14, dinoX + 38, dinoY - 32, dinoX + 14, dinoY - 32);    triangle(dinoX + 38, dinoY - 14, dinoX + 38, dinoY - 32, dinoX + 60, dinoY - 32);}',LongMethodRule
'int i = 0',correct
'stroke(strokeColor)',correct
'dinoX - speed',correct
'random(74, height - 72)',correct
'// drag all of the dinosaurs in a box of 200 by 200 pixelsvoid mouseIsPressed() {    if (mousePressed) {        dinoX = mouseX + random(-100, 100);        dinoY = mouseY + random(-100, 100);    }}',correct
'dinoX + 26',correct
'strokeJoin(BEVEL)',correct
'i = 0',correct
'dinoX = initX;',correct
'color(255)',correct
'Dino',correct
'triangle(dinoX + 50, dinoY - 32, dinoX + 38, dinoY - 32, dinoX + 50, dinoY - 64)',correct
'dinos[i]',correct
'Dino[]',correct
'background(100)',correct
'dinoX - 18',correct
'class Dino {    int strokeColor;    int bodyColor;    float dinoX;    float dinoY;    float speed;    Dino(int initBodyColor, int initStrokeColor, float initX, float initY, float initSpeed) {        bodyColor = initBodyColor;        strokeColor = initStrokeColor;        dinoX = initX;        dinoY = initY;        speed = initSpeed;    }    void display() {        fill(bodyColor);        stroke(strokeColor);        strokeJoin(BEVEL);        // legs        triangle(dinoX, dinoY + 70, dinoX, dinoY + 48, dinoX - 18, dinoY + 48);        triangle(dinoX, dinoY + 70, dinoX + 14, dinoY + 70, dinoX, dinoY + 60);        triangle(dinoX, dinoY + 60, dinoX + 16, dinoY + 60, dinoX, dinoY + 44);        triangle(dinoX, dinoY + 48, dinoX - 18, dinoY + 48, dinoX - 16, dinoY + 28);        triangle(dinoX, dinoY + 48, dinoX + 14, dinoY + 28, dinoX - 16, dinoY + 28);        triangle(dinoX + 14, dinoY + 28, dinoX - 16, dinoY + 28, dinoX - 24, dinoY + 4);        triangle(dinoX, dinoY + 60, dinoX + 14, dinoY + 28, dinoX, dinoY + 48);        // arms        triangle(dinoX + 36, dinoY - 14, dinoX + 44, dinoY, dinoX + 26, dinoY);        triangle(dinoX + 44, dinoY, dinoX + 34, dinoY, dinoX + 42, dinoY + 12);        triangle(dinoX + 38, dinoY - 14, dinoX + 56, dinoY - 14, dinoX + 44, dinoY - 22);        triangle(dinoX + 46, dinoY - 14, dinoX + 56, dinoY - 14, dinoX + 54, dinoY - 2);        // head        triangle(dinoX + 50, dinoY - 32, dinoX + 38, dinoY - 32, dinoX + 50, dinoY - 64);        triangle(dinoX + 88, dinoY - 58, dinoX + 50, dinoY - 64, dinoX + 86, dinoY - 66);        triangle(dinoX + 50, dinoY - 32, dinoX + 60, dinoY - 32, dinoX + 74, dinoY - 48);        triangle(dinoX + 74, dinoY - 48, dinoX + 60, dinoY - 32, dinoX + 88, dinoY - 40);        // mouth        triangle(dinoX + 88, dinoY - 40, dinoX + 74, dinoY - 48, dinoX + 88, dinoY - 50);        triangle(dinoX + 50, dinoY - 32, dinoX + 50, dinoY - 64, dinoX + 88, dinoY - 58);        // body        triangle(dinoX + 14, dinoY + 28, dinoX + 14, dinoY - 32, dinoX - 24, dinoY + 4);        triangle(dinoX - 24, dinoY + 4, dinoX + 14, dinoY - 32, dinoX - 110, dinoY - 32);        triangle(dinoX + 14, dinoY + 28, dinoX + 14, dinoY - 32, dinoX + 38, dinoY - 14);        triangle(dinoX + 38, dinoY - 14, dinoX + 38, dinoY - 32, dinoX + 14, dinoY - 32);        triangle(dinoX + 38, dinoY - 14, dinoX + 38, dinoY - 32, dinoX + 60, dinoY - 32);    }    // drag all of the dinosaurs in a box of 200 by 200 pixels    void mouseIsPressed() {        if (mousePressed) {            dinoX = mouseX + random(-100, 100);            dinoY = mouseY + random(-100, 100);        }    }    // move the dino by pressing the up, down, left or right key    void move() {        if (keyCode == DOWN) {            dinoY = dinoY + speed;        }        if (keyCode == UP) {            dinoY = dinoY - speed;        }        if (keyCode == LEFT) {            dinoX = dinoX - speed;        }        if (keyCode == RIGHT) {            dinoX = dinoX + speed;        }    }    void bounceOfWalls() {        if (((dinoX < 110) || (dinoX > width - 88)) || ((dinoY < 70) || (dinoY > height - 66))) {            speed = speed * -1;        }    }    // change the colors by pressing c    void changeColor() {        if (key == c) {            colorMode(HSB, 100);            bodyColor = color(random(1, 100), 100, 100, 80);        }    }}',correct
'speed = initSpeed;',correct
'dinoX + 74',correct
'dinoX - 16',correct
'dinos[i] = new Dino(color(0, 200, 40), color(255), random(114, width - 94), random(74, height - 72), random(1, 30))',correct
'triangle(dinoX - 24, dinoY + 4, dinoX + 14, dinoY - 32, dinoX - 110, dinoY - 32)',correct
'keyCode == LEFT',correct
'Dino[] dinos = new Dino[amountOfDinos];',correct
'triangle(dinoX + 38, dinoY - 14, dinoX + 38, dinoY - 32, dinoX + 60, dinoY - 32);',correct
'dinoY + 12',correct
'triangle(dinoX + 38, dinoY - 14, dinoX + 38, dinoY - 32, dinoX + 14, dinoY - 32)',correct
'dinoY - speed',correct
'triangle(dinoX - 24, dinoY + 4, dinoX + 14, dinoY - 32, dinoX - 110, dinoY - 32);',correct
'[amountOfDinos]',correct
'dinoX + 86',correct
'dinoX - 24',correct
'dinoX + 88',correct
'if (keyCode == UP) {    dinoY = dinoY - speed;}',DecentralizedEventHandlingRule
'// legstriangle(dinoX, dinoY + 70, dinoX, dinoY + 48, dinoX - 18, dinoY + 48);',correct
'triangle(dinoX + 44, dinoY, dinoX + 34, dinoY, dinoX + 42, dinoY + 12);',correct
'int strokeColor;',correct
'dinoY + 28',correct
'dinoX + 60',correct
'key == c',correct
'{    frameRate(100);    for (int i = 0; i < amountOfDinos; i++) {        dinos[i] = new Dino(color(0, 200, 40), color(255), random(114, width - 94), random(74, height - 72), random(1, 30));    }}',correct
'strokeJoin(BEVEL);',correct
'if (((dinoX < 110) || (dinoX > width - 88)) || ((dinoY < 70) || (dinoY > height - 66))) {    speed = speed * -1;}',correct
'keyCode == UP',correct
'dinoX + 54',correct
'dinos[i].bounceOfWalls();',correct
'new Dino[amountOfDinos]',correct
'dinoX + 56',correct
'keyCode == RIGHT',correct
'dinos[i] = new Dino(color(0, 200, 40), color(255), random(114, width - 94), random(74, height - 72), random(1, 30));',correct
'display',LongMethodRule
'float speed;',correct
'triangle(dinoX, dinoY + 48, dinoX - 18, dinoY + 48, dinoX - 16, dinoY + 28)',correct
'dinos = new Dino[amountOfDinos]',correct
'dinos[i].mouseIsPressed();',correct
'color(0, 200, 40)',correct
'{    if (keyCode == DOWN) {        dinoY = dinoY + speed;    }    if (keyCode == UP) {        dinoY = dinoY - speed;    }    if (keyCode == LEFT) {        dinoX = dinoX - speed;    }    if (keyCode == RIGHT) {        dinoX = dinoX + speed;    }}',correct
'triangle(dinoX, dinoY + 70, dinoX + 14, dinoY + 70, dinoX, dinoY + 60)',correct
'triangle(dinoX, dinoY + 60, dinoX + 16, dinoY + 60, dinoX, dinoY + 44);',correct
'bodyColor = initBodyColor',correct
'triangle(dinoX + 38, dinoY - 14, dinoX + 56, dinoY - 14, dinoX + 44, dinoY - 22);',correct
'speed * -1',correct
'float initX',correct
'dinos[i].display();',correct
'float initY',correct
'i++',correct
'((dinoX < 110) || (dinoX > width - 88)) || ((dinoY < 70) || (dinoY > height - 66))',correct
'// mouthtriangle(dinoX + 88, dinoY - 40, dinoX + 74, dinoY - 48, dinoX + 88, dinoY - 50);',correct
'dinoY + 48',correct
'dinoY + 44',correct
'random(114, width - 94)',correct
'keyCode == DOWN',correct
'void draw() {    colorMode(HSB, 100);    background(100);    for (int i = 0; i < amountOfDinos; i++) {        dinos[i].display();        dinos[i].mouseIsPressed();        dinos[i].move();        dinos[i].bounceOfWalls();        dinos[i].changeColor();    }}',correct
'triangle(dinoX, dinoY + 60, dinoX + 14, dinoY + 28, dinoX, dinoY + 48);',correct
'{    colorMode(HSB, 100);    background(100);    for (int i = 0; i < amountOfDinos; i++) {        dinos[i].display();        dinos[i].mouseIsPressed();        dinos[i].move();        dinos[i].bounceOfWalls();        dinos[i].changeColor();    }}',correct
'color(random(1, 100), 100, 100, 80)',correct
'strokeColor',correct
'bodyColor = initBodyColor;',correct
'dinoX',correct
'speed = initSpeed',correct
'mouseY + random(-100, 100)',correct
'dinoY',correct
'void',LongMethodRule
'triangle(dinoX + 74, dinoY - 48, dinoX + 60, dinoY - 32, dinoX + 88, dinoY - 40);',correct
'-1',correct
'// change the colors by pressing cvoid changeColor() {    if (key == c) {        colorMode(HSB, 100);        bodyColor = color(random(1, 100), 100, 100, 80);    }}',correct
'dinoY + 60',correct
'triangle(dinoX, dinoY + 48, dinoX - 18, dinoY + 48, dinoX - 16, dinoY + 28);',correct
'triangle(dinoX + 88, dinoY - 40, dinoX + 74, dinoY - 48, dinoX + 88, dinoY - 50)',correct
'{    dinoX = dinoX + speed;}',correct
'amountOfDinos = 20',correct
'bodyColor',correct
'width - 94',correct
'dinoX - 110',correct
'triangle(dinoX + 50, dinoY - 32, dinoX + 60, dinoY - 32, dinoX + 74, dinoY - 48);',correct
'triangle(dinoX, dinoY + 48, dinoX + 14, dinoY + 28, dinoX - 16, dinoY + 28);',correct
'mouseX + random(-100, 100)',correct
'triangle(dinoX + 14, dinoY + 28, dinoX + 14, dinoY - 32, dinoX + 38, dinoY - 14);',correct
'Dino(int initBodyColor, int initStrokeColor, float initX, float initY, float initSpeed) {    bodyColor = initBodyColor;    strokeColor = initStrokeColor;    dinoX = initX;    dinoY = initY;    speed = initSpeed;}',correct
'void display() {    fill(bodyColor);    stroke(strokeColor);    strokeJoin(BEVEL);    // legs    triangle(dinoX, dinoY + 70, dinoX, dinoY + 48, dinoX - 18, dinoY + 48);    triangle(dinoX, dinoY + 70, dinoX + 14, dinoY + 70, dinoX, dinoY + 60);    triangle(dinoX, dinoY + 60, dinoX + 16, dinoY + 60, dinoX, dinoY + 44);    triangle(dinoX, dinoY + 48, dinoX - 18, dinoY + 48, dinoX - 16, dinoY + 28);    triangle(dinoX, dinoY + 48, dinoX + 14, dinoY + 28, dinoX - 16, dinoY + 28);    triangle(dinoX + 14, dinoY + 28, dinoX - 16, dinoY + 28, dinoX - 24, dinoY + 4);    triangle(dinoX, dinoY + 60, dinoX + 14, dinoY + 28, dinoX, dinoY + 48);    // arms    triangle(dinoX + 36, dinoY - 14, dinoX + 44, dinoY, dinoX + 26, dinoY);    triangle(dinoX + 44, dinoY, dinoX + 34, dinoY, dinoX + 42, dinoY + 12);    triangle(dinoX + 38, dinoY - 14, dinoX + 56, dinoY - 14, dinoX + 44, dinoY - 22);    triangle(dinoX + 46, dinoY - 14, dinoX + 56, dinoY - 14, dinoX + 54, dinoY - 2);    // head    triangle(dinoX + 50, dinoY - 32, dinoX + 38, dinoY - 32, dinoX + 50, dinoY - 64);    triangle(dinoX + 88, dinoY - 58, dinoX + 50, dinoY - 64, dinoX + 86, dinoY - 66);    triangle(dinoX + 50, dinoY - 32, dinoX + 60, dinoY - 32, dinoX + 74, dinoY - 48);    triangle(dinoX + 74, dinoY - 48, dinoX + 60, dinoY - 32, dinoX + 88, dinoY - 40);    // mouth    triangle(dinoX + 88, dinoY - 40, dinoX + 74, dinoY - 48, dinoX + 88, dinoY - 50);    triangle(dinoX + 50, dinoY - 32, dinoX + 50, dinoY - 64, dinoX + 88, dinoY - 58);    // body    triangle(dinoX + 14, dinoY + 28, dinoX + 14, dinoY - 32, dinoX - 24, dinoY + 4);    triangle(dinoX - 24, dinoY + 4, dinoX + 14, dinoY - 32, dinoX - 110, dinoY - 32);    triangle(dinoX + 14, dinoY + 28, dinoX + 14, dinoY - 32, dinoX + 38, dinoY - 14);    triangle(dinoX + 38, dinoY - 14, dinoX + 38, dinoY - 32, dinoX + 14, dinoY - 32);    triangle(dinoX + 38, dinoY - 14, dinoX + 38, dinoY - 32, dinoX + 60, dinoY - 32);}',correct
'dinoX = initX',correct
'dinos[i].bounceOfWalls()',correct
'dinoY + 70',correct
'random(1, 30)',correct
'height - 72',correct
'// move the dino by pressing the up, down, left or right keyvoid move() {    if (keyCode == DOWN) {        dinoY = dinoY + speed;    }    if (keyCode == UP) {        dinoY = dinoY - speed;    }    if (keyCode == LEFT) {        dinoX = dinoX - speed;    }    if (keyCode == RIGHT) {        dinoX = dinoX + speed;    }}',correct
'triangle(dinoX + 36, dinoY - 14, dinoX + 44, dinoY, dinoX + 26, dinoY)',correct
'move',correct
'dinos[i].changeColor();',correct
'new Dino(color(0, 200, 40), color(255), random(114, width - 94), random(74, height - 72), random(1, 30))',correct
'speed = speed * -1;',correct
'bodyColor = color(random(1, 100), 100, 100, 80)',correct
'triangle(dinoX, dinoY + 60, dinoX + 16, dinoY + 60, dinoX, dinoY + 44)',correct
'dinoY + speed',correct
'dinoY - 14',correct
'strokeColor = initStrokeColor;',correct
'dinos[i].move()',correct
'frameRate(100);',correct
'triangle(dinoX + 44, dinoY, dinoX + 34, dinoY, dinoX + 42, dinoY + 12)',correct
'Ball',correct
'creatures[i].move()',correct
'pow(mouseX - creatureX, 2) + pow(mouseY - creatureY, 2) <= pow(40, 2)',correct
'random(width)',correct
'Creature',correct
'boolean isEyesClosed = false;',correct
'creatureX < 30',correct
'{    if (creatures[i].mouseOnCreature()) {        creatures[i].eyeClose();    }}',correct
'creatures[i].eyeOpen()',correct
'random(0, 255)',correct
'float speed',correct
'{    noStroke();    fill(255, 255, 255);    ellipse(ballX, ballY, size, size);}',correct
'creatureSpeed = speed',correct
'// Close mouth and eyes of a Creaturevoid mousePressed() {    for (int i = 0; i < creatures.length; i++) {        if (creatures[i].mouseOnCreature()) {            creatures[i].eyeClose();        }    }}',correct
'ellipse(creatureX + 16, creatureY + 23, 12, 10);',correct
'ellipse(creatureX, creatureY, 50, 50)',correct
'new Ball[400]',correct
'random(50, width - 50)',correct
'void setup() {    // Create Creatures and give them a initial color    for (int i = 0; i < creatures.length; i++) {        creatures[i] = new Creature(random(50, width - 50), random(220, height - 20), random(1, 4));        creatures[i].colorChange();    }    // Create Balls    for (int i = 0; i < balls.length; i++) {        balls[i] = new Ball(random(width), random(-600, -100), random(4, 8), random(2, 6));    }}',correct
'creatures[i]',correct
'float size;',correct
'fill(red, green, blue);',correct
'ballY = ballY_;',correct
'// Creature Earsellipse(creatureX - 30, creatureY - 100, 32, 20);',correct
'stroke(0);',correct
'// Creature Teethfill(255, 255, 255);',correct
'stroke(0)',correct
'// Open mouth and eyes of a Creaturevoid mouseReleased() {    for (int i = 0; i < creatures.length; i++) {        creatures[i].eyeOpen();    }}',correct
'float posX',correct
'float posY',correct
'Ball[] balls = new Ball[400];',correct
'{    ballX = ballX_;    ballY = ballY_;    size = size_;    speedY = speedY_;}',correct
'creatureY - 75',correct
'void move() {    creatureX += creatureSpeed;    if (creatureX > width - 30 || creatureX < 30) {        creatureSpeed *= -1;        colorChange();    }}',correct
'boolean isOn = false',correct
'{    balls[i] = new Ball(random(width), random(-600, -100), random(4, 8), random(2, 6));}',correct
'size',correct
'float creatureSpeed;',correct
'float size_',correct
'if (creatureX > width - 30 || creatureX < 30) {    creatureSpeed *= -1;    colorChange();}',correct
'creatureX - 16',correct
'balls[i]',correct
'creatureX - 13',correct
'pow(mouseX - creatureX, 2)',correct
'fill(255, 250, 250)',correct
'ellipse(creatureX + 17, creatureY - 75, 23, 32)',correct
'rect(0, 200, width, height);',correct
'isEyesClosed = true;',correct
'red = random(0, 255)',correct
'width - 50',correct
'ellipse(creatureX - 17, creatureY - 75, 20, 20)',correct
'creatureX - 17',correct
'creatureX',correct
'random(1, 4)',correct
'creatureY',correct
'fill(0);',correct
'isEyesClosed = false',correct
'creatureX = posX;',correct
'{    red = random(0, 255);    green = random(0, 255);    blue = random(0, 255);}',correct
'mouseReleased',correct
'float speedY;',correct
'creatureX + 7',correct
'ellipse(creatureX - 17, creatureY - 75, 20, 20);',correct
'class Ball {    float ballX;    float ballY;    float size;    float speedY;    Ball(float ballX_, float ballY_, float size_, float speedY_) {        ballX = ballX_;        ballY = ballY_;        size = size_;        speedY = speedY_;    }    void fall() {        ballY += speedY;        if (ballY > height) {            ballY = random(-200, -100);            ballX = random(0, width);        }    }    void display() {        noStroke();        fill(255, 255, 255);        ellipse(ballX, ballY, size, size);    }}',correct
'fill(9, 143, 202)',correct
'void colorChange() {    red = random(0, 255);    green = random(0, 255);    blue = random(0, 255);}',correct
'creatureX - 24',correct
'creatureX - 23',correct
'background(66, 134, 244);',correct
'creatureX + 3',correct
'creatureX - 20',correct
'if (creatures[i].mouseOnCreature()) {    creatures[i].eyeClose();}',correct
'rectMode(CENTER)',correct
'speedY',correct
'green = random(0, 255)',correct
'creatures[i].colorChange()',correct
'random(0, width)',correct
'new Ball(random(width), random(-600, -100), random(4, 8), random(2, 6))',correct
'return isOn;',correct
'creatureX - 30',correct
'-200',correct
'blue',correct
'line(creatureX - 20, creatureY - 35, creatureX + 20, creatureY - 35);',correct
'// Creature Bodystroke(0);',correct
'// Creature Armsellipse(creatureX - 24, creatureY - 8, 12, 16);',correct
'random(2, 6)',correct
'rectMode(CENTER);',correct
'float speedY_',correct
'creatures[i].eyeClose()',correct
'ellipse(creatureX + 17, creatureY - 75, 5, 5)',correct
'noStroke()',correct
'creatureX + 17',correct
'creatureY + 23',correct
'creatureX + 16',correct
'width - 30',correct
'creatureY - 100',correct
'balls[i] = new Ball(random(width), random(-600, -100), random(4, 8), random(2, 6))',correct
'if (ballY > height) {    ballY = random(-200, -100);    ballX = random(0, width);}',correct
'isOn = true;',correct
'{    for (int i = 0; i < creatures.length; i++) {        if (creatures[i].mouseOnCreature()) {            creatures[i].eyeClose();        }    }}',correct
'red',correct
'speedY = speedY_',correct
'rect(creatureX, creatureY - 35, 50, 20);',correct
'creatures = new Creature[8]',correct
'creatureX + 24',correct
'{    creatureX += creatureSpeed;    if (creatureX > width - 30 || creatureX < 30) {        creatureSpeed *= -1;        colorChange();    }}',correct
'ellipse(creatureX - 17, creatureY - 75, 23, 32)',correct
'creatureX + 23',correct
'balls[i].display()',correct
'creatureX + 20',correct
'ellipse(creatureX + 24, creatureY - 8, 12, 16)',correct
'balls[i] = new Ball(random(width), random(-600, -100), random(4, 8), random(2, 6));',correct
'creatureSpeed = speed;',correct
'{    // Create Creatures and give them a initial color    for (int i = 0; i < creatures.length; i++) {        creatures[i] = new Creature(random(50, width - 50), random(220, height - 20), random(1, 4));        creatures[i].colorChange();    }    // Create Balls    for (int i = 0; i < balls.length; i++) {        balls[i] = new Ball(random(width), random(-600, -100), random(4, 8), random(2, 6));    }}',correct
'mouseX - creatureX',correct
'void display() {    // Creature Body    stroke(0);    fill(red, green, blue);    ellipse(creatureX, creatureY, 50, 50);    // Creature Ears    ellipse(creatureX - 30, creatureY - 100, 32, 20);    ellipse(creatureX + 30, creatureY - 100, 32, 20);    // Creature Head    rect(creatureX, creatureY - 60, 60, 80);    // Creature Legs    ellipse(creatureX - 16, creatureY + 23, 12, 10);    ellipse(creatureX + 16, creatureY + 23, 12, 10);    // Creature Arms    ellipse(creatureX - 24, creatureY - 8, 12, 16);    ellipse(creatureX + 24, creatureY - 8, 12, 16);    // Creature Mouth    fill(255, 0, 0);    rect(creatureX, creatureY - 35, 50, 20);    // Creature Nose    fill(128, 64, 0);    triangle(creatureX - 7, creatureY - 64, creatureX + 7, creatureY - 64, creatureX, creatureY - 55);    // Creature Teeth    fill(255, 255, 255);    triangle(creatureX - 23, creatureY - 45, creatureX - 3, creatureY - 45, creatureX - 13, creatureY - 30);    triangle(creatureX + 23, creatureY - 45, creatureX + 3, creatureY - 45, creatureX + 13, creatureY - 30);    // Creature Eyes    ellipse(creatureX - 17, creatureY - 75, 23, 32);    ellipse(creatureX + 17, creatureY - 75, 23, 32);    fill(9, 143, 202);    ellipse(creatureX - 17, creatureY - 75, 20, 20);    ellipse(creatureX + 17, creatureY - 75, 20, 20);    fill(0);    ellipse(creatureX - 17, creatureY - 75, 5, 5);    ellipse(creatureX + 17, creatureY - 75, 5, 5);    if (isEyesClosed) {        fill(red, green, blue);        ellipse(creatureX - 17, creatureY - 75, 23, 32);        ellipse(creatureX + 17, creatureY - 75, 23, 32);        stroke(red, green, blue);        rect(creatureX, creatureY - 35, 50, 20);        stroke(0);        line(creatureX - 20, creatureY - 35, creatureX + 20, creatureY - 35);    }}',correct
'pow(mouseX - creatureX, 2) + pow(mouseY - creatureY, 2)',correct
'-100',correct
'// Creature Legsellipse(creatureX - 16, creatureY + 23, 12, 10);',correct
'fill(0)',correct
'creatureX = posX',correct
'height - 20',correct
'ellipse(creatureX + 17, creatureY - 75, 20, 20)',correct
'float creatureX;',correct
'rect(creatureX, creatureY - 35, 50, 20)',correct
'if (isEyesClosed) {    fill(red, green, blue);    ellipse(creatureX - 17, creatureY - 75, 23, 32);    ellipse(creatureX + 17, creatureY - 75, 23, 32);    stroke(red, green, blue);    rect(creatureX, creatureY - 35, 50, 20);    stroke(0);    line(creatureX - 20, creatureY - 35, creatureX + 20, creatureY - 35);}',correct
'creatureX + 30',correct
'[8]',correct
'balls[i].fall()',correct
'ellipse(ballX, ballY, size, size);',correct
'float blue;',correct
'ellipse(creatureX - 17, creatureY - 75, 5, 5);',correct
'creatureSpeed *= -1',correct
'class Creature {    float creatureX;    float creatureY;    float creatureSpeed;    float red;    float green;    float blue;    boolean isEyesClosed = false;    Creature(float posX, float posY, float speed) {        creatureX = posX;        creatureY = posY;        creatureSpeed = speed;    }    void display() {        // Creature Body        stroke(0);        fill(red, green, blue);        ellipse(creatureX, creatureY, 50, 50);        // Creature Ears        ellipse(creatureX - 30, creatureY - 100, 32, 20);        ellipse(creatureX + 30, creatureY - 100, 32, 20);        // Creature Head        rect(creatureX, creatureY - 60, 60, 80);        // Creature Legs        ellipse(creatureX - 16, creatureY + 23, 12, 10);        ellipse(creatureX + 16, creatureY + 23, 12, 10);        // Creature Arms        ellipse(creatureX - 24, creatureY - 8, 12, 16);        ellipse(creatureX + 24, creatureY - 8, 12, 16);        // Creature Mouth        fill(255, 0, 0);        rect(creatureX, creatureY - 35, 50, 20);        // Creature Nose        fill(128, 64, 0);        triangle(creatureX - 7, creatureY - 64, creatureX + 7, creatureY - 64, creatureX, creatureY - 55);        // Creature Teeth        fill(255, 255, 255);        triangle(creatureX - 23, creatureY - 45, creatureX - 3, creatureY - 45, creatureX - 13, creatureY - 30);        triangle(creatureX + 23, creatureY - 45, creatureX + 3, creatureY - 45, creatureX + 13, creatureY - 30);        // Creature Eyes        ellipse(creatureX - 17, creatureY - 75, 23, 32);        ellipse(creatureX + 17, creatureY - 75, 23, 32);        fill(9, 143, 202);        ellipse(creatureX - 17, creatureY - 75, 20, 20);        ellipse(creatureX + 17, creatureY - 75, 20, 20);        fill(0);        ellipse(creatureX - 17, creatureY - 75, 5, 5);        ellipse(creatureX + 17, creatureY - 75, 5, 5);        if (isEyesClosed) {            fill(red, green, blue);            ellipse(creatureX - 17, creatureY - 75, 23, 32);            ellipse(creatureX + 17, creatureY - 75, 23, 32);            stroke(red, green, blue);            rect(creatureX, creatureY - 35, 50, 20);            stroke(0);            line(creatureX - 20, creatureY - 35, creatureX + 20, creatureY - 35);        }    }    void colorChange() {        red = random(0, 255);        green = random(0, 255);        blue = random(0, 255);    }    void move() {        creatureX += creatureSpeed;        if (creatureX > width - 30 || creatureX < 30) {            creatureSpeed *= -1;            colorChange();        }    }    void eyeClose() {        isEyesClosed = true;    }    void eyeOpen() {        isEyesClosed = false;    }    boolean mouseOnCreature() {        boolean isOn = false;        if (pow(mouseX - creatureX, 2) + pow(mouseY - creatureY, 2) <= pow(40, 2)) {            isOn = true;        }        return isOn;    }}',correct
'{    isOn = true;}',correct
'line(creatureX - 20, creatureY - 35, creatureX + 20, creatureY - 35)',correct
'Processing',correct
'creatureX - 3',correct
'creatureX - 7',correct
'blue = random(0, 255);',correct
'ellipse(creatureX - 16, creatureY + 23, 12, 10)',correct
'// BackgroundrectMode(CORNER);',correct
'float creatureY;',correct
'stroke(red, green, blue)',correct
'green',correct
'random(-200, -100)',correct
'float red;',correct
'{    isEyesClosed = false;}',correct
'ballX = ballX_;',correct
'false',correct
'ballY = random(-200, -100);',correct
'fill(128, 64, 0)',correct
'isEyesClosed = true',correct
'int i = 0',correct
'if (pow(mouseX - creatureX, 2) + pow(mouseY - creatureY, 2) <= pow(40, 2)) {    isOn = true;}',correct
'{    creatures[i].move();    creatures[i].display();}',correct
'ellipse(creatureX + 24, creatureY - 8, 12, 16);',correct
'pow(mouseY - creatureY, 2)',correct
'ballY > height',correct
'setup',correct
'// Creature Mouthfill(255, 0, 0);',correct
'ellipse(creatureX - 17, creatureY - 75, 23, 32);',correct
'i = 0',correct
'size = size_',correct
'Creature(float posX, float posY, float speed) {    creatureX = posX;    creatureY = posY;    creatureSpeed = speed;}',correct
'creatureSpeed *= -1;',correct
'i < balls.length',correct
'pow(40, 2)',correct
'colorChange();',correct
'size = size_;',correct
'fill(255, 255, 255);',correct
'float ballX_',correct
'float ballY;',correct
'{    fill(red, green, blue);    ellipse(creatureX - 17, creatureY - 75, 23, 32);    ellipse(creatureX + 17, creatureY - 75, 23, 32);    stroke(red, green, blue);    rect(creatureX, creatureY - 35, 50, 20);    stroke(0);    line(creatureX - 20, creatureY - 35, creatureX + 20, creatureY - 35);}',correct
'isOn = false',correct
'creatures[i].mouseOnCreature()',correct
'ellipse(creatureX - 17, creatureY - 75, 5, 5)',correct
'random(4, 8)',correct
'speedY = speedY_;',correct
'new Creature(random(50, width - 50), random(220, height - 20), random(1, 4))',correct
'ellipse(ballX, ballY, size, size)',correct
'rectMode(CORNER)',correct
'balls[i].fall();',correct
'// Creature Eyesellipse(creatureX - 17, creatureY - 75, 23, 32);',correct
'creatureSpeed',correct
'for (int i = 0; i < creatures.length; i++) {    creatures[i].eyeOpen();}',correct
'float ballY_',correct
'noStroke();',correct
'// Creature Headrect(creatureX, creatureY - 60, 60, 80);',correct
'{    background(66, 134, 244);    // Background    rectMode(CORNER);    noStroke();    fill(255, 250, 250);    rect(0, 200, width, height);    rectMode(CENTER);    // Display and move Creatures    for (int i = 0; i < creatures.length; i++) {        creatures[i].move();        creatures[i].display();    }    // Display and move Balls    for (int i = 0; i < balls.length; i++) {        balls[i].display();        balls[i].fall();    }}',correct
'{    ballY = random(-200, -100);    ballX = random(0, width);}',correct
'ballY = random(-200, -100)',correct
'creatures[i].eyeOpen();',correct
'creatureY - 8',correct
'ellipse(creatureX + 17, creatureY - 75, 23, 32);',correct
'random(-600, -100)',correct
'green = random(0, 255);',correct
'{    ballY += speedY;    if (ballY > height) {        ballY = random(-200, -100);        ballX = random(0, width);    }}',correct
'{    balls[i].display();    balls[i].fall();}',correct
'isEyesClosed = false;',correct
'ellipse(creatureX + 17, creatureY - 75, 5, 5);',correct
'stroke(red, green, blue);',correct
'fill(255, 250, 250);',correct
'Creature[]',correct
'ballX = random(0, width)',correct
'fill(9, 143, 202);',correct
'triangle(creatureX + 23, creatureY - 45, creatureX + 3, creatureY - 45, creatureX + 13, creatureY - 30);',correct
'ellipse(creatureX + 30, creatureY - 100, 32, 20)',correct
'display',LongMethodRule
'ballX = ballX_',correct
'creatureX += creatureSpeed',correct
'draw',correct
'isOn = true',correct
'{    creatures[i].eyeOpen();}',correct
'triangle(creatureX + 23, creatureY - 45, creatureX + 3, creatureY - 45, creatureX + 13, creatureY - 30)',correct
'creatureY = posY',correct
'// Create Creatures and give them a initial colorfor (int i = 0; i < creatures.length; i++) {    creatures[i] = new Creature(random(50, width - 50), random(220, height - 20), random(1, 4));    creatures[i].colorChange();}',correct
'ellipse(creatureX + 16, creatureY + 23, 12, 10)',correct
'creatureX + 13',correct
'background(66, 134, 244)',correct
'// Create Ballsfor (int i = 0; i < balls.length; i++) {    balls[i] = new Ball(random(width), random(-600, -100), random(4, 8), random(2, 6));}',correct
'-600',correct
'ellipse(creatureX - 24, creatureY - 8, 12, 16)',correct
'fill(255, 0, 0)',correct
'// Display and move Ballsfor (int i = 0; i < balls.length; i++) {    balls[i].display();    balls[i].fall();}',correct
'creatureY - 45',correct
'triangle(creatureX - 7, creatureY - 64, creatureX + 7, creatureY - 64, creatureX, creatureY - 55);',correct
'void draw() {    background(66, 134, 244);    // Background    rectMode(CORNER);    noStroke();    fill(255, 250, 250);    rect(0, 200, width, height);    rectMode(CENTER);    // Display and move Creatures    for (int i = 0; i < creatures.length; i++) {        creatures[i].move();        creatures[i].display();    }    // Display and move Balls    for (int i = 0; i < balls.length; i++) {        balls[i].display();        balls[i].fall();    }}',correct
'i++',correct
'void fall() {    ballY += speedY;    if (ballY > height) {        ballY = random(-200, -100);        ballX = random(0, width);    }}',correct
'triangle(creatureX - 7, creatureY - 64, creatureX + 7, creatureY - 64, creatureX, creatureY - 55)',correct
'ballY = ballY_',correct
'colorChange()',correct
'ballY += speedY',correct
'mousePressed',correct
'Creature[] creatures = new Creature[8];',correct
'creatures.length',correct
'{    creatures[i].eyeClose();}',correct
'creatures[i] = new Creature(random(50, width - 50), random(220, height - 20), random(1, 4))',correct
'{    for (int i = 0; i < creatures.length; i++) {        creatures[i].eyeOpen();    }}',correct
'rect(creatureX, creatureY - 60, 60, 80)',correct
'blue = random(0, 255)',correct
'ellipse(creatureX + 30, creatureY - 100, 32, 20);',correct
'triangle(creatureX - 23, creatureY - 45, creatureX - 3, creatureY - 45, creatureX - 13, creatureY - 30)',correct
'fill(255, 255, 255)',correct
'[400]',correct
'creatureX += creatureSpeed;',correct
'creatures[i] = new Creature(random(50, width - 50), random(220, height - 20), random(1, 4));',correct
'void',correct
'-1',correct
'{    creatures[i] = new Creature(random(50, width - 50), random(220, height - 20), random(1, 4));    creatures[i].colorChange();}',correct
'creatureY - 35',correct
'ballY',correct
'{    // Creature Body    stroke(0);    fill(red, green, blue);    ellipse(creatureX, creatureY, 50, 50);    // Creature Ears    ellipse(creatureX - 30, creatureY - 100, 32, 20);    ellipse(creatureX + 30, creatureY - 100, 32, 20);    // Creature Head    rect(creatureX, creatureY - 60, 60, 80);    // Creature Legs    ellipse(creatureX - 16, creatureY + 23, 12, 10);    ellipse(creatureX + 16, creatureY + 23, 12, 10);    // Creature Arms    ellipse(creatureX - 24, creatureY - 8, 12, 16);    ellipse(creatureX + 24, creatureY - 8, 12, 16);    // Creature Mouth    fill(255, 0, 0);    rect(creatureX, creatureY - 35, 50, 20);    // Creature Nose    fill(128, 64, 0);    triangle(creatureX - 7, creatureY - 64, creatureX + 7, creatureY - 64, creatureX, creatureY - 55);    // Creature Teeth    fill(255, 255, 255);    triangle(creatureX - 23, creatureY - 45, creatureX - 3, creatureY - 45, creatureX - 13, creatureY - 30);    triangle(creatureX + 23, creatureY - 45, creatureX + 3, creatureY - 45, creatureX + 13, creatureY - 30);    // Creature Eyes    ellipse(creatureX - 17, creatureY - 75, 23, 32);    ellipse(creatureX + 17, creatureY - 75, 23, 32);    fill(9, 143, 202);    ellipse(creatureX - 17, creatureY - 75, 20, 20);    ellipse(creatureX + 17, creatureY - 75, 20, 20);    fill(0);    ellipse(creatureX - 17, creatureY - 75, 5, 5);    ellipse(creatureX + 17, creatureY - 75, 5, 5);    if (isEyesClosed) {        fill(red, green, blue);        ellipse(creatureX - 17, creatureY - 75, 23, 32);        ellipse(creatureX + 17, creatureY - 75, 23, 32);        stroke(red, green, blue);        rect(creatureX, creatureY - 35, 50, 20);        stroke(0);        line(creatureX - 20, creatureY - 35, creatureX + 20, creatureY - 35);    }}',LongMethodRule
'creatureY - 30',correct
'creatures[i].display()',correct
'ballX',correct
'rect(0, 200, width, height)',correct
'mouseY - creatureY',correct
'for (int i = 0; i < creatures.length; i++) {    if (creatures[i].mouseOnCreature()) {        creatures[i].eyeClose();    }}',correct
'creatures[i].display();',correct
'new Creature[8]',correct
'creatureX > width - 30',correct
'red = random(0, 255);',correct
'fill(red, green, blue)',correct
'true',correct
'balls[i].display();',correct
'random(220, height - 20)',correct
'ballY += speedY;',correct
'// Creature Nosefill(128, 64, 0);',correct
'ellipse(creatureX + 17, creatureY - 75, 20, 20);',correct
'// Display and move Creaturesfor (int i = 0; i < creatures.length; i++) {    creatures[i].move();    creatures[i].display();}',correct
'creatures[i].move();',correct
'creatureY - 64',correct
'ellipse(creatureX, creatureY, 50, 50);',correct
'float green;',correct
'creatureY - 60',correct
'{    creatureX = posX;    creatureY = posY;    creatureSpeed = speed;}',correct
'boolean mouseOnCreature() {    boolean isOn = false;    if (pow(mouseX - creatureX, 2) + pow(mouseY - creatureY, 2) <= pow(40, 2)) {        isOn = true;    }    return isOn;}',correct
'i < creatures.length',correct
'balls.length',correct
'creatures[i].colorChange();',correct
'triangle(creatureX - 23, creatureY - 45, creatureX - 3, creatureY - 45, creatureX - 13, creatureY - 30);',correct
'creatureX > width - 30 || creatureX < 30',correct
'void display() {    noStroke();    fill(255, 255, 255);    ellipse(ballX, ballY, size, size);}',correct
'balls = new Ball[400]',correct
'ballX = random(0, width);',correct
'creatureY - 55',correct
'void eyeClose() {    isEyesClosed = true;}',correct
'creatures[i].eyeClose();',correct
'Ball[]',correct
'boolean isOn = false;',correct
'creatureY = posY;',correct
'{    creatureSpeed *= -1;    colorChange();}',correct
'Ball(float ballX_, float ballY_, float size_, float speedY_) {    ballX = ballX_;    ballY = ballY_;    size = size_;    speedY = speedY_;}',correct
'void eyeOpen() {    isEyesClosed = false;}',correct
'{    boolean isOn = false;    if (pow(mouseX - creatureX, 2) + pow(mouseY - creatureY, 2) <= pow(40, 2)) {        isOn = true;    }    return isOn;}',correct
'float ballX;',correct
'ellipse(creatureX - 30, creatureY - 100, 32, 20)',correct
'{    isEyesClosed = true;}',correct
'keyCode == DOWN && doOnce2 == false',correct
'fill(55, 26, 138)',correct
'triangle(iconX, iconY + 50, iconX - 10, iconY + 40, iconX + 10, iconY + 40)',correct
'bubbles[i].move()',correct
'iconY + 55',correct
'handY = y;',correct
'bubbleY < 0',correct
'doOnce = false;',correct
'iconY + 50',correct
'armY += 50;',correct
'fill(0, 0, 255, 30)',correct
'fill(55, 26, 138);',correct
'bubbleX',correct
'{    bubbles[i] = new Bubble(random(0, width), random(0, height), random(15, 30), random(1, 4));}',correct
'doOnce2 = true;',correct
'bubbleY',correct
'bubbleSize = initSize',correct
'void mouseDragged() {    Spongebob.move(mouseX, mouseY);    arm.move(mouseX, mouseY);}',correct
'ellipse(bubbleX, bubbleY, bubbleSize, bubbleSize);',correct
'i < bubbles.length',correct
'{}',EmptyIfStmt
'stroke(0)',correct
'bubbles[i]',correct
'stroke(0, 0, 255)',correct
'iconX = x',correct
'arm.display()',correct
'fill(0, 0, 0)',correct
'// armsarm.display();',correct
'void display() {    fill(0, 0, 255, 30);    stroke(0, 0, 255);    ellipse(bubbleX, bubbleY, bubbleSize, bubbleSize);}',correct
'iconX = x;',correct
'iconY + 125',correct
'rect(iconX - 26, iconY + 95, 10, 50)',correct
'// eyesfill(255, 255, 255);',correct
'handY',correct
'handX',correct
'{    handY += 100;    armY += 50;    doOnce2 = true;    doOnce = false;}',correct
'void setup() {    // size of the frame    Spongebob = new Sponge(200, 200);    arm = new Arms(200, 200);    for (int i = 0; i < bubbles.length; i++) {        bubbles[i] = new Bubble(random(0, width), random(0, height), random(15, 30), random(1, 4));    }}',correct
'iconY + 60',correct
'rect(iconX + 26, iconY + 78, 14, 15);',correct
'fill(255, 0, 0);',correct
'{    bubbleY = random(400, 500);}',correct
'rect(iconX - 5, iconY + 11, 7, 12)',correct
'new Sponge(200, 200)',correct
'ellipse(iconX + 20, iconY - 25, 30, 30);',correct
'arm = new Arms(200, 200);',correct
'rect(iconX + 26, iconY + 95, 10, 50)',correct
'fill(160, 160, 160)',correct
'arm.cheer()',correct
'random(1, 4)',correct
'iconX + 5',correct
'Spongebob.display()',correct
'rect(iconX - 26, iconY + 103, 10, 2);',correct
'rect(40, 260, 5, 20);',correct
'rect(iconX, iconY + 55, 15, 15)',correct
'{    handY -= 100;    armY -= 50;    doOnce = true;    doOnce2 = false;}',correct
'bubbleY = random(400, 500)',correct
'{    Spongebob.move(mouseX, mouseY);    arm.move(mouseX, mouseY);}',correct
'armY -= 50;',correct
'bubbles[i].display()',correct
'int handY;',correct
'float initSize',correct
'handY -= 100;',correct
'arm',correct
'rect(iconX - 26, iconY + 110, 10, 20)',correct
'rectMode(CENTER)',correct
'new Bubble(random(0, width), random(0, height), random(15, 30), random(1, 4))',correct
'rect(200, 400, 450, 200)',correct
'rect(iconX - 26, iconY + 78, 14, 15)',correct
'random(0, width)',correct
'Spongebob',correct
'iconY + 40',correct
'// handsfill(255, 255, 0);',correct
'void move() {    bubbleY -= bubbleSpeed;    if (bubbleY < 0) {        bubbleY = random(400, 500);    }}',correct
'float bubbleSpeed;',correct
'rectMode(CENTER);',correct
'background(0, 200, 255)',correct
'boolean doOnce;',correct
'// sandfill(219, 209, 180);',correct
'rect(iconX + 26, iconY + 110, 10, 20);',correct
'rect(armX + 55, armY + 20, 10, 50)',correct
'bubbleY = initY;',correct
'Sponge(int x, int y) {    iconX = x;    iconY = y;}',correct
'fill(255, 230, 0)',correct
'rect(iconX, iconY + 60, 100, 20)',correct
'fill(193, 36, 36)',correct
'iconY + 11',correct
'// legsfill(255, 255, 0);',correct
'// beltfill(0, 0, 0);',correct
'new Arms(200, 200)',correct
'bubbleY = initY',correct
'// shirtfill(255, 255, 255);',correct
'iconX + 10',correct
'iconY = y',correct
'rect(iconX - 42, iconY + 55, 10, 5)',correct
'{    if (keyCode == UP) {        handY -= 100;        armY -= 50;        doOnce = true;        doOnce2 = false;    }}',correct
'stroke(0, 0, 255);',correct
'{    // arms    fill(255, 255, 0);    rect(armX + 55, armY + 20, 10, 50);    rect(armX - 55, armY + 20, 10, 50);    // hands    fill(255, 255, 0);    rect(handX + 57, handY + 40, 15, 15);    rect(handX - 57, handY + 40, 15, 15);}',correct
'fill(160, 160, 160);',correct
'rect(iconX + 26, iconY + 107, 10, 2);',correct
'ellipse(bubbleX, bubbleY, bubbleSize, bubbleSize)',correct
'rect(iconX + 22, iconY + 55, 10, 5)',correct
'handY += 100',correct
'if (bubbleY < 0) {    bubbleY = random(400, 500);}',correct
'rect(iconX - 26, iconY + 110, 10, 20);',correct
'fill(139, 69, 19);',correct
'handY = y',correct
'if (keyCode == DOWN && doOnce2 == false) {    handY += 100;    armY += 50;    doOnce2 = true;    doOnce = false;} else {}',SimplifyBooleanExpressions
'bubbles.length',correct
'rect(iconX - 5, iconY + 11, 7, 12);',correct
'class Sponge {    int iconX;    int iconY;    Sponge(int x, int y) {        iconX = x;        iconY = y;    }    void display() {        // body        stroke(0);        rectMode(CENTER);        fill(255, 255, 0);        rect(iconX, iconY, 100, 120);        // eyes        fill(255, 255, 255);        ellipse(iconX - 20, iconY - 25, 30, 30);        ellipse(iconX + 20, iconY - 25, 30, 30);        fill(0, 0, 0);        ellipse(iconX - 20, iconY - 25, 5, 5);        ellipse(iconX + 20, iconY - 25, 5, 5);        // legs        fill(255, 255, 0);        rect(iconX - 26, iconY + 95, 10, 50);        rect(iconX + 26, iconY + 95, 10, 50);        // mouth        fill(193, 36, 36);        arc(iconX, iconY + 5, 50, 50, 0, 3.13f, PIE);        fill(255, 255, 255);        rect(iconX - 5, iconY + 11, 7, 12);        rect(iconX + 5, iconY + 11, 7, 12);        // nose        fill(255, 230, 0);        rect(iconX + 10, iconY - 5, 20, 5);        // shirt        fill(255, 255, 255);        rect(iconX, iconY + 50, 100, 20);        fill(255, 0, 0);        triangle(iconX, iconY + 50, iconX - 10, iconY + 40, iconX + 10, iconY + 40);        // pants        fill(168, 84, 24);        rect(iconX, iconY + 60, 100, 20);        rect(iconX + 26, iconY + 78, 14, 15);        rect(iconX - 26, iconY + 78, 14, 15);        // socks        fill(255, 255, 255);        rect(iconX + 26, iconY + 110, 10, 20);        rect(iconX - 26, iconY + 110, 10, 20);        fill(55, 26, 138);        rect(iconX + 26, iconY + 103, 10, 2);        rect(iconX - 26, iconY + 103, 10, 2);        fill(255, 0, 0);        rect(iconX + 26, iconY + 107, 10, 2);        rect(iconX - 26, iconY + 107, 10, 2);        // belt        fill(0, 0, 0);        rect(iconX - 42, iconY + 55, 10, 5);        rect(iconX - 22, iconY + 55, 10, 5);        rect(iconX + 22, iconY + 55, 10, 5);        rect(iconX + 42, iconY + 55, 10, 5);        fill(160, 160, 160);        rect(iconX, iconY + 55, 15, 15);        fill(0, 0, 0);        rect(iconX, iconY + 55, 9, 9);        // shoes        rect(iconX - 26, iconY + 125, 15, 15);        rect(iconX + 26, iconY + 125, 15, 15);    }    void move(int x, int y) {        iconX = x;        iconY = y;    }}',correct
'// bodystroke(0);',correct
'3.13f',correct
'rect(iconX - 26, iconY + 78, 14, 15);',correct
'// background',correct
'doOnce2 = false',correct
'float initSpeed',correct
'rect(iconX + 42, iconY + 55, 10, 5);',correct
'// shoesrect(iconX - 26, iconY + 125, 15, 15);',correct
'class Bubble {    float bubbleX;    float bubbleY;    float bubbleSize;    float bubbleSpeed;    Bubble(float initX, float initY, float initSize, float initSpeed) {        bubbleX = initX;        bubbleY = initY;        bubbleSize = initSize;        bubbleSpeed = initSpeed;    }    void display() {        fill(0, 0, 255, 30);        stroke(0, 0, 255);        ellipse(bubbleX, bubbleY, bubbleSize, bubbleSize);    }    void move() {        bubbleY -= bubbleSpeed;        if (bubbleY < 0) {            bubbleY = random(400, 500);        }    }}',correct
'armY -= 50',correct
'bubbles = new Bubble[50]',correct
'rect(armX - 55, armY + 20, 10, 50)',correct
'iconY + 5',correct
'arm.move(mouseX, mouseY)',correct
'void draw() {    background(0, 200, 255);    // background    // patricks stone    stroke(0);    fill(222, 184, 135);    rect(40, 260, 5, 20);    fill(139, 69, 19);    ellipse(70, 300, 100, 100);    fill(0, 0, 0);    // sand    fill(219, 209, 180);    rect(200, 400, 450, 200);    // spongbob    Spongebob.display();    // arms    arm.display();    // bubbles    for (int i = 0; i < bubbles.length; i++) {        bubbles[i].display();        bubbles[i].move();    }}',correct
'rect(iconX - 26, iconY + 125, 15, 15)',correct
'random(0, height)',correct
'// spongbobSpongebob.display();',correct
'ellipse(iconX + 20, iconY - 25, 30, 30)',correct
'rect(handX - 57, handY + 40, 15, 15)',correct
'[50]',correct
'Processing',correct
'iconY + 110',correct
'rect(iconX + 26, iconY + 107, 10, 2)',correct
'float bubbleSize;',correct
'void move(int x, int y) {    armX = x;    armY = y;    handX = x;    handY = y;}',correct
'Bubble[] bubbles = new Bubble[50];',correct
'iconY + 107',correct
'bubbleSpeed',correct
'handX + 57',correct
'rect(iconX + 26, iconY + 125, 15, 15)',correct
'rect(iconX + 10, iconY - 5, 20, 5);',correct
'rect(iconX - 22, iconY + 55, 10, 5)',correct
'doOnce2 == false',correct
'// background// patricks stonestroke(0);',correct
'armX + 55',correct
'handX = x',correct
'armY + 20',correct
'if (keyCode == UP) {    handY -= 100;    armY -= 50;    doOnce = true;    doOnce2 = false;}',correct
'false',correct
'rect(iconX + 26, iconY + 125, 15, 15);',correct
'iconY + 103',correct
'fill(219, 209, 180)',correct
'iconX + 22',correct
'class Arms {    int armX;    int armY;    int handX;    int handY;    boolean doOnce;    boolean doOnce2;    Arms(int x, int y) {        armX = x;        armY = y;        handX = x;        handY = y;    }    void display() {        // arms        fill(255, 255, 0);        rect(armX + 55, armY + 20, 10, 50);        rect(armX - 55, armY + 20, 10, 50);        // hands        fill(255, 255, 0);        rect(handX + 57, handY + 40, 15, 15);        rect(handX - 57, handY + 40, 15, 15);    }    void cheer() {        if (keyPressed == true && doOnce == false) {            if (keyCode == UP) {                handY -= 100;                armY -= 50;                doOnce = true;                doOnce2 = false;            }        }        if (keyCode == DOWN && doOnce2 == false) {            handY += 100;            armY += 50;            doOnce2 = true;            doOnce = false;        } else {        }    }    void move(int x, int y) {        armX = x;        armY = y;        handX = x;        handY = y;    }}',correct
'int i = 0',correct
'iconX + 20',correct
'iconX - 5',correct
'ellipse(70, 300, 100, 100)',correct
'iconY',correct
'keyPressed == true',correct
'boolean doOnce2;',correct
'doOnce = true',correct
'setup',correct
'bubbleY -= bubbleSpeed',correct
'Sponge',correct
'iconX + 26',correct
'i = 0',correct
'handX = x;',correct
'fill(139, 69, 19)',correct
'rect(iconX, iconY + 55, 9, 9);',correct
'ellipse(iconX + 20, iconY - 25, 5, 5)',correct
'rect(iconX, iconY + 50, 100, 20);',correct
'arm = new Arms(200, 200)',correct
'iconX',correct
'handY + 40',correct
'bubbles[i].display();',correct
'rect(iconX - 26, iconY + 107, 10, 2);',correct
'rect(iconX, iconY + 60, 100, 20);',correct
'handY += 100;',correct
'doOnce == false',correct
'fill(0, 0, 255, 30);',correct
'ellipse(iconX - 20, iconY - 25, 30, 30)',correct
'fill(255, 255, 255);',correct
'bubbleSize',correct
'Bubble[]',correct
'handX - 57',correct
'void display() {    // body    stroke(0);    rectMode(CENTER);    fill(255, 255, 0);    rect(iconX, iconY, 100, 120);    // eyes    fill(255, 255, 255);    ellipse(iconX - 20, iconY - 25, 30, 30);    ellipse(iconX + 20, iconY - 25, 30, 30);    fill(0, 0, 0);    ellipse(iconX - 20, iconY - 25, 5, 5);    ellipse(iconX + 20, iconY - 25, 5, 5);    // legs    fill(255, 255, 0);    rect(iconX - 26, iconY + 95, 10, 50);    rect(iconX + 26, iconY + 95, 10, 50);    // mouth    fill(193, 36, 36);    arc(iconX, iconY + 5, 50, 50, 0, 3.13f, PIE);    fill(255, 255, 255);    rect(iconX - 5, iconY + 11, 7, 12);    rect(iconX + 5, iconY + 11, 7, 12);    // nose    fill(255, 230, 0);    rect(iconX + 10, iconY - 5, 20, 5);    // shirt    fill(255, 255, 255);    rect(iconX, iconY + 50, 100, 20);    fill(255, 0, 0);    triangle(iconX, iconY + 50, iconX - 10, iconY + 40, iconX + 10, iconY + 40);    // pants    fill(168, 84, 24);    rect(iconX, iconY + 60, 100, 20);    rect(iconX + 26, iconY + 78, 14, 15);    rect(iconX - 26, iconY + 78, 14, 15);    // socks    fill(255, 255, 255);    rect(iconX + 26, iconY + 110, 10, 20);    rect(iconX - 26, iconY + 110, 10, 20);    fill(55, 26, 138);    rect(iconX + 26, iconY + 103, 10, 2);    rect(iconX - 26, iconY + 103, 10, 2);    fill(255, 0, 0);    rect(iconX + 26, iconY + 107, 10, 2);    rect(iconX - 26, iconY + 107, 10, 2);    // belt    fill(0, 0, 0);    rect(iconX - 42, iconY + 55, 10, 5);    rect(iconX - 22, iconY + 55, 10, 5);    rect(iconX + 22, iconY + 55, 10, 5);    rect(iconX + 42, iconY + 55, 10, 5);    fill(160, 160, 160);    rect(iconX, iconY + 55, 15, 15);    fill(0, 0, 0);    rect(iconX, iconY + 55, 9, 9);    // shoes    rect(iconX - 26, iconY + 125, 15, 15);    rect(iconX + 26, iconY + 125, 15, 15);}',correct
'fill(168, 84, 24)',correct
'rect(armX + 55, armY + 20, 10, 50);',correct
'if (keyPressed == true && doOnce == false) {    if (keyCode == UP) {        handY -= 100;        armY -= 50;        doOnce = true;        doOnce2 = false;    }}',SimplifyBooleanExpressions
'iconY = y;',correct
'rect(iconX, iconY, 100, 120)',correct
'doOnce2 = false;',correct
'arc(iconX, iconY + 5, 50, 50, 0, 3.13f, PIE);',correct
'doOnce2 = true',correct
'Arms(int x, int y) {    armX = x;    armY = y;    handX = x;    handY = y;}',correct
'{    background(0, 200, 255);    // background    // patricks stone    stroke(0);    fill(222, 184, 135);    rect(40, 260, 5, 20);    fill(139, 69, 19);    ellipse(70, 300, 100, 100);    fill(0, 0, 0);    // sand    fill(219, 209, 180);    rect(200, 400, 450, 200);    // spongbob    Spongebob.display();    // arms    arm.display();    // bubbles    for (int i = 0; i < bubbles.length; i++) {        bubbles[i].display();        bubbles[i].move();    }}',correct
'keyPressed == true && doOnce == false',correct
'iconX + 42',correct
'// pantsfill(168, 84, 24);',correct
'rect(iconX - 22, iconY + 55, 10, 5);',correct
'void cheer() {    if (keyPressed == true && doOnce == false) {        if (keyCode == UP) {            handY -= 100;            armY -= 50;            doOnce = true;            doOnce2 = false;        }    }    if (keyCode == DOWN && doOnce2 == false) {        handY += 100;        armY += 50;        doOnce2 = true;        doOnce = false;    } else {    }}',correct
'iconY - 5',correct
'int iconX;',correct
'bubbleSize = initSize;',correct
'doOnce',correct
'ellipse(iconX - 20, iconY - 25, 30, 30);',correct
'arm.cheer();',correct
'rect(iconX + 26, iconY + 110, 10, 20)',correct
'armY',correct
'rect(iconX - 26, iconY + 107, 10, 2)',correct
'{    fill(0, 0, 255, 30);    stroke(0, 0, 255);    ellipse(bubbleX, bubbleY, bubbleSize, bubbleSize);}',correct
'armX',correct
'keyCode == UP',correct
'random(15, 30)',correct
'rect(iconX + 42, iconY + 55, 10, 5)',correct
'rect(iconX, iconY + 50, 100, 20)',correct
'rect(iconX + 10, iconY - 5, 20, 5)',correct
'background(0, 200, 255);',correct
'// size of the frameSpongebob = new Sponge(200, 200);',correct
'ellipse(iconX + 20, iconY - 25, 5, 5);',correct
'bubbles[i] = new Bubble(random(0, width), random(0, height), random(15, 30), random(1, 4));',correct
'iconX - 10',correct
'doOnce = false',correct
'// bubblesfor (int i = 0; i < bubbles.length; i++) {    bubbles[i].display();    bubbles[i].move();}',correct
'rect(iconX, iconY + 55, 9, 9)',correct
'ellipse(iconX - 20, iconY - 25, 5, 5)',correct
'// socksfill(255, 255, 255);',correct
'bubbleSpeed = initSpeed',correct
'display',LongMethodRule
'Spongebob = new Sponge(200, 200)',correct
'rect(iconX + 5, iconY + 11, 7, 12);',correct
'draw',correct
'rect(handX + 57, handY + 40, 15, 15)',correct
'rect(handX + 57, handY + 40, 15, 15);',correct
'void display() {    // arms    fill(255, 255, 0);    rect(armX + 55, armY + 20, 10, 50);    rect(armX - 55, armY + 20, 10, 50);    // hands    fill(255, 255, 0);    rect(handX + 57, handY + 40, 15, 15);    rect(handX - 57, handY + 40, 15, 15);}',correct
'armX = x',correct
'int y',correct
'doOnce = true;',correct
'// armsfill(255, 255, 0);',correct
'{    // size of the frame    Spongebob = new Sponge(200, 200);    arm = new Arms(200, 200);    for (int i = 0; i < bubbles.length; i++) {        bubbles[i] = new Bubble(random(0, width), random(0, height), random(15, 30), random(1, 4));    }}',correct
'int x',correct
'rect(iconX + 26, iconY + 103, 10, 2);',correct
'rect(armX - 55, armY + 20, 10, 50);',correct
'rect(handX - 57, handY + 40, 15, 15);',correct
'int armX;',correct
'fill(255, 0, 0)',correct
'{    bubbles[i].display();    bubbles[i].move();}',correct
'float initX',correct
'float initY',correct
'i++',correct
'bubbleX = initX;',correct
'rect(200, 400, 450, 200);',PixelHardcodeIgnoranceRule
'iconY + 95',correct
'Sponge Spongebob;',VariableNamingConventions
'armY = y;',correct
'// mouthfill(193, 36, 36);',correct
'Bubble',correct
'fill(255, 255, 0)',correct
'keyCode == DOWN',correct
'ellipse(iconX - 20, iconY - 25, 5, 5);',correct
'fill(255, 255, 255)',correct
'rect(iconX + 22, iconY + 55, 10, 5);',correct
'int armY;',correct
'void',LongMethodRule
'rect(iconX - 26, iconY + 103, 10, 2)',correct
'int iconY;',correct
'for (int i = 0; i < bubbles.length; i++) {    bubbles[i] = new Bubble(random(0, width), random(0, height), random(15, 30), random(1, 4));}',correct
'rect(iconX - 42, iconY + 55, 10, 5);',correct
'rect(iconX + 5, iconY + 11, 7, 12)',correct
'Arms',correct
'rect(iconX, iconY + 55, 15, 15);',correct
'armX - 55',correct
'new Bubble[50]',correct
'{    // body    stroke(0);    rectMode(CENTER);    fill(255, 255, 0);    rect(iconX, iconY, 100, 120);    // eyes    fill(255, 255, 255);    ellipse(iconX - 20, iconY - 25, 30, 30);    ellipse(iconX + 20, iconY - 25, 30, 30);    fill(0, 0, 0);    ellipse(iconX - 20, iconY - 25, 5, 5);    ellipse(iconX + 20, iconY - 25, 5, 5);    // legs    fill(255, 255, 0);    rect(iconX - 26, iconY + 95, 10, 50);    rect(iconX + 26, iconY + 95, 10, 50);    // mouth    fill(193, 36, 36);    arc(iconX, iconY + 5, 50, 50, 0, 3.13f, PIE);    fill(255, 255, 255);    rect(iconX - 5, iconY + 11, 7, 12);    rect(iconX + 5, iconY + 11, 7, 12);    // nose    fill(255, 230, 0);    rect(iconX + 10, iconY - 5, 20, 5);    // shirt    fill(255, 255, 255);    rect(iconX, iconY + 50, 100, 20);    fill(255, 0, 0);    triangle(iconX, iconY + 50, iconX - 10, iconY + 40, iconX + 10, iconY + 40);    // pants    fill(168, 84, 24);    rect(iconX, iconY + 60, 100, 20);    rect(iconX + 26, iconY + 78, 14, 15);    rect(iconX - 26, iconY + 78, 14, 15);    // socks    fill(255, 255, 255);    rect(iconX + 26, iconY + 110, 10, 20);    rect(iconX - 26, iconY + 110, 10, 20);    fill(55, 26, 138);    rect(iconX + 26, iconY + 103, 10, 2);    rect(iconX - 26, iconY + 103, 10, 2);    fill(255, 0, 0);    rect(iconX + 26, iconY + 107, 10, 2);    rect(iconX - 26, iconY + 107, 10, 2);    // belt    fill(0, 0, 0);    rect(iconX - 42, iconY + 55, 10, 5);    rect(iconX - 22, iconY + 55, 10, 5);    rect(iconX + 22, iconY + 55, 10, 5);    rect(iconX + 42, iconY + 55, 10, 5);    fill(160, 160, 160);    rect(iconX, iconY + 55, 15, 15);    fill(0, 0, 0);    rect(iconX, iconY + 55, 9, 9);    // shoes    rect(iconX - 26, iconY + 125, 15, 15);    rect(iconX + 26, iconY + 125, 15, 15);}',LongMethodRule
'fill(222, 184, 135)',correct
'iconX - 26',correct
'float bubbleY;',correct
'true',correct
'arm.move(mouseX, mouseY);',correct
'fill(255, 255, 0);',correct
'int handX;',correct
'iconX - 20',correct
'iconX - 22',correct
'{    arm.cheer();}',correct
'rect(iconX + 26, iconY + 78, 14, 15)',correct
'{    bubbleX = initX;    bubbleY = initY;    bubbleSize = initSize;    bubbleSpeed = initSpeed;}',correct
'ellipse(70, 300, 100, 100);',correct
'rect(iconX + 26, iconY + 103, 10, 2)',correct
'bubbleY = random(400, 500);',correct
'bubbleX = initX',correct
'iconY + 78',correct
'bubbles[i] = new Bubble(random(0, width), random(0, height), random(15, 30), random(1, 4))',correct
'fill(0, 0, 0);',correct
'{    iconX = x;    iconY = y;}',correct
'Bubble(float initX, float initY, float initSize, float initSpeed) {    bubbleX = initX;    bubbleY = initY;    bubbleSize = initSize;    bubbleSpeed = initSpeed;}',correct
'float bubbleX;',correct
'bubbleY -= bubbleSpeed;',correct
'{    if (keyPressed == true && doOnce == false) {        if (keyCode == UP) {            handY -= 100;            armY -= 50;            doOnce = true;            doOnce2 = false;        }    }    if (keyCode == DOWN && doOnce2 == false) {        handY += 100;        armY += 50;        doOnce2 = true;        doOnce = false;    } else {    }}',correct
'{    armX = x;    armY = y;    handX = x;    handY = y;}',correct
'rect(iconX, iconY, 100, 120);',correct
'bubbles[i].move();',correct
'doOnce2',correct
'rect(iconX + 26, iconY + 95, 10, 50);',correct
'void move(int x, int y) {    iconX = x;    iconY = y;}',correct
'Spongebob.move(mouseX, mouseY)',correct
'// nosefill(255, 230, 0);',correct
'iconY - 25',correct
'armY += 50',correct
'arc(iconX, iconY + 5, 50, 50, 0, 3.13f, PIE)',correct
'armX = x;',correct
'bubbleSpeed = initSpeed;',correct
'rect(iconX - 26, iconY + 95, 10, 50);',correct
'Arms arm;',correct
'triangle(iconX, iconY + 50, iconX - 10, iconY + 40, iconX + 10, iconY + 40);',correct
'rect(40, 260, 5, 20)',correct
'handY -= 100',correct
'Spongebob.move(mouseX, mouseY);',correct
'random(400, 500)',correct
'iconX - 42',correct
'void keyPressed() {    arm.cheer();}',correct
'armY = y',correct
'fill(222, 184, 135);',correct
'{    bubbleY -= bubbleSpeed;    if (bubbleY < 0) {        bubbleY = random(400, 500);    }}',correct
'grass = color(0xff59D326)',correct
'random(width)',correct
'// and lights up your day. But when you press the mouse the sun goes away and the night appears',correct
'ellipse(20, -20, bodyX2 - 90, bodyY2 - 90)',correct
'nosecolor',correct
'{    stroke(255);    strokeWeight(1);    triangle(0, -13, -3, -3, 3, -3);    rotate(radians(45));}',correct
'new Sun()',correct
'released = false;',DrawingStateChangeRule
'theSun[k].display();',correct
'bodyY2 - 90',correct
'void draw() {    if (mouseX >= width / 2) {        released = false;    } else if (mouseX <= width / 2) {        released = true;    }    if (released) {        for (int k = 0; k < 1; k++) {            theSun[k].display();        }    }    // night    if (!released) {        background(0);        for (int i = 0; i < sterren.length; i++) {            sterren[i].display();        }        for (int h = 0; h < theMoon.length; h++) {            theMoon[h].display();        }    }}',correct
'theMoon.length',correct
'eye1',correct
'sterren[i] = new Ster(PApplet.parseInt(random(width)), PApplet.parseInt(random(height)))',correct
'for (int h = 0; h < theMoon.length; h++) {    theMoon[h].display();}',correct
'ellipse(0, 0, 10, 10);',correct
'grass = color(0xff59D326);',correct
'rotate(radians(45))',correct
'// bodystroke(255);',correct
'int grass;',correct
'background1 = color(0xff47C2FA)',correct
'theMoon = new Moon[1]',correct
'Moon() {    // colors    eyemoon = color(255);    eyemoon1 = color(0);    sideeye = color(0);    mouthmoon = color(0xffEA7BAB);    nosecolormoon = color(0xffF79334);    cratestroke = color(0xffC8CCCE);    crate = color(0xffBBBFC1);    moon = color(255);}',correct
'int moon;',correct
'inc = TWO_PI / 25.0f',correct
'mouseX >= width / 2',correct
'stroke(0);',correct
'stroke(0)',correct
'fill(mouth);',correct
'triangle(0, -85, -20, -45, 20, -45)',correct
'{    released = false;}',correct
'pushMatrix();',correct
'arc(0, 0, 12, 14, 0, PI, CHORD)',correct
'sterren[i]',correct
'color(0xffF79334)',correct
'strokeWeight(1);',correct
'k = 0',correct
'Sun',correct
'// mouth',correct
'// cratestroke(cratestroke);',correct
'sterren',correct
'eye',correct
'bodyY1 = mouseY;',correct
'// array of objectsclass Sun {    // colors    int bodyColor;    int background1;    int nosecolor;    int mouth;    int grass;    int eye;    int eye1;    Sun() {        // colors        bodyColor = color(0xffFCF000);        background1 = color(0xff47C2FA);        nosecolor = color(0xffF79334);        mouth = color(0xffEA7BAB);        grass = color(0xff59D326);        eye = color(255);        eye1 = color(0);    }    void display() {        background(background1);        // grass        fill(grass);        stroke(grass);        rect(0, height, width * 2, height / 4);        pushMatrix();        translate(bodyX1, bodyY1);        stroke(bodyColor);        fill(bodyColor);        // triangels        pushMatrix();        for (int i = 0; i < 18; i++) {            stroke(0);            strokeWeight(2);            triangle(0, -85, -20, -45, 20, -45);            rotate(radians(20));        }        popMatrix();        // body        stroke(0);        ellipse(0, 0, bodyX2, bodyY2);        // eyes        fill(eye);        stroke(0);        ellipse(-20, -20, bodyX2 - 80, bodyY2 - 85);        ellipse(20, -20, bodyX2 - 80, bodyY2 - 85);        fill(eye1);        ellipse(-20, -20, bodyX2 - 90, bodyY2 - 90);        ellipse(20, -20, bodyX2 - 90, bodyY2 - 90);        // mouth        // vragen hoe ik hem recht kan krijgen, waar staat het pie ding voor        arc(0, 21, 30, 30, 0, PI);        fill(mouth);        arc(0, 22, 12, 28, 0, PI, CHORD);        line(0, 22, 0, 30);        fill(nosecolor);        arc(0, 0, 12, 14, 0, PI, CHORD);        // grass        fill(grass);        stroke(grass);        rect(0, height, width * 2, height / 4);        popMatrix();    }    // void update(){    // (bodyX1^2)+(bodyY1^2)=40;    // bodyX1++;    // }}',correct
'sterren.length',correct
'// }',correct
'{    // colors    bodyColor = color(0xffFCF000);    background1 = color(0xff47C2FA);    nosecolor = color(0xffF79334);    mouth = color(0xffEA7BAB);    grass = color(0xff59D326);    eye = color(255);    eye1 = color(0);}',correct
'for (int i = 0; i < sterren.length; i++) {    sterren[i] = new Ster(PApplet.parseInt(random(width)), PApplet.parseInt(random(height)));}',correct
'void display() {    pushMatrix();    translate(starX, starY);    // star    fill(255);    pushMatrix();    for (int i = 0; i < 8; i++) {        stroke(255);        strokeWeight(1);        triangle(0, -13, -3, -3, 3, -3);        rotate(radians(45));    }    popMatrix();    // body    stroke(255);    ellipse(0, 0, 10, 10);    popMatrix();}',correct
'theMoon[h] = new Moon()',correct
'Sun[]',correct
'triangle(0, -13, -3, -3, 3, -3)',correct
'stroke(bodyColor)',correct
'{    bodyY1 = bodyY1 + inc;}',correct
'{    pushMatrix();    translate(starX, starY);    // star    fill(255);    pushMatrix();    for (int i = 0; i < 8; i++) {        stroke(255);        strokeWeight(1);        triangle(0, -13, -3, -3, 3, -3);        rotate(radians(45));    }    popMatrix();    // body    stroke(255);    ellipse(0, 0, 10, 10);    popMatrix();}',correct
'for (int i = 0; i < 8; i++) {    stroke(255);    strokeWeight(1);    triangle(0, -13, -3, -3, 3, -3);    rotate(radians(45));}',correct
'bodyX1 = mouseX',correct
'bodyX2 - 90',correct
'crate = color(0xffBBBFC1);',correct
'theMoon[h] = new Moon();',correct
'grass',correct
'nosecolormoon',correct
'released = true;',DrawingStateChangeRule
'// grassfill(grass);',correct
'int xpos',correct
'// make the suntheSun = new Sun[1];',correct
'fill(moon);',correct
'rectMode(CENTER)',correct
'moon = color(255);',correct
'Sun[] theSun;',correct
'random(height)',correct
'{    background(0);    for (int i = 0; i < sterren.length; i++) {        sterren[i].display();    }    for (int h = 0; h < theMoon.length; h++) {        theMoon[h].display();    }}',correct
'crate',correct
'popMatrix();',correct
'released = false',correct
'theMoon',correct
'eyemoon1 = color(0)',correct
'ellipse(-20, -20, bodyX2 - 80, bodyY2 - 85);',correct
'int h = 0',correct
'strokeWeight(2);',correct
'theSun[k] = new Sun();',correct
'boolean released = true;',correct
'{    // moon    pushMatrix();    translate(bodyX1, bodyY1);    stroke(moon);    fill(moon);    ellipse(0, 0, 100, 100);    // eyesmoon    fill(eyemoon);    stroke(sideeye);    ellipse(-20, -20, bodyX2 - 80, bodyY2 - 85);    ellipse(20, -20, bodyX2 - 80, bodyY2 - 85);    fill(eyemoon1);    ellipse(-20, -20, bodyX2 - 90, bodyY2 - 90);    ellipse(20, -20, bodyX2 - 90, bodyY2 - 90);    // mouthmoon    // vragen hoe ik hem recht kan krijgen, waar staat het pie ding voor    arc(0, 21, 30, 30, 0, PI);    fill(mouthmoon);    arc(0, 22, 12, 28, 0, PI, CHORD);    line(0, 22, 0, 30);    fill(nosecolormoon);    arc(0, 0, 12, 14, 0, PI, CHORD);    // crate    stroke(cratestroke);    fill(crate);    ellipse(28, 8, 30, 30);    stroke(cratestroke);    fill(crate);    ellipse(-28, 8, 30, 30);    popMatrix();}',LongMethodRule
'fill(crate)',correct
'fill(eyemoon1)',correct
'bodyY1 + inc',correct
'stroke(sideeye)',correct
'{    if (mouseX >= width / 2) {        released = false;    } else if (mouseX <= width / 2) {        released = true;    }    if (released) {        for (int k = 0; k < 1; k++) {            theSun[k].display();        }    }    // night    if (!released) {        background(0);        for (int i = 0; i < sterren.length; i++) {            sterren[i].display();        }        for (int h = 0; h < theMoon.length; h++) {            theMoon[h].display();        }    }}',correct
'bodyY2 - 85',correct
'bodyX2',correct
'rectMode(CENTER);',correct
'int cratestroke;',correct
'bodyX1 = width / 2;',correct
'bodyX1',correct
'for (int h = 0; h < theMoon.length; h++) {    theMoon[h] = new Moon();}',correct
'theSun[k].display()',correct
'stroke(cratestroke);',correct
'// moonpushMatrix();',correct
'{    theSun[k].display();}',correct
'for (int k = 0; k < 1; k++) {    theSun[k] = new Sun();}',correct
'// (bodyX1^2)+(bodyY1^2)=40;',correct
'fill(moon)',correct
'eyemoon1',correct
'new Moon[1]',correct
'ellipse(0, 0, 100, 100)',correct
'// make the starssterren = new Ster[150];',correct
'rotate(radians(20))',correct
'mouthmoon',correct
'Moon[] theMoon;',correct
'bodyX1 = mouseX;',correct
'h = 0',correct
'rotate(radians(45));',correct
'ellipse(20, -20, bodyX2 - 80, bodyY2 - 85)',correct
'i + 4',correct
'fill(bodyColor)',correct
'new Ster(PApplet.parseInt(random(width)), PApplet.parseInt(random(height)))',correct
'sideeye = color(0)',correct
'for (int i = 0; i < 18; i++) {    stroke(0);    strokeWeight(2);    triangle(0, -85, -20, -45, 20, -45);    rotate(radians(20));}',correct
'bodyY2 = 100;',correct
'// bodystroke(0);',correct
'background(background1);',correct
'ellipse(-20, -20, bodyX2 - 80, bodyY2 - 85)',correct
'background1',correct
'bodyX2 - 80',correct
'// make the moontheMoon = new Moon[1];',correct
'height / 4',correct
'width * 2',correct
'// Joep Blanksma, s2113333// This is my first project for programming and it is a happy sun, that moves with your mouse// and lights up your day. But when you press the mouse the sun goes away and the night appears// dont worry the moon is happy as wel and can move around when you drag the mouse. The stars// in the sky are randomly generated every time you restart the program.int bodyX1;',correct
'fill(bodyColor);',correct
'mouseX <= width / 2',correct
'ellipse(-28, 8, 30, 30);',correct
'Ster',correct
'i < 8',correct
'fill(255)',correct
'starX',correct
'fill(eyemoon)',correct
'starY',correct
'Processing',correct
'fill(eye1);',correct
'void display() {    // moon    pushMatrix();    translate(bodyX1, bodyY1);    stroke(moon);    fill(moon);    ellipse(0, 0, 100, 100);    // eyesmoon    fill(eyemoon);    stroke(sideeye);    ellipse(-20, -20, bodyX2 - 80, bodyY2 - 85);    ellipse(20, -20, bodyX2 - 80, bodyY2 - 85);    fill(eyemoon1);    ellipse(-20, -20, bodyX2 - 90, bodyY2 - 90);    ellipse(20, -20, bodyX2 - 90, bodyY2 - 90);    // mouthmoon    // vragen hoe ik hem recht kan krijgen, waar staat het pie ding voor    arc(0, 21, 30, 30, 0, PI);    fill(mouthmoon);    arc(0, 22, 12, 28, 0, PI, CHORD);    line(0, 22, 0, 30);    fill(nosecolormoon);    arc(0, 0, 12, 14, 0, PI, CHORD);    // crate    stroke(cratestroke);    fill(crate);    ellipse(28, 8, 30, 30);    stroke(cratestroke);    fill(crate);    ellipse(-28, 8, 30, 30);    popMatrix();}',correct
'ellipse(0, 0, 10, 10)',correct
'new Moon()',correct
'cratestroke = color(0xffC8CCCE);',correct
'triangle(0, -85, -20, -45, 20, -45);',correct
'pushMatrix()',correct
'eyemoon = color(255)',correct
'fill(nosecolormoon);',correct
'{    background(background1);    // grass    fill(grass);    stroke(grass);    rect(0, height, width * 2, height / 4);    pushMatrix();    translate(bodyX1, bodyY1);    stroke(bodyColor);    fill(bodyColor);    // triangels    pushMatrix();    for (int i = 0; i < 18; i++) {        stroke(0);        strokeWeight(2);        triangle(0, -85, -20, -45, 20, -45);        rotate(radians(20));    }    popMatrix();    // body    stroke(0);    ellipse(0, 0, bodyX2, bodyY2);    // eyes    fill(eye);    stroke(0);    ellipse(-20, -20, bodyX2 - 80, bodyY2 - 85);    ellipse(20, -20, bodyX2 - 80, bodyY2 - 85);    fill(eye1);    ellipse(-20, -20, bodyX2 - 90, bodyY2 - 90);    ellipse(20, -20, bodyX2 - 90, bodyY2 - 90);    // mouth    // vragen hoe ik hem recht kan krijgen, waar staat het pie ding voor    arc(0, 21, 30, 30, 0, PI);    fill(mouth);    arc(0, 22, 12, 28, 0, PI, CHORD);    line(0, 22, 0, 30);    fill(nosecolor);    arc(0, 0, 12, 14, 0, PI, CHORD);    // grass    fill(grass);    stroke(grass);    rect(0, height, width * 2, height / 4);    popMatrix();}',LongMethodRule
'Ster(int xpos, int ypos) {    ellipseMode(CENTER);    starX = xpos;    starY = ypos;}',correct
'// bodyX1++;',correct
'nosecolor = color(0xffF79334);',correct
'Ster[]',correct
'ellipse(0, 0, bodyX2, bodyY2)',correct
'PApplet.parseInt(random(width))',correct
'false',correct
'i < 18',correct
'{    // colors    eyemoon = color(255);    eyemoon1 = color(0);    sideeye = color(0);    mouthmoon = color(0xffEA7BAB);    nosecolormoon = color(0xffF79334);    cratestroke = color(0xffC8CCCE);    crate = color(0xffBBBFC1);    moon = color(255);}',correct
'// void update(){',correct
'ellipse(28, 8, 30, 30)',correct
'translate(starX, starY)',correct
'radians(20)',correct
'fill(mouth)',correct
'// dont worry the moon is happy as wel and can move around when you drag the mouse. The stars',correct
'new Ster[150]',correct
'ellipse(20, -20, bodyX2 - 90, bodyY2 - 90);',correct
'int i = 0',correct
'ellipseMode(CENTER);',correct
'fill(eye)',correct
'bodyX2 = 100',correct
'mouth',correct
'eye = color(255);',correct
'arc(0, 22, 12, 28, 0, PI, CHORD)',correct
'setup',correct
'stroke(255)',correct
'int ypos',correct
'stroke(bodyColor);',correct
'mouth = color(0xffEA7BAB);',correct
'int starY;',correct
'i = 0',correct
'starX = xpos',correct
'background(background1)',correct
'float inc = TWO_PI / 25.0f;',correct
'Moon',correct
'color(255)',correct
'radians(45)',correct
'k++',correct
'float bodyY1;',correct
'nosecolormoon = color(0xffF79334)',correct
'line(0, 22, 0, 30)',correct
'TWO_PI / 25.0f',correct
'int mouth;',correct
'-13',correct
'background(0)',correct
'mouthmoon = color(0xffEA7BAB)',correct
'starY = ypos;',correct
'25.0f',correct
'void mouseMoved() {    bodyX1 = mouseX;    bodyY1 = mouseY;}',correct
'mouth = color(0xffEA7BAB)',correct
'int eyemoon1;',correct
'color(0xffFCF000)',correct
'ellipse(20, -20, bodyX2 - 80, bodyY2 - 85);',correct
'sterren[i].display();',correct
'int eye1;',correct
'// nightif (!released) {    background(0);    for (int i = 0; i < sterren.length; i++) {        sterren[i].display();    }    for (int h = 0; h < theMoon.length; h++) {        theMoon[h].display();    }}',correct
'int starX;',correct
'// colorsint eyemoon;',correct
'int nosecolormoon;',correct
'ellipse(-20, -20, bodyX2 - 90, bodyY2 - 90)',correct
'stroke(moon);',correct
'ellipse(-20, -20, bodyX2 - 90, bodyY2 - 90);',correct
'class Moon {    // colors    int eyemoon;    int eyemoon1;    int sideeye;    int mouthmoon;    int nosecolormoon;    int cratestroke;    int crate;    int moon;    Moon() {        // colors        eyemoon = color(255);        eyemoon1 = color(0);        sideeye = color(0);        mouthmoon = color(0xffEA7BAB);        nosecolormoon = color(0xffF79334);        cratestroke = color(0xffC8CCCE);        crate = color(0xffBBBFC1);        moon = color(255);    }    void display() {        // moon        pushMatrix();        translate(bodyX1, bodyY1);        stroke(moon);        fill(moon);        ellipse(0, 0, 100, 100);        // eyesmoon        fill(eyemoon);        stroke(sideeye);        ellipse(-20, -20, bodyX2 - 80, bodyY2 - 85);        ellipse(20, -20, bodyX2 - 80, bodyY2 - 85);        fill(eyemoon1);        ellipse(-20, -20, bodyX2 - 90, bodyY2 - 90);        ellipse(20, -20, bodyX2 - 90, bodyY2 - 90);        // mouthmoon        // vragen hoe ik hem recht kan krijgen, waar staat het pie ding voor        arc(0, 21, 30, 30, 0, PI);        fill(mouthmoon);        arc(0, 22, 12, 28, 0, PI, CHORD);        line(0, 22, 0, 30);        fill(nosecolormoon);        arc(0, 0, 12, 14, 0, PI, CHORD);        // crate        stroke(cratestroke);        fill(crate);        ellipse(28, 8, 30, 30);        stroke(cratestroke);        fill(crate);        ellipse(-28, 8, 30, 30);        popMatrix();    }}',correct
'-20',correct
'// starfill(255);',correct
'fill(crate);',correct
'sideeye',correct
'bodyY2 = 100',correct
'moon',correct
'void setup() {    ellipseMode(CENTER);    rectMode(CENTER);    bodyX1 = width / 2;    for (int i = 0; i < 100; i = i + 4) {        bodyY1 = bodyY1 + inc;    }    bodyY2 = 100;    bodyX2 = 100;    // make the stars    sterren = new Ster[150];    for (int i = 0; i < sterren.length; i++) {        sterren[i] = new Ster(PApplet.parseInt(random(width)), PApplet.parseInt(random(height)));    }    // make the sun    theSun = new Sun[1];    for (int k = 0; k < 1; k++) {        theSun[k] = new Sun();    }    // make the moon    theMoon = new Moon[1];    for (int h = 0; h < theMoon.length; h++) {        theMoon[h] = new Moon();    }}',correct
'-28',correct
'{    ellipseMode(CENTER);    starX = xpos;    starY = ypos;}',correct
'ellipse(0, 0, bodyX2, bodyY2);',correct
'fill(grass)',correct
'[150]',correct
'h < theMoon.length',correct
'moon = color(255)',correct
'theMoon[h].display()',correct
'if (mouseX >= width / 2) {    released = false;} else if (mouseX <= width / 2) {    released = true;}',correct
'translate(bodyX1, bodyY1);',correct
'// This is the class where I draw my beautifull happy moon',correct
'bodyColor = color(0xffFCF000)',correct
'{    stroke(0);    strokeWeight(2);    triangle(0, -85, -20, -45, 20, -45);    rotate(radians(20));}',correct
'ellipse(-28, 8, 30, 30)',correct
'fill(mouthmoon);',correct
'ellipse(28, 8, 30, 30);',correct
'int bodyX2;',correct
'strokeWeight(1)',correct
'Sun() {    // colors    bodyColor = color(0xffFCF000);    background1 = color(0xff47C2FA);    nosecolor = color(0xffF79334);    mouth = color(0xffEA7BAB);    grass = color(0xff59D326);    eye = color(255);    eye1 = color(0);}',correct
'void display() {    background(background1);    // grass    fill(grass);    stroke(grass);    rect(0, height, width * 2, height / 4);    pushMatrix();    translate(bodyX1, bodyY1);    stroke(bodyColor);    fill(bodyColor);    // triangels    pushMatrix();    for (int i = 0; i < 18; i++) {        stroke(0);        strokeWeight(2);        triangle(0, -85, -20, -45, 20, -45);        rotate(radians(20));    }    popMatrix();    // body    stroke(0);    ellipse(0, 0, bodyX2, bodyY2);    // eyes    fill(eye);    stroke(0);    ellipse(-20, -20, bodyX2 - 80, bodyY2 - 85);    ellipse(20, -20, bodyX2 - 80, bodyY2 - 85);    fill(eye1);    ellipse(-20, -20, bodyX2 - 90, bodyY2 - 90);    ellipse(20, -20, bodyX2 - 90, bodyY2 - 90);    // mouth    // vragen hoe ik hem recht kan krijgen, waar staat het pie ding voor    arc(0, 21, 30, 30, 0, PI);    fill(mouth);    arc(0, 22, 12, 28, 0, PI, CHORD);    line(0, 22, 0, 30);    fill(nosecolor);    arc(0, 0, 12, 14, 0, PI, CHORD);    // grass    fill(grass);    stroke(grass);    rect(0, height, width * 2, height / 4);    popMatrix();}',correct
'translate(starX, starY);',correct
'sterren = new Ster[150]',correct
'{    ellipseMode(CENTER);    rectMode(CENTER);    bodyX1 = width / 2;    for (int i = 0; i < 100; i = i + 4) {        bodyY1 = bodyY1 + inc;    }    bodyY2 = 100;    bodyX2 = 100;    // make the stars    sterren = new Ster[150];    for (int i = 0; i < sterren.length; i++) {        sterren[i] = new Ster(PApplet.parseInt(random(width)), PApplet.parseInt(random(height)));    }    // make the sun    theSun = new Sun[1];    for (int k = 0; k < 1; k++) {        theSun[k] = new Sun();    }    // make the moon    theMoon = new Moon[1];    for (int h = 0; h < theMoon.length; h++) {        theMoon[h] = new Moon();    }}',correct
'eye1 = color(0);',correct
'int nosecolor;',correct
'color(0xff47C2FA)',correct
'fill(eye1)',correct
'color(0)',correct
'i < sterren.length',correct
'eye1 = color(0)',correct
'// eyesfill(eye);',correct
'// Joep Blanksma, s2113333',correct
'bodyX2 = 100;',correct
'display',LongMethodRule
'{    bodyX1 = mouseX;    bodyY1 = mouseY;}',correct
'bodyX1 = width / 2',correct
'sideeye = color(0);',correct
'background(0);',correct
'theSun[k]',correct
'draw',correct
'i = i + 4',correct
'void mouseDragged() {    bodyX1 = mouseX;    bodyY1 = mouseY;}',correct
'triangle(0, -13, -3, -3, 3, -3);',correct
'-45',correct
'stroke(moon)',correct
'{    theSun[k] = new Sun();}',correct
'arc(0, 0, 12, 14, 0, PI, CHORD);',correct
'// in the sky are randomly generated every time you restart the program.',correct
'cratestroke',correct
'rect(0, height, width * 2, height / 4)',correct
'fill(nosecolor);',correct
'for (int i = 0; i < sterren.length; i++) {    sterren[i].display();}',correct
'if (mouseX <= width / 2) {    released = true;}',DecentralizedEventHandlingRule
'// colorsint bodyColor;',correct
'PApplet.parseInt(random(height))',correct
'color(0xffBBBFC1)',correct
'// colorseyemoon = color(255);',correct
'cratestroke = color(0xffC8CCCE)',correct
'int bodyY2;',correct
'i++',correct
'// colorsbodyColor = color(0xffFCF000);',correct
'background1 = color(0xff47C2FA);',correct
'theSun = new Sun[1]',correct
'theMoon[h].display();',correct
'rect(0, height, width * 2, height / 4);',correct
'// eyesmoonfill(eyemoon);',correct
'stroke(grass)',correct
'line(0, 22, 0, 30);',correct
'ellipseMode(CENTER)',correct
'translate(bodyX1, bodyY1)',correct
'int crate;',correct
'fill(mouthmoon)',correct
'color(0xffC8CCCE)',correct
'int eye;',correct
'stroke(sideeye);',correct
'bodyY1',correct
'{    theMoon[h].display();}',correct
'// mouth// vragen hoe ik hem recht kan krijgen, waar staat het pie ding voorarc(0, 21, 30, 30, 0, PI);',correct
'{    sterren[i].display();}',correct
'bodyY2',correct
'// classes;Ster[] sterren;',correct
'eyemoon',correct
'void',correct
'stroke(grass);',correct
'-3',correct
'!released',correct
'// mouthmoon// vragen hoe ik hem recht kan krijgen, waar staat het pie ding voorarc(0, 21, 30, 30, 0, PI);',correct
'sterren[i] = new Ster(PApplet.parseInt(random(width)), PApplet.parseInt(random(height)));',correct
'fill(nosecolor)',correct
'crate = color(0xffBBBFC1)',correct
'sterren[i].display()',correct
'class Ster {    int starX;    int starY;    Ster(int xpos, int ypos) {        ellipseMode(CENTER);        starX = xpos;        starY = ypos;    }    void display() {        pushMatrix();        translate(starX, starY);        // star        fill(255);        pushMatrix();        for (int i = 0; i < 8; i++) {            stroke(255);            strokeWeight(1);            triangle(0, -13, -3, -3, 3, -3);            rotate(radians(45));        }        popMatrix();        // body        stroke(255);        ellipse(0, 0, 10, 10);        popMatrix();    }}',correct
'fill(eyemoon1);',correct
'strokeWeight(2)',correct
'true',correct
'nosecolormoon = color(0xffF79334);',correct
'int background1;',correct
'{    theMoon[h] = new Moon();}',correct
'for (int k = 0; k < 1; k++) {    theSun[k].display();}',correct
'theSun',correct
'// triangelspushMatrix();',correct
'bodyColor',correct
'popMatrix()',correct
'ellipse(0, 0, 100, 100);',correct
'stroke(255);',correct
'eye = color(255)',correct
'h++',correct
'starX = xpos;',correct
'{    sterren[i] = new Ster(PApplet.parseInt(random(width)), PApplet.parseInt(random(height)));}',correct
'mouthmoon = color(0xffEA7BAB);',correct
'released = true',correct
'int k = 0',correct
'{    released = true;}',correct
'arc(0, 22, 12, 28, 0, PI, CHORD);',correct
'rotate(radians(20));',correct
'theMoon[h]',correct
'color(0xffEA7BAB)',correct
'arc(0, 21, 30, 30, 0, PI)',correct
'bodyY1 = bodyY1 + inc',correct
'[1]',correct
'fill(nosecolormoon)',correct
'for (int i = 0; i < 100; i = i + 4) {    bodyY1 = bodyY1 + inc;}',correct
'starY = ypos',correct
'-85',correct
'k < 1',correct
'theSun[k] = new Sun()',correct
'color(0xff59D326)',correct
'i < 100',correct
'bodyY1 = mouseY',correct
'width / 2',correct
'if (released) {    for (int k = 0; k < 1; k++) {        theSun[k].display();    }}',correct
'new Sun[1]',correct
'// This is my first project for programming and it is a happy sun, that moves with your mouse',correct
'stroke(cratestroke)',correct
'Moon[]',correct
'nosecolor = color(0xffF79334)',correct
'int mouthmoon;',correct
'bodyY1 = bodyY1 + inc;',correct
'{    for (int k = 0; k < 1; k++) {        theSun[k].display();    }}',correct
'eyemoon1 = color(0);',correct
'int sideeye;',correct
'// mouthmoon',correct
'ellipse(+23, -113, 14, 14)',correct
'B = 50',correct
'if (key == s) {    R = 200;    G = 50;    B = 50;}',correct
'-92',correct
'// arm leftfill(155, 100, 55);',correct
'for (int i = 0; i < bears.length; i++) {    bears[i].display();}',correct
'bears[i]',correct
'void update() {    // arm left    fill(155, 100, 55);    ellipse(armX - 42, armY, 28, 40);    // arm right    fill(155, 100, 55);    ellipse(armX + 42, armY, 28, 40);    armX = armX + 1;    if (armX >= armX_ + 5) {        armX = armX_ - 5;    }}',correct
'+60',correct
'fill(0, 0, 0)',correct
'ellipse(0, -65, 25, 18)',correct
'pushMatrix();',correct
'new Bear[10]',correct
'ellipse(-15, -92, 3, 3);',correct
'void display() {    pushMatrix();    translate(bearX, bearY);    // body    fill(155, 100, 55);    ellipse(0, 0, 85, 135);    fill(237, 200, 85);    ellipse(0, +15, 60, 90);    // left ear    fill(155, 100, 55);    ellipse(-25, -113, 22, 22);    fill(237, 200, 85);    ellipse(-25, -113, 14, 14);    // right ear    fill(155, 100, 55);    ellipse(+23, -113, 22, 22);    fill(237, 200, 85);    ellipse(+23, -113, 14, 14);    // head    fill(155, 100, 55);    ellipse(0, -82, 65, 65);    // left eye    fill(255, 255, 255);    ellipse(-15, -92, 10, 10);    fill(0, 0, 0);    ellipse(-15, -92, 3, 3);    // right eye    fill(255, 255, 255);    ellipse(+15, -92, 10, 10);    fill(0, 0, 0);    ellipse(+15, -92, 3, 3);    // mouth    fill(237, 200, 85);    ellipse(0, -65, 25, 18);    // foot left    fill(155, 100, 55);    ellipse(-25, +60, 30, 30);    fill(237, 200, 85);    ellipse(-25, +60, 15, 15);    // foot right    fill(155, 100, 55);    ellipse(+25, +60, 30, 30);    fill(237, 200, 85);    ellipse(+25, +60, 15, 15);    arm.update();    popMatrix();    bearY += PApplet.parseInt(random(-8, 8));}',correct
'ellipse(+25, +60, 15, 15);',correct
'bearY += PApplet.parseInt(random(-8, 8));',correct
'triangle(15, 490, 50, 75, 200, 500)',correct
'ellipse(+23, -113, 22, 22)',correct
'ellipse(+25, +60, 30, 30);',correct
'ellipse(-15, -92, 3, 3)',correct
'ellipse(-25, -113, 22, 22)',correct
'PApplet.parseInt(random(-8, 8))',correct
'arm.update()',correct
'translate(bearX, bearY);',correct
'bearY = Y;',correct
'// left eyefill(255, 255, 255);',correct
'ellipse(+23, -113, 14, 14);',correct
'armX = armX + 1',correct
'class Arms {    int armX, armY, armX_;    Arms(int bearX, int bearY) {        armX = bearX;        armY = bearY - 7;        armX_ = bearX;    }    void update() {        // arm left        fill(155, 100, 55);        ellipse(armX - 42, armY, 28, 40);        // arm right        fill(155, 100, 55);        ellipse(armX + 42, armY, 28, 40);        armX = armX + 1;        if (armX >= armX_ + 5) {            armX = armX_ - 5;        }    }}',correct
'arm',correct
'B = 50;',correct
'void setup() {    for (int i = 0; i < bears.length; i++) {        bears[i] = new Bear(random(0, 400), random(0, 400));    }}',correct
'a',correct
'G = 50;',correct
'd',correct
'int B = 255;',ShortVariable
'{    // arm left    fill(155, 100, 55);    ellipse(armX - 42, armY, 28, 40);    // arm right    fill(155, 100, 55);    ellipse(armX + 42, armY, 28, 40);    armX = armX + 1;    if (armX >= armX_ + 5) {        armX = armX_ - 5;    }}',correct
'bears.length',correct
'armX_ - 5',correct
'Bear[]',correct
'ellipse(-25, +60, 15, 15)',correct
'ellipse(425, 500, 170, 50)',correct
'popMatrix();',correct
'armX = armX_ - 5;',correct
's',correct
'ellipse(-15, -92, 10, 10);',correct
'// right eyefill(255, 255, 255);',correct
'arm = new Arms(0, 0);',correct
'ellipse(-25, -113, 14, 14)',correct
'R = 200;',correct
'armY = bearY - 7;',correct
'R = 50;',correct
'{    pushMatrix();    translate(bearX, bearY);    // body    fill(155, 100, 55);    ellipse(0, 0, 85, 135);    fill(237, 200, 85);    ellipse(0, +15, 60, 90);    // left ear    fill(155, 100, 55);    ellipse(-25, -113, 22, 22);    fill(237, 200, 85);    ellipse(-25, -113, 14, 14);    // right ear    fill(155, 100, 55);    ellipse(+23, -113, 22, 22);    fill(237, 200, 85);    ellipse(+23, -113, 14, 14);    // head    fill(155, 100, 55);    ellipse(0, -82, 65, 65);    // left eye    fill(255, 255, 255);    ellipse(-15, -92, 10, 10);    fill(0, 0, 0);    ellipse(-15, -92, 3, 3);    // right eye    fill(255, 255, 255);    ellipse(+15, -92, 10, 10);    fill(0, 0, 0);    ellipse(+15, -92, 3, 3);    // mouth    fill(237, 200, 85);    ellipse(0, -65, 25, 18);    // foot left    fill(155, 100, 55);    ellipse(-25, +60, 30, 30);    fill(237, 200, 85);    ellipse(-25, +60, 15, 15);    // foot right    fill(155, 100, 55);    ellipse(+25, +60, 30, 30);    fill(237, 200, 85);    ellipse(+25, +60, 15, 15);    arm.update();    popMatrix();    bearY += PApplet.parseInt(random(-8, 8));}',LongMethodRule
'armX + 42',correct
'bearX = X',correct
'ellipse(110, 500, 210, 50)',correct
'ellipse(+25, +60, 30, 30)',correct
'B = 200',correct
'G = 50',correct
'ellipse(+25, +60, 15, 15)',correct
'// boogie bear by Lieve Mijnster// press a,s,d for background changeint R = 255;',correct
'armX = bearX;',correct
'B = 200;',correct
'ellipse(+15, -92, 10, 10)',correct
'bearX',correct
'bearY',correct
'{    armX = armX_ - 5;}',correct
'fill(255, 245, 95)',correct
'fill(255, 239, 0);',correct
'// boogie bear by Lieve Mijnster',correct
'update',correct
'i < bears.length',correct
'ellipse(-25, -113, 14, 14);',correct
'Processing',correct
'-113',correct
'pushMatrix()',correct
'armY = bearY - 7',correct
'ellipse(-25, +60, 30, 30);',correct
'bearX = X;',correct
'int bearY',correct
'int bearX',correct
'G = 200;',correct
'// foot rightfill(155, 100, 55);',correct
'triangle(15, 490, 50, 75, 200, 500);',correct
'int i = 0',correct
'armX = armX_ - 5',correct
'armX = bearX',correct
'i = 0',correct
'new Bear(random(0, 400), random(0, 400))',correct
'armX = armX + 1;',correct
'// mouthfill(237, 200, 85);',correct
'-15',correct
'if (key == a) {    R = 50;    G = 50;    B = 200;}',correct
'int G = 255;',correct
'ellipse(110, 500, 210, 50);',PixelHardcodeIgnoranceRule
'bears[i].display()',correct
'class Bear {    float bearX, bearY;    Arms arm;    Bear(float X, float Y) {        bearX = X;        bearY = Y;        arm = new Arms(0, 0);    }    void display() {        pushMatrix();        translate(bearX, bearY);        // body        fill(155, 100, 55);        ellipse(0, 0, 85, 135);        fill(237, 200, 85);        ellipse(0, +15, 60, 90);        // left ear        fill(155, 100, 55);        ellipse(-25, -113, 22, 22);        fill(237, 200, 85);        ellipse(-25, -113, 14, 14);        // right ear        fill(155, 100, 55);        ellipse(+23, -113, 22, 22);        fill(237, 200, 85);        ellipse(+23, -113, 14, 14);        // head        fill(155, 100, 55);        ellipse(0, -82, 65, 65);        // left eye        fill(255, 255, 255);        ellipse(-15, -92, 10, 10);        fill(0, 0, 0);        ellipse(-15, -92, 3, 3);        // right eye        fill(255, 255, 255);        ellipse(+15, -92, 10, 10);        fill(0, 0, 0);        ellipse(+15, -92, 3, 3);        // mouth        fill(237, 200, 85);        ellipse(0, -65, 25, 18);        // foot left        fill(155, 100, 55);        ellipse(-25, +60, 30, 30);        fill(237, 200, 85);        ellipse(-25, +60, 15, 15);        // foot right        fill(155, 100, 55);        ellipse(+25, +60, 30, 30);        fill(237, 200, 85);        ellipse(+25, +60, 15, 15);        arm.update();        popMatrix();        bearY += PApplet.parseInt(random(-8, 8));    }}',correct
'{    background(R, G, B);    // lights    fill(255, 245, 95);    triangle(15, 490, 50, 75, 200, 500);    triangle(350, 490, 460, 75, 500, 500);    fill(255, 239, 0);    ellipse(110, 500, 210, 50);    ellipse(425, 500, 170, 50);    for (int i = 0; i < bears.length; i++) {        bears[i].display();    }}',correct
'ellipse(+15, -92, 10, 10);',correct
'ellipse(0, +15, 60, 90)',correct
'ellipse(-25, +60, 15, 15);',correct
'ellipse(armX + 42, armY, 28, 40)',correct
'armX_ = bearX;',correct
'ellipse(armX - 42, armY, 28, 40);',correct
'-25',correct
'armX_ = bearX',correct
'int armX, armY, armX_;',correct
'// foot leftfill(155, 100, 55);',correct
'triangle(350, 490, 460, 75, 500, 500);',PixelHardcodeIgnoranceRule
'{    if (key == a) {        R = 50;        G = 50;        B = 200;    }    if (key == s) {        R = 200;        G = 50;        B = 50;    }    if (key == d) {        R = 50;        G = 200;        B = 50;    }}',correct
'G = 255',correct
'ellipse(0, -82, 65, 65)',correct
'translate(bearX, bearY)',correct
'Bear[] bears = new Bear[10];',correct
'ellipse(armX - 42, armY, 28, 40)',correct
'// right earfill(155, 100, 55);',correct
'armX - 42',correct
'key == d',correct
'void draw() {    background(R, G, B);    // lights    fill(255, 245, 95);    triangle(15, 490, 50, 75, 200, 500);    triangle(350, 490, 460, 75, 500, 500);    fill(255, 239, 0);    ellipse(110, 500, 210, 50);    ellipse(425, 500, 170, 50);    for (int i = 0; i < bears.length; i++) {        bears[i].display();    }}',correct
'bearY - 7',correct
'// left earfill(155, 100, 55);',correct
'key == a',correct
'armY',correct
'armX',correct
'ellipse(0, 0, 85, 135)',correct
'if (armX >= armX_ + 5) {    armX = armX_ - 5;}',correct
'// lightsfill(255, 245, 95);',correct
'ellipse(-15, -92, 10, 10)',correct
'key == s',correct
'bears = new Bear[10]',correct
'bearY += PApplet.parseInt(random(-8, 8))',correct
'{    R = 50;    G = 50;    B = 200;}',correct
'Arms(int bearX, int bearY) {    armX = bearX;    armY = bearY - 7;    armX_ = bearX;}',correct
'R = 255',correct
'{    for (int i = 0; i < bears.length; i++) {        bears[i] = new Bear(random(0, 400), random(0, 400));    }}',correct
'ellipse(0, -82, 65, 65);',correct
'display',LongMethodRule
'armX + 1',correct
'draw',correct
'bears[i] = new Bear(random(0, 400), random(0, 400));',correct
'ellipse(0, +15, 60, 90);',correct
'{    bearX = X;    bearY = Y;    arm = new Arms(0, 0);}',correct
'bearY = Y',correct
'fill(255, 239, 0)',correct
'ellipse(+15, -92, 3, 3)',correct
'{    bears[i].display();}',correct
'random(-8, 8)',correct
'// bodyfill(155, 100, 55);',correct
'bears[i] = new Bear(random(0, 400), random(0, 400))',correct
'i++',correct
'ellipse(+23, -113, 22, 22);',correct
'if (key == d) {    R = 50;    G = 200;    B = 50;}',correct
'+15',correct
'ellipse(+15, -92, 3, 3);',correct
'ellipse(0, -65, 25, 18);',correct
'fill(255, 255, 255)',correct
'for (int i = 0; i < bears.length; i++) {    bears[i] = new Bear(random(0, 400), random(0, 400));}',correct
'float bearX, bearY;',correct
'{    bears[i] = new Bear(random(0, 400), random(0, 400));}',correct
'R = 50',correct
'void',correct
'Arms',correct
'{    armX = bearX;    armY = bearY - 7;    armX_ = bearX;}',correct
'bears[i].display();',correct
'-8',correct
'-65',correct
'+23',correct
'+25',correct
'ellipse(0, 0, 85, 135);',correct
'{    R = 200;    G = 50;    B = 50;}',correct
'background(R, G, B)',correct
'arm = new Arms(0, 0)',correct
'fill(155, 100, 55)',correct
'ellipse(armX + 42, armY, 28, 40);',correct
'popMatrix()',correct
'float X',correct
'float Y',correct
'R = 200',correct
'[10]',correct
'fill(0, 0, 0);',correct
'Bear',correct
'G = 200',correct
'ellipse(-25, -113, 22, 22);',correct
'ellipse(425, 500, 170, 50);',PixelHardcodeIgnoranceRule
'void keyPressed() {    if (key == a) {        R = 50;        G = 50;        B = 200;    }    if (key == s) {        R = 200;        G = 50;        B = 50;    }    if (key == d) {        R = 50;        G = 200;        B = 50;    }}',correct
'new Arms(0, 0)',correct
'Bear(float X, float Y) {    bearX = X;    bearY = Y;    arm = new Arms(0, 0);}',correct
'-82',correct
'fill(237, 200, 85)',correct
'fill(237, 200, 85);',correct
'background(R, G, B);',correct
'armX_ + 5',correct
'random(0, 400)',correct
'{    R = 50;    G = 200;    B = 50;}',correct
'triangle(350, 490, 460, 75, 500, 500)',correct
'armX_',correct
'B = 255',correct
'Arms arm;',correct
'ellipse(-25, +60, 30, 30)',correct
'// arm rightfill(155, 100, 55);',correct
'armX >= armX_ + 5',correct
'// headfill(155, 100, 55);',correct
'arm.update();',correct
'{    xdir = -1;}',correct
'fill(colorRandom)',correct
'{    ydir = -1;}',correct
'void movement() {    // Glass Movement    iconX = iconX + (xspeed * xdir);    iconY = iconY + (yspeed * ydir);    // Hit Wall Response    if (iconX + 35 > 800 || iconX - 35 < 0) {        xdir *= -1;        colorRandom = color(random(0, 255), random(0, 255), random(0, 255));    }    if (iconY + 50 > 800 || iconY - 50 < 0) {        ydir *= -1;        colorRandom = color(random(0, 255), random(0, 255), random(0, 255));    }}',AtLeastOneConstructor
'if (key == y) {    xspeed /= 1.3f;    yspeed /= 1.3f;    speedLevel = speedLevel - 1;}',correct
'yspeed *= 1.2f;',correct
'fill(colorRandom);',correct
'if (randomizerY < 50) {    ydir = 1;} else {    ydir = -1;}',correct
'ydir *= -1;',correct
'String',correct
'Glass[]',correct
'iconY + 50',correct
'quad(175, 100, 625, 100, 550, 700, 250, 700);',correct
'backgroundBier.display(color(255, 255, 0), color(255))',correct
'random(0, 255)',correct
'bubbleY',correct
'score',correct
'arrayofBubbles.length',correct
'random(-400, 0)',correct
'// bubbleMovementbubbleY = bubbleY - 0.1f;',correct
'for (int i = 0; i < arrayofGlass.length; i++) {    arrayofGlass[i].keyPressed();}',correct
'text(Clicks, 700, 50)',correct
'bubbleY - 0.1f',correct
'stroke(0);',correct
'stroke(0)',correct
'{    xspeed *= 1.2f;    yspeed *= 1.2f;    speedLevel = speedLevel + 1;}',correct
'// bier backgroundfill(BierColor);',correct
'ScoreCounter = ScoreCounter + 80 * speedLevel',correct
'mouseY > iconY - 50 && mouseY < iconY + 50',correct
'new Glass[Glasses]',correct
'{    iconX = mouseX;    iconY = mouseY;    xdir = 1;    ydir = 1;    xspeed = 4;    yspeed = 2;    speedLevel = 10;}',DecentralizedEventHandlingRule
'speedLevel = speedLevel + 1',correct
'xdir *= -1;',correct
'xspeed = 4',correct
'arrayofGlass[i].display();',correct
'iconY = random(100, 700);',correct
'color(random(0, 255), random(0, 255), random(0, 255))',correct
'arrayofGlass[i].movement();',correct
'void display(int ScoreCounter, int ClickCounter) {    // counters    String Score = "Your score is: " + ScoreCounter;    String Clicks = "Clicks: " + (ClickCounter / Glasses);    textSize(32);    fill(0);    textAlign(CENTER);    text(Score, 400, 50);    textSize(32);    fill(0);    textAlign(CENTER);    text(Clicks, 700, 50);}',AtLeastOneConstructor
'quad(175, 100, 625, 100, 550, 700, 250, 700)',correct
'int speedLevel = 10;',correct
'void keyPressed() {    // Glass Speed    if (keyPressed) {        if (key == t) {            xspeed *= 1.2f;            yspeed *= 1.2f;            speedLevel = speedLevel + 1;        }        if (key == y) {            xspeed /= 1.3f;            yspeed /= 1.3f;            speedLevel = speedLevel - 1;        }        // Reset glass        if (key == r) {            iconX = mouseX;            iconY = mouseY;            xdir = 1;            ydir = 1;            xspeed = 4;            yspeed = 2;            speedLevel = 10;        }    }}',AtLeastOneConstructor
'arrayofBubbles[i]',correct
'iconY + 50 > 800',correct
'textSize(32)',correct
'void display() {    // Bier    strokeWeight(3);    fill(colorRandom);    quad(iconX - 35, iconY - 50, iconX + 35, iconY - 50, iconX + 20, iconY + 50, iconX - 20, iconY + 50);    // Foam    strokeWeight(0);    fill(255);    quad(iconX - 35, iconY - 55, iconX + 35, iconY - 55, iconX + 30, iconY - 30, iconX - 30, iconY - 30);}',AtLeastOneConstructor
'new Glass()',correct
'// Reset glassif (key == r) {    iconX = mouseX;    iconY = mouseY;    xdir = 1;    ydir = 1;    xspeed = 4;    yspeed = 2;    speedLevel = 10;}',correct
'iconY = mouseY;',DecentralizedEventHandlingRule
'iconY + 50 > 800 || iconY - 50 < 0',correct
'ClickCounter = (ClickCounter + 1)',correct
'void display() {    stroke(255);    fill(255);    ellipseMode(CENTER);    ellipse(bubbleX + Xpos, bubbleY + Ypos, 20, 20);    stroke(0);}',correct
'// change direction on clickrandomizerX = random(0, 100);',correct
'yspeed = 2;',correct
'// BierstrokeWeight(3);',correct
'fill(0);',correct
'speedLevel = speedLevel - 1;',correct
'{    for (int i = 0; i < arrayofGlass.length; i++) {        arrayofGlass[i].keyPressed();    }}',correct
'iconY = random(100, 700)',correct
'xdir = -1',correct
'// countersString Score = "Your score is: " + ScoreCounter;',correct
'void move() {    // bubbleMovement    bubbleY = bubbleY - 0.1f;    // dissapear in foam    if (bubbleY + Ypos + 40 < 250) {        Ypos = -800;    }}',AtLeastOneConstructor
'ydir = -1;',correct
'textAlign(CENTER)',correct
'Glasses = 5',correct
'{    arrayofGlass[i] = new Glass();}',correct
'Bubble[] arrayofBubbles = new Bubble[Bubbles];',correct
'int BierColor',VariableNamingConventions
'void keyPressed() {    if (keyPressed) {        // spawnbubbles        if (key == b) {            bubbleX = 400;            bubbleY = 660;            Xpos = random(-100, 100);            Ypos = random(-400, 0);        }    }}',AtLeastOneConstructor
'void mousePressed() {    for (int i = 0; i < arrayofGlass.length; i++) {        arrayofGlass[i].mousePressed();    }}',correct
'b',correct
'{    Ypos = -800;}',correct
'score = new Score()',correct
'iconX + 35 > 800',correct
'bubbleY = bubbleY - 0.1f',correct
'i < arrayofBubbles.length',correct
'String Clicks = "Clicks: " + (ClickCounter / Glasses)',correct
'ScoreCounter = 0',correct
'class Bubble {    float Xpos;    float Ypos;    void display() {        stroke(255);        fill(255);        ellipseMode(CENTER);        ellipse(bubbleX + Xpos, bubbleY + Ypos, 20, 20);        stroke(0);    }    void move() {        // bubbleMovement        bubbleY = bubbleY - 0.1f;        // dissapear in foam        if (bubbleY + Ypos + 40 < 250) {            Ypos = -800;        }    }    void keyPressed() {        if (keyPressed) {            // spawnbubbles            if (key == b) {                bubbleX = 400;                bubbleY = 660;                Xpos = random(-100, 100);                Ypos = random(-400, 0);            }        }    }}',correct
'{    if (key == t) {        xspeed *= 1.2f;        yspeed *= 1.2f;        speedLevel = speedLevel + 1;    }    if (key == y) {        xspeed /= 1.3f;        yspeed /= 1.3f;        speedLevel = speedLevel - 1;    }    // Reset glass    if (key == r) {        iconX = mouseX;        iconY = mouseY;        xdir = 1;        ydir = 1;        xspeed = 4;        yspeed = 2;        speedLevel = 10;    }}',DecentralizedEventHandlingRule
'new BackgroundBier()',correct
'iconY = mouseY',correct
'backgroundBier = new BackgroundBier();',correct
'r',correct
't',correct
'{    arrayofGlass[i].mousePressed();}',correct
'new Bubble()',correct
'iconX = iconX + (xspeed * xdir)',correct
'y',correct
'{    // Glass Speed    if (keyPressed) {        if (key == t) {            xspeed *= 1.2f;            yspeed *= 1.2f;            speedLevel = speedLevel + 1;        }        if (key == y) {            xspeed /= 1.3f;            yspeed /= 1.3f;            speedLevel = speedLevel - 1;        }        // Reset glass        if (key == r) {            iconX = mouseX;            iconY = mouseY;            xdir = 1;            ydir = 1;            xspeed = 4;            yspeed = 2;            speedLevel = 10;        }    }}',correct
'Glass[] arrayofGlass = new Glass[Glasses];',correct
'randomizerX = random(0, 100)',correct
'arrayofGlass[i] = new Glass();',correct
'ydir = 1',correct
'text(Score, 400, 50);',correct
'{    ydir *= -1;    colorRandom = color(random(0, 255), random(0, 255), random(0, 255));}',correct
'ClickCounter',correct
'Score score;',correct
'speedLevel = speedLevel + 1;',correct
'text(Score, 400, 50)',correct
'arrayofBubbles[i] = new Bubble();',correct
'String Score = "Your score is: " + ScoreCounter',correct
'backgroundBier',correct
'// Glass MovementiconX = iconX + (xspeed * xdir);',correct
'float yspeed = 2;',correct
'speedLevel = speedLevel - 1',correct
'if (randomizerX < 50) {    xdir = 1;} else {    xdir = -1;}',correct
'arrayofBubbles[i].keyPressed()',correct
'randomizerY = random(0, 100);',correct
'float ydir = -1;',AtLeastOneConstructor
'xspeed *= 1.2f;',correct
'arrayofBubbles[i].keyPressed();',correct
'randomizerY = random(0, 100)',correct
'xspeed = 4;',correct
'Ypos = random(-400, 0)',correct
'arrayofGlass[i]',correct
'bubbleX = 400;',correct
'background(230)',correct
'ScoreCounter',correct
'strokeWeight(3);',correct
'{    arrayofGlass[i].keyPressed();}',correct
'mouseX > iconX - 35 && mouseX < iconX + 35',DecentralizedEventHandlingRule
'random(-100, 100)',correct
'iconX + (xspeed * xdir)',correct
'ydir = -1',correct
'-100',correct
'Score',correct
'fill(0)',correct
'bubbleY = 660',correct
'speedLevel = 10;',correct
'iconX + 35 > 800 || iconX - 35 < 0',correct
'void setup() {    // Load in    for (int i = 0; i < arrayofBubbles.length; i++) {        arrayofBubbles[i] = new Bubble();    }    for (int i = 0; i < arrayofGlass.length; i++) {        arrayofGlass[i] = new Glass();    }    backgroundBier = new BackgroundBier();    score = new Score();}',correct
'arrayofGlass[i].keyPressed();',correct
'iconX = mouseX;',DecentralizedEventHandlingRule
'arrayofGlass.length',correct
'0.1f',correct
'int ScoreCounter',correct
'xspeed /= 1.3f',correct
'Xpos = random(-100, 100);',correct
'BackgroundBier backgroundBier;',correct
'arrayofGlass[i].mousePressed();',correct
'fill(255)',correct
'"Your score is: "',correct
'// Hit Wall Responseif (iconX + 35 > 800 || iconX - 35 < 0) {    xdir *= -1;    colorRandom = color(random(0, 255), random(0, 255), random(0, 255));}',correct
'speedLevel + 1',correct
'Processing',correct
'random(0, 100)',correct
'float iconY = 500;',AtLeastOneConstructor
'iconX + 30',correct
'Xpos',correct
'xdir *= -1',correct
'Clicks = "Clicks: " + (ClickCounter / Glasses)',correct
'{    arrayofGlass[i].display();    arrayofGlass[i].movement();}',correct
'bubbleX = 660',correct
'{    // change direction on click    randomizerX = random(0, 100);    randomizerY = random(0, 100);    if (randomizerX < 50) {        xdir = 1;    } else {        xdir = -1;    }    if (randomizerY < 50) {        ydir = 1;    } else {        ydir = -1;    }    // clicks    ClickCounter = (ClickCounter + 1);    // glass hitbox    if (mouseX > iconX - 35 && mouseX < iconX + 35) {        if (mouseY > iconY - 50 && mouseY < iconY + 50) {            iconX = random(100, 700);            iconY = random(100, 700);            ScoreCounter = ScoreCounter + 80 * speedLevel;            score.display(ScoreCounter, ClickCounter);        }    }}',correct
'arrayofGlass[i].movement()',correct
'{    if (keyPressed) {        // spawnbubbles        if (key == b) {            bubbleX = 400;            bubbleY = 660;            Xpos = random(-100, 100);            Ypos = random(-400, 0);        }    }}',correct
'String Clicks = "Clicks: " + (ClickCounter / Glasses);',VariableNamingConventions
'iconX + 35',correct
'Ypos = -800;',correct
'{    ydir = 1;}',correct
'arrayofBubbles = new Bubble[Bubbles]',correct
'{    for (int i = 0; i < arrayofGlass.length; i++) {        arrayofGlass[i].mousePressed();    }}',correct
'arrayofBubbles[i].move();',correct
'ellipse(bubbleX + Xpos, bubbleY + Ypos, 20, 20)',correct
'{    stroke(255);    fill(255);    ellipseMode(CENTER);    ellipse(bubbleX + Xpos, bubbleY + Ypos, 20, 20);    stroke(0);}',correct
'{    // counters    String Score = "Your score is: " + ScoreCounter;    String Clicks = "Clicks: " + (ClickCounter / Glasses);    textSize(32);    fill(0);    textAlign(CENTER);    text(Score, 400, 50);    textSize(32);    fill(0);    textAlign(CENTER);    text(Clicks, 700, 50);}',VariableNamingConventions
'Bubbles = 40',correct
'bubbleX + Xpos',correct
'Score = "Your score is: " + ScoreCounter',correct
'textAlign(CENTER);',correct
'random(100, 700)',correct
'ellipseMode(CENTER);',correct
'int i = 0',correct
'iconX + 20',correct
'BackgroundBier',correct
'iconY = iconY + (yspeed * ydir)',correct
'for (int i = 0; i < arrayofBubbles.length; i++) {    arrayofBubbles[i].display();    arrayofBubbles[i].move();    arrayofBubbles[i].keyPressed();}',correct
'xdir = -1;',correct
'stroke(255)',correct
'setup',correct
'{    iconX = random(100, 700);    iconY = random(100, 700);    ScoreCounter = ScoreCounter + 80 * speedLevel;    score.display(ScoreCounter, ClickCounter);}',correct
'Ypos = random(-400, 0);',correct
'-800',correct
'iconX = random(100, 700)',correct
'i = 0',correct
'yspeed /= 1.3f',correct
'color(255)',correct
'fill(BierColor)',correct
'iconY + (yspeed * ydir)',correct
'// dissapear in foamif (bubbleY + Ypos + 40 < 250) {    Ypos = -800;}',correct
'// glass hitboxif (mouseX > iconX - 35 && mouseX < iconX + 35) {    if (mouseY > iconY - 50 && mouseY < iconY + 50) {        iconX = random(100, 700);        iconY = random(100, 700);        ScoreCounter = ScoreCounter + 80 * speedLevel;        score.display(ScoreCounter, ClickCounter);    }}',correct
'if (mouseY > iconY - 50 && mouseY < iconY + 50) {    iconX = random(100, 700);    iconY = random(100, 700);    ScoreCounter = ScoreCounter + 80 * speedLevel;    score.display(ScoreCounter, ClickCounter);}',DecentralizedEventHandlingRule
'80 * speedLevel',correct
'float randomizerX = random(0, 100);',AtLeastOneConstructor
'if (key == t) {    xspeed *= 1.2f;    yspeed *= 1.2f;    speedLevel = speedLevel + 1;}',correct
'[Glasses]',correct
'Bubble[]',correct
'void keyPressed() {    for (int i = 0; i < arrayofGlass.length; i++) {        arrayofGlass[i].keyPressed();    }}',correct
'int Bubbles = 40;',correct
'{    xdir *= -1;    colorRandom = color(random(0, 255), random(0, 255), random(0, 255));}',correct
'bubbleX = 400',correct
'arrayofGlass[i].keyPressed()',correct
'backgroundBier = new BackgroundBier()',correct
'{    bubbleX = 400;    bubbleY = 660;    Xpos = random(-100, 100);    Ypos = random(-400, 0);}',correct
'textSize(32);',correct
'colorRandom = color(random(0, 255), random(0, 255), random(0, 255));',correct
'arrayofBubbles[i] = new Bubble()',correct
'int Glasses = 5;',correct
'fill(FoamColor)',correct
'text(Clicks, 700, 50);',correct
'{    // spawnbubbles    if (key == b) {        bubbleX = 400;        bubbleY = 660;        Xpos = random(-100, 100);        Ypos = random(-400, 0);    }}',DecentralizedEventHandlingRule
'ydir = 1;',correct
'[Bubbles]',correct
'iconY - 50 < 0',correct
'score.display(ScoreCounter, ClickCounter)',correct
'yspeed /= 1.3f;',correct
'1.2f',correct
'Glass',AtLeastOneConstructor
'bubbleY + Ypos + 40',correct
'speedLevel - 1',correct
'iconY - 55',correct
'key == b',correct
'if (iconY + 50 > 800 || iconY - 50 < 0) {    ydir *= -1;    colorRandom = color(random(0, 255), random(0, 255), random(0, 255));}',correct
'iconY - 50',correct
'{    background(230);    // bier background    fill(BierColor);    strokeWeight(3);    quad(175, 100, 625, 100, 550, 700, 250, 700);    // foam background    fill(FoamColor);    strokeWeight(0);    quad(176, 98, 624, 98, 605, 250, 195, 250);}',VariableNamingConventions
'new Bubble[Bubbles]',correct
'{    // (BierColor, SchuimColor) NTM BOVENAAN LATEN STAAN ANDERS NIKS TE ZIEN    backgroundBier.display(color(255, 255, 0), color(255));    for (int i = 0; i < arrayofBubbles.length; i++) {        arrayofBubbles[i].display();        arrayofBubbles[i].move();        arrayofBubbles[i].keyPressed();    }    for (int i = 0; i < arrayofGlass.length; i++) {        arrayofGlass[i].display();        arrayofGlass[i].movement();    }    score.display(ScoreCounter, ClickCounter);}',correct
'randomizerY < 50',correct
'key == y',correct
'bubbleY = 660;',correct
'key == t',correct
'int colorRandom = color(random(0, 255), random(0, 255), random(0, 255));',correct
'ScoreCounter = ScoreCounter + 80 * speedLevel;',correct
'float Ypos;',VariableNamingConventions
'key == r',DecentralizedEventHandlingRule
'1.3f',correct
'score.display(ScoreCounter, ClickCounter);',correct
'display',VariableNamingConventions
'new Score()',correct
'strokeWeight(0)',correct
'draw',correct
'mouseX > iconX - 35',correct
'arrayofBubbles[i].display()',correct
'Ypos',correct
'// FoamstrokeWeight(0);',correct
'void draw() {    // (BierColor, SchuimColor) NTM BOVENAAN LATEN STAAN ANDERS NIKS TE ZIEN    backgroundBier.display(color(255, 255, 0), color(255));    for (int i = 0; i < arrayofBubbles.length; i++) {        arrayofBubbles[i].display();        arrayofBubbles[i].move();        arrayofBubbles[i].keyPressed();    }    for (int i = 0; i < arrayofGlass.length; i++) {        arrayofGlass[i].display();        arrayofGlass[i].movement();    }    score.display(ScoreCounter, ClickCounter);}',correct
'yspeed *= 1.2f',correct
'float randomizerY = random(0, 100);',correct
'xdir = 1',correct
'movement',correct
'float xspeed = 4;',correct
'Ypos = -800',correct
'// (BierColor, SchuimColor) NTM BOVENAAN LATEN STAAN ANDERS NIKS TE ZIENbackgroundBier.display(color(255, 255, 0), color(255));',correct
'mouseY > iconY - 50',correct
'for (int i = 0; i < arrayofGlass.length; i++) {    arrayofGlass[i].mousePressed();}',correct
'arrayofBubbles[i].move()',correct
'i++',correct
'{    xdir = 1;}',correct
'{    // bubbleMovement    bubbleY = bubbleY - 0.1f;    // dissapear in foam    if (bubbleY + Ypos + 40 < 250) {        Ypos = -800;    }}',correct
'mouseX < iconX + 35',correct
'iconY - 30',correct
'mousePressed',correct
'{    // Bier    strokeWeight(3);    fill(colorRandom);    quad(iconX - 35, iconY - 50, iconX + 35, iconY - 50, iconX + 20, iconY + 50, iconX - 20, iconY + 50);    // Foam    strokeWeight(0);    fill(255);    quad(iconX - 35, iconY - 55, iconX + 35, iconY - 55, iconX + 30, iconY - 30, iconX - 30, iconY - 30);}',correct
'fill(255);',correct
'ellipseMode(CENTER)',correct
'Bubble',correct
'float bubbleX = 660;',correct
'class Score {    int ScoreCounter = 0;    void display(int ScoreCounter, int ClickCounter) {        // counters        String Score = "Your score is: " + ScoreCounter;        String Clicks = "Clicks: " + (ClickCounter / Glasses);        textSize(32);        fill(0);        textAlign(CENTER);        text(Score, 400, 50);        textSize(32);        fill(0);        textAlign(CENTER);        text(Clicks, 700, 50);    }}',correct
'strokeWeight(3)',correct
'mouseY < iconY + 50',correct
'iconX - 30',correct
'iconX - 35',correct
'float xdir = 1;',AtLeastOneConstructor
'int ScoreCounter = 0;',AtLeastOneConstructor
'score = new Score();',correct
'quad(176, 98, 624, 98, 605, 250, 195, 250);',correct
'void',correct
'keyPressed',DecentralizedEventHandlingRule
'-1',correct
'{    arrayofBubbles[i] = new Bubble();}',correct
'void display(int BierColor, int FoamColor) {    background(230);    // bier background    fill(BierColor);    strokeWeight(3);    quad(175, 100, 625, 100, 550, 700, 250, 700);    // foam background    fill(FoamColor);    strokeWeight(0);    quad(176, 98, 624, 98, 605, 250, 195, 250);}',AtLeastOneConstructor
'bubbleY + Ypos + 40 < 250',correct
'float bubbleY;',correct
'xspeed /= 1.3f;',correct
'iconX - 20',correct
'background(230);',correct
'ydir *= -1',correct
'i < arrayofGlass.length',correct
'iconY = 500',correct
'{    arrayofBubbles[i].display();    arrayofBubbles[i].move();    arrayofBubbles[i].keyPressed();}',correct
'arrayofGlass[i].mousePressed()',correct
'int FoamColor',VariableNamingConventions
'xdir = 1;',correct
'stroke(255);',correct
'{    // Load in    for (int i = 0; i < arrayofBubbles.length; i++) {        arrayofBubbles[i] = new Bubble();    }    for (int i = 0; i < arrayofGlass.length; i++) {        arrayofGlass[i] = new Glass();    }    backgroundBier = new BackgroundBier();    score = new Score();}',correct
'bubbleY + Ypos',correct
'quad(iconX - 35, iconY - 50, iconX + 35, iconY - 50, iconX + 20, iconY + 50, iconX - 20, iconY + 50)',correct
'quad(iconX - 35, iconY - 55, iconX + 35, iconY - 55, iconX + 30, iconY - 30, iconX - 30, iconY - 30);',correct
'for (int i = 0; i < arrayofGlass.length; i++) {    arrayofGlass[i].display();    arrayofGlass[i].movement();}',correct
'"Clicks: "',correct
'"Clicks: " + (ClickCounter / Glasses)',correct
'arrayofGlass[i] = new Glass()',correct
'{    if (mouseY > iconY - 50 && mouseY < iconY + 50) {        iconX = random(100, 700);        iconY = random(100, 700);        ScoreCounter = ScoreCounter + 80 * speedLevel;        score.display(ScoreCounter, ClickCounter);    }}',DecentralizedEventHandlingRule
'float iconX = 500;',correct
'// foam backgroundfill(FoamColor);',correct
'ScoreCounter + 80 * speedLevel',correct
'color(255, 255, 0)',correct
'iconX = random(100, 700);',correct
'{    xspeed /= 1.3f;    yspeed /= 1.3f;    speedLevel = speedLevel - 1;}',correct
'arrayofBubbles[i].display();',correct
'int ScoreCounter;',VariableNamingConventions
'arrayofGlass = new Glass[Glasses]',correct
'// clicksClickCounter = (ClickCounter + 1);',correct
'class Glass {    int colorRandom = color(random(0, 255), random(0, 255), random(0, 255));    float iconX = 500;    float iconY = 500;    float randomizerX = random(0, 100);    float randomizerY = random(0, 100);    float xdir = 1;    float ydir = -1;    void display() {        // Bier        strokeWeight(3);        fill(colorRandom);        quad(iconX - 35, iconY - 50, iconX + 35, iconY - 50, iconX + 20, iconY + 50, iconX - 20, iconY + 50);        // Foam        strokeWeight(0);        fill(255);        quad(iconX - 35, iconY - 55, iconX + 35, iconY - 55, iconX + 30, iconY - 30, iconX - 30, iconY - 30);    }    void movement() {        // Glass Movement        iconX = iconX + (xspeed * xdir);        iconY = iconY + (yspeed * ydir);        // Hit Wall Response        if (iconX + 35 > 800 || iconX - 35 < 0) {            xdir *= -1;            colorRandom = color(random(0, 255), random(0, 255), random(0, 255));        }        if (iconY + 50 > 800 || iconY - 50 < 0) {            ydir *= -1;            colorRandom = color(random(0, 255), random(0, 255), random(0, 255));        }    }    void keyPressed() {        // Glass Speed        if (keyPressed) {            if (key == t) {                xspeed *= 1.2f;                yspeed *= 1.2f;                speedLevel = speedLevel + 1;            }            if (key == y) {                xspeed /= 1.3f;                yspeed /= 1.3f;                speedLevel = speedLevel - 1;            }            // Reset glass            if (key == r) {                iconX = mouseX;                iconY = mouseY;                xdir = 1;                ydir = 1;                xspeed = 4;                yspeed = 2;                speedLevel = 10;            }        }    }    void mousePressed() {        // change direction on click        randomizerX = random(0, 100);        randomizerY = random(0, 100);        if (randomizerX < 50) {            xdir = 1;        } else {            xdir = -1;        }        if (randomizerY < 50) {            ydir = 1;        } else {            ydir = -1;        }        // clicks        ClickCounter = (ClickCounter + 1);        // glass hitbox        if (mouseX > iconX - 35 && mouseX < iconX + 35) {            if (mouseY > iconY - 50 && mouseY < iconY + 50) {                iconX = random(100, 700);                iconY = random(100, 700);                ScoreCounter = ScoreCounter + 80 * speedLevel;                score.display(ScoreCounter, ClickCounter);            }        }    }}',correct
'ellipse(bubbleX + Xpos, bubbleY + Ypos, 20, 20);',correct
'{    // Glass Movement    iconX = iconX + (xspeed * xdir);    iconY = iconY + (yspeed * ydir);    // Hit Wall Response    if (iconX + 35 > 800 || iconX - 35 < 0) {        xdir *= -1;        colorRandom = color(random(0, 255), random(0, 255), random(0, 255));    }    if (iconY + 50 > 800 || iconY - 50 < 0) {        ydir *= -1;        colorRandom = color(random(0, 255), random(0, 255), random(0, 255));    }}',correct
'"Your score is: " + ScoreCounter',correct
'iconY = iconY + (yspeed * ydir);',correct
'int ClickCounter;',correct
'move',correct
'quad(iconX - 35, iconY - 50, iconX + 35, iconY - 50, iconX + 20, iconY + 50, iconX - 20, iconY + 50);',correct
'colorRandom = color(random(0, 255), random(0, 255), random(0, 255))',correct
'// Load infor (int i = 0; i < arrayofBubbles.length; i++) {    arrayofBubbles[i] = new Bubble();}',correct
'float Xpos;',VariableNamingConventions
'yspeed = 2',correct
'iconX = mouseX',correct
'speedLevel = 10',correct
'strokeWeight(0);',correct
'-400',correct
'arrayofGlass[i].display()',correct
'void mousePressed() {    // change direction on click    randomizerX = random(0, 100);    randomizerY = random(0, 100);    if (randomizerX < 50) {        xdir = 1;    } else {        xdir = -1;    }    if (randomizerY < 50) {        ydir = 1;    } else {        ydir = -1;    }    // clicks    ClickCounter = (ClickCounter + 1);    // glass hitbox    if (mouseX > iconX - 35 && mouseX < iconX + 35) {        if (mouseY > iconY - 50 && mouseY < iconY + 50) {            iconX = random(100, 700);            iconY = random(100, 700);            ScoreCounter = ScoreCounter + 80 * speedLevel;            score.display(ScoreCounter, ClickCounter);        }    }}',AtLeastOneConstructor
'randomizerX < 50',correct
'quad(176, 98, 624, 98, 605, 250, 195, 250)',correct
'Xpos = random(-100, 100)',correct
'xspeed *= 1.2f',correct
'iconX = 500',correct
'iconX - 35 < 0',correct
'int ClickCounter',correct
'class BackgroundBier {    void display(int BierColor, int FoamColor) {        background(230);        // bier background        fill(BierColor);        strokeWeight(3);        quad(175, 100, 625, 100, 550, 700, 250, 700);        // foam background        fill(FoamColor);        strokeWeight(0);        quad(176, 98, 624, 98, 605, 250, 195, 250);    }}',correct
'for (int i = 0; i < arrayofGlass.length; i++) {    arrayofGlass[i] = new Glass();}',correct
'quad(iconX - 35, iconY - 55, iconX + 35, iconY - 55, iconX + 30, iconY - 30, iconX - 30, iconY - 30)',correct
'Navi[]',correct
'Navi(float initX, float initY, float initSize) {    naviX = initX;    naviY = initY;    int red = PApplet.parseInt(random(0, 256));    int green = PApplet.parseInt(random(0, 256));    int blue = PApplet.parseInt(random(0, 256));    bodyColor = color(red, green, blue);    naviBody = initSize;    wingColor = color(255);}',correct
'i = 0',correct
'{    navi[i].display();}',correct
'if (i != j) {    navi[i].jump(navi[j].naviX, navi[j].naviY);}',correct
'navi[i].update()',correct
'bodyColor = color(red, green, blue);',correct
'color(255)',correct
'navi[i].display()',correct
'int red = PApplet.parseInt(random(0, 256))',correct
'naviY + 65',correct
'for (int j = 0; j < 10; j++) {    if (i != j) {        navi[i].jump(navi[j].naviX, navi[j].naviY);    }}',correct
'stroke(wingColor)',correct
'2.5f',correct
'{    naviX = initX;    naviY = initY;    int red = PApplet.parseInt(random(0, 256));    int green = PApplet.parseInt(random(0, 256));    int blue = PApplet.parseInt(random(0, 256));    bodyColor = color(red, green, blue);    naviBody = initSize;    wingColor = color(255);}',correct
'i != j',correct
'{    ellipseMode(CENTER);    for (int i = 0; i < navi.length; i++) {        navi[i] = new Navi(random(100, 1300), random(100, 900), random(90, 110));    }}',correct
'naviBody',correct
'navi[i].jump(navi[j].naviX, navi[j].naviY);',correct
'{    for (int i = 0; i < 10; i++) {        for (int j = 0; j < 10; j++) {            if (i != j) {                navi[i].jump(navi[j].naviX, navi[j].naviY);            }        }    }}',correct
'random(0, 256)',correct
'naviBody * 2.5f',correct
'{    fill(wingColor);    stroke(wingColor);    arc(naviX, naviY - 130, naviBody * 2.7f, naviBody * 2.5f, PI / 2, PI, CHORD);    arc(naviX, naviY - 130, naviBody * 2.7f, naviBody * 2.5f, 0, PI / 2, CHORD);    triangle(naviX - 25, naviY + 25, naviX - 65, naviY + 25, naviX - 25, naviY + 65);    triangle(naviX + 25, naviY + 25, naviX + 65, naviY + 25, naviX + 25, naviY + 65);    fill(bodyColor);    stroke(bodyColor);    ellipse(naviX, naviY, naviBody, naviBody);    if (jumpDelay > 0) {        jumpDelay--;    }    if (jumpDelay == 1) {        naviX = random(100, 1300);        naviY = random(100, 900);    }}',correct
'navi[i].jump(mouseX, mouseY);',correct
'random(100, 900)',correct
'ellipse(naviX, naviY, naviBody, naviBody);',correct
'void update() {    for (int i = 0; i < 10; i++) {        for (int j = 0; j < 10; j++) {            if (i != j) {                navi[i].jump(navi[j].naviX, navi[j].naviY);            }        }    }}',correct
'jumpDelay = 0',correct
'{    jumpDelay = 50;}',correct
'for (int i = 0; i < navi.length; i++) {    navi[i].display();}',correct
'naviX - 65',correct
'fill(wingColor)',correct
'navi.length',correct
'int j = 0',correct
'naviY',correct
'stroke(bodyColor)',correct
'naviX',correct
'navi[j]',correct
'j++',correct
'navi = new Navi[10]',correct
'PI / 2',correct
'green = PApplet.parseInt(random(0, 256))',correct
'triangle(naviX - 25, naviY + 25, naviX - 65, naviY + 25, naviX - 25, naviY + 65);',correct
'naviBody = initSize',correct
'jumpDelay--;',correct
'new Navi[10]',correct
'random(100, 1300)',correct
'float naviX;',correct
'wingColor = color(255);',correct
'ellipse(naviX, naviY, naviBody, naviBody)',correct
'float otherX',correct
'stroke(wingColor);',correct
'float otherY',correct
'int red = PApplet.parseInt(random(0, 256));',correct
'2.7f',correct
'float initSize',correct
'void display() {    fill(wingColor);    stroke(wingColor);    arc(naviX, naviY - 130, naviBody * 2.7f, naviBody * 2.5f, PI / 2, PI, CHORD);    arc(naviX, naviY - 130, naviBody * 2.7f, naviBody * 2.5f, 0, PI / 2, CHORD);    triangle(naviX - 25, naviY + 25, naviX - 65, naviY + 25, naviX - 25, naviY + 65);    triangle(naviX + 25, naviY + 25, naviX + 65, naviY + 25, naviX + 25, naviY + 65);    fill(bodyColor);    stroke(bodyColor);    ellipse(naviX, naviY, naviBody, naviBody);    if (jumpDelay > 0) {        jumpDelay--;    }    if (jumpDelay == 1) {        naviX = random(100, 1300);        naviY = random(100, 900);    }}',correct
'{    for (int j = 0; j < 10; j++) {        if (i != j) {            navi[i].jump(navi[j].naviX, navi[j].naviY);        }    }}',correct
'if (dist(otherX, otherY, naviX, naviY) < 200 && jumpDelay == 0) {    jumpDelay = 50;}',correct
'int wingColor;',correct
'PApplet.parseInt(random(0, 256))',correct
'{    if (i != j) {        navi[i].jump(navi[j].naviX, navi[j].naviY);    }}',correct
'naviBody = initSize;',correct
'naviY = random(100, 900)',correct
'navi[i].update();',correct
'navi[i]',correct
'arc(naviX, naviY - 130, naviBody * 2.7f, naviBody * 2.5f, 0, PI / 2, CHORD);',correct
'naviX = initX;',correct
'float naviY;',correct
'naviY = initY',correct
'int green = PApplet.parseInt(random(0, 256));',correct
'Navi[] navi = new Navi[10];',correct
'naviX + 65',correct
'jumpDelay > 0',correct
'int blue = PApplet.parseInt(random(0, 256))',correct
'{    background(100, 200, 50);    for (int i = 0; i < navi.length; i++) {        navi[i].display();    }    for (int i = 0; i < navi.length; i++) {        navi[i].update();    }}',correct
'for (int i = 0; i < navi.length; i++) {    navi[i].jump(mouseX, mouseY);}',correct
'navi[j].naviX',correct
'navi[j].naviY',correct
'jumpDelay == 0',correct
'jumpDelay == 1',correct
'navi[i] = new Navi(random(100, 1300), random(100, 900), random(90, 110))',correct
'background(100, 200, 50);',correct
'{    navi[i].jump(mouseX, mouseY);}',correct
'int blue = PApplet.parseInt(random(0, 256));',correct
'float initX',correct
'float initY',correct
'i++',correct
'{    navi[i].jump(navi[j].naviX, navi[j].naviY);}',correct
'naviY + 25',correct
'ellipseMode(CENTER)',correct
'{    navi[i] = new Navi(random(100, 1300), random(100, 900), random(90, 110));}',correct
'dist(otherX, otherY, naviX, naviY) < 200 && jumpDelay == 0',correct
'if (jumpDelay > 0) {    jumpDelay--;}',correct
'{    naviX = random(100, 1300);    naviY = random(100, 900);}',correct
'dist(otherX, otherY, naviX, naviY)',correct
'if (jumpDelay == 1) {    naviX = random(100, 1300);    naviY = random(100, 900);}',correct
'for (int i = 0; i < navi.length; i++) {    navi[i] = new Navi(random(100, 1300), random(100, 900), random(90, 110));}',correct
'fill(bodyColor)',correct
'{    navi[i].update();}',correct
'void draw() {    background(100, 200, 50);    for (int i = 0; i < navi.length; i++) {        navi[i].display();    }    for (int i = 0; i < navi.length; i++) {        navi[i].update();    }}',correct
'{    for (int i = 0; i < navi.length; i++) {        navi[i].jump(mouseX, mouseY);    }}',correct
'void',correct
'int green = PApplet.parseInt(random(0, 256))',correct
'{    if (dist(otherX, otherY, naviX, naviY) < 200 && jumpDelay == 0) {        jumpDelay = 50;    }}',correct
'wingColor',correct
'navi[i].jump(mouseX, mouseY)',correct
'arc(naviX, naviY - 130, naviBody * 2.7f, naviBody * 2.5f, PI / 2, PI, CHORD);',correct
'void mouseClicked() {    for (int i = 0; i < navi.length; i++) {        navi[i].jump(mouseX, mouseY);    }}',correct
'int jumpDelay = 0;',correct
'arc(naviX, naviY - 130, naviBody * 2.7f, naviBody * 2.5f, PI / 2, PI, CHORD)',correct
'j = 0',correct
'naviX = initX',correct
'triangle(naviX + 25, naviY + 25, naviX + 65, naviY + 25, naviX + 25, naviY + 65);',correct
'fill(bodyColor);',correct
'j < 10',correct
'bodyColor = color(red, green, blue)',correct
'naviX - 25',correct
'naviX = random(100, 1300)',correct
'red = PApplet.parseInt(random(0, 256))',correct
'naviY - 130',correct
'bodyColor',correct
'void setup() {    ellipseMode(CENTER);    for (int i = 0; i < navi.length; i++) {        navi[i] = new Navi(random(100, 1300), random(100, 900), random(90, 110));    }}',correct
'background(100, 200, 50)',correct
'int bodyColor;',correct
'triangle(naviX - 25, naviY + 25, naviX - 65, naviY + 25, naviX - 25, naviY + 65)',correct
'void jump(float otherX, float otherY) {    if (dist(otherX, otherY, naviX, naviY) < 200 && jumpDelay == 0) {        jumpDelay = 50;    }}',correct
'color(red, green, blue)',correct
'triangle(naviX + 25, naviY + 25, naviX + 65, naviY + 25, naviX + 25, naviY + 65)',correct
'float naviBody;',correct
'jumpDelay = 50;',correct
'{    jumpDelay--;}',correct
'naviY = random(100, 900);',correct
'[10]',correct
'wingColor = color(255)',correct
'Processing',correct
'i < 10',correct
'fill(wingColor);',correct
'arc(naviX, naviY - 130, naviBody * 2.7f, naviBody * 2.5f, 0, PI / 2, CHORD)',correct
'jumpDelay = 50',correct
'navi[i].jump(navi[j].naviX, navi[j].naviY)',correct
'dist(otherX, otherY, naviX, naviY) < 200',correct
'i < navi.length',correct
'jumpDelay--',correct
'Navi',correct
'navi[i].display();',correct
'random(90, 110)',correct
'class Navi {    float naviX;    float naviY;    int bodyColor;    int wingColor;    float naviBody;    int jumpDelay = 0;    Navi(float initX, float initY, float initSize) {        naviX = initX;        naviY = initY;        int red = PApplet.parseInt(random(0, 256));        int green = PApplet.parseInt(random(0, 256));        int blue = PApplet.parseInt(random(0, 256));        bodyColor = color(red, green, blue);        naviBody = initSize;        wingColor = color(255);    }    void display() {        fill(wingColor);        stroke(wingColor);        arc(naviX, naviY - 130, naviBody * 2.7f, naviBody * 2.5f, PI / 2, PI, CHORD);        arc(naviX, naviY - 130, naviBody * 2.7f, naviBody * 2.5f, 0, PI / 2, CHORD);        triangle(naviX - 25, naviY + 25, naviX - 65, naviY + 25, naviX - 25, naviY + 65);        triangle(naviX + 25, naviY + 25, naviX + 65, naviY + 25, naviX + 25, naviY + 65);        fill(bodyColor);        stroke(bodyColor);        ellipse(naviX, naviY, naviBody, naviBody);        if (jumpDelay > 0) {            jumpDelay--;        }        if (jumpDelay == 1) {            naviX = random(100, 1300);            naviY = random(100, 900);        }    }    void update() {        for (int i = 0; i < 10; i++) {            for (int j = 0; j < 10; j++) {                if (i != j) {                    navi[i].jump(navi[j].naviX, navi[j].naviY);                }            }        }    }    void jump(float otherX, float otherY) {        if (dist(otherX, otherY, naviX, naviY) < 200 && jumpDelay == 0) {            jumpDelay = 50;        }    }}',correct
'naviBody * 2.7f',correct
'for (int i = 0; i < navi.length; i++) {    navi[i].update();}',correct
'for (int i = 0; i < 10; i++) {    for (int j = 0; j < 10; j++) {        if (i != j) {            navi[i].jump(navi[j].naviX, navi[j].naviY);        }    }}',correct
'naviX + 25',correct
'naviY = initY;',correct
'int i = 0',correct
'ellipseMode(CENTER);',correct
'new Navi(random(100, 1300), random(100, 900), random(90, 110))',correct
'blue = PApplet.parseInt(random(0, 256))',correct
'naviX = random(100, 1300);',correct
'navi[i] = new Navi(random(100, 1300), random(100, 900), random(90, 110));',correct
'stroke(bodyColor);',correct
'Heart',correct
'text("Try to collect all the hearts.", 210, 650)',correct
'PImage[]',correct
'{    if (keyCode == UP & yPos > 0) {        yPos = yPos - 10;    } else if (keyCode == DOWN & yPos < 550) {        yPos = yPos + 10;    }}',DecentralizedEventHandlingRule
'"PLAY"',correct
'score++;',DrawingStateChangeRule
'// By Nina Verbeeke (s2108208)',correct
'xPos -= speed;',correct
'class Heart {    // store image    PImage heartImg;    int xPos = 1000, yPos = PApplet.parseInt(random(0, 650));    Heart() {        heartImg = loadImage("images/heart.png");    }    void display() {        // show a heart and let it move        image(heartImg, xPos, yPos, 50, 50);        xPos -= speed;    }}',correct
'loadImage("images/frame-3.png")',correct
'String',correct
'text = initText;',correct
'// load fontmyFont = createFont("PTMono-Bold", 32);',correct
'backImg',correct
'"PTMono-Bold"',correct
'Button',correct
'// draw the background and make the background movingimageMode(CORNER);',correct
'heart = new Heart();',correct
'buttonPlay = new Button(500, 450, 160, 74, "PLAY", 465, 460)',correct
'void display() {    // Use % to cycle through frames    currentFrame = (currentFrame + 1) % numFrames;    image(images[currentFrame], xPos, yPos);}',correct
'Background',correct
'yPos = 200',correct
'yPos = yPos - 10',correct
'currentFrame = 0',correct
'widthRect',correct
'fill(0, 0, 0)',correct
'{    // load different frames of the bird    images[0] = loadImage("images/frame-1.png");    images[1] = loadImage("images/frame-2.png");    images[2] = loadImage("images/frame-3.png");    images[3] = loadImage("images/frame-4.png");}',correct
'// the game restarts when the user clicks on replayif (buttonRestart.pressed()) {    gameState = 2;    score = 0;    heart = new Heart();    speed = 4;    bird.xPos = 310;    bird.yPos = 200;}',correct
'buttonRestart',correct
'dist(90 + bird.xPos, 76 + bird.yPos, 25 + heart.xPos, 25 + heart.yPos)',correct
'76 + bird.yPos',correct
'mouseX > xRect - widthRect / 2',correct
'backImg.width - width',correct
'PFont',correct
'// define global variablesint speed = 4, score = 0, gameState = 1;',correct
'textSize(32)',correct
'images[1] = loadImage("images/frame-2.png");',correct
'yRect = initYRect;',correct
'{    // show the "button" with text    rectMode(CENTER);    strokeWeight(4);    fill(227, 233, 255);    rect(xRect, yRect, widthRect, heightRect);    fill(0);    text(text, xText, yText);}',correct
'heart.xPos < 0',correct
'images[3] = loadImage("images/frame-4.png")',correct
'void display() {    // show the "button" with text    rectMode(CENTER);    strokeWeight(4);    fill(227, 233, 255);    rect(xRect, yRect, widthRect, heightRect);    fill(0);    text(text, xText, yText);}',correct
'yPos < 550',correct
'// show a start screenbackground.display();',correct
'yPos - 10',correct
'text("Use your arrow keys to move the bird.", 150, 600)',correct
'bird.yPos',correct
'"images/frame-2.png"',correct
'fill(0);',correct
'background = new Background()',correct
'// load different frames of the birdimages[0] = loadImage("images/frame-1.png");',correct
'backImg = loadImage("images/background.png");',correct
'PImage',correct
'buttonPlay.pressed()',correct
'return false;',correct
'keyCode == DOWN & yPos < 550',correct
'heightRect / 2',correct
'String initText',LongParameterListRule
'rectMode(CENTER)',correct
'25 + heart.yPos',correct
'heightRect = initHeight;',correct
'heart.display()',correct
'{    x -= backImg.width;}',correct
'int xPos = 310, yPos = 200;',correct
'textFont(myFont)',correct
'void move() {    // let the background image move    image(backImg, -x - backImg.width, 0);    x += 2;    if (x > backImg.width - width) {        x -= backImg.width;    }}',correct
'widthRect = initWidth;',correct
'loadImage("images/frame-2.png")',correct
'{    yPos = yPos + 10;}',correct
'String text;',correct
'if (gameState == 3) {    // show the game over screen    background.display();    background.move();    image(gameOverImg, 350, 70, 300, 300);    buttonRestart.display();    // the game restarts when the user clicks on replay    if (buttonRestart.pressed()) {        gameState = 2;        score = 0;        heart = new Heart();        speed = 4;        bird.xPos = 310;        bird.yPos = 200;    }}',correct
'{    gameState = 2;    score = 0;    heart = new Heart();    speed = 4;}',correct
'x',correct
'image(backImg, -x, 0)',correct
'bird.xPos = 310;',correct
'background.display()',correct
'float initYText',LongParameterListRule
'"images/home.png"',correct
'buttonRestart = new Button(500, 450, 160, 74, "REPLAY", 445, 460);',correct
'class Button {    // initialize variables    float xRect, yRect, widthRect, heightRect, xText, yText;    String text;    // constructor    Button(float initXRect, float initYRect, float initWidth, float initHeight, String initText, float initXText, float initYText) {        xRect = initXRect;        yRect = initYRect;        widthRect = initWidth;        heightRect = initHeight;        text = initText;        xText = initXText;        yText = initYText;    }    void display() {        // show the "button" with text        rectMode(CENTER);        strokeWeight(4);        fill(227, 233, 255);        rect(xRect, yRect, widthRect, heightRect);        fill(0);        text(text, xText, yText);    }    boolean pressed() {        // if the button is pressed > return true (=play the game)        if (mousePressed && mouseX > xRect - widthRect / 2 && mouseX < xRect + widthRect / 2 && mouseY > yRect - heightRect / 2 && mouseY < yRect + heightRect / 2) {            return true;        }        return false;    }}',correct
'image(images[currentFrame], xPos, yPos)',correct
'xPos -= speed',correct
'gameState = 3;',DrawingStateChangeRule
'images[currentFrame]',correct
'yPos + 10',correct
'void draw() {    if (gameState == 1) {        // show a start screen        background.display();        background.move();        buttonPlay.display();        image(homeImg, 25, 0);        fill(0);        text("Use your arrow keys to move the bird.", 150, 600);        text("Try to collect all the hearts.", 210, 650);        if (buttonPlay.pressed()) {            gameState = 2;            score = 0;            heart = new Heart();            speed = 4;        }    }    if (gameState == 2) {        background.display();        background.move();        heart.display();        bird.display();        bird.pressedKey();        // show the score        textSize(32);        fill(0, 0, 0);        text("SCORE: " + score, 50, 50);        // when the bird collects a heart, there appears a new heart, and the speed and score increments        if (dist(90 + bird.xPos, 76 + bird.yPos, 25 + heart.xPos, 25 + heart.yPos) < 100) {            speed++;            heart = new Heart();            score++;        }        // when the bird didnt collect the heart and the heart is on the left of the window the game is over        if (heart.xPos < 0) {            gameState = 3;        }    }    if (gameState == 3) {        // show the game over screen        background.display();        background.move();        image(gameOverImg, 350, 70, 300, 300);        buttonRestart.display();        // the game restarts when the user clicks on replay        if (buttonRestart.pressed()) {            gameState = 2;            score = 0;            heart = new Heart();            speed = 4;            bird.xPos = 310;            bird.yPos = 200;        }    }}',correct
'"images/heart.png"',correct
'yPos = PApplet.parseInt(random(0, 650))',correct
'loadImage("images/home.png")',correct
'images[3] = loadImage("images/frame-4.png");',correct
'Button buttonRestart;',correct
'// store images and fontPImage gameOverImg, homeImg;',correct
'{    xRect = initXRect;    yRect = initYRect;    widthRect = initWidth;    heightRect = initHeight;    text = initText;    xText = initXText;    yText = initYText;}',correct
'{    // let the background image move    image(backImg, -x - backImg.width, 0);    x += 2;    if (x > backImg.width - width) {        x -= backImg.width;    }}',correct
'yRect - heightRect / 2',correct
'bird',correct
'boolean pressed() {    // if the button is pressed > return true (=play the game)    if (mousePressed && mouseX > xRect - widthRect / 2 && mouseX < xRect + widthRect / 2 && mouseY > yRect - heightRect / 2 && mouseY < yRect + heightRect / 2) {        return true;    }    return false;}',correct
'Bird() {    // load different frames of the bird    images[0] = loadImage("images/frame-1.png");    images[1] = loadImage("images/frame-2.png");    images[2] = loadImage("images/frame-3.png");    images[3] = loadImage("images/frame-4.png");}',correct
'gameState = 2;',DrawingStateChangeRule
'loadImage("images/frame-4.png")',correct
'images[2] = loadImage("images/frame-3.png");',correct
'bird.yPos = 200',correct
'[numFrames]',correct
'"Use your arrow keys to move the bird."',correct
'score = 0',correct
'fill(0)',correct
'rect(xRect, yRect, widthRect, heightRect)',correct
'if (gameState == 2) {    background.display();    background.move();    heart.display();    bird.display();    bird.pressedKey();    // show the score    textSize(32);    fill(0, 0, 0);    text("SCORE: " + score, 50, 50);    // when the bird collects a heart, there appears a new heart, and the speed and score increments    if (dist(90 + bird.xPos, 76 + bird.yPos, 25 + heart.xPos, 25 + heart.yPos) < 100) {        speed++;        heart = new Heart();        score++;    }    // when the bird didnt collect the heart and the heart is on the left of the window the game is over    if (heart.xPos < 0) {        gameState = 3;    }}',correct
'buttonRestart.display()',correct
'x > backImg.width - width',correct
'buttonPlay.display();',correct
'xRect',correct
'widthRect = initWidth',correct
'dist(90 + bird.xPos, 76 + bird.yPos, 25 + heart.xPos, 25 + heart.yPos) < 100',correct
'buttonRestart.pressed()',correct
'25 + heart.xPos',correct
'{    backImg = loadImage("images/background.png");}',correct
'Bird',correct
'myFont = createFont("PTMono-Bold", 32)',correct
'float initWidth',correct
'void setup() {    // setup the size of the window    // specifies 26 frames/second    frameRate(26);    // initialize objects    background = new Background();    bird = new Bird();    heart = new Heart();    buttonPlay = new Button(500, 450, 160, 74, "PLAY", 465, 460);    buttonRestart = new Button(500, 450, 160, 74, "REPLAY", 445, 460);    // load images    gameOverImg = loadImage("images/game-over.png");    homeImg = loadImage("images/home.png");    // load font    myFont = createFont("PTMono-Bold", 32);    textFont(myFont);}',correct
'image(gameOverImg, 350, 70, 300, 300)',correct
'background.display();',correct
'Heart() {    heartImg = loadImage("images/heart.png");}',correct
'mousePressed && mouseX > xRect - widthRect / 2',correct
'float initXText',correct
'images[2] = loadImage("images/frame-3.png")',correct
'Processing',correct
'class Bird {    // define/initalize variables    int numFrames = 4, currentFrame = 0;    // store images    PImage[] images = new PImage[numFrames];    int xPos = 310, yPos = 200;    Bird() {        // load different frames of the bird        images[0] = loadImage("images/frame-1.png");        images[1] = loadImage("images/frame-2.png");        images[2] = loadImage("images/frame-3.png");        images[3] = loadImage("images/frame-4.png");    }    void display() {        // Use % to cycle through frames        currentFrame = (currentFrame + 1) % numFrames;        image(images[currentFrame], xPos, yPos);    }    void pressedKey() {        // change the position if a specific key is pressed        if (keyPressed == true) {            if (keyCode == UP & yPos > 0) {                yPos = yPos - 10;            } else if (keyCode == DOWN & yPos < 550) {                yPos = yPos + 10;            }        }    }}',correct
'mouseY > yRect - heightRect / 2',correct
'yPos = yPos - 10;',correct
'myFont',correct
'void display() {    // draw the background and make the background moving    imageMode(CORNER);    image(backImg, -x, 0);}',correct
'images = new PImage[numFrames]',correct
'text("Try to collect all the hearts.", 210, 650);',PixelHardcodeIgnoranceRule
'image(heartImg, xPos, yPos, 50, 50)',correct
'buttonPlay',correct
'buttonRestart.display();',correct
'fill(227, 233, 255)',correct
'{    // Use % to cycle through frames    currentFrame = (currentFrame + 1) % numFrames;    image(images[currentFrame], xPos, yPos);}',correct
'xText = initXText',correct
'"SCORE: "',correct
'"images/frame-1.png"',correct
'// store imagesPImage[] images = new PImage[numFrames];',correct
'class Background {    PImage backImg;    int x;    Background() {        backImg = loadImage("images/background.png");    }    void display() {        // draw the background and make the background moving        imageMode(CORNER);        image(backImg, -x, 0);    }    void move() {        // let the background image move        image(backImg, -x - backImg.width, 0);        x += 2;        if (x > backImg.width - width) {            x -= backImg.width;        }    }}',correct
'currentFrame = (currentFrame + 1) % numFrames',correct
'{    gameState = 3;}',correct
'{    yPos = yPos - 10;}',correct
'false',correct
'PFont myFont;',correct
'heightRect = initHeight',correct
'rect(xRect, yRect, widthRect, heightRect);',correct
'strokeWeight(4);',correct
'{    background.display();    background.move();    heart.display();    bird.display();    bird.pressedKey();    // show the score    textSize(32);    fill(0, 0, 0);    text("SCORE: " + score, 50, 50);    // when the bird collects a heart, there appears a new heart, and the speed and score increments    if (dist(90 + bird.xPos, 76 + bird.yPos, 25 + heart.xPos, 25 + heart.yPos) < 100) {        speed++;        heart = new Heart();        score++;    }    // when the bird didnt collect the heart and the heart is on the left of the window the game is over    if (heart.xPos < 0) {        gameState = 3;    }}',correct
'{    heartImg = loadImage("images/heart.png");}',correct
'xPos = 1000',correct
'keyPressed == true',DecentralizedEventHandlingRule
'setup',correct
'xText = initXText;',correct
'float initHeight',correct
'loadImage("images/background.png")',correct
'new Heart()',correct
'heartImg = loadImage("images/heart.png")',correct
'// show a heart and let it moveimage(heartImg, xPos, yPos, 50, 50);',correct
'gameOverImg',correct
'heart.xPos',correct
'pressedKey',correct
'xText',correct
'{    // show a start screen    background.display();    background.move();    buttonPlay.display();    image(homeImg, 25, 0);    fill(0);    text("Use your arrow keys to move the bird.", 150, 600);    text("Try to collect all the hearts.", 210, 650);    if (buttonPlay.pressed()) {        gameState = 2;        score = 0;        heart = new Heart();        speed = 4;    }}',correct
'image(images[currentFrame], xPos, yPos);',correct
'{    if (gameState == 1) {        // show a start screen        background.display();        background.move();        buttonPlay.display();        image(homeImg, 25, 0);        fill(0);        text("Use your arrow keys to move the bird.", 150, 600);        text("Try to collect all the hearts.", 210, 650);        if (buttonPlay.pressed()) {            gameState = 2;            score = 0;            heart = new Heart();            speed = 4;        }    }    if (gameState == 2) {        background.display();        background.move();        heart.display();        bird.display();        bird.pressedKey();        // show the score        textSize(32);        fill(0, 0, 0);        text("SCORE: " + score, 50, 50);        // when the bird collects a heart, there appears a new heart, and the speed and score increments        if (dist(90 + bird.xPos, 76 + bird.yPos, 25 + heart.xPos, 25 + heart.yPos) < 100) {            speed++;            heart = new Heart();            score++;        }        // when the bird didnt collect the heart and the heart is on the left of the window the game is over        if (heart.xPos < 0) {            gameState = 3;        }    }    if (gameState == 3) {        // show the game over screen        background.display();        background.move();        image(gameOverImg, 350, 70, 300, 300);        buttonRestart.display();        // the game restarts when the user clicks on replay        if (buttonRestart.pressed()) {            gameState = 2;            score = 0;            heart = new Heart();            speed = 4;            bird.xPos = 310;            bird.yPos = 200;        }    }}',LongMethodRule
'x += 2;',correct
'mouseY < yRect + heightRect / 2',correct
'// if the button is pressed > return true (=play the game)if (mousePressed && mouseX > xRect - widthRect / 2 && mouseX < xRect + widthRect / 2 && mouseY > yRect - heightRect / 2 && mouseY < yRect + heightRect / 2) {    return true;}',correct
'image(backImg, -x - backImg.width, 0)',correct
'{    // draw the background and make the background moving    imageMode(CORNER);    image(backImg, -x, 0);}',correct
'// Use % to cycle through framescurrentFrame = (currentFrame + 1) % numFrames;',correct
'new Background()',correct
'text("Use your arrow keys to move the bird.", 150, 600);',PixelHardcodeIgnoranceRule
'gameState == 3',correct
'images[3]',correct
'text',correct
'gameState == 2',correct
'gameState == 1',correct
'// constructorButton(float initXRect, float initYRect, float initWidth, float initHeight, String initText, float initXText, float initYText) {    xRect = initXRect;    yRect = initYRect;    widthRect = initWidth;    heightRect = initHeight;    text = initText;    xText = initXText;    yText = initYText;}',correct
'Button buttonPlay;',correct
'bird.pressedKey();',correct
'{    // show the game over screen    background.display();    background.move();    image(gameOverImg, 350, 70, 300, 300);    buttonRestart.display();    // the game restarts when the user clicks on replay    if (buttonRestart.pressed()) {        gameState = 2;        score = 0;        heart = new Heart();        speed = 4;        bird.xPos = 310;        bird.yPos = 200;    }}',correct
'background.move()',correct
'float initYRect',correct
'pressed',correct
'keyCode == UP & yPos > 0',correct
'xRect + widthRect / 2',correct
'PApplet.parseInt(random(0, 650))',correct
'PImage backImg;',correct
'createFont("PTMono-Bold", 32)',correct
'xPos = 310',correct
'x += 2',correct
'yRect',correct
'mousePressed && mouseX > xRect - widthRect / 2 && mouseX < xRect + widthRect / 2 && mouseY > yRect - heightRect / 2 && mouseY < yRect + heightRect / 2',DecentralizedEventHandlingRule
'yText = initYText',correct
'{    gameState = 2;    score = 0;    heart = new Heart();    speed = 4;    bird.xPos = 310;    bird.yPos = 200;}',correct
'image(gameOverImg, 350, 70, 300, 300);',correct
'// [P4WCI] Tutorial assessment - Your creature// By Nina Verbeeke (s2108208)// load classesBird bird;',correct
'return true;',correct
'images[2]',correct
'heartImg = loadImage("images/heart.png");',correct
'if (x > backImg.width - width) {    x -= backImg.width;}',correct
'text(text, xText, yText)',correct
'numFrames = 4',correct
'if (gameState == 1) {    // show a start screen    background.display();    background.move();    buttonPlay.display();    image(homeImg, 25, 0);    fill(0);    text("Use your arrow keys to move the bird.", 150, 600);    text("Try to collect all the hearts.", 210, 650);    if (buttonPlay.pressed()) {        gameState = 2;        score = 0;        heart = new Heart();        speed = 4;    }}',correct
'"images/background.png"',correct
'new Button(500, 450, 160, 74, "PLAY", 465, 460)',correct
'bird.display()',correct
'bird.pressedKey()',correct
'homeImg',correct
'backImg = loadImage("images/background.png")',correct
'// let the background image moveimage(backImg, -x - backImg.width, 0);',correct
'gameState = 2',correct
'gameState = 3',correct
'"REPLAY"',correct
'heart.display();',correct
'score = 0;',DrawingStateChangeRule
'gameState = 1',correct
'// setup the size of the window',correct
'mousePressed && mouseX > xRect - widthRect / 2 && mouseX < xRect + widthRect / 2',correct
'text("SCORE: " + score, 50, 50);',PixelHardcodeIgnoranceRule
'// when the bird collects a heart, there appears a new heart, and the speed and score incrementsif (dist(90 + bird.xPos, 76 + bird.yPos, 25 + heart.xPos, 25 + heart.yPos) < 100) {    speed++;    heart = new Heart();    score++;}',correct
'keyCode == UP',correct
'bird = new Bird();',correct
'images[0] = loadImage("images/frame-1.png")',correct
'{    // show a heart and let it move    image(heartImg, xPos, yPos, 50, 50);    xPos -= speed;}',correct
'xRect = initXRect;',correct
'// initialize variablesfloat xRect, yRect, widthRect, heightRect, xText, yText;',correct
'"images/frame-3.png"',correct
'if (keyCode == DOWN & yPos < 550) {    yPos = yPos + 10;}',DecentralizedEventHandlingRule
'-x - backImg.width',correct
'display',correct
'yPos > 0',correct
'{    // change the position if a specific key is pressed    if (keyPressed == true) {        if (keyCode == UP & yPos > 0) {            yPos = yPos - 10;        } else if (keyCode == DOWN & yPos < 550) {            yPos = yPos + 10;        }    }}',correct
'backImg.width',correct
'draw',LongMethodRule
'image(backImg, -x, 0);',correct
'gameOverImg = loadImage("images/game-over.png")',correct
'Heart heart;',correct
'random(0, 650)',correct
'textFont(myFont);',correct
'void display() {    // show a heart and let it move    image(heartImg, xPos, yPos, 50, 50);    xPos -= speed;}',correct
'yPos = yPos + 10',correct
'background.move();',correct
'{    return true;}',DecentralizedEventHandlingRule
'heightRect',correct
'int xPos = 1000, yPos = PApplet.parseInt(random(0, 650));',correct
'new Bird()',correct
'frameRate(26)',correct
'yText = initYText;',correct
'buttonPlay.display()',correct
'text("SCORE: " + score, 50, 50)',correct
'if (keyCode == UP & yPos > 0) {    yPos = yPos - 10;} else if (keyCode == DOWN & yPos < 550) {    yPos = yPos + 10;}',DecentralizedEventHandlingRule
'buttonRestart = new Button(500, 450, 160, 74, "REPLAY", 445, 460)',correct
'buttonPlay = new Button(500, 450, 160, 74, "PLAY", 465, 460);',correct
'// [P4WCI] Tutorial assessment - Your creature',correct
'image(homeImg, 25, 0)',correct
'bird.xPos = 310',correct
'// load imagesgameOverImg = loadImage("images/game-over.png");',correct
'float initXRect',LongParameterListRule
'yText',correct
'keyCode == DOWN',correct
'new PImage[numFrames]',correct
'homeImg = loadImage("images/home.png")',correct
'speed = 4;',DrawingStateChangeRule
'"Try to collect all the hearts."',correct
'text(text, xText, yText);',correct
'loadImage("images/game-over.png")',correct
'// store imagePImage heartImg;',correct
'void',correct
'heart.yPos',correct
'xRect = initXRect',correct
'homeImg = loadImage("images/home.png");',correct
'bird.xPos',correct
'90 + bird.xPos',correct
'widthRect / 2',correct
'speed++',correct
'heart',correct
'fill(227, 233, 255);',correct
'loadImage("images/frame-1.png")',correct
'void pressedKey() {    // change the position if a specific key is pressed    if (keyPressed == true) {        if (keyCode == UP & yPos > 0) {            yPos = yPos - 10;        } else if (keyCode == DOWN & yPos < 550) {            yPos = yPos + 10;        }    }}',correct
'{    // setup the size of the window    // specifies 26 frames/second    frameRate(26);    // initialize objects    background = new Background();    bird = new Bird();    heart = new Heart();    buttonPlay = new Button(500, 450, 160, 74, "PLAY", 465, 460);    buttonRestart = new Button(500, 450, 160, 74, "REPLAY", 445, 460);    // load images    gameOverImg = loadImage("images/game-over.png");    homeImg = loadImage("images/home.png");    // load font    myFont = createFont("PTMono-Bold", 32);    textFont(myFont);}',correct
'loadImage("images/heart.png")',correct
'background',correct
'true',correct
'speed = 4',correct
'image(homeImg, 25, 0);',correct
'x -= backImg.width;',correct
'Background background;',correct
'// initialize objectsbackground = new Background();',correct
'(currentFrame + 1) % numFrames',correct
'speed++;',DrawingStateChangeRule
'mousePressed && mouseX > xRect - widthRect / 2 && mouseX < xRect + widthRect / 2 && mouseY > yRect - heightRect / 2',correct
'// setup the size of the window// specifies 26 frames/secondframeRate(26);',correct
'images[1] = loadImage("images/frame-2.png")',correct
'text = initText',correct
'{    speed++;    heart = new Heart();    score++;}',correct
'yPos = yPos + 10;',correct
'fill(0, 0, 0);',correct
'x -= backImg.width',correct
'heartImg',correct
'if (buttonPlay.pressed()) {    gameState = 2;    score = 0;    heart = new Heart();    speed = 4;}',correct
'mouseX < xRect + widthRect / 2',correct
'images[1]',correct
'"images/game-over.png"',correct
'// show the game over screenbackground.display();',correct
'yRect = initYRect',correct
'score++',correct
'imageMode(CORNER)',correct
'"images/frame-4.png"',correct
'move',correct
'int x;',correct
'bird.display();',correct
'xRect - widthRect / 2',correct
'images[0]',correct
'-x',correct
'heart = new Heart()',correct
'Background() {    backImg = loadImage("images/background.png");}',correct
'bird.yPos = 200;',correct
'new Button(500, 450, 160, 74, "REPLAY", 445, 460)',correct
'// show the scoretextSize(32);',correct
'boolean',correct
'yRect + heightRect / 2',correct
'strokeWeight(4)',correct
'// when the bird didnt collect the heart and the heart is on the left of the window the game is overif (heart.xPos < 0) {    gameState = 3;}',correct
'{    // if the button is pressed > return true (=play the game)    if (mousePressed && mouseX > xRect - widthRect / 2 && mouseX < xRect + widthRect / 2 && mouseY > yRect - heightRect / 2 && mouseY < yRect + heightRect / 2) {        return true;    }    return false;}',correct
'bird = new Bird()',correct
'// define/initalize variablesint numFrames = 4, currentFrame = 0;',correct
'"SCORE: " + score',correct
'// show the "button" with textrectMode(CENTER);',correct
'speedX = random(-1, 1)',correct
'{    noStroke();    background(0, 188, 255);    // The triangles and the rectangle are mountains//    fill(237, 243, 245);    triangle(bergX, bergY, bergX + 40, bergY - 100, bergX + 100, bergY);    triangle(bergX + 80, bergY, bergX + 130, bergY - 50, bergX + 180, bergY);    triangle(bergX + 150, bergY, bergX + 220, bergY - 150, bergX + 310, bergY);    triangle(bergX + 270, bergY, bergX + 340, bergY - 200, bergX + 420, bergY);    triangle(bergX + 300, bergY, bergX + 420, bergY - 160, bergX + 540, bergY);    triangle(bergX + 480, bergY, bergX + 540, bergY - 100, bergX + 600, bergY);    rect(bergX, bergY, 600, 20);}',correct
'bergX + 600',correct
'triangle(bergX, bergY, bergX + 40, bergY - 100, bergX + 100, bergY);',correct
'iconY = iconY + 20',correct
'void display() {    // this is the ice//    fill(116, 212, 255);    ellipse(iconX - 4, iconY + 124, 200, 150);    fill(213, 242, 255);    ellipse(iconX - 4, iconY + 118, 200, 145);    strokeWeight(0);    // main body and head//    fill(0, 0, 0);    ellipse(iconX, iconY + 50, 120, 150);    ellipse(iconX, iconY - 50, 100, 100);    // these are the belly and the eyes//    fill(255);    ellipse(iconX, iconY + 50, 90, 110);    ellipse(iconX + 20, iconY - 65, 20, 25);    ellipse(iconX - 20, iconY - 65, 20, 25);    // The pupils//    fill(100, 0, 255);    ellipse(iconX + 20, iconY - 65, 10, 10);    ellipse(iconX - 20, iconY - 65, 10, 10);    // These are the feet and the mouth//    fill(255, 180, 0);    triangle(iconX - 15, iconY - 50, iconX, iconY - 30, iconX + 15, iconY - 50);    triangle(iconX - 15, iconY + 124, iconX - 40, iconY + 105, iconX - 42, iconY + 130);    triangle(iconX + 15, iconY + 124, iconX + 40, iconY + 105, iconX + 42, iconY + 130);    fill(0);    stroke(255, 102, 0);    stroke(0, 0, 0);    bezier(iconX - 50, iconY + 8, iconX - 85, iconY + 70, iconX - 85, iconY + 70, iconX - 50, iconY + 55);    bezier(iconX + 50, iconY + 8, iconX + 85, iconY + 70, iconX + 85, iconY + 70, iconX + 50, iconY + 55);}',correct
'iconY + 55',correct
'{    directionX *= -1;}',correct
'triangle(iconX - 15, iconY - 50, iconX, iconY - 30, iconX + 15, iconY - 50)',correct
'iconY + 50',correct
'iconY < 200',correct
'iconY + 130',correct
'golfX + 140',correct
'kc == RIGHT',correct
'void moveByKey(int kc) {    if (iconY >= 200) {        if (kc == UP)            iconY = iconY - 20;    }    if (kc == DOWN)        iconY = iconY + 20;    if (kc == LEFT)        iconX = iconX - 20;    if (kc == RIGHT)        iconX = iconX + 20;}',correct
'if (kc == RIGHT)    iconX = iconX + 20;',IfStmtsMustUseBraces
'Penguins[i] = new Penguin()',correct
'Ijsberg_landschap() {    bergX = 0;    bergY = 200;}',correct
'golfY - 50',correct
'int golfy = 1',correct
'iconX = iconX + 20;',correct
'triangle(bergX + 300, bergY, bergX + 420, bergY - 160, bergX + 540, bergY);',correct
'iconY >= 200',correct
'fill(0, 0, 0)',correct
'ellipse(iconX, iconY + 50, 90, 110)',correct
'iconY + 124',correct
'if (iconY > height) {    directionY *= -1;}',correct
'// This makes the wave movepushMatrix();',correct
'bergX + 180',correct
'golfX + 150',correct
'directionY *= -1;',correct
'golfY - 40',correct
'-300',correct
'speedX += (random(-0.1f, 0.1f))',correct
'golfy = golfy + 30',correct
'bergX',correct
'bergY',correct
'triangle(bergX + 300, bergY, bergX + 420, bergY - 160, bergX + 540, bergY)',correct
'Penguins[i].update()',correct
'iconY + 118',correct
'triangle(bergX, bergY, bergX + 40, bergY - 100, bergX + 100, bergY)',correct
'int golf = 1',correct
'iconX < 0',correct
'// The pupils//fill(100, 0, 255);',correct
'iconY = mouseY;',correct
'{    // This makes the wave move    pushMatrix();    translate(-300, golfy);    translate(-200, 0);    for (int golf = 1; golf <= width; golf = golf + 50) {        // this is the code for the wave        translate(80, 0);        bezier(golfX + 180, golfY - 50, golfX + 140, golfY - 65, golfX + 150, golfY - 40, golfX + 115, golfY - 50);    }    popMatrix();}',correct
'Penguin penguinA;',correct
'ellipse(iconX, iconY + 50, 120, 150);',correct
'iconY = iconY - 20;',correct
'if (key == CODED) {    penguinA.moveByKey(keyCode);}',correct
'triangle(bergX + 80, bergY, bergX + 130, bergY - 50, bergX + 180, bergY)',correct
'fill(0);',correct
'{    iconX = width / 2;    iconY = height / 2;}',correct
'{    penguinA.moveByKey(keyCode);}',correct
'directionY = 1',correct
'if (iconY < 200) {    directionY *= -1;}',correct
'bergY = 200;',correct
'bergX + 150',correct
'bergX + 270',correct
'iconY = iconY + (speedY * directionY)',correct
'if (iconX < 0) {    directionX *= -1;}',correct
'int kc',correct
'triangle(bergX + 150, bergY, bergX + 220, bergY - 150, bergX + 310, bergY);',correct
'ellipse(iconX - 20, iconY - 65, 10, 10)',correct
'Penguins[i].display()',correct
'triangle(bergX + 270, bergY, bergX + 340, bergY - 200, bergX + 420, bergY);',correct
'ellipse(iconX + 20, iconY - 65, 20, 25);',correct
'int golfY;',correct
'iconY = height / 2;',correct
'{    golfA = new Golf();    penguinA = new Penguin();    ijsberg_landschapA = new Ijsberg_landschap();    for (int i = 0; i < Penguins.length; i++) {        Penguins[i] = new Penguin();    }}',correct
'golfX = 0',correct
'[5]',correct
'ijsberg_landschapA.display()',correct
'golf <= width',correct
'void mouseClicked() {    penguinA.moveByMouse();}',correct
'triangle(iconX - 15, iconY - 50, iconX, iconY - 30, iconX + 15, iconY - 50);',correct
'penguinA',correct
'golf = golf + 50',correct
'penguinA.display()',correct
'iconX = iconX - 20',correct
'kc == UP',correct
'popMatrix();',correct
'strokeWeight(2);',correct
'-200',correct
'iconY = mouseY',correct
'golfY - 65',correct
'background(0, 188, 255)',correct
'Penguins[i]',correct
'// this is the ice//fill(116, 212, 255);',correct
'new Penguin[5]',correct
'iconX - 85',correct
'ellipse(iconX + 20, iconY - 65, 10, 10);',correct
'int golfX;',correct
'golfA = new Golf();',correct
'kc == DOWN',correct
'noStroke()',correct
'iconX = iconX + (speedX * directionX);',correct
'float speedY = random(-1, 1);',correct
'bezier(golfX + 180, golfY - 50, golfX + 140, golfY - 65, golfX + 150, golfY - 40, golfX + 115, golfY - 50);',correct
'triangle(bergX + 270, bergY, bergX + 340, bergY - 200, bergX + 420, bergY)',correct
'golfY = width / 2;',correct
'int directionX = 1;',correct
'mouseY >= 200',correct
'ijsberg_landschapA = new Ijsberg_landschap();',correct
'void moveByMouse() {    if (mouseY >= 200) {        iconX = mouseX;        iconY = mouseY;    }}',correct
'Penguin[] Penguins = new Penguin[5];',VariableNamingConventions
'iconY + (speedY * directionY)',correct
'triangle(iconX + 15, iconY + 124, iconX + 40, iconY + 105, iconX + 42, iconY + 130)',correct
'if (kc == UP)    iconY = iconY - 20;',IfStmtsMustUseBraces
'{    // this is the code for the wave    translate(80, 0);    bezier(golfX + 180, golfY - 50, golfX + 140, golfY - 65, golfX + 150, golfY - 40, golfX + 115, golfY - 50);}',correct
'if (kc == DOWN)    iconY = iconY + 20;',IfStmtsMustUseBraces
'int directionY = 1;',correct
'fill(237, 243, 245)',correct
'golfX = golfX + 1;',correct
'void update() {    speedX += (random(-0.1f, 0.1f));    speedY += (random(-0.1f, 0.1f));    iconX = iconX + (speedX * directionX);    iconY = iconY + (speedY * directionY);    if (iconX > width) {        directionX *= -1;    }    if (iconX < 0) {        directionX *= -1;    }    if (iconY > height) {        directionY *= -1;    }    if (iconY < 200) {        directionY *= -1;    }}',correct
'bergX + 130',correct
'iconX + 15',correct
'ellipse(iconX - 4, iconY + 118, 200, 145)',correct
'golf + 50',correct
'Golf',correct
'bezier(iconX + 50, iconY + 8, iconX + 85, iconY + 70, iconX + 85, iconY + 70, iconX + 50, iconY + 55);',correct
'iconX = iconX + 20',correct
'stroke(0, 0, 0)',correct
'fill(213, 242, 255);',correct
'{    // this is the ice//    fill(116, 212, 255);    ellipse(iconX - 4, iconY + 124, 200, 150);    fill(213, 242, 255);    ellipse(iconX - 4, iconY + 118, 200, 145);    strokeWeight(0);    // main body and head//    fill(0, 0, 0);    ellipse(iconX, iconY + 50, 120, 150);    ellipse(iconX, iconY - 50, 100, 100);    // these are the belly and the eyes//    fill(255);    ellipse(iconX, iconY + 50, 90, 110);    ellipse(iconX + 20, iconY - 65, 20, 25);    ellipse(iconX - 20, iconY - 65, 20, 25);    // The pupils//    fill(100, 0, 255);    ellipse(iconX + 20, iconY - 65, 10, 10);    ellipse(iconX - 20, iconY - 65, 10, 10);    // These are the feet and the mouth//    fill(255, 180, 0);    triangle(iconX - 15, iconY - 50, iconX, iconY - 30, iconX + 15, iconY - 50);    triangle(iconX - 15, iconY + 124, iconX - 40, iconY + 105, iconX - 42, iconY + 130);    triangle(iconX + 15, iconY + 124, iconX + 40, iconY + 105, iconX + 42, iconY + 130);    fill(0);    stroke(255, 102, 0);    stroke(0, 0, 0);    bezier(iconX - 50, iconY + 8, iconX - 85, iconY + 70, iconX - 85, iconY + 70, iconX - 50, iconY + 55);    bezier(iconX + 50, iconY + 8, iconX + 85, iconY + 70, iconX + 85, iconY + 70, iconX + 50, iconY + 55);}',LongMethodRule
'golfX + 115',correct
'key == CODED',correct
'// these are the belly and the eyes//fill(255);',correct
'// The triangles and the rectangle are mountains//fill(237, 243, 245);',correct
'iconY + 20',correct
'fill(0)',correct
'ellipse(iconX, iconY + 50, 120, 150)',correct
'golfA.display()',correct
'fill(100, 0, 255)',correct
'height / 2',correct
'Penguins.length',correct
'bergY = 200',correct
'int bergX;',correct
'iconX = mouseX;',correct
'triangle(bergX + 150, bergY, bergX + 220, bergY - 150, bergX + 310, bergY)',correct
'triangle(iconX - 15, iconY + 124, iconX - 40, iconY + 105, iconX - 42, iconY + 130);',correct
'speedX += (random(-0.1f, 0.1f));',correct
'golfA = new Golf()',correct
'ellipse(iconX, iconY - 50, 100, 100)',correct
'iconY + 8',correct
'rect(bergX, bergY, 600, 20);',correct
'fill(255, 180, 0)',correct
'fill(255)',correct
'golfA.display();',correct
'Processing',correct
'golfX + 1',correct
'iconX = iconX + (speedX * directionX)',correct
'iconY + 105',correct
'pushMatrix()',correct
'void display() {    noFill();    golfX = golfX + 1;    if (golfX == 320) {        golfX = 0;    }    strokeWeight(2);    stroke(116, 212, 255);    for (int golfy = 1; golfy <= height / 2; golfy = golfy + 30) {        // This makes the wave move        pushMatrix();        translate(-300, golfy);        translate(-200, 0);        for (int golf = 1; golf <= width; golf = golf + 50) {            // this is the code for the wave            translate(80, 0);            bezier(golfX + 180, golfY - 50, golfX + 140, golfY - 65, golfX + 150, golfY - 40, golfX + 115, golfY - 50);        }        popMatrix();    }}',correct
'ellipse(iconX - 20, iconY - 65, 20, 25)',correct
'golfy + 30',correct
'for (int golf = 1; golf <= width; golf = golf + 50) {    // this is the code for the wave    translate(80, 0);    bezier(golfX + 180, golfY - 50, golfX + 140, golfY - 65, golfX + 150, golfY - 40, golfX + 115, golfY - 50);}',correct
'stroke(255, 102, 0)',correct
'noFill()',correct
'iconY = iconY + (speedY * directionY);',correct
'class Golf {    int golfX;    int golfY;    Golf() {        golfX = 20;        golfY = width / 2;    }    void display() {        noFill();        golfX = golfX + 1;        if (golfX == 320) {            golfX = 0;        }        strokeWeight(2);        stroke(116, 212, 255);        for (int golfy = 1; golfy <= height / 2; golfy = golfy + 30) {            // This makes the wave move            pushMatrix();            translate(-300, golfy);            translate(-200, 0);            for (int golf = 1; golf <= width; golf = golf + 50) {                // this is the code for the wave                translate(80, 0);                bezier(golfX + 180, golfY - 50, golfX + 140, golfY - 65, golfX + 150, golfY - 40, golfX + 115, golfY - 50);            }            popMatrix();        }    }}',correct
'{    iconX = mouseX;    iconY = mouseY;}',correct
'if (kc == LEFT)    iconX = iconX - 20;',IfStmtsMustUseBraces
'translate(-300, golfy)',correct
'speedY += (random(-0.1f, 0.1f));',correct
'directionX *= -1;',correct
'int i = 0',correct
'ellipse(iconX - 4, iconY + 124, 200, 150)',correct
'bergX + 480',correct
'iconX + 20',correct
'iconX - 4',correct
'iconY',correct
'penguinA.moveByMouse();',correct
'bezier(golfX + 180, golfY - 50, golfX + 140, golfY - 65, golfX + 150, golfY - 40, golfX + 115, golfY - 50)',correct
'rect(bergX, bergY, 600, 20)',correct
'i = 0',correct
'{    if (iconY >= 200) {        if (kc == UP)            iconY = iconY - 20;    }    if (kc == DOWN)        iconY = iconY + 20;    if (kc == LEFT)        iconX = iconX - 20;    if (kc == RIGHT)        iconX = iconX + 20;}',correct
'Penguins[i] = new Penguin();',correct
'Golf() {    golfX = 20;    golfY = width / 2;}',correct
'ellipse(iconX - 4, iconY + 118, 200, 145);',correct
'iconX',correct
'ellipse(iconX, iconY - 50, 100, 100);',correct
'translate(-200, 0);',correct
'directionX *= -1',correct
'translate(-200, 0)',correct
'iconX + 50',correct
'bergX + 40',correct
'class Ijsberg_landschap {    int bergX;    int bergY;    Ijsberg_landschap() {        bergX = 0;        bergY = 200;    }    void display() {        noStroke();        background(0, 188, 255);        // The triangles and the rectangle are mountains//        fill(237, 243, 245);        triangle(bergX, bergY, bergX + 40, bergY - 100, bergX + 100, bergY);        triangle(bergX + 80, bergY, bergX + 130, bergY - 50, bergX + 180, bergY);        triangle(bergX + 150, bergY, bergX + 220, bergY - 150, bergX + 310, bergY);        triangle(bergX + 270, bergY, bergX + 340, bergY - 200, bergX + 420, bergY);        triangle(bergX + 300, bergY, bergX + 420, bergY - 160, bergX + 540, bergY);        triangle(bergX + 480, bergY, bergX + 540, bergY - 100, bergX + 600, bergY);        rect(bergX, bergY, 600, 20);    }}',correct
'stroke(255, 102, 0);',correct
'bergY - 150',correct
'Penguins[i].display();',correct
'translate(80, 0)',correct
'triangle(bergX + 80, bergY, bergX + 130, bergY - 50, bergX + 180, bergY);',correct
'iconX = width / 2',correct
'{    Penguins[i] = new Penguin();}',correct
'ellipse(iconX - 20, iconY - 65, 20, 25);',correct
'bergY - 50',correct
'golfX = golfX + 1',correct
'iconX + 42',correct
'golf = 1',correct
'iconX + 40',correct
'Penguin() {    iconX = width / 2;    iconY = height / 2;}',correct
'noStroke();',correct
'ijsberg_landschapA.display();',correct
'bergX + 100',correct
'speedY += (random(-0.1f, 0.1f))',correct
'iconX = iconX - 20;',correct
'penguinA.moveByKey(keyCode);',correct
'bezier(iconX - 50, iconY + 8, iconX - 85, iconY + 70, iconX - 85, iconY + 70, iconX - 50, iconY + 55);',correct
'bergX + 220',correct
'triangle(bergX + 480, bergY, bergX + 540, bergY - 100, bergX + 600, bergY)',correct
'bergY - 160',correct
'iconX + (speedX * directionX)',correct
'bergX + 340',correct
'bergX = 0;',correct
'void setup() {    golfA = new Golf();    penguinA = new Penguin();    ijsberg_landschapA = new Ijsberg_landschap();    for (int i = 0; i < Penguins.length; i++) {        Penguins[i] = new Penguin();    }}',correct
'if (mouseY >= 200) {    iconX = mouseX;    iconY = mouseY;}',correct
'iconY = iconY - 20',correct
'{    speedX += (random(-0.1f, 0.1f));    speedY += (random(-0.1f, 0.1f));    iconX = iconX + (speedX * directionX);    iconY = iconY + (speedY * directionY);    if (iconX > width) {        directionX *= -1;    }    if (iconX < 0) {        directionX *= -1;    }    if (iconY > height) {        directionY *= -1;    }    if (iconY < 200) {        directionY *= -1;    }}',correct
'Ijsberg_landschap ijsberg_landschapA;',correct
'penguinA = new Penguin();',correct
'ellipse(iconX - 20, iconY - 65, 10, 10);',correct
'iconX - 15',correct
'i < Penguins.length',correct
'golfY = width / 2',correct
'iconY - 50',correct
'penguinA.display();',correct
'golfX = 20',correct
'bergX + 310',correct
'class Penguin {    float iconX;    float iconY;    float speedX = random(-1, 1);    float speedY = random(-1, 1);    int directionX = 1;    int directionY = 1;    Penguin() {        iconX = width / 2;        iconY = height / 2;    }    void update() {        speedX += (random(-0.1f, 0.1f));        speedY += (random(-0.1f, 0.1f));        iconX = iconX + (speedX * directionX);        iconY = iconY + (speedY * directionY);        if (iconX > width) {            directionX *= -1;        }        if (iconX < 0) {            directionX *= -1;        }        if (iconY > height) {            directionY *= -1;        }        if (iconY < 200) {            directionY *= -1;        }    }    void moveByMouse() {        if (mouseY >= 200) {            iconX = mouseX;            iconY = mouseY;        }    }    void moveByKey(int kc) {        if (iconY >= 200) {            if (kc == UP)                iconY = iconY - 20;        }        if (kc == DOWN)            iconY = iconY + 20;        if (kc == LEFT)            iconX = iconX - 20;        if (kc == RIGHT)            iconX = iconX + 20;    }    void display() {        // this is the ice//        fill(116, 212, 255);        ellipse(iconX - 4, iconY + 124, 200, 150);        fill(213, 242, 255);        ellipse(iconX - 4, iconY + 118, 200, 145);        strokeWeight(0);        // main body and head//        fill(0, 0, 0);        ellipse(iconX, iconY + 50, 120, 150);        ellipse(iconX, iconY - 50, 100, 100);        // these are the belly and the eyes//        fill(255);        ellipse(iconX, iconY + 50, 90, 110);        ellipse(iconX + 20, iconY - 65, 20, 25);        ellipse(iconX - 20, iconY - 65, 20, 25);        // The pupils//        fill(100, 0, 255);        ellipse(iconX + 20, iconY - 65, 10, 10);        ellipse(iconX - 20, iconY - 65, 10, 10);        // These are the feet and the mouth//        fill(255, 180, 0);        triangle(iconX - 15, iconY - 50, iconX, iconY - 30, iconX + 15, iconY - 50);        triangle(iconX - 15, iconY + 124, iconX - 40, iconY + 105, iconX - 42, iconY + 130);        triangle(iconX + 15, iconY + 124, iconX + 40, iconY + 105, iconX + 42, iconY + 130);        fill(0);        stroke(255, 102, 0);        stroke(0, 0, 0);        bezier(iconX - 50, iconY + 8, iconX - 85, iconY + 70, iconX - 85, iconY + 70, iconX - 50, iconY + 55);        bezier(iconX + 50, iconY + 8, iconX + 85, iconY + 70, iconX + 85, iconY + 70, iconX + 50, iconY + 55);    }}',correct
'void draw() {    ijsberg_landschapA.display();    golfA.display();    penguinA.display();    for (int i = 0; i < Penguins.length; i++) {        Penguins[i].display();        Penguins[i].update();    }}',correct
'iconX = width / 2;',correct
'int bergY;',correct
'bezier(iconX - 50, iconY + 8, iconX - 85, iconY + 70, iconX - 85, iconY + 70, iconX - 50, iconY + 55)',correct
'{    bergX = 0;    bergY = 200;}',correct
'iconY = iconY + 20;',correct
'display',correct
'translate(-300, golfy);',correct
'speedY = random(-1, 1)',correct
'strokeWeight(0)',correct
'golfX = 20;',correct
'iconY - 65',correct
'{    ijsberg_landschapA.display();    golfA.display();    penguinA.display();    for (int i = 0; i < Penguins.length; i++) {        Penguins[i].display();        Penguins[i].update();    }}',correct
'for (int i = 0; i < Penguins.length; i++) {    Penguins[i].display();    Penguins[i].update();}',correct
'void keyPressed() {    if (key == CODED) {        penguinA.moveByKey(keyCode);    }}',correct
'if (golfX == 320) {    golfX = 0;}',correct
'{    golfX = 20;    golfY = width / 2;}',correct
'new Ijsberg_landschap()',correct
'ellipse(iconX + 20, iconY - 65, 20, 25)',correct
'random(-1, 1)',correct
'golfX = 0;',correct
'ellipse(iconX + 20, iconY - 65, 10, 10)',correct
'Penguin',correct
'i++',correct
'fill(116, 212, 255)',correct
'bergX + 80',correct
'iconY - 30',correct
'triangle(bergX + 480, bergY, bergX + 540, bergY - 100, bergX + 600, bergY);',correct
'{    noFill();    golfX = golfX + 1;    if (golfX == 320) {        golfX = 0;    }    strokeWeight(2);    stroke(116, 212, 255);    for (int golfy = 1; golfy <= height / 2; golfy = golfy + 30) {        // This makes the wave move        pushMatrix();        translate(-300, golfy);        translate(-200, 0);        for (int golf = 1; golf <= width; golf = golf + 50) {            // this is the code for the wave            translate(80, 0);            bezier(golfX + 180, golfY - 50, golfX + 140, golfY - 65, golfX + 150, golfY - 40, golfX + 115, golfY - 50);        }        popMatrix();    }}',correct
'ellipse(iconX - 4, iconY + 124, 200, 150);',correct
'golfX + 180',correct
'kc == LEFT',correct
'// this is the code for the wavetranslate(80, 0);',correct
'triangle(iconX - 15, iconY + 124, iconX - 40, iconY + 105, iconX - 42, iconY + 130)',correct
'stroke(116, 212, 255)',correct
'golfy <= height / 2',correct
'Penguins[i].update();',correct
'{    Penguins[i].display();    Penguins[i].update();}',correct
'void',correct
'if (iconX > width) {    directionX *= -1;}',correct
'-1',correct
'{    golfX = 0;}',correct
'for (int golfy = 1; golfy <= height / 2; golfy = golfy + 30) {    // This makes the wave move    pushMatrix();    translate(-300, golfy);    translate(-200, 0);    for (int golf = 1; golf <= width; golf = golf + 50) {        // this is the code for the wave        translate(80, 0);        bezier(golfX + 180, golfY - 50, golfX + 140, golfY - 65, golfX + 150, golfY - 40, golfX + 115, golfY - 50);    }    popMatrix();}',correct
'if (iconY >= 200) {    if (kc == UP)        iconY = iconY - 20;}',correct
'penguinA.moveByKey(keyCode)',correct
'void display() {    noStroke();    background(0, 188, 255);    // The triangles and the rectangle are mountains//    fill(237, 243, 245);    triangle(bergX, bergY, bergX + 40, bergY - 100, bergX + 100, bergY);    triangle(bergX + 80, bergY, bergX + 130, bergY - 50, bergX + 180, bergY);    triangle(bergX + 150, bergY, bergX + 220, bergY - 150, bergX + 310, bergY);    triangle(bergX + 270, bergY, bergX + 340, bergY - 200, bergX + 420, bergY);    triangle(bergX + 300, bergY, bergX + 420, bergY - 160, bergX + 540, bergY);    triangle(bergX + 480, bergY, bergX + 540, bergY - 100, bergX + 600, bergY);    rect(bergX, bergY, 600, 20);}',correct
'iconX > width',correct
'stroke(116, 212, 255);',correct
'iconX + 85',correct
'ellipse(iconX, iconY + 50, 90, 110);',correct
'// These are the feet and the mouth//fill(255, 180, 0);',correct
'bergX = 0',correct
'strokeWeight(2)',correct
'noFill();',correct
'bergX + 420',correct
'bergX + 540',correct
'iconX - 20',correct
'penguinA.moveByMouse()',correct
'bergX + 300',correct
'golfA',correct
'{    penguinA.moveByMouse();}',correct
'popMatrix()',correct
'// main body and head//fill(0, 0, 0);',correct
'fill(213, 242, 255)',correct
'iconX - 50',correct
'bergY - 200',correct
'directionY *= -1',correct
'penguinA = new Penguin()',correct
'directionX = 1',correct
'triangle(iconX + 15, iconY + 124, iconX + 40, iconY + 105, iconX + 42, iconY + 130);',correct
'float iconX;',correct
'golfX == 320',correct
'iconY + 70',correct
'float iconY;',correct
'{    if (kc == UP)        iconY = iconY - 20;}',correct
'Penguins = new Penguin[5]',correct
'golfy = 1',correct
'background(0, 188, 255);',correct
'iconY = height / 2',correct
'stroke(0, 0, 0);',correct
'Ijsberg_landschap',correct
'new Penguin()',correct
'Penguin[]',correct
'iconY > height',correct
'ijsberg_landschapA',correct
'golfY',correct
'golfX',correct
'iconX = mouseX',correct
'strokeWeight(0);',correct
'{    if (mouseY >= 200) {        iconX = mouseX;        iconY = mouseY;    }}',correct
'iconY - 20',correct
'Golf golfA;',correct
'width / 2',correct
'{    if (key == CODED) {        penguinA.moveByKey(keyCode);    }}',correct
'float speedX = random(-1, 1);',correct
'ijsberg_landschapA = new Ijsberg_landschap()',correct
'bergY - 100',correct
'for (int i = 0; i < Penguins.length; i++) {    Penguins[i] = new Penguin();}',correct
'iconX - 40',correct
'{    directionY *= -1;}',correct
'iconX - 42',correct
'new Golf()',correct
'bezier(iconX + 50, iconY + 8, iconX + 85, iconY + 70, iconX + 85, iconY + 70, iconX + 50, iconY + 55)',correct
'-ySpeed',correct
'eyeColor = color(0xffFF9F0D)',correct
'eyeColor = color(0xff25297C);',correct
'ySpeed',correct
'random(0, 255)',correct
'ySpeed = -ySpeed',correct
'catX + 70',correct
'g = 100;',correct
'text("Slow down", (width / 2) - 300, (height / 2) - 200)',correct
'random(50, width - 50)',correct
'height - 50',correct
'{    eyeColor = color(0xff25297C);}',correct
'// nosefill(noseColor);',correct
'mouseX >= width / 2',correct
'for (int i = 0; i < cats.length; i++) {    cats[i] = new Cat(random(50, width - 50), random(50, height - 50), random(0.000001f, 8), random(0.000001f, 8));}',correct
'PApplet.parseInt(random(0, 255))',correct
'eyeColor = color(0xffF72D99)',correct
'ySpeed = ySpeed * 2;',correct
'cats[i].updateFur()',correct
'catX - 25',correct
'updateFur',correct
'catX + 60 > width',correct
'catX - 20',correct
'fill(30)',correct
'g = 100',correct
'color(0xff25297C)',correct
'float catY;',correct
'background(255);',correct
'line(catX - 5, catY + 50, catX + 5, catY + 50);',correct
'b = 200',correct
'xSpeed = xSpeed * 2',correct
'ellipse(catX - 30, catY + 5, 5, 17);',correct
'// this part draws the catvoid body() {    // head    fill(furColor);    noStroke();    ellipse(catX, catY, 150, 120);    triangle(catX - 70, catY - 20, catX - 25, catY - 55, catX - 70, catY - 70);    triangle(catX + 70, catY - 20, catX + 25, catY - 55, catX + 70, catY - 70);    triangle(catX - 70, catY - 20, catX - 25, catY - 55, catX - 70, catY - 70);    triangle(catX + 70, catY - 20, catX + 25, catY - 55, catX + 70, catY - 70);    // eyes    fill(eyeColor);    ellipse(catX - 30, catY + 5, 35, 17);    ellipse(catX + 30, catY + 5, 35, 17);    fill(0);    ellipse(catX - 30, catY + 5, 5, 17);    ellipse(catX + 30, catY + 5, 5, 17);    // nose    fill(noseColor);    ellipse(catX, catY + 25, 25, 15);    // whiskers    stroke(20);    line(catX - 20, catY + 30, catX - 90, catY + 40);    line(catX - 20, catY + 25, catX - 90, catY + 25);    line(catX + 20, catY + 30, catX + 90, catY + 40);    line(catX + 20, catY + 25, catX + 90, catY + 25);    line(catX, catY + 35, catX, catY + 50);    line(catX - 5, catY + 50, catX + 5, catY + 50);}',correct
'eyeColor = color(0xffFF9F0D);',correct
'ySpeed = -ySpeed;',correct
'Cat[]',correct
'width - 50',correct
'// this program makes an array of cats that: move at random speed, bounce against the wall, slow down when you press on the top left side, speed up when you press on the top right side,',correct
'(width / 2) - 300',correct
'triangle(catX + 70, catY - 20, catX + 25, catY - 55, catX + 70, catY - 70);',correct
'ySpeed = ySpeed / 2;',correct
'fill(0);',correct
'cats.length',correct
'xSpeed / 2',correct
'catX - 30',correct
'ellipse(catX + 30, catY + 5, 5, 17);',correct
'catX + 90',correct
'Cat(float x, float y, float speedX, float speedY) {    r = 100;    g = 100;    b = 100;    furColor = color(r, g, b);    eyeColor = color(0xff9FF72D);    r = 30;    g = 100;    b = 200;    noseColor = color(b, r, g);    catX = x;    catY = y;    xSpeed = speedX;    ySpeed = speedY;}',correct
'g = PApplet.parseInt(random(0, 255))',correct
'catX + 60 > width || catX - 60 < 0',correct
'cats[i] = new Cat(random(50, width - 50), random(50, height - 50), random(0.000001f, 8), random(0.000001f, 8));',correct
'ySpeed = ySpeed / 2',correct
'b',correct
'g',correct
'noseColor = color(b, r, g)',correct
'r = 30',correct
'{    // head    fill(furColor);    noStroke();    ellipse(catX, catY, 150, 120);    triangle(catX - 70, catY - 20, catX - 25, catY - 55, catX - 70, catY - 70);    triangle(catX + 70, catY - 20, catX + 25, catY - 55, catX + 70, catY - 70);    triangle(catX - 70, catY - 20, catX - 25, catY - 55, catX - 70, catY - 70);    triangle(catX + 70, catY - 20, catX + 25, catY - 55, catX + 70, catY - 70);    // eyes    fill(eyeColor);    ellipse(catX - 30, catY + 5, 35, 17);    ellipse(catX + 30, catY + 5, 35, 17);    fill(0);    ellipse(catX - 30, catY + 5, 5, 17);    ellipse(catX + 30, catY + 5, 5, 17);    // nose    fill(noseColor);    ellipse(catX, catY + 25, 25, 15);    // whiskers    stroke(20);    line(catX - 20, catY + 30, catX - 90, catY + 40);    line(catX - 20, catY + 25, catX - 90, catY + 25);    line(catX + 20, catY + 30, catX + 90, catY + 40);    line(catX + 20, catY + 25, catX + 90, catY + 25);    line(catX, catY + 35, catX, catY + 50);    line(catX - 5, catY + 50, catX + 5, catY + 50);}',correct
'eyeColor = color(0xff9FF72D)',correct
'r',correct
'b = PApplet.parseInt(random(0, 255));',correct
'{    xSpeed = xSpeed * 2;    ySpeed = ySpeed * 2;}',correct
'textSize(30)',correct
'b = 100',correct
'{    cats[i] = new Cat(random(50, width - 50), random(50, height - 50), random(0.000001f, 8), random(0.000001f, 8));}',correct
'{    r = PApplet.parseInt(random(0, 255));    b = PApplet.parseInt(random(0, 255));    g = PApplet.parseInt(random(0, 255));    furColor = color(r, g, b);    noseColor = color(b, r, g);}',correct
'catX < (width / 4)',correct
'fill(furColor)',correct
'// Marloes Collewijn, s2135426 - 9/2018 /  10/2018',correct
'noStroke()',correct
'color(0xffFF9F0D)',correct
'cats[i] = new Cat(random(50, width - 50), random(50, height - 50), random(0.000001f, 8), random(0.000001f, 8))',correct
'catX = x;',correct
'if (mouseX >= width / 2) {    xSpeed = xSpeed * 2;    ySpeed = ySpeed * 2;} else if (mouseX < width / 2) {    xSpeed = xSpeed / 2;    ySpeed = ySpeed / 2;}',correct
'ySpeed / 2',correct
'new Cat(random(50, width - 50), random(50, height - 50), random(0.000001f, 8), random(0.000001f, 8))',correct
'ellipse(catX + 30, catY + 5, 35, 17)',correct
'{    for (int i = 0; i < cats.length; i++) {        if (mouseY >= width / 2) {            cats[i].updateFur();        } else if (mouseY < width / 2) {            cats[i].speedUp();        }    }}',correct
'void draw() {    background(255);    // this part adds text telling the user what you can do with the program    fill(30);    textSize(30);    text("Change colour", width / 2 - 100, height / 2 + 200);    text("Slow down", (width / 2) - 300, (height / 2) - 200);    text("Speed up", (width / 2) + 200, (height / 2) - 200);    // this draws the cats and establishes their eye color and standard speed    for (int i = 0; i < cats.length; i++) {        cats[i].speed();        cats[i].eyeColor();        cats[i].body();    }}',correct
'int furColor;',correct
'line(catX + 20, catY + 25, catX + 90, catY + 25);',correct
'eyeColor = color(0xff25297C)',correct
'int b;',correct
'float xSpeed;',correct
'if (catY - 50 < 0 || catY + 50 > height) {    ySpeed = -ySpeed;}',correct
'text("Change colour", width / 2 - 100, height / 2 + 200);',correct
'b = 200;',correct
'color(0xffF72D99)',correct
'mouseY < width / 2',correct
'// change fur and nose colour when you click on the lower half and change eyecolor depending on their horizontal position',correct
'color(r, g, b)',correct
'int r;',ShortVariable
'catY + ySpeed',correct
'class Cat {    int eyeColor;    int furColor;    int noseColor;    float catX;    float catY;    int r;    int b;    int g;    float xSpeed;    float ySpeed;    Cat(float x, float y, float speedX, float speedY) {        r = 100;        g = 100;        b = 100;        furColor = color(r, g, b);        eyeColor = color(0xff9FF72D);        r = 30;        g = 100;        b = 200;        noseColor = color(b, r, g);        catX = x;        catY = y;        xSpeed = speedX;        ySpeed = speedY;    }    // the next part determines the speed of the cat and that it bounces of the wall    void speed() {        catX = catX + xSpeed;        catY = catY + ySpeed;        if (catX + 60 > width || catX - 60 < 0) {            xSpeed = -xSpeed;        }        if (catY - 50 < 0 || catY + 50 > height) {            ySpeed = -ySpeed;        }    }    // this part makes the cat speed up if the mouse is on the right half and slow down when the mouse is on the left half.    void speedUp() {        if (mouseX >= width / 2) {            xSpeed = xSpeed * 2;            ySpeed = ySpeed * 2;        } else if (mouseX < width / 2) {            xSpeed = xSpeed / 2;            ySpeed = ySpeed / 2;        }    }    // the next part determines the eyecolour of the cat, based on its horizontal position    void eyeColor() {        if (catX < (width / 4)) {            eyeColor = color(0xffFF9F0D);        } else if (catX < (2 * (width / 4))) {            eyeColor = color(0xff9FF72D);        } else if (catX < (3 * (width / 4))) {            eyeColor = color(0xff25297C);        } else            eyeColor = color(0xffF72D99);    }    // this part draws the cat    void body() {        // head        fill(furColor);        noStroke();        ellipse(catX, catY, 150, 120);        triangle(catX - 70, catY - 20, catX - 25, catY - 55, catX - 70, catY - 70);        triangle(catX + 70, catY - 20, catX + 25, catY - 55, catX + 70, catY - 70);        triangle(catX - 70, catY - 20, catX - 25, catY - 55, catX - 70, catY - 70);        triangle(catX + 70, catY - 20, catX + 25, catY - 55, catX + 70, catY - 70);        // eyes        fill(eyeColor);        ellipse(catX - 30, catY + 5, 35, 17);        ellipse(catX + 30, catY + 5, 35, 17);        fill(0);        ellipse(catX - 30, catY + 5, 5, 17);        ellipse(catX + 30, catY + 5, 5, 17);        // nose        fill(noseColor);        ellipse(catX, catY + 25, 25, 15);        // whiskers        stroke(20);        line(catX - 20, catY + 30, catX - 90, catY + 40);        line(catX - 20, catY + 25, catX - 90, catY + 25);        line(catX + 20, catY + 30, catX + 90, catY + 40);        line(catX + 20, catY + 25, catX + 90, catY + 25);        line(catX, catY + 35, catX, catY + 50);        line(catX - 5, catY + 50, catX + 5, catY + 50);    }    // this part makes the fur change color when you click    void updateFur() {        r = PApplet.parseInt(random(0, 255));        b = PApplet.parseInt(random(0, 255));        g = PApplet.parseInt(random(0, 255));        furColor = color(r, g, b);        noseColor = color(b, r, g);    }}',correct
'new Cat[amount]',correct
'textSize(30);',correct
'fill(0)',correct
'height / 2',correct
'catX - 60',correct
'catY = catY + ySpeed',correct
'line(catX - 20, catY + 30, catX - 90, catY + 40)',correct
'"Speed up"',correct
'line(catX + 20, catY + 25, catX + 90, catY + 25)',correct
'catY = y;',correct
'furColor = color(r, g, b);',correct
'catY - 70',correct
'// this part makes the fur change color when you clickvoid updateFur() {    r = PApplet.parseInt(random(0, 255));    b = PApplet.parseInt(random(0, 255));    g = PApplet.parseInt(random(0, 255));    furColor = color(r, g, b);    noseColor = color(b, r, g);}',correct
'eyeColor = color(0xff9FF72D);',correct
'catY = y',correct
'color(b, r, g)',correct
'width / 2 - 100',correct
'{    background(255);    // this part adds text telling the user what you can do with the program    fill(30);    textSize(30);    text("Change colour", width / 2 - 100, height / 2 + 200);    text("Slow down", (width / 2) - 300, (height / 2) - 200);    text("Speed up", (width / 2) + 200, (height / 2) - 200);    // this draws the cats and establishes their eye color and standard speed    for (int i = 0; i < cats.length; i++) {        cats[i].speed();        cats[i].eyeColor();        cats[i].body();    }}',correct
'speed',correct
'cats[i].eyeColor()',correct
'background(255)',correct
'Processing',correct
'[amount]',correct
'catY + 50 > height',correct
'// this next part makes the cats change color when you press on the bottom half and the cats change speed when you press the top halfvoid mousePressed() {    for (int i = 0; i < cats.length; i++) {        if (mouseY >= width / 2) {            cats[i].updateFur();        } else if (mouseY < width / 2) {            cats[i].speedUp();        }    }}',correct
'float catX;',correct
'catX - 70',correct
'{    if (catX < (width / 4)) {        eyeColor = color(0xffFF9F0D);    } else if (catX < (2 * (width / 4))) {        eyeColor = color(0xff9FF72D);    } else if (catX < (3 * (width / 4))) {        eyeColor = color(0xff25297C);    } else        eyeColor = color(0xffF72D99);}',correct
'color(0xff9FF72D)',correct
'mouseY >= width / 2',correct
'cats[i].eyeColor();',correct
'triangle(catX - 70, catY - 20, catX - 25, catY - 55, catX - 70, catY - 70)',correct
'cats[i].body()',correct
'{    if (mouseY >= width / 2) {        cats[i].updateFur();    } else if (mouseY < width / 2) {        cats[i].speedUp();    }}',correct
'catY - 55',correct
'{    eyeColor = color(0xffFF9F0D);}',correct
'{    eyeColor = color(0xff9FF72D);}',correct
'noseColor',correct
'catY - 50 < 0',correct
'r = PApplet.parseInt(random(0, 255));',correct
'stroke(20)',correct
'catX + xSpeed',correct
'r = 100',correct
'line(catX - 20, catY + 25, catX - 90, catY + 25);',correct
'float ySpeed;',correct
'int i = 0',correct
'ellipseMode(CENTER);',correct
'ellipse(catX + 30, catY + 5, 35, 17);',correct
'catY - 50',correct
'// this part adds text telling the user what you can do with the programfill(30);',correct
'furColor',correct
'// this draws the cats and establishes their eye color and standard speedfor (int i = 0; i < cats.length; i++) {    cats[i].speed();    cats[i].eyeColor();    cats[i].body();}',correct
'i = 0',correct
'triangle(catX - 70, catY - 20, catX - 25, catY - 55, catX - 70, catY - 70);',correct
'// this part makes the cat speed up if the mouse is on the right half and slow down when the mouse is on the left half.void speedUp() {    if (mouseX >= width / 2) {        xSpeed = xSpeed * 2;        ySpeed = ySpeed * 2;    } else if (mouseX < width / 2) {        xSpeed = xSpeed / 2;        ySpeed = ySpeed / 2;    }}',correct
'catX = catX + xSpeed;',correct
'b = 100;',correct
'speedUp',correct
'r = PApplet.parseInt(random(0, 255))',correct
'cats[i].updateFur();',correct
'if (mouseX < width / 2) {    xSpeed = xSpeed / 2;    ySpeed = ySpeed / 2;}',correct
'text("Speed up", (width / 2) + 200, (height / 2) - 200);',correct
'b = PApplet.parseInt(random(0, 255))',correct
'catX - 5',correct
'int eyeColor;',correct
'xSpeed * 2',correct
'cats[i]',correct
'catX - 90',correct
'height / 2 + 200',correct
'-xSpeed',correct
'catY + 5',correct
'catY - 20',correct
'if (mouseY >= width / 2) {    cats[i].updateFur();} else if (mouseY < width / 2) {    cats[i].speedUp();}',correct
'// the next part determines the eyecolour of the cat, based on its horizontal positionvoid eyeColor() {    if (catX < (width / 4)) {        eyeColor = color(0xffFF9F0D);    } else if (catX < (2 * (width / 4))) {        eyeColor = color(0xff9FF72D);    } else if (catX < (3 * (width / 4))) {        eyeColor = color(0xff25297C);    } else        eyeColor = color(0xffF72D99);}',correct
'cats[i].speed();',correct
'xSpeed',correct
'r = 100;',correct
'text("Slow down", (width / 2) - 300, (height / 2) - 200);',correct
'xSpeed = speedX',correct
'text("Speed up", (width / 2) + 200, (height / 2) - 200)',correct
'noStroke();',correct
'ellipse(catX - 30, catY + 5, 35, 17);',correct
'cats = new Cat[amount]',correct
'{    ySpeed = -ySpeed;}',correct
'{    ellipseMode(CENTER);    for (int i = 0; i < cats.length; i++) {        cats[i] = new Cat(random(50, width - 50), random(50, height - 50), random(0.000001f, 8), random(0.000001f, 8));    }}',correct
'catY = catY + ySpeed;',correct
'i < cats.length',correct
'ySpeed = speedY',correct
'xSpeed = xSpeed / 2',correct
'if (catX + 60 > width || catX - 60 < 0) {    xSpeed = -xSpeed;}',correct
'float speedX',correct
'float speedY',correct
'xSpeed = -xSpeed',correct
'{    xSpeed = xSpeed / 2;    ySpeed = ySpeed / 2;}',correct
'eyeColor',correct
'{    xSpeed = -xSpeed;}',correct
'catX = x',correct
'{    cats[i].speedUp();}',correct
'{    cats[i].updateFur();}',correct
'noseColor = color(b, r, g);',correct
'"Change colour"',correct
'r = 30;',correct
'ySpeed = ySpeed * 2',correct
'if (mouseY < width / 2) {    cats[i].speedUp();}',correct
'draw',correct
'catX + 25',correct
'catX + 20',correct
'ellipse(catX, catY + 25, 25, 15);',correct
'catX',correct
'line(catX + 20, catY + 30, catX + 90, catY + 40)',correct
'catY',correct
'ySpeed = speedY;',correct
'{    r = 100;    g = 100;    b = 100;    furColor = color(r, g, b);    eyeColor = color(0xff9FF72D);    r = 30;    g = 100;    b = 200;    noseColor = color(b, r, g);    catX = x;    catY = y;    xSpeed = speedX;    ySpeed = speedY;}',correct
'line(catX - 20, catY + 25, catX - 90, catY + 25)',correct
'Cat[] cats = new Cat[amount];',correct
'i++',correct
'int noseColor;',correct
'catX + 5',correct
'furColor = color(r, g, b)',correct
'catX < (3 * (width / 4))',correct
'line(catX, catY + 35, catX, catY + 50)',correct
'body',correct
'catX + 30',correct
'catX = catX + xSpeed',correct
'mousePressed',correct
'triangle(catX + 70, catY - 20, catX + 25, catY - 55, catX + 70, catY - 70)',correct
'ellipseMode(CENTER)',correct
'text("Change colour", width / 2 - 100, height / 2 + 200)',correct
'xSpeed = -xSpeed;',correct
'// whiskersstroke(20);',correct
'// the next part determines the speed of the cat and that it bounces of the wallvoid speed() {    catX = catX + xSpeed;    catY = catY + ySpeed;    if (catX + 60 > width || catX - 60 < 0) {        xSpeed = -xSpeed;    }    if (catY - 50 < 0 || catY + 50 > height) {        ySpeed = -ySpeed;    }}',correct
'g = PApplet.parseInt(random(0, 255));',correct
'catY + 40',correct
'ellipse(catX + 30, catY + 5, 5, 17)',correct
'catY - 50 < 0 || catY + 50 > height',correct
'(width / 2) + 200',correct
'void',correct
'"Slow down"',correct
'{    catX = catX + xSpeed;    catY = catY + ySpeed;    if (catX + 60 > width || catX - 60 < 0) {        xSpeed = -xSpeed;    }    if (catY - 50 < 0 || catY + 50 > height) {        ySpeed = -ySpeed;    }}',correct
'ellipse(catX - 30, catY + 5, 35, 17)',correct
'if (catX < (3 * (width / 4))) {    eyeColor = color(0xff25297C);} else    eyeColor = color(0xffF72D99);',correct
'line(catX - 5, catY + 50, catX + 5, catY + 50)',correct
'void setup() {    ellipseMode(CENTER);    for (int i = 0; i < cats.length; i++) {        cats[i] = new Cat(random(50, width - 50), random(50, height - 50), random(0.000001f, 8), random(0.000001f, 8));    }}',correct
'mouseX < width / 2',correct
'fill(noseColor)',correct
'cats[i].body();',correct
'random(0.000001f, 8)',correct
'{    if (mouseX >= width / 2) {        xSpeed = xSpeed * 2;        ySpeed = ySpeed * 2;    } else if (mouseX < width / 2) {        xSpeed = xSpeed / 2;        ySpeed = ySpeed / 2;    }}',correct
'amount = 7',correct
'(height / 2) - 200',correct
'Cat',correct
'eyeColor = color(0xffF72D99);',IfElseStmtsMustUseBraces
'fill(eyeColor)',correct
'catY + 50',correct
'xSpeed = speedX;',correct
'ySpeed * 2',correct
'catX < (2 * (width / 4))',correct
'catY + 25',correct
'random(50, height - 50)',correct
'catX - 60 < 0',correct
'if (catX < (width / 4)) {    eyeColor = color(0xffFF9F0D);} else if (catX < (2 * (width / 4))) {    eyeColor = color(0xff9FF72D);} else if (catX < (3 * (width / 4))) {    eyeColor = color(0xff25297C);} else    eyeColor = color(0xffF72D99);',correct
'xSpeed = xSpeed * 2;',correct
'line(catX - 20, catY + 30, catX - 90, catY + 40);',correct
'// headfill(furColor);',correct
'for (int i = 0; i < cats.length; i++) {    if (mouseY >= width / 2) {        cats[i].updateFur();    } else if (mouseY < width / 2) {        cats[i].speedUp();    }}',correct
'{    cats[i].speed();    cats[i].eyeColor();    cats[i].body();}',correct
'cats[i].speedUp();',correct
'// eyesfill(eyeColor);',correct
'cats[i].speedUp()',correct
'cats[i].speed()',correct
'0.000001f',correct
'xSpeed = xSpeed / 2;',correct
'float x',correct
'float y',correct
'catY + 35',correct
'line(catX + 20, catY + 30, catX + 90, catY + 40);',correct
'ellipse(catX, catY, 150, 120)',correct
'// Marloes Collewijn, s2135426 - 9/2018 /  10/2018// this program makes an array of cats that: move at random speed, bounce against the wall, slow down when you press on the top left side, speed up when you press on the top right side,// change fur and nose colour when you click on the lower half and change eyecolor depending on their horizontal positionint amount = 7;',correct
'line(catX, catY + 35, catX, catY + 50);',correct
'catX + 60',correct
'ellipse(catX, catY + 25, 25, 15)',correct
'ellipse(catX, catY, 150, 120);',correct
'width / 2',correct
'if (catX < (2 * (width / 4))) {    eyeColor = color(0xff9FF72D);} else if (catX < (3 * (width / 4))) {    eyeColor = color(0xff25297C);} else    eyeColor = color(0xffF72D99);',correct
'int g;',ShortVariable
'catY + 30',correct
'ellipse(catX - 30, catY + 5, 5, 17)',correct
'// earfill(earColor);',correct
'random(width)',correct
'acceleration.add(f);',correct
'{    PVector gravity = new PVector(0, 0.1f * panda.mass);    panda.applyForce(gravity);    panda.display();    panda.update();    panda.bounce();}',correct
'onPanda = dist(panda.position.x, panda.position.y, mouseX, mouseY) < panda.mass / 2',correct
'float xPos = position.x',correct
'velocity.y *= -0.5f',correct
'rotate(0.5f);',correct
'boolean onPanda = dist(panda.position.x, panda.position.y, mouseX, mouseY) < panda.mass / 2;',correct
'',correct
'stroke(0)',correct
'earColor = color(xPos * 0.255f, yPos * 0.255f, (xPos + yPos) / 2)',correct
'ellipse(xPos - mass * 0.4f, yPos - mass * 0.3f, mass * 0.4f, mass * 0.4f)',correct
'pushMatrix();',correct
'velocity.add(acceleration)',correct
'void setup() {    reset();}',correct
'panda.position.y = mouseY;',correct
'0.020f',correct
'background(255);',correct
'acceleration = new PVector(0, 0);',correct
'float mass;',correct
'pandas = new Panda[10]',correct
'ellipse(xPos - mass * 0.15f, yPos - mass * 0.025f, mass * 0.075f, mass * 0.075f);',correct
'textSize(20)',correct
'yPos + mass * 0.275f',correct
'PVector gravity = new PVector(0, 0.1f * panda.mass)',correct
'fill(0);',correct
'ellipse(xPos, yPos, mass, mass)',correct
'/* Ear color depending on position */int earColor;',correct
'{    for (Panda panda : pandas) {        boolean onPanda = dist(panda.position.x, panda.position.y, mouseX, mouseY) < panda.mass / 2;        if (onPanda == true) {            panda.velocity.mult(0);            panda.position.x = mouseX;            panda.position.y = mouseY;        }    }}',correct
'panda.update()',correct
'0.275f',correct
'stroke(1);',correct
'ellipse(xPos + mass * 0.4f, yPos - mass * 0.3f, mass * 0.4f, mass * 0.4f);',correct
'ellipse(xPos, yPos, mass, mass);',correct
'void display() {    float xPos = position.x;    float yPos = position.y;    /* Ear color depending on position */    int earColor;    earColor = color(xPos * 0.255f, yPos * 0.255f, (xPos + yPos) / 2);    pushMatrix();    stroke(1);    strokeWeight(mass * 0.020f);    // ear    fill(earColor);    ellipse(xPos - mass * 0.4f, yPos - mass * 0.3f, mass * 0.4f, mass * 0.4f);    ellipse(xPos + mass * 0.4f, yPos - mass * 0.3f, mass * 0.4f, mass * 0.4f);    // face    fill(255);    ellipse(xPos, yPos, mass, mass);    // eyes    pushMatrix();    fill(0);    translate(xPos - mass * 0.25f, yPos);    rotate(0.5f);    ellipse(0, 0, mass * 0.3f, mass * 0.4f);    popMatrix();    pushMatrix();    translate(xPos + mass * 0.25f, yPos);    rotate(-0.5f);    ellipse(0, 0, mass * 0.3f, mass * 0.4f);    popMatrix();    fill(255);    noStroke();    ellipse(xPos + mass * 0.15f, yPos - mass * 0.025f, mass * 0.075f, mass * 0.075f);    ellipse(xPos - mass * 0.15f, yPos - mass * 0.025f, mass * 0.075f, mass * 0.075f);    // nose    fill(0);    ellipse(xPos, yPos + mass * 0.15f, mass * 0.2f, mass * 0.125f);    // mouth    stroke(0);    fill(255);    arc(xPos, yPos + mass * 0.275f, mass * 0.2f, mass * 0.15f, 0, PI);    popMatrix();}',correct
'popMatrix();',correct
'-0.5f',correct
'{    float xPos = position.x;    float yPos = position.y;    /* Ear color depending on position */    int earColor;    earColor = color(xPos * 0.255f, yPos * 0.255f, (xPos + yPos) / 2);    pushMatrix();    stroke(1);    strokeWeight(mass * 0.020f);    // ear    fill(earColor);    ellipse(xPos - mass * 0.4f, yPos - mass * 0.3f, mass * 0.4f, mass * 0.4f);    ellipse(xPos + mass * 0.4f, yPos - mass * 0.3f, mass * 0.4f, mass * 0.4f);    // face    fill(255);    ellipse(xPos, yPos, mass, mass);    // eyes    pushMatrix();    fill(0);    translate(xPos - mass * 0.25f, yPos);    rotate(0.5f);    ellipse(0, 0, mass * 0.3f, mass * 0.4f);    popMatrix();    pushMatrix();    translate(xPos + mass * 0.25f, yPos);    rotate(-0.5f);    ellipse(0, 0, mass * 0.3f, mass * 0.4f);    popMatrix();    fill(255);    noStroke();    ellipse(xPos + mass * 0.15f, yPos - mass * 0.025f, mass * 0.075f, mass * 0.075f);    ellipse(xPos - mass * 0.15f, yPos - mass * 0.025f, mass * 0.075f, mass * 0.075f);    // nose    fill(0);    ellipse(xPos, yPos + mass * 0.15f, mass * 0.2f, mass * 0.125f);    // mouth    stroke(0);    fill(255);    arc(xPos, yPos + mass * 0.275f, mass * 0.2f, mass * 0.15f, 0, PI);    popMatrix();}',LongMethodRule
'mass * 0.4f',correct
'float xPos = position.x;',correct
'PVector f = PVector.div(force, mass)',correct
'noStroke()',correct
'panda.velocity.mult(0)',correct
'pandas.length',correct
'float yPos = position.y;',correct
'key ==',correct
'onPanda == true',correct
'pandas[i] = new Panda(random(width), initHeight, pandaMass);',correct
'0.075f',correct
'acceleration',correct
'PVector position;',correct
'ellipse(xPos - mass * 0.4f, yPos - mass * 0.3f, mass * 0.4f, mass * 0.4f);',correct
'text("Press space to restart.", 50, 50)',correct
'xPos - mass * 0.4f',correct
'// eyespushMatrix();',correct
'boolean onPanda = dist(panda.position.x, panda.position.y, mouseX, mouseY) < panda.mass / 2',correct
'position.x',correct
'mass = m',correct
'position.y',correct
'xPos + mass * 0.4f',correct
'float initHeight = 50',correct
'/* initiate pandas array */void reset() {    for (int i = 0; i < pandas.length; i++) {        float initHeight = 50;        float pandaMass = random(40, 100);        pandas[i] = new Panda(random(width), initHeight, pandaMass);    }}',correct
'translate(xPos + mass * 0.25f, yPos)',correct
'translate(xPos + mass * 0.25f, yPos);',correct
'mass * 0.125f',correct
'fill(0)',correct
'reset();',correct
'(xPos + yPos) / 2',correct
'PVector velocity;',correct
'panda.update();',correct
'Panda(float x, float y, float m) {    /* mass = size */    mass = m;    position = new PVector(x, y);    velocity = new PVector(0, 0);    acceleration = new PVector(0, 0);}',correct
'0.15f',correct
'panda.display();',correct
'new PVector(0, 0)',correct
'new Panda(random(width), initHeight, pandaMass)',correct
'position.y > floorY',correct
'pandaMass = random(40, 100)',correct
'0.1f',correct
'mass',correct
'panda.position.y = mouseY',correct
'fill(255)',correct
'Processing',correct
'background(255)',correct
'textSize(20);',correct
'earColor',correct
'void applyForce(PVector force) {    PVector f = PVector.div(force, mass);    acceleration.add(f);}',correct
'dist(panda.position.x, panda.position.y, mouseX, mouseY)',correct
'pushMatrix()',correct
'"Press space to restart."',correct
'float floorY = height - mass / 2;',correct
'mass * 0.075f',correct
'{    for (int i = 0; i < pandas.length; i++) {        float initHeight = 50;        float pandaMass = random(40, 100);        pandas[i] = new Panda(random(width), initHeight, pandaMass);    }}',correct
'yPos = position.y',correct
'{    reset();}',correct
'0.1f * panda.mass',correct
'xPos + mass * 0.15f',correct
'0.2f',correct
'void draw() {    background(255);    fill(0);    textSize(20);    text("Press space to restart.", 50, 50);    for (Panda panda : pandas) {        PVector gravity = new PVector(0, 0.1f * panda.mass);        panda.applyForce(gravity);        panda.display();        panda.update();        panda.bounce();    }}',correct
'velocity = new PVector(0, 0);',correct
'pandas[i] = new Panda(random(width), initHeight, pandaMass)',correct
'int i = 0',correct
'translate(xPos - mass * 0.25f, yPos);',correct
'if (onPanda == true) {    panda.velocity.mult(0);    panda.position.x = mouseX;    panda.position.y = mouseY;}',SimplifyBooleanExpressions
'acceleration = new PVector(0, 0)',correct
'translate(xPos - mass * 0.25f, yPos)',correct
'ellipse(xPos + mass * 0.4f, yPos - mass * 0.3f, mass * 0.4f, mass * 0.4f)',correct
'f = PVector.div(force, mass)',correct
'i = 0',correct
'yPos * 0.255f',correct
'velocity = new PVector(0, 0)',correct
'0.3f',correct
'strokeWeight(mass * 0.020f);',correct
'float pandaMass = random(40, 100)',correct
'xPos * 0.255f',correct
'xPos = position.x',correct
'yPos - mass * 0.3f',correct
'arc(xPos, yPos + mass * 0.275f, mass * 0.2f, mass * 0.15f, 0, PI)',correct
'// facefill(255);',correct
'mass * 0.025f',correct
'{    panda.velocity.mult(0);    panda.position.x = mouseX;    panda.position.y = mouseY;}',correct
'acceleration.mult(0);',correct
'void bounce() {    float floorY = height - mass / 2;    if (position.y > floorY) {        velocity.y *= -0.5f;        position.y = floorY;    }}',correct
'new PVector(x, y)',correct
'color(xPos * 0.255f, yPos * 0.255f, (xPos + yPos) / 2)',correct
'xPos + mass * 0.25f',correct
'mass * 0.15f',correct
'0.4f',correct
'void update() {    velocity.add(acceleration);    position.add(velocity);    acceleration.mult(0);}',correct
'float initHeight = 50;',correct
'i < pandas.length',correct
'/* reset pandas when spacebar is placed */void keyPressed() {    if (key ==  ) {        reset();    }}',correct
'Panda[]',correct
'acceleration.add(f)',correct
'Panda panda',correct
'Panda',correct
'rotate(-0.5f)',correct
'velocity.y',correct
'PVector.div(force, mass)',correct
'arc(xPos, yPos + mass * 0.275f, mass * 0.2f, mass * 0.15f, 0, PI);',correct
'position = new PVector(x, y);',correct
'noStroke();',correct
'0.125f',correct
'earColor = color(xPos * 0.255f, yPos * 0.255f, (xPos + yPos) / 2);',correct
'for (Panda panda : pandas) {    boolean onPanda = dist(panda.position.x, panda.position.y, mouseX, mouseY) < panda.mass / 2;    if (onPanda == true) {        panda.velocity.mult(0);        panda.position.x = mouseX;        panda.position.y = mouseY;    }}',correct
'velocity.add(acceleration);',correct
'{    velocity.add(acceleration);    position.add(velocity);    acceleration.mult(0);}',correct
'panda.bounce();',correct
'{    /* mass = size */    mass = m;    position = new PVector(x, y);    velocity = new PVector(0, 0);    acceleration = new PVector(0, 0);}',correct
'/* set velocity of selected Panda to 0 and set position to mouse position */void mouseDragged() {    for (Panda panda : pandas) {        boolean onPanda = dist(panda.position.x, panda.position.y, mouseX, mouseY) < panda.mass / 2;        if (onPanda == true) {            panda.velocity.mult(0);            panda.position.x = mouseX;            panda.position.y = mouseY;        }    }}',correct
'// nosefill(0);',correct
'initHeight = 50',correct
'rotate(-0.5f);',correct
'pandas[i]',correct
'for (int i = 0; i < pandas.length; i++) {    float initHeight = 50;    float pandaMass = random(40, 100);    pandas[i] = new Panda(random(width), initHeight, pandaMass);}',correct
'0.5f',correct
'ellipse(0, 0, mass * 0.3f, mass * 0.4f)',correct
'float yPos = position.y',correct
'mass * 0.25f',correct
'float floorY = height - mass / 2',correct
'display',LongMethodRule
'panda.applyForce(gravity);',correct
'dist(panda.position.x, panda.position.y, mouseX, mouseY) < panda.mass / 2',correct
'random(40, 100)',correct
'new PVector(0, 0.1f * panda.mass)',correct
'{    boolean onPanda = dist(panda.position.x, panda.position.y, mouseX, mouseY) < panda.mass / 2;    if (onPanda == true) {        panda.velocity.mult(0);        panda.position.x = mouseX;        panda.position.y = mouseY;    }}',correct
'class Panda {    PVector position;    PVector velocity;    PVector acceleration;    float mass;    Panda(float x, float y, float m) {        /* mass = size */        mass = m;        position = new PVector(x, y);        velocity = new PVector(0, 0);        acceleration = new PVector(0, 0);    }    void applyForce(PVector force) {        PVector f = PVector.div(force, mass);        acceleration.add(f);    }    void update() {        velocity.add(acceleration);        position.add(velocity);        acceleration.mult(0);    }    void bounce() {        float floorY = height - mass / 2;        if (position.y > floorY) {            velocity.y *= -0.5f;            position.y = floorY;        }    }    void display() {        float xPos = position.x;        float yPos = position.y;        /* Ear color depending on position */        int earColor;        earColor = color(xPos * 0.255f, yPos * 0.255f, (xPos + yPos) / 2);        pushMatrix();        stroke(1);        strokeWeight(mass * 0.020f);        // ear        fill(earColor);        ellipse(xPos - mass * 0.4f, yPos - mass * 0.3f, mass * 0.4f, mass * 0.4f);        ellipse(xPos + mass * 0.4f, yPos - mass * 0.3f, mass * 0.4f, mass * 0.4f);        // face        fill(255);        ellipse(xPos, yPos, mass, mass);        // eyes        pushMatrix();        fill(0);        translate(xPos - mass * 0.25f, yPos);        rotate(0.5f);        ellipse(0, 0, mass * 0.3f, mass * 0.4f);        popMatrix();        pushMatrix();        translate(xPos + mass * 0.25f, yPos);        rotate(-0.5f);        ellipse(0, 0, mass * 0.3f, mass * 0.4f);        popMatrix();        fill(255);        noStroke();        ellipse(xPos + mass * 0.15f, yPos - mass * 0.025f, mass * 0.075f, mass * 0.075f);        ellipse(xPos - mass * 0.15f, yPos - mass * 0.025f, mass * 0.075f, mass * 0.075f);        // nose        fill(0);        ellipse(xPos, yPos + mass * 0.15f, mass * 0.2f, mass * 0.125f);        // mouth        stroke(0);        fill(255);        arc(xPos, yPos + mass * 0.275f, mass * 0.2f, mass * 0.15f, 0, PI);        popMatrix();    }}',correct
'panda.applyForce(gravity)',correct
'panda.display()',correct
'ellipse(xPos + mass * 0.15f, yPos - mass * 0.025f, mass * 0.075f, mass * 0.075f)',correct
'ellipse(xPos - mass * 0.15f, yPos - mass * 0.025f, mass * 0.075f, mass * 0.075f)',correct
'0.25f',correct
'yPos + mass * 0.15f',correct
'panda.bounce()',correct
'for (Panda panda : pandas) {    PVector gravity = new PVector(0, 0.1f * panda.mass);    panda.applyForce(gravity);    panda.display();    panda.update();    panda.bounce();}',correct
'panda',correct
'acceleration.mult(0)',correct
'PVector acceleration;',correct
'strokeWeight(mass * 0.020f)',correct
'i++',correct
'panda.mass',correct
'velocity.y *= -0.5f;',correct
'yPos - mass * 0.025f',correct
'fill(255);',correct
'position.y = floorY;',correct
'panda.position.x = mouseX',correct
'mass * 0.275f',correct
'mass * 0.3f',correct
'position = new PVector(x, y)',correct
'ellipse(xPos, yPos + mass * 0.15f, mass * 0.2f, mass * 0.125f)',correct
'{    velocity.y *= -0.5f;    position.y = floorY;}',correct
'{    PVector f = PVector.div(force, mass);    acceleration.add(f);}',correct
'if (position.y > floorY) {    velocity.y *= -0.5f;    position.y = floorY;}',correct
'position.add(velocity);',correct
'panda.position.y',correct
'void',correct
'xPos - mass * 0.25f',correct
'panda.position.x',correct
'mass * 0.2f',correct
'PVector gravity = new PVector(0, 0.1f * panda.mass);',correct
'floorY = height - mass / 2',correct
'new Panda[10]',correct
'panda.position',correct
'true',correct
'mass * 0.020f',correct
'position',correct
'{    float floorY = height - mass / 2;    if (position.y > floorY) {        velocity.y *= -0.5f;        position.y = floorY;    }}',correct
'stroke(1)',correct
'PVector',correct
'// mouthstroke(0);',correct
'popMatrix()',correct
'ellipse(xPos, yPos + mass * 0.15f, mass * 0.2f, mass * 0.125f);',correct
'int earColor',correct
'fill(earColor)',correct
'[10]',correct
'{    background(255);    fill(0);    textSize(20);    text("Press space to restart.", 50, 50);    for (Panda panda : pandas) {        PVector gravity = new PVector(0, 0.1f * panda.mass);        panda.applyForce(gravity);        panda.display();        panda.update();        panda.bounce();    }}',correct
'position.y = floorY',correct
'height - mass / 2',correct
'panda.position.x = mouseX;',correct
'0.025f',correct
'0.255f',correct
'position.add(velocity)',correct
'float pandaMass = random(40, 100);',correct
'ellipse(xPos + mass * 0.15f, yPos - mass * 0.025f, mass * 0.075f, mass * 0.075f);',correct
'panda.velocity',correct
'panda.mass / 2',correct
'PVector f = PVector.div(force, mass);',ShortVariable
'{    float initHeight = 50;    float pandaMass = random(40, 100);    pandas[i] = new Panda(random(width), initHeight, pandaMass);}',correct
'float x',correct
'float y',correct
'PVector force',correct
'gravity = new PVector(0, 0.1f * panda.mass)',correct
'mass / 2',correct
'if (key ==  ) {    reset();}',correct
'panda.velocity.mult(0);',correct
'velocity',correct
'/* mass = size */mass = m;',correct
'Panda[] pandas = new Panda[10];',correct
'xPos - mass * 0.15f',correct
'ellipse(0, 0, mass * 0.3f, mass * 0.4f);',correct
'reset()',correct
'float m',correct
'rotate(0.5f)',correct
'text("Press space to restart.", 50, 50);',PixelHardcodeIgnoranceRule
'{    if (key ==  ) {        reset();    }}',correct
'i = 0',correct
'if (y < -50) {    y = 575;}',correct
'bodyColor = backgroundColor;',correct
'ghosts[i].display()',correct
'isOverGhost = false',correct
'ghosts[i].update()',correct
'bodyColor = color(random(100, 255))',correct
'{    if (isOver(overX, overY)) {        bodyColor = backgroundColor;        // mouth        fill(bodyColor);        ellipse(x, y - 67.10f, 10, 5);    } else        bodyColor = color(230);}',correct
'if (pow(overX - x, 2) / (75 * 75) + pow(overY - y, 2) / (50 * 75) <= 1) {    isOverGhost = true;}',correct
'ghosts = new Ghost[10]',correct
'y + 37.5f',correct
'// bodyfill(bodyColor);',correct
'pow(overX - x, 2) / (75 * 75) + pow(overY - y, 2) / (50 * 75)',correct
'float overX',correct
'2.5f',correct
'float overY',correct
'i < ghosts.length',correct
'y = y - 1',correct
'x = overX;',correct
'x - 25',correct
'int backgroundColor;',correct
'rect(x - 30, y - 27.5f, 7.5f, 42.5f, 7.5f)',correct
'bodyColor = color(230);',IfElseStmtsMustUseBraces
'color(230)',correct
'pow(overY - y, 2) / (50 * 75)',correct
'background(backgroundColor)',correct
'y = overY;',correct
'{    x = overX;    y = overY;    bodyColor = color(random(100, 255));}',correct
'{    background(backgroundColor);    for (int i = 0; i < ghosts.length; i++) {        ghosts[i].display();        ghosts[i].update();        if (mousePressed) {            ghosts[i].bully(mouseX, mouseY);        }    }}',correct
'strokeWeight(5);',correct
'{    // auto-movement    y = y - 1;    if (y < -50) {        y = 575;    }}',correct
'ellipse(x, y - 67.10f, 10, 5)',correct
'void update() {    // auto-movement    y = y - 1;    if (y < -50) {        y = 575;    }}',correct
'noStroke();',correct
'67.10f',correct
'{    ghosts[i].display();    ghosts[i].update();    if (mousePressed) {        ghosts[i].bully(mouseX, mouseY);    }}',correct
'i * random(50, 75)',correct
'y - 80',correct
'// check if over ghostboolean isOver(float overX, float overY) {    boolean isOverGhost = false;    if (pow(overX - x, 2) / (75 * 75) + pow(overY - y, 2) / (50 * 75) <= 1) {        isOverGhost = true;    }    return isOverGhost;}',correct
'{    bodyColor = backgroundColor;    // mouth    fill(bodyColor);    ellipse(x, y - 67.10f, 10, 5);}',correct
'color(random(100, 255))',correct
'void draw() {    background(backgroundColor);    for (int i = 0; i < ghosts.length; i++) {        ghosts[i].display();        ghosts[i].update();        if (mousePressed) {            ghosts[i].bully(mouseX, mouseY);        }    }}',correct
'x - 30',correct
'backgroundColor = color(4, 231, 247)',correct
'background(backgroundColor);',correct
'float xspeed;',correct
'isOverGhost = true',correct
'stroke(bodyColor)',correct
'triangle(x - 25, y - 50, x, y + 37.5f, x + 25, y - 50)',correct
'new Ghost(i * random(50, 75), i * random(50, 75))',correct
'{    backgroundColor = color(4, 231, 247);    for (int i = 0; i < ghosts.length; i++) {        ghosts[i] = new Ghost(i * random(50, 75), i * random(50, 75));    }}',correct
'x - 7.5f',correct
'Ghost(float overX, float overY) {    x = overX;    y = overY;    bodyColor = color(random(100, 255));}',correct
'ellipse(x - 7.5f, y - 80, 5, 2.5f)',correct
'bully',correct
'{    boolean isOverGhost = false;    if (pow(overX - x, 2) / (75 * 75) + pow(overY - y, 2) / (50 * 75) <= 1) {        isOverGhost = true;    }    return isOverGhost;}',correct
'rectMode(CENTER)',correct
'overY - y',correct
'bodyColor = backgroundColor',correct
'backgroundColor',correct
'if (mousePressed) {    ghosts[i].bully(mouseX, mouseY);}',DecentralizedEventHandlingRule
'display',correct
'void display() {    ellipseMode(CENTER);    rectMode(CENTER);    // body    fill(bodyColor);    noStroke();    triangle(x - 25, y - 50, x, y + 37.5f, x + 25, y - 50);    // head    noFill();    stroke(bodyColor);    strokeWeight(5);    ellipse(x, y - 75, 37.5f, 37.5f);    strokeWeight(2);    ellipse(x - 7.5f, y - 80, 5, 2.5f);    ellipse(x + 7.5f, y - 80, 5, 2.5f);    // Leftarm    fill(bodyColor);    noStroke();    rect(x + 30, y - 27.5f, 7.5f, 42.5f, 7.5f);    // Rightarm    fill(bodyColor);    noStroke();    rect(x - 30, y - 27.5f, 7.5f, 42.5f, 7.5f);}',correct
'void setup() {    backgroundColor = color(4, 231, 247);    for (int i = 0; i < ghosts.length; i++) {        ghosts[i] = new Ghost(i * random(50, 75), i * random(50, 75));    }}',correct
'strokeWeight(2);',correct
'isOver(overX, overY)',correct
'yspeed',correct
'y - 1',correct
'for (int i = 0; i < ghosts.length; i++) {    ghosts[i].display();    ghosts[i].update();    if (mousePressed) {        ghosts[i].bully(mouseX, mouseY);    }}',correct
'37.5f',correct
'// headnoFill();',correct
'Ghost',correct
'random(100, 255)',correct
'y - 67.10f',correct
'x',correct
'y',correct
'rectMode(CENTER);',correct
'y = 575;',correct
'// changing colourvoid bully(float overX, float overY) {    if (isOver(overX, overY)) {        bodyColor = backgroundColor;        // mouth        fill(bodyColor);        ellipse(x, y - 67.10f, 10, 5);    } else        bodyColor = color(230);}',correct
'boolean isOverGhost = false;',correct
'float yspeed;',correct
'rect(x + 30, y - 27.5f, 7.5f, 42.5f, 7.5f)',correct
'noStroke()',correct
'xspeed',correct
'x + 30',correct
'-50',correct
'i++',correct
'return isOverGhost;',correct
'ellipseMode(CENTER)',correct
'overX - x',correct
'ellipse(x + 7.5f, y - 80, 5, 2.5f)',correct
'rect(x - 30, y - 27.5f, 7.5f, 42.5f, 7.5f);',correct
'x + 25',correct
'ghosts[i].bully(mouseX, mouseY)',correct
'ellipse(x + 7.5f, y - 80, 5, 2.5f);',correct
'pow(overY - y, 2)',correct
'{    isOverGhost = true;}',correct
'fill(bodyColor)',correct
'new Ghost[10]',correct
'void',correct
'y - 75',correct
'y - 27.5f',correct
'pow(overX - x, 2) / (75 * 75)',correct
'// interactive ghost creature. by Jorn Buse //<>//Ghost[] ghosts = new Ghost[10];',correct
'// mouthfill(bodyColor);',correct
'42.5f',correct
'Ghost[]',correct
'strokeWeight(2)',correct
'true',correct
'isOver',correct
'for (int i = 0; i < ghosts.length; i++) {    ghosts[i] = new Ghost(i * random(50, 75), i * random(50, 75));}',correct
'random(50, 75)',correct
'ghosts[i].update();',correct
'x = overX',correct
'27.5f',correct
'pow(overX - x, 2)',correct
'ellipse(x - 7.5f, y - 80, 5, 2.5f);',correct
'bodyColor',correct
'int bodyColor;',correct
'{    ellipseMode(CENTER);    rectMode(CENTER);    // body    fill(bodyColor);    noStroke();    triangle(x - 25, y - 50, x, y + 37.5f, x + 25, y - 50);    // head    noFill();    stroke(bodyColor);    strokeWeight(5);    ellipse(x, y - 75, 37.5f, 37.5f);    strokeWeight(2);    ellipse(x - 7.5f, y - 80, 5, 2.5f);    ellipse(x + 7.5f, y - 80, 5, 2.5f);    // Leftarm    fill(bodyColor);    noStroke();    rect(x + 30, y - 27.5f, 7.5f, 42.5f, 7.5f);    // Rightarm    fill(bodyColor);    noStroke();    rect(x - 30, y - 27.5f, 7.5f, 42.5f, 7.5f);}',correct
'ghosts[i]',correct
'// Rightarmfill(bodyColor);',correct
'rect(x + 30, y - 27.5f, 7.5f, 42.5f, 7.5f);',correct
'triangle(x - 25, y - 50, x, y + 37.5f, x + 25, y - 50);',correct
'float x;',correct
'update',correct
'[10]',correct
'{    ghosts[i].bully(mouseX, mouseY);}',correct
'ghosts[i] = new Ghost(i * random(50, 75), i * random(50, 75))',correct
'Processing',correct
'bodyColor = color(230)',correct
'// Leftarmfill(bodyColor);',correct
'y = 575',correct
'strokeWeight(5)',correct
'{    ghosts[i] = new Ghost(i * random(50, 75), i * random(50, 75));}',correct
'bodyColor = color(random(100, 255));',correct
'color(4, 231, 247)',correct
'// auto-movementy = y - 1;',correct
'ghosts[i] = new Ghost(i * random(50, 75), i * random(50, 75));',correct
'y - 50',correct
'pow(overX - x, 2) / (75 * 75) + pow(overY - y, 2) / (50 * 75) <= 1',correct
'noFill()',correct
'float y;',correct
'false',correct
'ellipse(x, y - 75, 37.5f, 37.5f)',correct
'class Ghost {    float x;    float y;    float xspeed;    float yspeed;    int bodyColor;    Ghost(float overX, float overY) {        x = overX;        y = overY;        bodyColor = color(random(100, 255));    }    void display() {        ellipseMode(CENTER);        rectMode(CENTER);        // body        fill(bodyColor);        noStroke();        triangle(x - 25, y - 50, x, y + 37.5f, x + 25, y - 50);        // head        noFill();        stroke(bodyColor);        strokeWeight(5);        ellipse(x, y - 75, 37.5f, 37.5f);        strokeWeight(2);        ellipse(x - 7.5f, y - 80, 5, 2.5f);        ellipse(x + 7.5f, y - 80, 5, 2.5f);        // Leftarm        fill(bodyColor);        noStroke();        rect(x + 30, y - 27.5f, 7.5f, 42.5f, 7.5f);        // Rightarm        fill(bodyColor);        noStroke();        rect(x - 30, y - 27.5f, 7.5f, 42.5f, 7.5f);    }    void update() {        // auto-movement        y = y - 1;        if (y < -50) {            y = 575;        }    }    // changing colour    void bully(float overX, float overY) {        if (isOver(overX, overY)) {            bodyColor = backgroundColor;            // mouth            fill(bodyColor);            ellipse(x, y - 67.10f, 10, 5);        } else            bodyColor = color(230);    }    // check if over ghost    boolean isOver(float overX, float overY) {        boolean isOverGhost = false;        if (pow(overX - x, 2) / (75 * 75) + pow(overY - y, 2) / (50 * 75) <= 1) {            isOverGhost = true;        }        return isOverGhost;    }}',correct
'ghosts.length',correct
'boolean isOverGhost = false',correct
'7.5f',correct
'int i = 0',correct
'ghosts[i].bully(mouseX, mouseY);',DecentralizedEventHandlingRule
'ellipseMode(CENTER);',correct
'boolean',correct
'y = overY',correct
'y < -50',correct
'x + 7.5f',correct
'ellipse(x, y - 75, 37.5f, 37.5f);',correct
'ghosts[i].display();',correct
'isOverGhost = true;',correct
'stroke(bodyColor);',correct
'{    y = 575;}',correct
'backgroundColor = color(4, 231, 247);',correct
'ellipse(x, y - 67.10f, 10, 5);',correct
'// armsfill(166, 83, 0);',correct
'float eyeSize;',correct
'dy = -dy;',correct
'fill(81, 211, 55);',correct
'random(1, 2)',correct
'dx > 0',correct
'ellipse(teddyX, teddyY, 100, 100);',correct
'ellipse(teddyX, teddyY + 100, 30, 30);',correct
'ellipse(teddyX, teddyY + 100, 50, 30);',correct
'line(teddyX, teddyY + 10, teddyX, teddyY + 30);',correct
'teddyY + 30',correct
'ellipse(cloudX, cloudY + 15, size, size)',correct
'if (dist(Xmouse, Ymouse, teddyX, teddyY) <= 50) {    fill(255, 255, 255);    ellipse(teddyX, teddyY + 100, 50, 30);    fill(255, 0, 0);    ellipse(teddyX, teddyY + 100, 30, 30);    fill(0, 0, 0);    ellipse(teddyX, teddyY + 100, 10, 10);    eyeSize = 20;    eyeColor = color(255, 0, 0);} else {    eyeSize = 5;}',correct
'dx = speedX',correct
'random(0, 60)',correct
'key == ENTER',correct
'ellipse(teddyX + 35, teddyY - 35, 15, 15);',correct
'float size;',correct
'// nose+mouthfill(166, 83, 0);',correct
'dy < 0',correct
'triangle(teddyX - 10, teddyY, teddyX, teddyY + 10, teddyX + 10, teddyY);',correct
'stroke(0)',correct
'dx = random(-3, 3);',correct
'teddyX - 60',correct
'teddyX - 80 < 0',correct
'ellipse(cloudX - 15, cloudY - 5, size, size)',correct
'{    if (key == ENTER) {        teddyX = width / 2;        teddyY = height / 2;        dx = random(-3, 3);        dy = random(-3, 3);    }}',correct
'fill(0, 0, 0)',correct
'teddyY += dy',correct
'if (teddyY + 170 > width && dy > 0) {    dy = -dy;}',correct
'// TeddyTeddy1.Display();',correct
'int Xmouse',correct
'eyeSize = initeyeSize',correct
'arc(teddyX, teddyY + 15, 30, 30, 0, PI);',correct
'ellipse(teddyX + 15, teddyY - 15, eyeSize, eyeSize);',correct
'size',correct
'teddyX = initX',correct
'teddyY - 50 < 0 && dy < 0',correct
'color(255, 0, 0)',correct
'{    dy = -dy;}',correct
'ellipse(teddyX - 30, teddyY + 150, 20, 20);',correct
'void move() {    teddyX += dx;    teddyY += dy;    if (teddyX + 80 > width && dx > 0) {        dx = -dx;    }    if (teddyY + 170 > width && dy > 0) {        dy = -dy;    }    if (teddyX - 80 < 0 && dx < 0) {        dx = -dx;    }    if (teddyY - 50 < 0 && dy < 0) {        dy = -dy;    }}',correct
'fill(255, 0, 0);',correct
'arc(teddyX, teddyY + 15, 30, 30, 0, PI)',correct
'random(100, 150)',correct
'50 + cloudDistance * i',correct
'if (cloudX > width + 70) {    cloudX = -40;}',correct
'teddyY - 50 < 0',correct
'ellipse(teddyX + 35, teddyY - 35, 30, 30)',correct
'ellipse(teddyX - 30, teddyY + 150, 20, 20)',correct
'line(teddyX - 25, teddyY + 100, teddyX + 25, teddyY + 100)',correct
'Teddy1.center()',correct
'height / 1.5f',correct
'// earsfill(233, 206, 116);',correct
'teddyY + 170 > width && dy > 0',correct
'teddyY + 10',correct
'ellipse(teddyX + 35, teddyY - 35, 30, 30);',correct
'// belly eyeline(teddyX - 25, teddyY + 100, teddyX + 25, teddyY + 100);',correct
'teddyY + 15',correct
'float initSize',correct
'ellipse(teddyX, teddyY + 100, 50, 30)',correct
'teddyX - 80',correct
'cloudY - 10',correct
'ellipse(cloudX, cloudY - 10, size, size)',correct
'float dx;',correct
'strokeWeight(2);',correct
'{    fill(255, 255, 255);    ellipse(teddyX, teddyY + 100, 50, 30);    fill(255, 0, 0);    ellipse(teddyX, teddyY + 100, 30, 30);    fill(0, 0, 0);    ellipse(teddyX, teddyY + 100, 10, 10);    eyeSize = 20;    eyeColor = color(255, 0, 0);}',correct
'{    // background    background(5, 231, 252);    noStroke();    fill(81, 211, 55);    rect(0, height / 1.5f, width, height / 3);    // Clouds    for (int i = 0; i < clouds.length; i++) {        clouds[i].display();        clouds[i].move();    }    // Teddy    Teddy1.Display();    Teddy1.faceOver(mouseX, mouseY);    Teddy1.move();    Teddy1.center();}',correct
'cloudX += dx;',correct
'void draw() {    // background    background(5, 231, 252);    noStroke();    fill(81, 211, 55);    rect(0, height / 1.5f, width, height / 3);    // Clouds    for (int i = 0; i < clouds.length; i++) {        clouds[i].display();        clouds[i].move();    }    // Teddy    Teddy1.Display();    Teddy1.faceOver(mouseX, mouseY);    Teddy1.move();    Teddy1.center();}',correct
'Teddy1',correct
'ellipse(cloudX - 40, cloudY + 15, size, size);',correct
'cloudHeight = random(0, 60)',correct
'ellipse(teddyX + 15, teddyY - 15, 2, 2);',correct
'noStroke()',correct
'Display',LongMethodRule
'cloudX - 40',correct
'size = initSize',correct
'ellipse(teddyX, teddyY + 100, 70, 70);',correct
'[6]',correct
'{    cloudX += dx;    if (cloudX > width + 70) {        cloudX = -40;    }}',correct
'Teddy1.move()',correct
'float initeyeSize',correct
'ellipse(cloudX + 15, cloudY + 15, size, size);',correct
'float dy;',correct
'float teddyY;',correct
'clouds = new Cloud[6]',correct
'dx < 0',correct
'ellipse(teddyX + 30, teddyY + 150, 40, 40);',correct
'{    cloudX = -40;}',correct
'dx',correct
'dy',correct
'class Teddy {    float teddyX;    float teddyY;    int eyeColor;    float eyeSize;    float dx;    float dy;    Teddy(float initX, float initY, float initeyeSize, float speedX, float speedY) {        teddyX = initX;        teddyY = initY;        eyeSize = initeyeSize;        dx = speedX;        dy = speedY;    }    void Display() {        // body        stroke(0);        strokeWeight(2);        fill(233, 206, 116);        ellipse(teddyX, teddyY + 80, 120, 150);        fill(249, 202, 119);        ellipse(teddyX, teddyY + 100, 70, 70);        // ears        fill(233, 206, 116);        ellipse(teddyX - 35, teddyY - 35, 30, 30);        ellipse(teddyX + 35, teddyY - 35, 30, 30);        fill(249, 202, 119);        ellipse(teddyX - 35, teddyY - 35, 15, 15);        ellipse(teddyX + 35, teddyY - 35, 15, 15);        // face        fill(233, 206, 116);        ellipse(teddyX, teddyY, 100, 100);        // nose+mouth        fill(166, 83, 0);        triangle(teddyX - 10, teddyY, teddyX, teddyY + 10, teddyX + 10, teddyY);        line(teddyX, teddyY + 10, teddyX, teddyY + 30);        noFill();        arc(teddyX, teddyY + 15, 30, 30, 0, PI);        // eyes        fill(eyeColor);        ellipse(teddyX - 15, teddyY - 15, eyeSize, eyeSize);        ellipse(teddyX + 15, teddyY - 15, eyeSize, eyeSize);        fill(255, 255, 255);        ellipse(teddyX - 15, teddyY - 15, 2, 2);        ellipse(teddyX + 15, teddyY - 15, 2, 2);        // legs        fill(166, 83, 0);        ellipse(teddyX + 30, teddyY + 150, 40, 40);        ellipse(teddyX - 30, teddyY + 150, 40, 40);        fill(233, 206, 116);        ellipse(teddyX + 30, teddyY + 150, 20, 20);        ellipse(teddyX - 30, teddyY + 150, 20, 20);        // arms        fill(166, 83, 0);        ellipse(teddyX + 60, teddyY + 70, 40, 40);        ellipse(teddyX - 60, teddyY + 70, 40, 40);        fill(233, 206, 116);        ellipse(teddyX + 60, teddyY + 70, 20, 20);        ellipse(teddyX - 60, teddyY + 70, 20, 20);        // belly eye        line(teddyX - 25, teddyY + 100, teddyX + 25, teddyY + 100);    }    void faceOver(int Xmouse, int Ymouse) {        if (dist(Xmouse, Ymouse, teddyX, teddyY) <= 50) {            fill(255, 255, 255);            ellipse(teddyX, teddyY + 100, 50, 30);            fill(255, 0, 0);            ellipse(teddyX, teddyY + 100, 30, 30);            fill(0, 0, 0);            ellipse(teddyX, teddyY + 100, 10, 10);            eyeSize = 20;            eyeColor = color(255, 0, 0);        } else {            eyeSize = 5;        }    }    void move() {        teddyX += dx;        teddyY += dy;        if (teddyX + 80 > width && dx > 0) {            dx = -dx;        }        if (teddyY + 170 > width && dy > 0) {            dy = -dy;        }        if (teddyX - 80 < 0 && dx < 0) {            dx = -dx;        }        if (teddyY - 50 < 0 && dy < 0) {            dy = -dy;        }    }    void center() {        if (keyPressed) {            if (key == ENTER) {                teddyX = width / 2;                teddyY = height / 2;                dx = random(-3, 3);                dy = random(-3, 3);            }        }    }}',correct
'new Cloud[6]',correct
'teddyY + 170 > width',correct
'ellipse(teddyX - 15, teddyY - 15, eyeSize, eyeSize)',correct
'{    // body    stroke(0);    strokeWeight(2);    fill(233, 206, 116);    ellipse(teddyX, teddyY + 80, 120, 150);    fill(249, 202, 119);    ellipse(teddyX, teddyY + 100, 70, 70);    // ears    fill(233, 206, 116);    ellipse(teddyX - 35, teddyY - 35, 30, 30);    ellipse(teddyX + 35, teddyY - 35, 30, 30);    fill(249, 202, 119);    ellipse(teddyX - 35, teddyY - 35, 15, 15);    ellipse(teddyX + 35, teddyY - 35, 15, 15);    // face    fill(233, 206, 116);    ellipse(teddyX, teddyY, 100, 100);    // nose+mouth    fill(166, 83, 0);    triangle(teddyX - 10, teddyY, teddyX, teddyY + 10, teddyX + 10, teddyY);    line(teddyX, teddyY + 10, teddyX, teddyY + 30);    noFill();    arc(teddyX, teddyY + 15, 30, 30, 0, PI);    // eyes    fill(eyeColor);    ellipse(teddyX - 15, teddyY - 15, eyeSize, eyeSize);    ellipse(teddyX + 15, teddyY - 15, eyeSize, eyeSize);    fill(255, 255, 255);    ellipse(teddyX - 15, teddyY - 15, 2, 2);    ellipse(teddyX + 15, teddyY - 15, 2, 2);    // legs    fill(166, 83, 0);    ellipse(teddyX + 30, teddyY + 150, 40, 40);    ellipse(teddyX - 30, teddyY + 150, 40, 40);    fill(233, 206, 116);    ellipse(teddyX + 30, teddyY + 150, 20, 20);    ellipse(teddyX - 30, teddyY + 150, 20, 20);    // arms    fill(166, 83, 0);    ellipse(teddyX + 60, teddyY + 70, 40, 40);    ellipse(teddyX - 60, teddyY + 70, 40, 40);    fill(233, 206, 116);    ellipse(teddyX + 60, teddyY + 70, 20, 20);    ellipse(teddyX - 60, teddyY + 70, 20, 20);    // belly eye    line(teddyX - 25, teddyY + 100, teddyX + 25, teddyY + 100);}',LongMethodRule
'ellipse(teddyX - 60, teddyY + 70, 40, 40);',correct
'clouds[i].move();',correct
'cloudX - 30',correct
'teddyX += dx',correct
'random(-3, 3)',correct
'teddyX = initX;',correct
'fill(81, 211, 55)',correct
'{    eyeSize = 5;}',correct
'// bodystroke(0);',correct
'float initdx',correct
'teddyY = initY;',correct
'float teddyX;',correct
'if (teddyX + 80 > width && dx > 0) {    dx = -dx;}',correct
'{    clouds[i].display();    clouds[i].move();}',correct
'class Cloud {    float cloudX;    float cloudY;    float size;    float dx;    Cloud(float initX, float initY, float initSize, float initdx) {        cloudX = initX;        cloudY = initY;        size = initSize;        dx = initdx;    }    void display() {        noStroke();        fill(255, 255, 255);        ellipse(cloudX, cloudY, size, size);        ellipse(cloudX + 15, cloudY + 15, size, size);        ellipse(cloudX, cloudY + 15, size, size);        ellipse(cloudX, cloudY - 10, size, size);        ellipse(cloudX - 15, cloudY + 15, size, size);        ellipse(cloudX - 15, cloudY - 5, size, size);        ellipse(cloudX - 30, cloudY, size, size);        ellipse(cloudX - 30, cloudY + 15, size, size);        ellipse(cloudX - 40, cloudY + 15, size, size);    }    void move() {        cloudX += dx;        if (cloudX > width + 70) {            cloudX = -40;        }    }}',correct
'cloudY + 15',correct
'ellipse(cloudX, cloudY + 15, size, size);',correct
'{    if (dist(Xmouse, Ymouse, teddyX, teddyY) <= 50) {        fill(255, 255, 255);        ellipse(teddyX, teddyY + 100, 50, 30);        fill(255, 0, 0);        ellipse(teddyX, teddyY + 100, 30, 30);        fill(0, 0, 0);        ellipse(teddyX, teddyY + 100, 10, 10);        eyeSize = 20;        eyeColor = color(255, 0, 0);    } else {        eyeSize = 5;    }}',correct
'height / 2',correct
'height / 3',correct
'float cloudHeight = random(0, 60);',correct
'Teddy(float initX, float initY, float initeyeSize, float speedX, float speedY) {    teddyX = initX;    teddyY = initY;    eyeSize = initeyeSize;    dx = speedX;    dy = speedY;}',correct
'Teddy1.center();',correct
'fill(166, 83, 0)',correct
'if (teddyY - 50 < 0 && dy < 0) {    dy = -dy;}',correct
'teddyX',correct
'line(teddyX, teddyY + 10, teddyX, teddyY + 30)',correct
'teddyY',correct
'float cloudY;',correct
'cloudX = -40;',correct
'width + 70',correct
'cloudX - 15',correct
'new Teddy(width / 2, width / 2, 5, random(-3, 3), random(-3, 3))',correct
'clouds[i].display();',correct
'if (keyPressed) {    if (key == ENTER) {        teddyX = width / 2;        teddyY = height / 2;        dx = random(-3, 3);        dy = random(-3, 3);    }}',DecentralizedEventHandlingRule
'Processing',correct
'eyeSize',correct
'Teddy1 = new Teddy(width / 2, width / 2, 5, random(-3, 3), random(-3, 3))',correct
'ellipse(teddyX - 60, teddyY + 70, 20, 20);',correct
'cloudHeight * i',correct
'void Display() {    // body    stroke(0);    strokeWeight(2);    fill(233, 206, 116);    ellipse(teddyX, teddyY + 80, 120, 150);    fill(249, 202, 119);    ellipse(teddyX, teddyY + 100, 70, 70);    // ears    fill(233, 206, 116);    ellipse(teddyX - 35, teddyY - 35, 30, 30);    ellipse(teddyX + 35, teddyY - 35, 30, 30);    fill(249, 202, 119);    ellipse(teddyX - 35, teddyY - 35, 15, 15);    ellipse(teddyX + 35, teddyY - 35, 15, 15);    // face    fill(233, 206, 116);    ellipse(teddyX, teddyY, 100, 100);    // nose+mouth    fill(166, 83, 0);    triangle(teddyX - 10, teddyY, teddyX, teddyY + 10, teddyX + 10, teddyY);    line(teddyX, teddyY + 10, teddyX, teddyY + 30);    noFill();    arc(teddyX, teddyY + 15, 30, 30, 0, PI);    // eyes    fill(eyeColor);    ellipse(teddyX - 15, teddyY - 15, eyeSize, eyeSize);    ellipse(teddyX + 15, teddyY - 15, eyeSize, eyeSize);    fill(255, 255, 255);    ellipse(teddyX - 15, teddyY - 15, 2, 2);    ellipse(teddyX + 15, teddyY - 15, 2, 2);    // legs    fill(166, 83, 0);    ellipse(teddyX + 30, teddyY + 150, 40, 40);    ellipse(teddyX - 30, teddyY + 150, 40, 40);    fill(233, 206, 116);    ellipse(teddyX + 30, teddyY + 150, 20, 20);    ellipse(teddyX - 30, teddyY + 150, 20, 20);    // arms    fill(166, 83, 0);    ellipse(teddyX + 60, teddyY + 70, 40, 40);    ellipse(teddyX - 60, teddyY + 70, 40, 40);    fill(233, 206, 116);    ellipse(teddyX + 60, teddyY + 70, 20, 20);    ellipse(teddyX - 60, teddyY + 70, 20, 20);    // belly eye    line(teddyX - 25, teddyY + 100, teddyX + 25, teddyY + 100);}',correct
'cloudY = initY',correct
'eyeSize = initeyeSize;',correct
'ellipse(teddyX - 35, teddyY - 35, 15, 15);',correct
'float cloudX;',correct
'if (key == ENTER) {    teddyX = width / 2;    teddyY = height / 2;    dx = random(-3, 3);    dy = random(-3, 3);}',DecentralizedEventHandlingRule
'noFill()',correct
'teddyX += dx;',correct
'Cloud[]',correct
'dx = -dx;',correct
'i < clouds.length',correct
'dx = random(-3, 3)',correct
'ellipse(cloudX, cloudY, size, size)',correct
'int i = 0',correct
'ellipse(teddyX - 30, teddyY + 150, 40, 40);',correct
'teddyY = initY',correct
'ellipse(teddyX + 60, teddyY + 70, 40, 40);',correct
'teddyX + 15',correct
'teddyX + 80 > width && dx > 0',correct
'ellipse(cloudX - 15, cloudY + 15, size, size);',correct
'teddyX + 10',correct
'teddyX + 80 > width',correct
'ellipse(cloudX - 15, cloudY + 15, size, size)',correct
'i = 0',correct
'if (teddyX - 80 < 0 && dx < 0) {    dx = -dx;}',correct
'cloudX = -40',correct
'Teddy',correct
'ellipse(teddyX, teddyY + 100, 30, 30)',correct
'{    Teddy1 = new Teddy(width / 2, width / 2, 5, random(-3, 3), random(-3, 3));    for (int i = 0; i < clouds.length; i++) {        float cloudDistance = random(100, 150);        float cloudHeight = random(0, 60);        clouds[i] = new Cloud(50 + cloudDistance * i, 60 + cloudHeight * i, 40, random(1, 2));    }}',correct
'teddyY + 150',correct
'// legsfill(166, 83, 0);',correct
'int eyeColor;',correct
'ellipse(cloudX - 30, cloudY + 15, size, size)',correct
'dy = random(-3, 3)',correct
'fill(255, 255, 255);',correct
'teddyX + 25',correct
'dy = -dy',correct
'cloudX += dx',correct
'Cloud[] clouds = new Cloud[6];',correct
'cloudX > width + 70',correct
'cloudY - 5',correct
'ellipse(teddyX + 60, teddyY + 70, 20, 20);',correct
'ellipse(teddyX, teddyY + 80, 120, 150)',correct
'{    teddyX = width / 2;    teddyY = height / 2;    dx = random(-3, 3);    dy = random(-3, 3);}',correct
'ellipse(cloudX + 15, cloudY + 15, size, size)',correct
'eyeSize = 20',correct
'cloudX = initX',correct
'teddyX = width / 2',correct
'float cloudHeight = random(0, 60)',correct
'{    teddyX = initX;    teddyY = initY;    eyeSize = initeyeSize;    dx = speedX;    dy = speedY;}',correct
'noStroke();',correct
'clouds[i] = new Cloud(50 + cloudDistance * i, 60 + cloudHeight * i, 40, random(1, 2));',correct
'ellipse(teddyX + 60, teddyY + 70, 40, 40)',correct
'clouds[i].display()',correct
'teddyX + 35',correct
'teddyX + 30',correct
'ellipse(teddyX - 35, teddyY - 35, 30, 30);',correct
'eyeColor = color(255, 0, 0)',correct
'teddyY + 170',correct
'teddyX = width / 2;',correct
'teddyY = height / 2;',correct
'float speedX',correct
'float speedY',correct
'ellipse(teddyX - 60, teddyY + 70, 20, 20)',correct
'ellipse(teddyX + 60, teddyY + 70, 20, 20)',correct
'void faceOver(int Xmouse, int Ymouse) {    if (dist(Xmouse, Ymouse, teddyX, teddyY) <= 50) {        fill(255, 255, 255);        ellipse(teddyX, teddyY + 100, 50, 30);        fill(255, 0, 0);        ellipse(teddyX, teddyY + 100, 30, 30);        fill(0, 0, 0);        ellipse(teddyX, teddyY + 100, 10, 10);        eyeSize = 20;        eyeColor = color(255, 0, 0);    } else {        eyeSize = 5;    }}',VariableNamingConventions
'ellipse(cloudX - 30, cloudY + 15, size, size);',correct
'teddyY - 35',correct
'clouds.length',correct
'dist(Xmouse, Ymouse, teddyX, teddyY)',correct
'eyeSize = 5;',correct
'eyeColor',correct
'ellipse(cloudX - 30, cloudY, size, size);',correct
'ellipse(cloudX - 30, cloudY, size, size)',correct
'ellipse(teddyX - 35, teddyY - 35, 30, 30)',correct
'int Ymouse',correct
'ellipse(teddyX + 15, teddyY - 15, eyeSize, eyeSize)',correct
'Teddy1.faceOver(mouseX, mouseY)',correct
'ellipse(teddyX + 30, teddyY + 150, 20, 20);',correct
'teddyX + 60',correct
'eyeSize = 20;',correct
'rect(0, height / 1.5f, width, height / 3);',PixelHardcodeIgnoranceRule
'fill(233, 206, 116)',correct
'teddyY - 50',correct
'-40',correct
'{    if (keyPressed) {        if (key == ENTER) {            teddyX = width / 2;            teddyY = height / 2;            dx = random(-3, 3);            dy = random(-3, 3);        }    }}',correct
'draw',correct
'{    cloudX = initX;    cloudY = initY;    size = initSize;    dx = initdx;}',correct
'ellipse(teddyX, teddyY + 100, 10, 10)',correct
'dx = -dx',correct
'dx = speedX;',correct
'ellipse(teddyX - 15, teddyY - 15, eyeSize, eyeSize);',correct
'{    noStroke();    fill(255, 255, 255);    ellipse(cloudX, cloudY, size, size);    ellipse(cloudX + 15, cloudY + 15, size, size);    ellipse(cloudX, cloudY + 15, size, size);    ellipse(cloudX, cloudY - 10, size, size);    ellipse(cloudX - 15, cloudY + 15, size, size);    ellipse(cloudX - 15, cloudY - 5, size, size);    ellipse(cloudX - 30, cloudY, size, size);    ellipse(cloudX - 30, cloudY + 15, size, size);    ellipse(cloudX - 40, cloudY + 15, size, size);}',correct
'-dx',correct
'-dy',correct
'cloudY = initY;',correct
'fill(255, 0, 0)',correct
'{    teddyX += dx;    teddyY += dy;    if (teddyX + 80 > width && dx > 0) {        dx = -dx;    }    if (teddyY + 170 > width && dy > 0) {        dy = -dy;    }    if (teddyX - 80 < 0 && dx < 0) {        dx = -dx;    }    if (teddyY - 50 < 0 && dy < 0) {        dy = -dy;    }}',correct
'background(5, 231, 252)',correct
'cloudX + 15',correct
'float initX',correct
'ellipse(cloudX - 40, cloudY + 15, size, size)',correct
'ellipse(teddyX - 60, teddyY + 70, 40, 40)',correct
'float initY',correct
'i++',correct
'void move() {    cloudX += dx;    if (cloudX > width + 70) {        cloudX = -40;    }}',correct
'teddyY += dy;',correct
'Teddy1.faceOver(mouseX, mouseY);',DecentralizedEventHandlingRule
'ellipse(teddyX, teddyY + 100, 70, 70)',correct
'void setup() {    Teddy1 = new Teddy(width / 2, width / 2, 5, random(-3, 3), random(-3, 3));    for (int i = 0; i < clouds.length; i++) {        float cloudDistance = random(100, 150);        float cloudHeight = random(0, 60);        clouds[i] = new Cloud(50 + cloudDistance * i, 60 + cloudHeight * i, 40, random(1, 2));    }}',correct
'teddyY + 80',correct
'teddyY - 15',correct
'Cloud(float initX, float initY, float initSize, float initdx) {    cloudX = initX;    cloudY = initY;    size = initSize;    dx = initdx;}',correct
'cloudX = initX;',correct
'ellipse(teddyX, teddyY, 100, 100)',correct
'fill(255, 255, 255)',correct
'dy > 0',correct
'dist(Xmouse, Ymouse, teddyX, teddyY) <= 50',correct
'{    float cloudDistance = random(100, 150);    float cloudHeight = random(0, 60);    clouds[i] = new Cloud(50 + cloudDistance * i, 60 + cloudHeight * i, 40, random(1, 2));}',correct
'void',correct
'ellipse(teddyX + 30, teddyY + 150, 20, 20)',correct
'ellipse(teddyX - 15, teddyY - 15, 2, 2)',correct
'teddyX + 80',correct
'-3',correct
'clouds[i] = new Cloud(50 + cloudDistance * i, 60 + cloudHeight * i, 40, random(1, 2))',correct
'size = initSize;',correct
'cloudDistance * i',correct
'teddyY + 100',correct
'for (int i = 0; i < clouds.length; i++) {    float cloudDistance = random(100, 150);    float cloudHeight = random(0, 60);    clouds[i] = new Cloud(50 + cloudDistance * i, 60 + cloudHeight * i, 40, random(1, 2));}',correct
'ellipse(teddyX, teddyY + 100, 10, 10);',correct
'// backgroundbackground(5, 231, 252);',correct
'dy = speedY;',correct
'// facefill(233, 206, 116);',correct
'eyeColor = color(255, 0, 0);',correct
'clouds[i]',correct
'Teddy Teddy1;',correct
'ellipse(teddyX - 30, teddyY + 150, 40, 40)',correct
'strokeWeight(2)',correct
'noFill();',correct
'fill(249, 202, 119)',correct
'1.5f',correct
'teddyX - 15',correct
'ellipse(cloudX, cloudY, size, size);',correct
'fill(eyeColor)',correct
'Teddy1.Display()',correct
'teddyX - 10',correct
'new Cloud(50 + cloudDistance * i, 60 + cloudHeight * i, 40, random(1, 2))',correct
'fill(233, 206, 116);',correct
'dy = speedY',correct
'ellipse(teddyX - 35, teddyY - 35, 15, 15)',correct
'teddyX - 80 < 0 && dx < 0',correct
'fill(249, 202, 119);',correct
'fill(0, 0, 0);',correct
'ellipse(teddyX + 35, teddyY - 35, 15, 15)',correct
'triangle(teddyX - 10, teddyY, teddyX, teddyY + 10, teddyX + 10, teddyY)',correct
'Teddy1 = new Teddy(width / 2, width / 2, 5, random(-3, 3), random(-3, 3));',correct
'60 + cloudHeight * i',correct
'cloudY',correct
'cloudDistance = random(100, 150)',correct
'// eyesfill(eyeColor);',correct
'cloudX',correct
'// Cloudsfor (int i = 0; i < clouds.length; i++) {    clouds[i].display();    clouds[i].move();}',correct
'teddyX - 25',correct
'rect(0, height / 1.5f, width, height / 3)',correct
'ellipse(teddyX - 15, teddyY - 15, 2, 2);',correct
'clouds[i].move()',correct
'void display() {    noStroke();    fill(255, 255, 255);    ellipse(cloudX, cloudY, size, size);    ellipse(cloudX + 15, cloudY + 15, size, size);    ellipse(cloudX, cloudY + 15, size, size);    ellipse(cloudX, cloudY - 10, size, size);    ellipse(cloudX - 15, cloudY + 15, size, size);    ellipse(cloudX - 15, cloudY - 5, size, size);    ellipse(cloudX - 30, cloudY, size, size);    ellipse(cloudX - 30, cloudY + 15, size, size);    ellipse(cloudX - 40, cloudY + 15, size, size);}',correct
'dx = initdx',correct
'ellipse(teddyX + 15, teddyY - 15, 2, 2)',correct
'float cloudDistance = random(100, 150);',correct
'void center() {    if (keyPressed) {        if (key == ENTER) {            teddyX = width / 2;            teddyY = height / 2;            dx = random(-3, 3);            dy = random(-3, 3);        }    }}',correct
'eyeSize = 5',correct
'teddyY = height / 2',correct
'ellipse(teddyX + 30, teddyY + 150, 40, 40)',correct
'teddyY + 70',correct
'Teddy1.move();',correct
'width / 2',correct
'dy = random(-3, 3);',correct
'dx = initdx;',correct
'ellipse(cloudX, cloudY - 10, size, size);',correct
'ellipse(cloudX - 15, cloudY - 5, size, size);',correct
'Cloud',correct
'{    dx = -dx;}',correct
'float cloudDistance = random(100, 150)',correct
'teddyX - 35',correct
'ellipse(teddyX, teddyY + 80, 120, 150);',correct
'teddyX - 30',correct
'skyAutumn = color(18, 98, 226)',correct
'bearY - 60',correct
'dy = -dy;',correct
'bear11.changeColorBack();',correct
'Hunny[] hunnys = new Hunny[1];',correct
'ellipse(bearX, bearY + 20, size3, size3)',correct
'// legsfill(bearColor);',correct
'{    treeX = initX;    treeY = initY;    trunkColor = color(76, 69, 4);    leafColor = color(0, 132, 22);    leafSpring = color(0, 132, 22);    leafAutumn = color(226, 117, 0);}',correct
'bear9.display();',correct
'ellipse(bearX - 50, bearY - 90, size2, size2);',correct
'bear10 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));',correct
'bear9.changeColorBack()',correct
'class Bear {    float bearX;    float bearY;    float dx = random(2, 5);    float dy = random(2, 5);    float size1 = 120;    float size2 = 40;    float size3 = 70;    float size4 = 20;    float size5 = 15;    int bearColor;    int bearColor2;    int bodyColor;    int bodyColor2;    Bear(float initX, float initY) {        bearX = initX;        bearY = initY;        bearColor = color(160, 82, 45);        bearColor2 = color(205, 133, 63);        bodyColor = color(160, 82, 45);        bodyColor2 = color(205, 133, 63);    }    void display() {        // legs        fill(bearColor);        ellipse(bearX - 25, bearY + 80, size2, size3);        ellipse(bearX + 25, bearY + 80, size2, size3);        // body        fill(bearColor);        ellipse(bearX, bearY + 20, size1, size1);        fill(bearColor2);        ellipse(bearX, bearY + 20, size3, size3);        // head        fill(bearColor);        ellipse(bearX, bearY - 60, size1, 90);        // snout        fill(255, 182, 193);        arc(bearX, bearY - 37, size5, size5, 0, PI, CHORD);        fill(bearColor2);        ellipse(bearX, bearY - 45, size2, size4);        fill(0, 0, 0);        ellipse(bearX, bearY - 50, size5, 10);        // eyes        fill(255);        ellipse(bearX - 20, bearY - 70, size4, 25);        ellipse(bearX + 20, bearY - 70, size4, 25);        fill(0);        ellipse(bearX - 20, bearY - 70, size5, size5);        ellipse(bearX + 20, bearY - 70, size5, size5);        // ears        fill(bearColor);        noStroke();        ellipse(bearX - 50, bearY - 90, size2, size2);        ellipse(bearX + 50, bearY - 90, size2, size2);        fill(bearColor2);        arc(bearX - 50, bearY - 90, size4, size4, HALF_PI, 2 * PI, CHORD);        arc(bearX + 50, bearY - 90, size4, size4, -PI, PI - HALF_PI, CHORD);        // arms        fill(bearColor);        pushMatrix();        translate(bearX - 75, bearY + 20);        rotate(PI / 10.0f);        ellipse(0, 0, 35, size3);        popMatrix();        pushMatrix();        translate(bearX + 75, bearY + 20);        rotate(-PI / 10.0f);        ellipse(0, 0, 35, size3);        popMatrix();    }    void switchColors() {        bearColor = color(bodyColor2);        bearColor2 = color(bodyColor);    }    void changeToBlack() {        bearColor = color(0);        bearColor2 = color(255);    }    void changeToYellow() {        bearColor = color(0, 0, 255);        bearColor2 = color(255, 255, 0);    }    void changeColorBack() {        bearColor = color(bodyColor);        bearColor2 = color(bodyColor2);    }    void move() {        bearX = bearX + dx;        if (bearX > width - 95 && dx > 0 || (bearX < 95)) {            dx = -dx;        }        bearY = bearY + dy;        if ((bearY > height - 110 && dy > 0) || (bearY < 110)) {            dy = -dy;        }    }}',correct
'bear5 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));',correct
'hunnyX - 20',correct
'fill(skyColor)',correct
'hunnys = new Hunny[1]',correct
'hunnyY + 5',correct
'float hunnyX;',correct
'bear5.changeColorBack();',correct
'cloudX - 70',correct
'bear5.display()',correct
'rect(450, 800, 900, 200)',correct
'bear7.move();',correct
'ellipse(bearX - 20, bearY - 70, size5, size5)',correct
'bear14',correct
'if (key == b) {    bear2.changeToBlack();    bear5.changeToBlack();    bear8.changeToBlack();    bear11.changeToBlack();    bear14.changeToBlack();}',correct
'bear13',correct
'{    // legs    fill(bearColor);    ellipse(bearX - 25, bearY + 80, size2, size3);    ellipse(bearX + 25, bearY + 80, size2, size3);    // body    fill(bearColor);    ellipse(bearX, bearY + 20, size1, size1);    fill(bearColor2);    ellipse(bearX, bearY + 20, size3, size3);    // head    fill(bearColor);    ellipse(bearX, bearY - 60, size1, 90);    // snout    fill(255, 182, 193);    arc(bearX, bearY - 37, size5, size5, 0, PI, CHORD);    fill(bearColor2);    ellipse(bearX, bearY - 45, size2, size4);    fill(0, 0, 0);    ellipse(bearX, bearY - 50, size5, 10);    // eyes    fill(255);    ellipse(bearX - 20, bearY - 70, size4, 25);    ellipse(bearX + 20, bearY - 70, size4, 25);    fill(0);    ellipse(bearX - 20, bearY - 70, size5, size5);    ellipse(bearX + 20, bearY - 70, size5, size5);    // ears    fill(bearColor);    noStroke();    ellipse(bearX - 50, bearY - 90, size2, size2);    ellipse(bearX + 50, bearY - 90, size2, size2);    fill(bearColor2);    arc(bearX - 50, bearY - 90, size4, size4, HALF_PI, 2 * PI, CHORD);    arc(bearX + 50, bearY - 90, size4, size4, -PI, PI - HALF_PI, CHORD);    // arms    fill(bearColor);    pushMatrix();    translate(bearX - 75, bearY + 20);    rotate(PI / 10.0f);    ellipse(0, 0, 35, size3);    popMatrix();    pushMatrix();    translate(bearX + 75, bearY + 20);    rotate(-PI / 10.0f);    ellipse(0, 0, 35, size3);    popMatrix();}',LongMethodRule
'bear10.display();',correct
'skySpring',correct
'bearX + 25',correct
'bear12',correct
'bear2.changeToBlack();',correct
'bear11',correct
'ellipse(bearX, bearY - 50, size5, 10);',correct
'bear10',correct
'bearY - 50',correct
'fill(0, 0, 0)',correct
'trunkColor = color(76, 69, 4)',correct
'ellipse(bearX - 25, bearY + 80, size2, size3);',correct
'bear15',correct
'bearX = bearX + dx',correct
'mainColor = color(2, 154, 237);',correct
'{    hunnyX = initX;    hunnyY = initY;    mainColor = color(2, 154, 237);}',correct
'hunnys[0]',correct
'bearX + 20',correct
'fill(mainColor);',correct
'{    dy = -dy;}',correct
'treeY = initY;',correct
'int skyAutumn;',correct
'int trunkColor;',correct
'bear10 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100))',correct
'grassColor = color(grassAutumn);',correct
'hunnys[0] = new Hunny(random(width), random(height))',correct
'dy = random(2, 5)',correct
'ellipse(bearX - 50, bearY - 90, size2, size2)',correct
'bg',correct
'tree1.display();',correct
'color(skySpring)',correct
'bear7.move()',correct
'PI / 10.0f',correct
'fill(0);',correct
'leafSpring = color(0, 132, 22);',correct
'bear14.changeColorBack();',correct
'bear7.display()',correct
'cloudSpring',correct
'bear6.changeColorBack()',correct
'hunnys[i].gravity();',correct
'cloud1.display()',correct
'bearColor = color(bodyColor)',correct
'bearY = initY',correct
'ellipse(0, 0, 35, size3)',correct
'ellipse(hunnyX, hunnyY + 30, 35, 20);',correct
'random(2, 5)',correct
'bear2.display();',correct
'bearColor2 = color(bodyColor2)',correct
'bear13.switchColors()',correct
'int mainColor;',correct
'new Cloud(250, 100)',correct
'fill(trunkColor);',correct
'rectMode(CENTER)',correct
'a',correct
'hunnys[i].display();',correct
'b',correct
'bear8.changeColorBack()',correct
'cloud2.changeToSpring()',correct
'random(height)',correct
'float speed = 1.5f;',correct
'leafSpring = color(0, 132, 22)',correct
'Hunny[]',correct
'color(175)',correct
'tree3.display();',correct
'bearY - 70',correct
'l',correct
'// eyesfill(255);',correct
'bear4.display();',correct
'{    bg = new Background();    bear1 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear2 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear3 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear4 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear5 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear6 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear7 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear8 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear9 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear10 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear11 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear12 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear13 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear14 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear15 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    cloud1 = new Cloud(250, 100);    cloud2 = new Cloud(650, 200);    hunnys[0] = new Hunny(random(width), random(height));    tree1 = new Tree(100, 500);    tree2 = new Tree(450, 600);    tree3 = new Tree(800, 500);}',correct
's',correct
'cloudAutumn = color(175);',correct
'float hunnyY;',correct
'bear11 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100))',correct
'bear3.move()',correct
'bearX > width - 95',correct
'y',correct
'{    cloudX = cloudX + speed;    if (cloudX > width + 110)        cloudX = 0 - 100;}',correct
'mainColor = color(2, 154, 237)',correct
'rectMode(CENTER);',correct
'void mousePressed() {    Hunny n = new Hunny(mouseX, mouseY);    hunnys = (Hunny[]) append(hunnys, n);}',correct
'tree2.changeToAutumn()',correct
'bg = new Background();',correct
'grassColor = color(45, 209, 0);',correct
'rect(450, 350, 900, 700);',PixelHardcodeIgnoranceRule
'color(2, 154, 237)',correct
'bearY + 80',correct
'bear4.changeColorBack()',correct
'cloudColor = color(255);',correct
'if (key == a) {    bg.changeToAutumn();    tree1.changeToAutumn();    tree2.changeToAutumn();    tree3.changeToAutumn();    cloud1.changeToAutumn();    cloud2.changeToAutumn();}',correct
'translate(bearX - 75, bearY + 20);',correct
'bear12.changeToYellow()',correct
'int grassSpring;',correct
'cloudSpring = color(255)',correct
'{    skyColor = color(skySpring);    grassColor = color(grassSpring);}',correct
'color(grassSpring)',correct
'cloudColor = color(255)',correct
'i < hunnys.length',correct
'if (hunnyY > height) {    speed = speed * -0.95f;}',correct
'text("HUNNY", hunnyX - 20, hunnyY + 5);',correct
'leafAutumn',correct
'bear3.changeColorBack()',correct
'bear10.switchColors()',correct
'color(160, 82, 45)',correct
'ellipse(cloudX - 70, cloudY - 10, ellipseSize, ellipseSize)',correct
'Bear bear15;',correct
'n = new Hunny(mouseX, mouseY)',correct
'bear5.changeToBlack();',correct
'size1 = 120',correct
'bearColor2',correct
'cloudX - 30',correct
'void setup() {    bg = new Background();    bear1 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear2 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear3 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear4 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear5 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear6 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear7 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear8 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear9 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear10 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear11 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear12 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear13 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear14 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    bear15 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    cloud1 = new Cloud(250, 100);    cloud2 = new Cloud(650, 200);    hunnys[0] = new Hunny(random(width), random(height));    tree1 = new Tree(100, 500);    tree2 = new Tree(450, 600);    tree3 = new Tree(800, 500);}',correct
'tree1.changeToSpring()',correct
'{    speed = speed * -0.95f;}',correct
'int skySpring;',correct
'cloud2.move();',correct
'bear14.changeToBlack();',correct
'bear12.move()',correct
'void keyPressed() {    if (keyPressed) {        if (key == l) {            bear1.switchColors();            bear4.switchColors();            bear7.switchColors();            bear10.switchColors();            bear13.switchColors();        }        if (key == b) {            bear2.changeToBlack();            bear5.changeToBlack();            bear8.changeToBlack();            bear11.changeToBlack();            bear14.changeToBlack();        }        if (key == y) {            bear3.changeToYellow();            bear6.changeToYellow();            bear9.changeToYellow();            bear12.changeToYellow();            bear15.changeToYellow();        }        if (key == a) {            bg.changeToAutumn();            tree1.changeToAutumn();            tree2.changeToAutumn();            tree3.changeToAutumn();            cloud1.changeToAutumn();            cloud2.changeToAutumn();        }        if (key == s) {            bg.changeToSpring();            tree1.changeToSpring();            tree2.changeToSpring();            tree3.changeToSpring();            cloud1.changeToSpring();            cloud2.changeToSpring();        }    }}',correct
'grassColor',correct
'bearY = bearY + dy;',correct
'new Tree(450, 600)',correct
'0.95f',correct
'size5 = 15',correct
'rect(treeX, treeY, 100, 400);',correct
'hunnyX = initX',correct
'bearY - 45',correct
'bear12.display();',correct
'color(leafAutumn)',correct
'bear11.changeToBlack();',correct
'cloud2.changeToSpring();',correct
'tree2 = new Tree(450, 600);',correct
'tree3.changeToAutumn();',correct
'hunnyY = hunnyY + speed',correct
'bearColor2 = color(255, 255, 0)',correct
'float size2 = 40;',TooManyFields
'treeX = initX;',correct
'{    bearColor = color(0, 0, 255);    bearColor2 = color(255, 255, 0);}',correct
'Processing',correct
'ellipse(bearX + 50, bearY - 90, size2, size2);',correct
'fill(leafColor);',correct
'tree3.changeToSpring();',correct
'bear3.changeToYellow()',correct
'bear6 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100))',correct
'Background() {    skyColor = color(63, 226, 255);    skySpring = color(63, 226, 255);    skyAutumn = color(18, 98, 226);    grassColor = color(45, 209, 0);    grassSpring = color(45, 209, 0);    grassAutumn = color(0, 132, 22);}',correct
'pushMatrix()',correct
'void changeToBlack() {    bearColor = color(0);    bearColor2 = color(255);}',TooManyFields
'bear7.changeColorBack()',correct
'bg = new Background()',correct
'bear14.display()',correct
'hunnys[i].display()',correct
'0.2f',correct
'bear7 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));',correct
'hunnys = (Hunny[]) append(hunnys, n);',correct
'cloudColor = color(cloudSpring);',correct
'grassSpring = color(45, 209, 0)',correct
'fill(leafColor)',correct
'color(0, 0, 255)',correct
'// armsfill(bearColor);',correct
'bear1 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100))',correct
'// Keys that do something: l,b,y,a,sBackground bg;',correct
'cloud2.changeToAutumn()',correct
'speed = speed + gravity',correct
'cloud1.move()',correct
'int skyColor;',correct
'bearColor2 = color(255);',correct
'void changeToAutumn() {    skyColor = color(skyAutumn);    grassColor = color(grassAutumn);}',correct
'grassColor = color(grassSpring);',correct
'bearY - 37',correct
'leafSpring',correct
'i = 0',correct
'hunnyY - 35',correct
'bear12.display()',correct
'void display() {    rectMode(CENTER);    fill(trunkColor);    rect(treeX, treeY, 100, 400);    fill(leafColor);    ellipse(treeX, treeY - 200, 300, 300);}',correct
'{    hunnys[i].display();    hunnys[i].gravity();}',correct
'{    if (key == l) {        bear1.switchColors();        bear4.switchColors();        bear7.switchColors();        bear10.switchColors();        bear13.switchColors();    }    if (key == b) {        bear2.changeToBlack();        bear5.changeToBlack();        bear8.changeToBlack();        bear11.changeToBlack();        bear14.changeToBlack();    }    if (key == y) {        bear3.changeToYellow();        bear6.changeToYellow();        bear9.changeToYellow();        bear12.changeToYellow();        bear15.changeToYellow();    }    if (key == a) {        bg.changeToAutumn();        tree1.changeToAutumn();        tree2.changeToAutumn();        tree3.changeToAutumn();        cloud1.changeToAutumn();        cloud2.changeToAutumn();    }    if (key == s) {        bg.changeToSpring();        tree1.changeToSpring();        tree2.changeToSpring();        tree3.changeToSpring();        cloud1.changeToSpring();        cloud2.changeToSpring();    }}',correct
'new Cloud(650, 200)',correct
'bear1 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));',correct
'hunnyY - 30',correct
'float bearX;',TooManyFields
'tree1.changeToAutumn();',correct
'bear15.changeColorBack();',correct
'{    bearX = bearX + dx;    if (bearX > width - 95 && dx > 0 || (bearX < 95)) {        dx = -dx;    }    bearY = bearY + dy;    if ((bearY > height - 110 && dy > 0) || (bearY < 110)) {        dy = -dy;    }}',correct
'bear12.move();',correct
'rect(450, 350, 900, 700)',correct
'color(cloudSpring)',correct
'new Background()',correct
'ellipse(bearX + 50, bearY - 90, size2, size2)',correct
'dy = -dy',correct
'trunkColor',correct
'tree2.changeToAutumn();',correct
'if (key == s) {    bg.changeToSpring();    tree1.changeToSpring();    tree2.changeToSpring();    tree3.changeToSpring();    cloud1.changeToSpring();    cloud2.changeToSpring();}',correct
'bear8 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));',correct
'bear12 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100))',correct
'color(leafSpring)',correct
'fill(trunkColor)',correct
'void display() {    // legs    fill(bearColor);    ellipse(bearX - 25, bearY + 80, size2, size3);    ellipse(bearX + 25, bearY + 80, size2, size3);    // body    fill(bearColor);    ellipse(bearX, bearY + 20, size1, size1);    fill(bearColor2);    ellipse(bearX, bearY + 20, size3, size3);    // head    fill(bearColor);    ellipse(bearX, bearY - 60, size1, 90);    // snout    fill(255, 182, 193);    arc(bearX, bearY - 37, size5, size5, 0, PI, CHORD);    fill(bearColor2);    ellipse(bearX, bearY - 45, size2, size4);    fill(0, 0, 0);    ellipse(bearX, bearY - 50, size5, 10);    // eyes    fill(255);    ellipse(bearX - 20, bearY - 70, size4, 25);    ellipse(bearX + 20, bearY - 70, size4, 25);    fill(0);    ellipse(bearX - 20, bearY - 70, size5, size5);    ellipse(bearX + 20, bearY - 70, size5, size5);    // ears    fill(bearColor);    noStroke();    ellipse(bearX - 50, bearY - 90, size2, size2);    ellipse(bearX + 50, bearY - 90, size2, size2);    fill(bearColor2);    arc(bearX - 50, bearY - 90, size4, size4, HALF_PI, 2 * PI, CHORD);    arc(bearX + 50, bearY - 90, size4, size4, -PI, PI - HALF_PI, CHORD);    // arms    fill(bearColor);    pushMatrix();    translate(bearX - 75, bearY + 20);    rotate(PI / 10.0f);    ellipse(0, 0, 35, size3);    popMatrix();    pushMatrix();    translate(bearX + 75, bearY + 20);    rotate(-PI / 10.0f);    ellipse(0, 0, 35, size3);    popMatrix();}',TooManyFields
'float bearY;',TooManyFields
'bear3.move();',correct
'bear11.display()',correct
'cloud1 = new Cloud(250, 100);',correct
'int bearColor;',TooManyFields
'hunnyY + speed',correct
'width - 800',correct
'noStroke();',correct
'cloud1.changeToSpring()',correct
'ellipse(bearX, bearY - 50, size5, 10)',correct
'bear14 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));',correct
'PI - HALF_PI',correct
'fill(grassColor);',correct
'ellipse(bearX + 20, bearY - 70, size4, 25)',correct
'{    bear3.changeToYellow();    bear6.changeToYellow();    bear9.changeToYellow();    bear12.changeToYellow();    bear15.changeToYellow();}',correct
'bear1.changeColorBack()',correct
'bearColor2 = color(bodyColor);',correct
'bear6.move()',correct
'bear5 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100))',correct
'bear10.display()',correct
'new Tree(100, 500)',correct
'hunnys[i].gravity()',correct
'ellipse(cloudX, cloudY, ellipseSize, ellipseSize)',correct
'ellipse(0, 0, 35, size3);',correct
'float size5 = 15;',TooManyFields
'{    cloudColor = color(cloudAutumn);}',correct
'color(grassAutumn)',correct
'int leafAutumn;',correct
'bear12.changeToYellow();',correct
'{    bear2.changeToBlack();    bear5.changeToBlack();    bear8.changeToBlack();    bear11.changeToBlack();    bear14.changeToBlack();}',correct
'leafColor = color(leafSpring);',correct
'int grassColor;',correct
'bear13.display()',correct
'tree2 = new Tree(450, 600)',correct
'tree2.changeToSpring();',correct
'bear1.display()',correct
'hunnyX = initX;',correct
'bear4 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100))',correct
'grassColor = color(grassSpring)',correct
'bear15.move()',correct
'append(hunnys, n)',correct
'ellipse(bearX, bearY - 45, size2, size4);',correct
'cloudX = cloudX + speed',correct
'bodyColor = color(160, 82, 45);',correct
'height - 800',correct
'dx = -dx',correct
'cloudX = 0 - 100',correct
'bodyColor2 = color(205, 133, 63);',correct
'float size1 = 120;',TooManyFields
'new Hunny(random(width), random(height))',correct
'int value = 0;',correct
'void display() {    fill(cloudColor);    ellipse(cloudX, cloudY, ellipseSize, ellipseSize);    ellipse(cloudX - 30, cloudY - 40, ellipseSize, ellipseSize);    ellipse(cloudX + 40, cloudY - 25, ellipseSize, ellipseSize);    ellipse(cloudX - 70, cloudY - 10, ellipseSize, ellipseSize);}',correct
'bear15.changeColorBack()',correct
'-dx',correct
'// snoutfill(255, 182, 193);',correct
'-dy',correct
'tree1.changeToSpring();',correct
'bear9 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100))',correct
'cloudColor',correct
'ellipse(hunnyX, hunnyY, 60, 70);',correct
'bear2.display()',correct
'bearColor = color(0, 0, 255);',correct
'int bearColor2;',TooManyFields
'ellipseMode(CENTER)',correct
'bear11.move()',correct
'bear10.move()',correct
'cloud1.display();',correct
'bear14.changeColorBack()',correct
'bg.display();',correct
'bear13 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100))',correct
'float size4 = 20;',TooManyFields
'cloudX = initX;',correct
'color(205, 133, 63)',correct
'ellipse(hunnyX, hunnyY, 60, 70)',correct
'class Cloud {    float cloudX;    float cloudY;    float ellipseSize = 100;    float speed = 1.5f;    int cloudColor;    int cloudSpring;    int cloudAutumn;    Cloud(float initX, float initY) {        cloudX = initX;        cloudY = initY;        cloudColor = color(255);        cloudSpring = color(255);        cloudAutumn = color(175);    }    void display() {        fill(cloudColor);        ellipse(cloudX, cloudY, ellipseSize, ellipseSize);        ellipse(cloudX - 30, cloudY - 40, ellipseSize, ellipseSize);        ellipse(cloudX + 40, cloudY - 25, ellipseSize, ellipseSize);        ellipse(cloudX - 70, cloudY - 10, ellipseSize, ellipseSize);    }    void move() {        cloudX = cloudX + speed;        if (cloudX > width + 110)            cloudX = 0 - 100;    }    void changeToSpring() {        cloudColor = color(cloudSpring);    }    void changeToAutumn() {        cloudColor = color(cloudAutumn);    }}',correct
'ellipse(bearX + 20, bearY - 70, size5, size5)',correct
'void',correct
'skySpring = color(63, 226, 255);',correct
'trunkColor = color(76, 69, 4);',correct
'void switchColors() {    bearColor = color(bodyColor2);    bearColor2 = color(bodyColor);}',TooManyFields
'bear7.display();',correct
'speed * -0.95f',correct
'arc(bearX + 50, bearY - 90, size4, size4, -PI, PI - HALF_PI, CHORD)',correct
'new Hunny[1]',correct
'leafAutumn = color(226, 117, 0)',correct
'color(bodyColor)',correct
'1.5f',correct
'ellipse(cloudX + 40, cloudY - 25, ellipseSize, ellipseSize)',correct
'float gravity = 0.2f;',AvoidFieldNameMatchingMethodName
'cloud2.move()',correct
'bearColor = color(bodyColor2);',correct
'popMatrix()',correct
'bearY + 20',correct
'bear5.move()',correct
'ellipse(bearX, bearY - 60, size1, 90)',correct
'{    skyColor = color(skyAutumn);    grassColor = color(grassAutumn);}',correct
'skyColor = color(skySpring);',correct
'{    cloudX = initX;    cloudY = initY;    cloudColor = color(255);    cloudSpring = color(255);    cloudAutumn = color(175);}',correct
'cloud2 = new Cloud(650, 200);',correct
'bear3.display()',correct
'bear8.changeColorBack();',correct
'new Bear(random(width - 800, width - 100), random(height - 800, height - 100))',correct
'hunnys[0] = new Hunny(random(width), random(height));',correct
'ellipse(bearX, bearY + 20, size1, size1);',correct
'bearX + dx',correct
'translate(bearX - 75, bearY + 20)',correct
'bear13.move();',correct
'bg.changeToSpring();',correct
'color(skyAutumn)',correct
'{    leafColor = color(leafAutumn);}',correct
'if (keyPressed) {    if (key == l) {        bear1.switchColors();        bear4.switchColors();        bear7.switchColors();        bear10.switchColors();        bear13.switchColors();    }    if (key == b) {        bear2.changeToBlack();        bear5.changeToBlack();        bear8.changeToBlack();        bear11.changeToBlack();        bear14.changeToBlack();    }    if (key == y) {        bear3.changeToYellow();        bear6.changeToYellow();        bear9.changeToYellow();        bear12.changeToYellow();        bear15.changeToYellow();    }    if (key == a) {        bg.changeToAutumn();        tree1.changeToAutumn();        tree2.changeToAutumn();        tree3.changeToAutumn();        cloud1.changeToAutumn();        cloud2.changeToAutumn();    }    if (key == s) {        bg.changeToSpring();        tree1.changeToSpring();        tree2.changeToSpring();        tree3.changeToSpring();        cloud1.changeToSpring();        cloud2.changeToSpring();    }}',correct
'bear6.changeColorBack();',correct
'bearColor = color(0, 0, 255)',correct
'bear4.changeColorBack();',correct
'{    bear1.changeColorBack();    bear2.changeColorBack();    bear3.changeColorBack();    bear4.changeColorBack();    bear5.changeColorBack();    bear6.changeColorBack();    bear7.changeColorBack();    bear8.changeColorBack();    bear9.changeColorBack();    bear10.changeColorBack();    bear11.changeColorBack();    bear12.changeColorBack();    bear13.changeColorBack();    bear14.changeColorBack();    bear15.changeColorBack();}',correct
'bear1.switchColors()',correct
'bear2.changeColorBack();',correct
'ellipse(hunnyX, hunnyY - 35, 20, 20);',correct
'class Tree {    float treeX;    float treeY;    int trunkColor;    int leafColor;    int leafSpring;    int leafAutumn;    Tree(float initX, float initY) {        treeX = initX;        treeY = initY;        trunkColor = color(76, 69, 4);        leafColor = color(0, 132, 22);        leafSpring = color(0, 132, 22);        leafAutumn = color(226, 117, 0);    }    void display() {        rectMode(CENTER);        fill(trunkColor);        rect(treeX, treeY, 100, 400);        fill(leafColor);        ellipse(treeX, treeY - 200, 300, 300);    }    void changeToSpring() {        leafColor = color(leafSpring);    }    void changeToAutumn() {        leafColor = color(leafAutumn);    }}',correct
'ellipse(bearX - 20, bearY - 70, size4, 25)',correct
'bearColor2 = color(205, 133, 63)',correct
'bear4.move();',correct
'skyAutumn = color(18, 98, 226);',correct
'{    Hunny n = new Hunny(mouseX, mouseY);    hunnys = (Hunny[]) append(hunnys, n);}',correct
'{    if (value == 0) {        bear1.changeColorBack();        bear2.changeColorBack();        bear3.changeColorBack();        bear4.changeColorBack();        bear5.changeColorBack();        bear6.changeColorBack();        bear7.changeColorBack();        bear8.changeColorBack();        bear9.changeColorBack();        bear10.changeColorBack();        bear11.changeColorBack();        bear12.changeColorBack();        bear13.changeColorBack();        bear14.changeColorBack();        bear15.changeColorBack();    }}',correct
'bear8.changeToBlack()',correct
'class Background {    int skyColor;    int skySpring;    int skyAutumn;    int grassColor;    int grassSpring;    int grassAutumn;    Background() {        skyColor = color(63, 226, 255);        skySpring = color(63, 226, 255);        skyAutumn = color(18, 98, 226);        grassColor = color(45, 209, 0);        grassSpring = color(45, 209, 0);        grassAutumn = color(0, 132, 22);    }    void display() {        rectMode(CENTER);        fill(skyColor);        rect(450, 350, 900, 700);        fill(grassColor);        rect(450, 800, 900, 200);    }    void changeToSpring() {        skyColor = color(skySpring);        grassColor = color(grassSpring);    }    void changeToAutumn() {        skyColor = color(skyAutumn);        grassColor = color(grassAutumn);    }}',correct
'arc(bearX - 50, bearY - 90, size4, size4, HALF_PI, 2 * PI, CHORD);',correct
'tree2.changeToSpring()',correct
'bear5.changeToBlack()',correct
'{    bearColor = color(0);    bearColor2 = color(255);}',correct
'rect(treeX, treeY, 100, 400)',correct
'Cloud',correct
'bear13.display();',correct
'bear2.changeToBlack()',correct
'void changeToAutumn() {    cloudColor = color(cloudAutumn);}',correct
'fill(bearColor2);',correct
'skyColor = color(skySpring)',correct
'bear2.changeColorBack()',correct
'bear9.changeToYellow()',correct
'skyColor',correct
'random(width)',correct
'width + 110',correct
'tree1 = new Tree(100, 500);',correct
'fill(skyColor);',correct
'tree3 = new Tree(800, 500);',correct
'ellipse(hunnyX, hunnyY - 30, 50, 20);',correct
'dx > 0',correct
'bear6.changeToYellow();',correct
'treeY = initY',correct
'leafColor = color(0, 132, 22);',correct
'bear14 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100))',correct
'bear3 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100))',correct
'ellipse(treeX, treeY - 200, 300, 300);',correct
'if (key == l) {    bear1.switchColors();    bear4.switchColors();    bear7.switchColors();    bear10.switchColors();    bear13.switchColors();}',correct
'bearColor = color(0)',correct
'ellipse(bearX - 20, bearY - 70, size5, size5);',correct
'fill(bearColor2)',correct
'{    fill(cloudColor);    ellipse(cloudX, cloudY, ellipseSize, ellipseSize);    ellipse(cloudX - 30, cloudY - 40, ellipseSize, ellipseSize);    ellipse(cloudX + 40, cloudY - 25, ellipseSize, ellipseSize);    ellipse(cloudX - 70, cloudY - 10, ellipseSize, ellipseSize);}',correct
'Background',correct
'bear6.display()',correct
'float size3 = 70;',correct
'pushMatrix();',correct
'cloudAutumn',correct
'speed = 1.5f',correct
'// earsfill(bearColor);',correct
'// headfill(bearColor);',correct
'cloud1.changeToAutumn()',correct
'cloudX = 0 - 100;',correct
'{    bg.display();    tree1.display();    tree2.display();    tree3.display();    cloud1.display();    cloud1.move();    cloud2.display();    cloud2.move();    bear1.display();    bear1.move();    bear2.display();    bear2.move();    bear3.display();    bear3.move();    bear4.display();    bear4.move();    bear5.display();    bear5.move();    bear6.display();    bear6.move();    bear7.display();    bear7.move();    bear8.display();    bear8.move();    bear9.display();    bear9.move();    bear10.display();    bear10.move();    bear11.display();    bear11.move();    bear12.display();    bear12.move();    bear13.display();    bear13.move();    bear14.display();    bear14.move();    bear15.display();    bear15.move();    for (int i = 0; i < hunnys.length; i++) {        hunnys[i].display();        hunnys[i].gravity();    }}',correct
'skyColor = color(skyAutumn);',correct
'ellipse(bearX, bearY - 60, size1, 90);',correct
'new Tree(800, 500)',correct
'grassAutumn = color(0, 132, 22)',correct
'bearColor = color(160, 82, 45)',correct
'cloud2.display()',correct
'Hunny n = new Hunny(mouseX, mouseY);',ShortVariable
'void changeToSpring() {    skyColor = color(skySpring);    grassColor = color(grassSpring);}',correct
'bear1.switchColors();',correct
'Bear bear9;',correct
'Hunny',correct
'bearY = initY;',correct
'Bear(float initX, float initY) {    bearX = initX;    bearY = initY;    bearColor = color(160, 82, 45);    bearColor2 = color(205, 133, 63);    bodyColor = color(160, 82, 45);    bodyColor2 = color(205, 133, 63);}',TooManyFields
'void display() {    fill(mainColor);    ellipseMode(CENTER);    ellipse(hunnyX, hunnyY, 60, 70);    ellipse(hunnyX, hunnyY + 30, 35, 20);    ellipse(hunnyX, hunnyY - 35, 20, 20);    ellipse(hunnyX, hunnyY - 30, 50, 20);    fill(0);    text("HUNNY", hunnyX - 20, hunnyY + 5);}',correct
'Tree(float initX, float initY) {    treeX = initX;    treeY = initY;    trunkColor = color(76, 69, 4);    leafColor = color(0, 132, 22);    leafSpring = color(0, 132, 22);    leafAutumn = color(226, 117, 0);}',correct
'bodyColor2',correct
'leafColor = color(leafAutumn)',correct
'bear4.switchColors();',correct
'bear11 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));',correct
'bear7.switchColors();',correct
'hunnyY = hunnyY + speed;',correct
'bear3.changeToYellow();',correct
'Cloud cloud2;',correct
'hunnyY + 30',correct
'ellipse(bearX, bearY - 45, size2, size4)',correct
'ellipseSize = 100',correct
'bg.changeToAutumn();',correct
'cloudColor = color(cloudSpring)',correct
'mainColor',correct
'rotate(PI / 10.0f)',correct
'cloud1.changeToAutumn();',correct
'void changeToAutumn() {    leafColor = color(leafAutumn);}',correct
'cloudY - 25',correct
'ellipse(hunnyX, hunnyY - 30, 50, 20)',correct
'speed = speed * -0.95f',correct
'bear4 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));',correct
'Bear bear8;',correct
'skyColor = color(skyAutumn)',correct
'color(45, 209, 0)',correct
'cloud1.move();',correct
'rotate(-PI / 10.0f);',correct
'bear3.display();',correct
'hunnyY > height',correct
'bear10.changeColorBack()',correct
'hunnys.length',correct
'bear7.switchColors()',correct
'cloudY - 10',correct
'int cloudColor;',correct
'bodyColor = color(160, 82, 45)',correct
'Cloud cloud1;',correct
'popMatrix();',correct
'void changeColorBack() {    bearColor = color(bodyColor);    bearColor2 = color(bodyColor2);}',correct
'bear9.move();',correct
'void changeToSpring() {    cloudColor = color(cloudSpring);}',correct
'skyColor = color(63, 226, 255)',correct
'cloudX > width + 110',correct
'color(cloudAutumn)',correct
'fill(255, 182, 193)',correct
'ellipse(bearX, bearY + 20, size1, size1)',correct
'bear2.move();',correct
'tree2.display();',correct
'int cloudAutumn;',correct
'{    bg.changeToAutumn();    tree1.changeToAutumn();    tree2.changeToAutumn();    tree3.changeToAutumn();    cloud1.changeToAutumn();    cloud2.changeToAutumn();}',correct
'-0.95f',correct
'fill(mainColor)',correct
'cloudSpring = color(255);',correct
'bear4.display()',correct
'noStroke()',correct
'(Hunny[]) append(hunnys, n)',correct
'speed + gravity',correct
'Bear bear7;',correct
'speed = speed + gravity;',correct
'if (cloudX > width + 110)    cloudX = 0 - 100;',IfStmtsMustUseBraces
'bear13.switchColors();',correct
'bear10.switchColors();',correct
'arc(bearX, bearY - 37, size5, size5, 0, PI, CHORD);',correct
'bear13.changeColorBack();',correct
'skyColor = color(63, 226, 255);',correct
'bear8',correct
'gravity = 0.2f',correct
'bear9',correct
'tree3.display()',correct
'bearX > width - 95 && dx > 0',correct
'bear4',correct
'bear5',correct
'ellipse(bearX - 25, bearY + 80, size2, size3)',correct
'skySpring = color(63, 226, 255)',correct
'bear6',correct
'bear7',correct
'bear14.move();',correct
'color(0, 132, 22)',correct
'grassAutumn',correct
'translate(bearX + 75, bearY + 20);',correct
'bear13.changeColorBack()',correct
'bear5.move();',correct
'Bear bear6;',correct
'skyAutumn',correct
'bear14.move()',correct
'10.0f',correct
'bearColor2 = color(255, 255, 0);',correct
'cloud2 = new Cloud(650, 200)',correct
'size3 = 70',correct
'bearX',correct
'bearY',correct
'fill(0)',correct
'bear11.move();',correct
'float dx = random(2, 5);',TooManyFields
'bear15.display()',correct
'bear1.display();',correct
'color(76, 69, 4)',correct
'float ellipseSize = 100;',correct
'bear4.move()',correct
'bear8.display();',correct
'bear12.changeColorBack()',correct
'grassColor = color(45, 209, 0)',correct
'Cloud(float initX, float initY) {    cloudX = initX;    cloudY = initY;    cloudColor = color(255);    cloudSpring = color(255);    cloudAutumn = color(175);}',correct
'if (value == 0) {    bear1.changeColorBack();    bear2.changeColorBack();    bear3.changeColorBack();    bear4.changeColorBack();    bear5.changeColorBack();    bear6.changeColorBack();    bear7.changeColorBack();    bear8.changeColorBack();    bear9.changeColorBack();    bear10.changeColorBack();    bear11.changeColorBack();    bear12.changeColorBack();    bear13.changeColorBack();    bear14.changeColorBack();    bear15.changeColorBack();}',correct
'translate(bearX + 75, bearY + 20)',correct
'bear6.changeToYellow()',correct
'class Hunny {    float hunnyX;    float hunnyY;    int mainColor;    float gravity = 0.2f;    float speed = 3;    Hunny(float initX, float initY) {        hunnyX = initX;        hunnyY = initY;        mainColor = color(2, 154, 237);    }    void display() {        fill(mainColor);        ellipseMode(CENTER);        ellipse(hunnyX, hunnyY, 60, 70);        ellipse(hunnyX, hunnyY + 30, 35, 20);        ellipse(hunnyX, hunnyY - 35, 20, 20);        ellipse(hunnyX, hunnyY - 30, 50, 20);        fill(0);        text("HUNNY", hunnyX - 20, hunnyY + 5);    }    void gravity() {        hunnyY = hunnyY + speed;        speed = speed + gravity;        if (hunnyY > height) {            speed = speed * -0.95f;        }    }}',correct
'bear2 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));',correct
'float cloudY;',correct
'cloud2.changeToAutumn();',correct
'{    leafColor = color(leafSpring);}',correct
'bearX = bearX + dx;',correct
'cloudX = cloudX + speed;',correct
'fill(grassColor)',correct
'int bodyColor;',TooManyFields
'bear9.move()',correct
'Bear bear5;',correct
'value == 0',correct
'bearColor = color(bodyColor2)',correct
'bear11.changeToBlack()',correct
'bodyColor2 = color(205, 133, 63)',correct
'fill(255)',correct
'tree1',correct
'tree2',correct
'Tree tree2;',correct
'tree3',correct
'bear8.changeToBlack();',correct
'tree3.changeToAutumn()',correct
'bear14.changeToBlack()',correct
'bear9.changeToYellow();',correct
'cloudColor = color(cloudAutumn)',correct
'leafColor = color(leafAutumn);',correct
'bear8.move();',correct
'bearX - 75',correct
'fill(cloudColor)',correct
'void gravity() {    hunnyY = hunnyY + speed;    speed = speed + gravity;    if (hunnyY > height) {        speed = speed * -0.95f;    }}',correct
'void move() {    cloudX = cloudX + speed;    if (cloudX > width + 110)        cloudX = 0 - 100;}',correct
'hunnys[i]',correct
'cloudY = initY',correct
'treeX',correct
'treeY',correct
'Bear bear4;',correct
'leafColor = color(leafSpring)',correct
'-PI',correct
'float cloudX;',correct
'ellipse(hunnyX, hunnyY - 35, 20, 20)',correct
'{    rectMode(CENTER);    fill(skyColor);    rect(450, 350, 900, 700);    fill(grassColor);    rect(450, 800, 900, 200);}',correct
'dx = -dx;',correct
'int leafSpring;',correct
'Tree tree3;',correct
'{    bearX = initX;    bearY = initY;    bearColor = color(160, 82, 45);    bearColor2 = color(205, 133, 63);    bodyColor = color(160, 82, 45);    bodyColor2 = color(205, 133, 63);}',correct
'bearColor2 = color(255)',correct
'bear13 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));',correct
'int i = 0',correct
'ellipseMode(CENTER);',correct
'{    fill(mainColor);    ellipseMode(CENTER);    ellipse(hunnyX, hunnyY, 60, 70);    ellipse(hunnyX, hunnyY + 30, 35, 20);    ellipse(hunnyX, hunnyY - 35, 20, 20);    ellipse(hunnyX, hunnyY - 30, 50, 20);    fill(0);    text("HUNNY", hunnyX - 20, hunnyY + 5);}',correct
'ellipse(cloudX - 30, cloudY - 40, ellipseSize, ellipseSize);',correct
'bear14.display();',correct
'bear1.move()',correct
'treeY - 200',correct
'void keyReleased() {    if (value == 0) {        bear1.changeColorBack();        bear2.changeColorBack();        bear3.changeColorBack();        bear4.changeColorBack();        bear5.changeColorBack();        bear6.changeColorBack();        bear7.changeColorBack();        bear8.changeColorBack();        bear9.changeColorBack();        bear10.changeColorBack();        bear11.changeColorBack();        bear12.changeColorBack();        bear13.changeColorBack();        bear14.changeColorBack();        bear15.changeColorBack();    }}',correct
'int leafColor;',correct
'if ((bearY > height - 110 && dy > 0) || (bearY < 110)) {    dy = -dy;}',correct
'{    bear1.switchColors();    bear4.switchColors();    bear7.switchColors();    bear10.switchColors();    bear13.switchColors();}',correct
'float treeX;',correct
'color(255)',correct
'cloudAutumn = color(175)',correct
'int bodyColor2;',correct
'bearX > width - 95 && dx > 0 || (bearX < 95)',correct
'{    bg.changeToSpring();    tree1.changeToSpring();    tree2.changeToSpring();    tree3.changeToSpring();    cloud1.changeToSpring();    cloud2.changeToSpring();}',correct
'Bear bear3;',correct
'random(width - 800, width - 100)',correct
'bearX = initX',correct
'int cloudSpring;',correct
'bear9.changeColorBack();',correct
'bear6.display();',correct
'hunnys = (Hunny[]) append(hunnys, n)',correct
'float speed = 3;',correct
'Bear bear11;',correct
'cloudColor = color(cloudAutumn);',correct
'bear15.changeToYellow();',correct
'bear1.changeColorBack();',correct
'bearColor2 = color(bodyColor2);',correct
'bearX - 50',correct
'void display() {    rectMode(CENTER);    fill(skyColor);    rect(450, 350, 900, 700);    fill(grassColor);    rect(450, 800, 900, 200);}',correct
'bg.display()',correct
'ellipse(cloudX + 40, cloudY - 25, ellipseSize, ellipseSize);',correct
'{    bearColor = color(bodyColor2);    bearColor2 = color(bodyColor);}',correct
'float treeY;',correct
'Bear bear2;',correct
'{    bearColor = color(bodyColor);    bearColor2 = color(bodyColor2);}',correct
'tree3 = new Tree(800, 500)',correct
'grassSpring = color(45, 209, 0);',correct
'Tree tree1;',correct
'cloudX = initX',correct
'cloud1 = new Cloud(250, 100)',correct
'bear15.changeToYellow()',correct
'leafAutumn = color(226, 117, 0);',correct
'treeX = initX',correct
'bear8 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100))',correct
'Bear bear12;',correct
'cloudX + 40',correct
'void changeToSpring() {    leafColor = color(leafSpring);}',correct
'key == l',correct
'leafColor',correct
'bear5.display();',correct
'bg.changeToAutumn()',correct
'bear10.changeColorBack();',correct
'Bear bear1;',correct
'bearY = bearY + dy',correct
'tree3.changeToSpring()',correct
'bear12.changeColorBack();',correct
'fill(bearColor)',correct
'key == b',correct
'bearColor2 = color(205, 133, 63);',correct
'key == a',correct
'rotate(PI / 10.0f);',correct
'grassAutumn = color(0, 132, 22);',correct
'hunnyX',correct
'hunnyY',correct
'fill(cloudColor);',correct
'key == y',correct
'Bear bear13;',correct
'color(18, 98, 226)',correct
'key == s',correct
'color(0)',correct
'int grassAutumn;',correct
'bear15.move();',correct
'grassSpring',correct
'ellipse(cloudX - 30, cloudY - 40, ellipseSize, ellipseSize)',correct
'size4 = 20',correct
'bear6.move();',correct
'void changeToYellow() {    bearColor = color(0, 0, 255);    bearColor2 = color(255, 255, 0);}',TooManyFields
'bearX - 25',correct
'display',LongMethodRule
'bear1',correct
'{    hunnyY = hunnyY + speed;    speed = speed + gravity;    if (hunnyY > height) {        speed = speed * -0.95f;    }}',correct
'bear2',correct
'bear3',correct
'bearY + dy',correct
'bear9 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));',correct
'cloudX + speed',correct
'ellipse(bearX + 20, bearY - 70, size4, 25);',correct
'rotate(-PI / 10.0f)',correct
'{    skyColor = color(63, 226, 255);    skySpring = color(63, 226, 255);    skyAutumn = color(18, 98, 226);    grassColor = color(45, 209, 0);    grassSpring = color(45, 209, 0);    grassAutumn = color(0, 132, 22);}',correct
'cloud2.display();',correct
'Bear bear14;',correct
'width - 100',correct
'Hunny(float initX, float initY) {    hunnyX = initX;    hunnyY = initY;    mainColor = color(2, 154, 237);}',correct
'bearX - 20',correct
'ellipse(bearX + 25, bearY + 80, size2, size3)',correct
'tree1 = new Tree(100, 500)',correct
'bear15 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));',correct
'hunnyY = initY',correct
'cloud1.changeToSpring();',correct
'ellipse(bearX, bearY + 20, size3, size3);',correct
'text("HUNNY", hunnyX - 20, hunnyY + 5)',correct
'ellipse(bearX + 20, bearY - 70, size5, size5);',correct
'cloudY = initY;',correct
'cloudY - 40',correct
'bear2 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100))',correct
'-PI / 10.0f',correct
'float initX',correct
'float initY',correct
'ellipse(bearX + 25, bearY + 80, size2, size3);',correct
'i++',correct
'cloud2',correct
'cloud1',correct
'dx = random(2, 5)',correct
'rect(450, 800, 900, 200);',PixelHardcodeIgnoranceRule
'ellipse(treeX, treeY - 200, 300, 300)',correct
'bear7.changeColorBack();',correct
'bear11.display();',correct
'Tree',correct
'bearX + 75',correct
'leafColor = color(0, 132, 22)',correct
'bear3 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));',correct
'"HUNNY"',correct
'value = 0',correct
'ellipse(cloudX, cloudY, ellipseSize, ellipseSize);',correct
'bear3.changeColorBack();',correct
'bear15 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100))',correct
'(bearY > height - 110 && dy > 0) || (bearY < 110)',correct
'bearY - 90',correct
'tree1.changeToAutumn()',correct
'ellipse(hunnyX, hunnyY + 30, 35, 20)',correct
'bear1.move();',correct
'// bodyfill(bearColor);',correct
'bear4.switchColors()',correct
'bear12 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));',correct
'bear2.move()',correct
'color(bodyColor2)',correct
'speed = 3',correct
'height - 100',correct
'{    cloudColor = color(cloudSpring);}',correct
'bear9.display()',correct
'bear5.changeColorBack()',correct
'bearColor',correct
'tree2.display()',correct
'void move() {    bearX = bearX + dx;    if (bearX > width - 95 && dx > 0 || (bearX < 95)) {        dx = -dx;    }    bearY = bearY + dy;    if ((bearY > height - 110 && dy > 0) || (bearY < 110)) {        dy = -dy;    }}',TooManyFields
'0 - 100',correct
'{    rectMode(CENTER);    fill(trunkColor);    rect(treeX, treeY, 100, 400);    fill(leafColor);    ellipse(treeX, treeY - 200, 300, 300);}',correct
'bear8.move()',correct
'bearColor = color(bodyColor);',correct
'bodyColor',correct
'bear15.display();',correct
'width - 95',correct
'bearColor = color(160, 82, 45);',correct
'bg.changeToSpring()',correct
'Bear',correct
'fill(0, 0, 0);',correct
'size2 = 40',correct
'float dy = random(2, 5);',TooManyFields
'bearColor2 = color(bodyColor)',correct
'bear11.changeColorBack()',correct
'cloudY',correct
'if (bearX > width - 95 && dx > 0 || (bearX < 95)) {    dx = -dx;}',correct
'{    if (keyPressed) {        if (key == l) {            bear1.switchColors();            bear4.switchColors();            bear7.switchColors();            bear10.switchColors();            bear13.switchColors();        }        if (key == b) {            bear2.changeToBlack();            bear5.changeToBlack();            bear8.changeToBlack();            bear11.changeToBlack();            bear14.changeToBlack();        }        if (key == y) {            bear3.changeToYellow();            bear6.changeToYellow();            bear9.changeToYellow();            bear12.changeToYellow();            bear15.changeToYellow();        }        if (key == a) {            bg.changeToAutumn();            tree1.changeToAutumn();            tree2.changeToAutumn();            tree3.changeToAutumn();            cloud1.changeToAutumn();            cloud2.changeToAutumn();        }        if (key == s) {            bg.changeToSpring();            tree1.changeToSpring();            tree2.changeToSpring();            tree3.changeToSpring();            cloud1.changeToSpring();            cloud2.changeToSpring();        }    }}',correct
'speed = speed * -0.95f;',correct
'bear6 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));',correct
'color(255, 255, 0)',correct
'random(height - 800, height - 100)',correct
'cloudX',correct
'if (key == y) {    bear3.changeToYellow();    bear6.changeToYellow();    bear9.changeToYellow();    bear12.changeToYellow();    bear15.changeToYellow();}',correct
'tree1.display()',correct
'bearX = initX;',correct
'bearX + 50',correct
'arc(bearX, bearY - 37, size5, size5, 0, PI, CHORD)',correct
'ellipse(cloudX - 70, cloudY - 10, ellipseSize, ellipseSize);',correct
'bear7 = new Bear(random(width - 800, width - 100), random(height - 800, height - 100))',correct
'bear8.display()',correct
'for (int i = 0; i < hunnys.length; i++) {    hunnys[i].display();    hunnys[i].gravity();}',correct
'hunnyY = initY;',correct
'[1]',correct
'Hunny n = new Hunny(mouseX, mouseY)',correct
'bear13.move()',correct
'ellipse(bearX - 20, bearY - 70, size4, 25);',correct
'arc(bearX - 50, bearY - 90, size4, size4, HALF_PI, 2 * PI, CHORD)',correct
'new Hunny(mouseX, mouseY)',correct
'color(63, 226, 255)',correct
'arc(bearX + 50, bearY - 90, size4, size4, -PI, PI - HALF_PI, CHORD);',correct
'void draw() {    bg.display();    tree1.display();    tree2.display();    tree3.display();    cloud1.display();    cloud1.move();    cloud2.display();    cloud2.move();    bear1.display();    bear1.move();    bear2.display();    bear2.move();    bear3.display();    bear3.move();    bear4.display();    bear4.move();    bear5.display();    bear5.move();    bear6.display();    bear6.move();    bear7.display();    bear7.move();    bear8.display();    bear8.move();    bear9.display();    bear9.move();    bear10.display();    bear10.move();    bear11.display();    bear11.move();    bear12.display();    bear12.move();    bear13.display();    bear13.move();    bear14.display();    bear14.move();    bear15.display();    bear15.move();    for (int i = 0; i < hunnys.length; i++) {        hunnys[i].display();        hunnys[i].gravity();    }}',LongMethodRule
'2 * PI',correct
'bear10.move();',correct
'color(226, 117, 0)',correct
'{    dx = -dx;}',correct
'grassColor = color(grassAutumn)',correct
'Bear bear10;',correct
'bearColor = color(0);',correct
'for (int i = 0; i < arrayofGun.length; i++) {    arrayofGun[i].mousePressed();}',correct
'boardY = boardY - 7',correct
'int ydirection = 0;',correct
'random(0, 255)',correct
'boardX < 100',correct
'arrayofGun[i].mousePressed();',correct
'background(27, 202, 245)',correct
'boardX = initX',correct
'borderbounce();',correct
'{    display();    borderbounce();    keyPressed();}',correct
'stroke(0);',correct
'stroke(0)',correct
'display();',correct
'xspeed = 20;',correct
'class Board {    // GLOBAL VARIABLES    float boardX, boardY;    int xdirection = 1;    int ydirection = 0;    float xspeed = 8;    float yspeed = 2;    // CONSTRUCTOR    Board(float initX, float initY) {        boardX = initX;        boardY = initY;        boardX = width / 2;    }    // FUNCTIONS    void run() {        display();        borderbounce();        keyPressed();    }    void borderbounce() {        boardX = boardX + (xspeed * xdirection);        boardY = boardY + (yspeed * ydirection);        if (boardX > width - 100 || boardX < 100) {            xdirection *= -1;        }    }    void display() {        // BOARD        // white        int boardColor = color(255, 255, 255);        fill(boardColor);        stroke(0);        ellipse(boardX, boardY, 120, 15);        ellipseMode(CENTER);        // FIN        triangle(boardX + 60, boardY + 22, boardX + 55, boardY + 6, boardX + 40, boardY + 7);        // MAST        // black        int mastColor = color(0, 0, 0);        fill(mastColor);        strokeWeight(3);        stroke(mastColor);        line(boardX, boardY, boardX, boardY - 200);        // SAIL        int sailColor = color(random(0, 255), random(0, 255), random(0, 255));        fill(sailColor);        strokeWeight(0);        triangle(boardX, boardY, boardX, boardY - 200, boardX + 90, boardY - 70);        // TRACE        int traceColor = color(255);        fill(traceColor);        strokeWeight(0);        line(boardX + 60, boardY + 22, boardX + 55, boardY);    }    void keyPressed() {        if (key == CODED) {            if (keyCode == UP) {                boardY = boardY - 7;            } else if (keyCode == DOWN) {                boardY = boardY + 7;            }        }        if (key == CODED) {            if (keyCode == RIGHT) {                xspeed = 20;            }        }        if (key == CODED) {            if (keyCode == LEFT) {                xspeed = 8;            }        }    }}',correct
'xspeed = 8',correct
'boardY = boardY + (yspeed * ydirection)',correct
'boardY + 7',correct
'boardY + 6',correct
'color(random(0, 255), random(0, 255), random(0, 255))',correct
'boardX > width - 100 || boardX < 100',correct
'// CONSTRUCTOR',AtLeastOneConstructor
'borderbounce()',correct
'int mastColor = color(0, 0, 0)',correct
'boardX + 40',correct
'boardX = boardX + (xspeed * xdirection);',correct
'amountGuns = 10',correct
'ellipse(boardX, boardY, 120, 15)',correct
'{    rect(100, ypos, 1000, 15);}',correct
'int boardColor = color(255, 255, 255)',correct
'stroke(mastColor)',correct
'boardY - 70',correct
'boardY + (yspeed * ydirection)',correct
'if (key == CODED) {    if (keyCode == UP) {        boardY = boardY - 7;    } else if (keyCode == DOWN) {        boardY = boardY + 7;    }}',DecentralizedEventHandlingRule
'boardY = boardY + 7;',correct
'PImage',correct
'// FUNCTIONS',AtLeastOneConstructor
'i < arrayofGun.length',correct
'traceColor = color(255)',correct
'new Gun[amountGuns]',correct
'fill(sailColor)',correct
'// SAILint sailColor = color(random(0, 255), random(0, 255), random(0, 255));',correct
'{    if (mouseX < 100) {        if (mouseY > ypos && mouseY < ypos + 70) {            rect(100, ypos, 1000, 15);        }    }}',correct
'if (boardX > width - 100 || boardX < 100) {    xdirection *= -1;}',correct
'new Board(300, 300)',correct
'boardA = new Board(300, 300)',correct
'"data/watergun.png"',correct
'fill(boardColor)',correct
'boardX + 55',correct
'[amountGuns]',correct
'boardX + 60',correct
'keyPressed()',correct
'ypos + 70',correct
'{    arrayofGun[i] = new Gun();}',correct
'{    background(27, 202, 245);    // CALL FUNCTIONALITY    boardA.run();    for (int i = 0; i < arrayofGun.length; i++) {        arrayofGun[i].display(70 * i);    }}',correct
'line(boardX, boardY, boardX, boardY - 200);',correct
'boardY = boardY + 7',correct
'void mousePressed() {    if (mouseX < 100) {        if (mouseY > ypos && mouseY < ypos + 70) {            rect(100, ypos, 1000, 15);        }    }}',AtLeastOneConstructor
'for (int i = 0; i < arrayofGun.length; i++) {    arrayofGun[i] = new Gun();}',correct
'void setup() {    // INITIALIZE    boardA = new Board(300, 300);    for (int i = 0; i < arrayofGun.length; i++) {        arrayofGun[i] = new Gun();    }}',correct
'run',correct
'{    xspeed = 20;}',correct
'boardX = initX;',correct
'arrayofGun[i].display(70 * i)',correct
'boardY = initY;',correct
'boardY = boardY - 7;',correct
'float yspeed = 2;',correct
'float imageY;',AtLeastOneConstructor
'if (key == CODED) {    if (keyCode == LEFT) {        xspeed = 8;    }}',DecentralizedEventHandlingRule
'{    boardX = initX;    boardY = initY;    boardX = width / 2;}',correct
'Gun[]',correct
'{    if (keyCode == LEFT) {        xspeed = 8;    }}',correct
'triangle(boardX + 60, boardY + 22, boardX + 55, boardY + 6, boardX + 40, boardY + 7)',correct
'70 * i',correct
'line(boardX, boardY, boardX, boardY - 200)',correct
'// TRACEint traceColor = color(255);',correct
'key == CODED',correct
'strokeWeight(3);',correct
'boardX + (xspeed * xdirection)',correct
'{    if (keyCode == UP) {        boardY = boardY - 7;    } else if (keyCode == DOWN) {        boardY = boardY + 7;    }}',correct
'// BOARD',correct
'triangle(boardX, boardY, boardX, boardY - 200, boardX + 90, boardY - 70)',correct
'int xdirection = 1;',correct
'{    // BOARD    // white    int boardColor = color(255, 255, 255);    fill(boardColor);    stroke(0);    ellipse(boardX, boardY, 120, 15);    ellipseMode(CENTER);    // FIN    triangle(boardX + 60, boardY + 22, boardX + 55, boardY + 6, boardX + 40, boardY + 7);    // MAST    // black    int mastColor = color(0, 0, 0);    fill(mastColor);    strokeWeight(3);    stroke(mastColor);    line(boardX, boardY, boardX, boardY - 200);    // SAIL    int sailColor = color(random(0, 255), random(0, 255), random(0, 255));    fill(sailColor);    strokeWeight(0);    triangle(boardX, boardY, boardX, boardY - 200, boardX + 90, boardY - 70);    // TRACE    int traceColor = color(255);    fill(traceColor);    strokeWeight(0);    line(boardX + 60, boardY + 22, boardX + 55, boardY);}',correct
'stroke(mastColor);',correct
'rect(100, ypos, 1000, 15)',correct
'{    xpos = 0;    ypos = imageY;    image(img, xpos, ypos, 100, 70);    bullitY = ypos;}',correct
'{    for (int i = 0; i < arrayofGun.length; i++) {        arrayofGun[i].mousePressed();    }}',correct
'// BOARD// whiteint boardColor = color(255, 255, 255);',correct
'mouseY < ypos + 70',correct
'xdirection *= -1;',correct
'Processing',correct
'// GLOBAL VARIABLESPImage img = loadImage("data/watergun.png");',AtLeastOneConstructor
'if (keyCode == UP) {    boardY = boardY - 7;} else if (keyCode == DOWN) {    boardY = boardY + 7;}',DecentralizedEventHandlingRule
'if (keyCode == DOWN) {    boardY = boardY + 7;}',DecentralizedEventHandlingRule
'Gun[] arrayofGun = new Gun[amountGuns];',correct
'int traceColor = color(255)',correct
'xspeed = 20',correct
'if (key == CODED) {    if (keyCode == RIGHT) {        xspeed = 20;    }}',DecentralizedEventHandlingRule
'xpos',correct
'fill(mastColor)',correct
'int i = 0',correct
'ellipseMode(CENTER);',correct
'line(boardX + 60, boardY + 22, boardX + 55, boardY);',correct
'setup',correct
'{    arrayofGun[i].display(70 * i);}',correct
'i = 0',correct
'Board boardA;',correct
'mouseY > ypos',correct
'ypos',correct
'rect(100, ypos, 1000, 15);',PixelHardcodeIgnoranceRule
'imageY',correct
'color(255)',correct
'imageX',correct
'// CONSTRUCTORBoard(float initX, float initY) {    boardX = initX;    boardY = initY;    boardX = width / 2;}',correct
'arrayofGun[i] = new Gun()',correct
'{    // INITIALIZE    boardA = new Board(300, 300);    for (int i = 0; i < arrayofGun.length; i++) {        arrayofGun[i] = new Gun();    }}',correct
'color(255, 255, 255)',correct
'mouseX < 100',correct
'void borderbounce() {    boardX = boardX + (xspeed * xdirection);    boardY = boardY + (yspeed * ydirection);    if (boardX > width - 100 || boardX < 100) {        xdirection *= -1;    }}',correct
'{    if (key == CODED) {        if (keyCode == UP) {            boardY = boardY - 7;        } else if (keyCode == DOWN) {            boardY = boardY + 7;        }    }    if (key == CODED) {        if (keyCode == RIGHT) {            xspeed = 20;        }    }    if (key == CODED) {        if (keyCode == LEFT) {            xspeed = 8;        }    }}',correct
'Board',correct
'xpos = 0;',correct
'// MAST// blackint mastColor = color(0, 0, 0);',correct
'bullitY = ypos',correct
'arrayofGun[i].mousePressed()',correct
'boardY + 22',correct
'Gun',correct
'fill(traceColor)',correct
'xspeed = 8;',correct
'keyCode == LEFT',correct
'keyPressed();',correct
'image(img, xpos, ypos, 100, 70);',correct
'// DECLAREfloat imageX;',correct
'float bullitX, bullitY;',AtLeastOneConstructor
'fill(traceColor);',correct
'ydirection = 0',correct
'boardX = width / 2;',correct
'xdirection = 1',correct
'mastColor = color(0, 0, 0)',correct
'// FUNCTIONSvoid run() {    display();    borderbounce();    keyPressed();}',correct
'for (int i = 0; i < arrayofGun.length; i++) {    arrayofGun[i].display(70 * i);}',correct
'boardY = initY',correct
'line(boardX + 60, boardY + 22, boardX + 55, boardY)',correct
'img = loadImage("data/watergun.png")',correct
'keyCode == UP',correct
'if (mouseX < 100) {    if (mouseY > ypos && mouseY < ypos + 70) {        rect(100, ypos, 1000, 15);    }}',DecentralizedEventHandlingRule
'fill(sailColor);',correct
'sailColor = color(random(0, 255), random(0, 255), random(0, 255))',correct
'// MAST',correct
'new Gun()',correct
'keyCode == RIGHT',correct
'boardY = boardY + (yspeed * ydirection);',correct
'if (keyCode == LEFT) {    xspeed = 8;}',DecentralizedEventHandlingRule
'float xpos, ypos;',correct
'display',correct
'// INITIALIZEboardA = new Board(300, 300);',correct
'strokeWeight(0)',correct
'draw',correct
'triangle(boardX, boardY, boardX, boardY - 200, boardX + 90, boardY - 70);',correct
'{    boardX = boardX + (xspeed * xdirection);    boardY = boardY + (yspeed * ydirection);    if (boardX > width - 100 || boardX < 100) {        xdirection *= -1;    }}',correct
'bullitX',correct
'bullitY',correct
'fill(mastColor);',correct
'width - 100',correct
'{    boardY = boardY + 7;}',correct
'arrayofGun[i].display(70 * i);',correct
'display()',correct
'float initX',correct
'float initY',correct
'i++',correct
'class Gun {    // GLOBAL VARIABLES    PImage img = loadImage("data/watergun.png");    float xpos, ypos;    float bullitX, bullitY;    float imageY;    // CONSTRUCTOR    // FUNCTIONS    void display(float imageY) {        xpos = 0;        ypos = imageY;        image(img, xpos, ypos, 100, 70);        bullitY = ypos;    }    void mousePressed() {        if (mouseX < 100) {            if (mouseY > ypos && mouseY < ypos + 70) {                rect(100, ypos, 1000, 15);            }        }    }}',correct
'int amountGuns = 10;',correct
'boardY - 200',correct
'arrayofGun[i]',correct
'float imageY',correct
'ellipseMode(CENTER)',correct
'arrayofGun.length',correct
'void draw() {    background(27, 202, 245);    // CALL FUNCTIONALITY    boardA.run();    for (int i = 0; i < arrayofGun.length; i++) {        arrayofGun[i].display(70 * i);    }}',correct
'strokeWeight(3)',correct
'keyCode == DOWN',correct
'ypos = imageY;',correct
'void mousePressed() {    for (int i = 0; i < arrayofGun.length; i++) {        arrayofGun[i].mousePressed();    }}',correct
'// CONSTRUCTOR// FUNCTIONSvoid display(float imageY) {    xpos = 0;    ypos = imageY;    image(img, xpos, ypos, 100, 70);    bullitY = ypos;}',AtLeastOneConstructor
'boardA',correct
'void',correct
'-1',correct
'background(27, 202, 245);',correct
'{    xdirection *= -1;}',correct
'if (keyCode == RIGHT) {    xspeed = 20;}',DecentralizedEventHandlingRule
'color(0, 0, 0)',correct
'boardY - 7',correct
'{    boardY = boardY - 7;}',correct
'if (mouseY > ypos && mouseY < ypos + 70) {    rect(100, ypos, 1000, 15);}',DecentralizedEventHandlingRule
'arrayofGun = new Gun[amountGuns]',correct
'boardX = boardX + (xspeed * xdirection)',correct
'boardX',correct
'arrayofGun[i] = new Gun();',correct
'// CALL FUNCTIONALITYboardA.run();',correct
'boardY',correct
'{    if (mouseY > ypos && mouseY < ypos + 70) {        rect(100, ypos, 1000, 15);    }}',correct
'{    if (keyCode == RIGHT) {        xspeed = 20;    }}',correct
'ypos = imageY',correct
'{    xspeed = 8;}',correct
'{    arrayofGun[i].mousePressed();}',correct
'fill(boardColor);',correct
'boardX = width / 2',correct
'// FINtriangle(boardX + 60, boardY + 22, boardX + 55, boardY + 6, boardX + 40, boardY + 7);',correct
'boardX + 90',correct
'bullitY = ypos;',correct
'image(img, xpos, ypos, 100, 70)',correct
'xpos = 0',correct
'mouseY > ypos && mouseY < ypos + 70',correct
'xdirection *= -1',correct
'boardA.run()',correct
'yspeed = 2',correct
'strokeWeight(0);',correct
'void keyPressed() {    if (key == CODED) {        if (keyCode == UP) {            boardY = boardY - 7;        } else if (keyCode == DOWN) {            boardY = boardY + 7;        }    }    if (key == CODED) {        if (keyCode == RIGHT) {            xspeed = 20;        }    }    if (key == CODED) {        if (keyCode == LEFT) {            xspeed = 8;        }    }}',correct
'// GLOBAL VARIABLESfloat boardX, boardY;',correct
'width / 2',correct
'void display() {    // BOARD    // white    int boardColor = color(255, 255, 255);    fill(boardColor);    stroke(0);    ellipse(boardX, boardY, 120, 15);    ellipseMode(CENTER);    // FIN    triangle(boardX + 60, boardY + 22, boardX + 55, boardY + 6, boardX + 40, boardY + 7);    // MAST    // black    int mastColor = color(0, 0, 0);    fill(mastColor);    strokeWeight(3);    stroke(mastColor);    line(boardX, boardY, boardX, boardY - 200);    // SAIL    int sailColor = color(random(0, 255), random(0, 255), random(0, 255));    fill(sailColor);    strokeWeight(0);    triangle(boardX, boardY, boardX, boardY - 200, boardX + 90, boardY - 70);    // TRACE    int traceColor = color(255);    fill(traceColor);    strokeWeight(0);    line(boardX + 60, boardY + 22, boardX + 55, boardY);}',correct
'float xspeed = 8;',correct
'loadImage("data/watergun.png")',correct
'boardX > width - 100',correct
'int sailColor = color(random(0, 255), random(0, 255), random(0, 255))',correct
'ellipse(boardX, boardY, 120, 15);',correct
'boardColor = color(255, 255, 255)',correct
'color(252, 218, 46)',correct
'hatfacecolor = color(252, 218, 46)',correct
'hatfacecolor = color(252, 218, 46);',correct
'float hatfaceYspeed = 10;',correct
'hatfaceXspeed = Xspeed;',correct
'hatfaceY > 0',correct
'hatfaces[i].bounce()',correct
'h1 = new Hatface(250, 250)',correct
'{    spressed = !spressed;    if (spressed == true) {        h1.speedupdate(0, 0);    } else {        h1.speedupdate(10, 10);    }}',correct
'hatfaceYspeed = Yspeed',correct
'random(3, 10)',correct
'h1.speedupdate(10, 10);',correct
'if (hatfaceX > 0 && hatfaceX < width / 2 && hatfaceY > 0 && hatfaceY < height / 2) {    hatfacecolor = color(255, 0, 0);} else if (hatfaceX > width / 2 && hatfaceX < width && hatfaceY > 0 && hatfaceY < height / 2) {    hatfacecolor = color(0, 0, 255);} else if (hatfaceX > 0 && hatfaceX < width / 2 && hatfaceY > height / 2 && hatfaceY < height) {    hatfacecolor = color(0, 255, 0);} else {    hatfacecolor = color(252, 218, 46);}',correct
'// hatface',correct
'ellipse(hatfaceX, hatfaceY, 30, 30)',correct
'hatfaceX > 0 && hatfaceX < width / 2 && hatfaceY > height / 2 && hatfaceY < height',correct
'h1.bounce()',correct
'// s key stops or starts bounceBoolean spressed;',correct
'if (hatfaceX > 0 && hatfaceX < width / 2 && hatfaceY > height / 2 && hatfaceY < height) {    hatfacecolor = color(0, 255, 0);} else {    hatfacecolor = color(252, 218, 46);}',correct
'rect(hatfaceX, hatfaceY - 30, 100, 20);',correct
'hatfaceYspeed = 10',correct
'for (int i = 0; i < hatfaces.length; i++) {    hatfaces[i].speedupdate(0, 0);}',correct
'hatfaceYspeed = hatfaceYspeed * -1;',correct
'color(255, 0, 0)',correct
'ellipse(hatfaceX, hatfaceY, 70, 80)',correct
'int hatfacecolor;',correct
'{    if (key == e || key == E) {        explode = true;    }    if (key == s || key == S) {        spressed = !spressed;        if (spressed == true) {            for (int i = 0; i < hatfaces.length; i++) {                hatfaces[i].speedupdate(0, 0);            }        } else {            for (int i = 0; i < hatfaces.length; i++) {                hatfaces[i].speedupdate(10, 10);            }        }    }}',correct
'{    if (hatfaceX > 0 && hatfaceX < width / 2 && hatfaceY > 0 && hatfaceY < height / 2) {        hatfacecolor = color(255, 0, 0);    } else if (hatfaceX > width / 2 && hatfaceX < width && hatfaceY > 0 && hatfaceY < height / 2) {        hatfacecolor = color(0, 0, 255);    } else if (hatfaceX > 0 && hatfaceX < width / 2 && hatfaceY > height / 2 && hatfaceY < height) {        hatfacecolor = color(0, 255, 0);    } else {        hatfacecolor = color(252, 218, 46);    }}',correct
'rect(hatfaceX, hatfaceY - 30, 100, 20)',correct
'E',correct
'rect(hatfaceX, hatfaceY - 40, 30, 20)',correct
'explode = true;',correct
'hatfacecolor',correct
'S',correct
'hatfaces[i].changecolor()',correct
'hatfaceXspeed = 10',correct
'color(0, 255, 0)',correct
'float hatfaceXspeed = 10;',correct
'rectMode(CENTER)',correct
'e',correct
'h1.bounce();',correct
'// e key makes arrayBoolean explode;',correct
'{    hatfacecolor = color(0, 0, 255);}',correct
'new Hatface(0, 0)',correct
'hatfaceX < width',correct
'hatfaces[i].speedupdate(0, 0);',correct
'hatfaceXspeed > 0',correct
'h1.changecolor();',correct
's',correct
'// hatface// hatrectMode(CENTER);',correct
'spressed == true',correct
'// Five assignment - My creature Hyeji Yun 2033879// The name of this creature is hatface.// This creature is based on Korean Character of initial.Hatface h1;',correct
'explode == true',correct
'hatfaceX > 0 && hatfaceX < width / 2 && hatfaceY > 0 && hatfaceY < height / 2',correct
'rectMode(CENTER);',correct
'// The name of this creature is hatface.',correct
'noStroke()',correct
'{    hatfaces[i] = new Hatface(0, 0);}',correct
'if (hatfaceY > height && hatfaceYspeed > 0) {    hatfaceYspeed = hatfaceYspeed * -1;}',correct
'hatfaceY < 0',correct
'hatfaceX > 0 && hatfaceX < width / 2 && hatfaceY > 0',correct
'{    for (int i = 0; i < hatfaces.length; i++) {        hatfaces[i].display();        hatfaces[i].bounce();        hatfaces[i].changecolor();    }}',correct
'hatfaceX < width / 2',correct
'hatfaces = new Hatface[9]',correct
'hatfaceY > height && hatfaceYspeed > 0',correct
'hatfaceYspeed > 0',correct
'void speedupdate(float Xspeed, float Yspeed) {    hatfaceXspeed = Xspeed;    hatfaceYspeed = Yspeed;}',correct
'key == s || key == S',correct
'{    hatfaces[i].display();    hatfaces[i].bounce();    hatfaces[i].changecolor();}',correct
'if (spressed == true) {    for (int i = 0; i < hatfaces.length; i++) {        hatfaces[i].speedupdate(0, 0);    }} else {    for (int i = 0; i < hatfaces.length; i++) {        hatfaces[i].speedupdate(10, 10);    }}',SimplifyBooleanExpressions
'{    h1.speedupdate(0, 0);}',correct
'fill(hatfacecolor)',correct
'key == E',correct
'h1.changecolor()',correct
'hatfaces[i].speedupdate(10, 10)',correct
'{    hatfacecolor = color(252, 218, 46);}',correct
'hatfaceY = hatfaceY + hatfaceYspeed;',correct
'height / 2',correct
'hatfaceX > width / 2 && hatfaceX < width && hatfaceY > 0 && hatfaceY < height / 2',correct
'{    hatfaces[i].speedupdate(10, 10);}',correct
'hatfaceXspeed = random(3, 10)',correct
'key == S',correct
'explode = false;',correct
'if (hatfaceY < 0 && hatfaceYspeed < 0) {    hatfaceYspeed = hatfaceYspeed * -1;}',correct
'hatfaceYspeed = Yspeed;',correct
'hatfaceY = inithatfaceY',correct
'void display() {    noStroke();    fill(hatfacecolor);    // hatface    // hat    rectMode(CENTER);    rect(hatfaceX, hatfaceY - 30, 100, 20);    rectMode(CENTER);    rect(hatfaceX, hatfaceY - 40, 30, 20);    // face    ellipseMode(CENTER);    ellipse(hatfaceX, hatfaceY, 70, 80);    fill(255);    noStroke();    ellipse(hatfaceX, hatfaceY, 30, 30);}',correct
'h1.speedupdate(0, 0)',correct
'h1',correct
'fill(255)',correct
'hatfaceY = hatfaceY + hatfaceYspeed',correct
'hatfaceXspeed = random(3, 10);',correct
'Processing',correct
'if (hatfaceX > width / 2 && hatfaceX < width && hatfaceY > 0 && hatfaceY < height / 2) {    hatfacecolor = color(0, 0, 255);} else if (hatfaceX > 0 && hatfaceX < width / 2 && hatfaceY > height / 2 && hatfaceY < height) {    hatfacecolor = color(0, 255, 0);} else {    hatfacecolor = color(252, 218, 46);}',correct
'explode = true',correct
'hatfaces[i].speedupdate(0, 0)',correct
'hatfaceY - 40',correct
'if (spressed == true) {    h1.speedupdate(0, 0);} else {    h1.speedupdate(10, 10);}',SimplifyBooleanExpressions
'{    h1 = new Hatface(250, 250);    explode = false;    spressed = false;    for (int i = 0; i < hatfaces.length; i++) {        hatfaces[i] = new Hatface(0, 0);    }}',correct
'spressed = !spressed;',correct
'hatfacecolor = color(0, 0, 255);',correct
'hatfaceY < height / 2',correct
'if (hatfaceX < 0 && hatfaceXspeed < 0) {    hatfaceXspeed = hatfaceXspeed * -1;}',correct
'hatfaceXspeed = Xspeed',correct
'[9]',correct
'hatfacecolor = color(0, 255, 0);',correct
'hatfaceX = inithatfaceX;',correct
'hatfaces[i].bounce();',correct
'false',correct
'fill(hatfacecolor);',correct
'hatfaceX > width / 2 && hatfaceX < width',correct
'color(0, 0, 255)',correct
'hatfaceY - 30',correct
'int i = 0',correct
'hatfaceX > 0 && hatfaceX < width / 2',correct
'hatfaces[i].display();',correct
'// faceellipseMode(CENTER);',correct
'float inithatfaceY',correct
'hatfaceX < 0',correct
'float inithatfaceX',correct
'{    hatfaces[i].speedupdate(0, 0);}',correct
'hatfaces[i].speedupdate(10, 10);',correct
'hatfaceXspeed = hatfaceXspeed * -1',correct
'hatfaces[i].changecolor();',correct
'hatfaceY > height / 2',correct
'i = 0',correct
'hatfacecolor = color(0, 255, 0)',correct
'void setup() {    h1 = new Hatface(250, 250);    explode = false;    spressed = false;    for (int i = 0; i < hatfaces.length; i++) {        hatfaces[i] = new Hatface(0, 0);    }}',correct
'void changecolor() {    if (hatfaceX > 0 && hatfaceX < width / 2 && hatfaceY > 0 && hatfaceY < height / 2) {        hatfacecolor = color(255, 0, 0);    } else if (hatfaceX > width / 2 && hatfaceX < width && hatfaceY > 0 && hatfaceY < height / 2) {        hatfacecolor = color(0, 0, 255);    } else if (hatfaceX > 0 && hatfaceX < width / 2 && hatfaceY > height / 2 && hatfaceY < height) {        hatfacecolor = color(0, 255, 0);    } else {        hatfacecolor = color(252, 218, 46);    }}',correct
'{    background(33, 188, 203);    h1.display();    h1.bounce();    h1.changecolor();    if (explode == true) {        for (int i = 0; i < hatfaces.length; i++) {            hatfaces[i].display();            hatfaces[i].bounce();            hatfaces[i].changecolor();        }    }}',correct
'spressed = false',correct
'{    for (int i = 0; i < hatfaces.length; i++) {        hatfaces[i].speedupdate(10, 10);    }}',correct
'spressed = false;',correct
'explode',correct
'hatfaceX > 0 && hatfaceX < width / 2 && hatfaceY > height / 2',correct
'hatfaceX + hatfaceXspeed',correct
'for (int i = 0; i < hatfaces.length; i++) {    hatfaces[i] = new Hatface(0, 0);}',correct
'Boolean',correct
'spressed = !spressed',correct
'hatfaceYspeed < 0',correct
'class Hatface {    int hatfacecolor;    float hatfaceX;    float hatfaceY;    float hatfaceXspeed = 10;    float hatfaceYspeed = 10;    // Hatface constructor: initialize the variables    Hatface(float inithatfaceX, float inithatfaceY) {        hatfaceX = inithatfaceX;        hatfaceY = inithatfaceY;        hatfacecolor = color(252, 218, 46);        hatfaceXspeed = random(3, 10);        hatfaceYspeed = random(3, 10);    }    void display() {        noStroke();        fill(hatfacecolor);        // hatface        // hat        rectMode(CENTER);        rect(hatfaceX, hatfaceY - 30, 100, 20);        rectMode(CENTER);        rect(hatfaceX, hatfaceY - 40, 30, 20);        // face        ellipseMode(CENTER);        ellipse(hatfaceX, hatfaceY, 70, 80);        fill(255);        noStroke();        ellipse(hatfaceX, hatfaceY, 30, 30);    }    void bounce() {        hatfaceX = hatfaceX + hatfaceXspeed;        hatfaceY = hatfaceY + hatfaceYspeed;        if (hatfaceX > width && hatfaceXspeed > 0) {            hatfaceXspeed = hatfaceXspeed * -1;        }        if (hatfaceX < 0 && hatfaceXspeed < 0) {            hatfaceXspeed = hatfaceXspeed * -1;        }        if (hatfaceY > height && hatfaceYspeed > 0) {            hatfaceYspeed = hatfaceYspeed * -1;        }        if (hatfaceY < 0 && hatfaceYspeed < 0) {            hatfaceYspeed = hatfaceYspeed * -1;        }    }    void speedupdate(float Xspeed, float Yspeed) {        hatfaceXspeed = Xspeed;        hatfaceYspeed = Yspeed;    }    void changecolor() {        if (hatfaceX > 0 && hatfaceX < width / 2 && hatfaceY > 0 && hatfaceY < height / 2) {            hatfacecolor = color(255, 0, 0);        } else if (hatfaceX > width / 2 && hatfaceX < width && hatfaceY > 0 && hatfaceY < height / 2) {            hatfacecolor = color(0, 0, 255);        } else if (hatfaceX > 0 && hatfaceX < width / 2 && hatfaceY > height / 2 && hatfaceY < height) {            hatfacecolor = color(0, 255, 0);        } else {            hatfacecolor = color(252, 218, 46);        }    }}',correct
'hatfaceX = inithatfaceX',correct
'{    noStroke();    fill(hatfacecolor);    // hatface    // hat    rectMode(CENTER);    rect(hatfaceX, hatfaceY - 30, 100, 20);    rectMode(CENTER);    rect(hatfaceX, hatfaceY - 40, 30, 20);    // face    ellipseMode(CENTER);    ellipse(hatfaceX, hatfaceY, 70, 80);    fill(255);    noStroke();    ellipse(hatfaceX, hatfaceY, 30, 30);}',correct
'{    hatfaceX = inithatfaceX;    hatfaceY = inithatfaceY;    hatfacecolor = color(252, 218, 46);    hatfaceXspeed = random(3, 10);    hatfaceYspeed = random(3, 10);}',correct
'{    hatfacecolor = color(0, 255, 0);}',correct
'noStroke();',correct
'{    hatfaceXspeed = Xspeed;    hatfaceYspeed = Yspeed;}',correct
'hatfaceYspeed = hatfaceYspeed * -1',correct
'i < hatfaces.length',correct
'{    hatfaceX = hatfaceX + hatfaceXspeed;    hatfaceY = hatfaceY + hatfaceYspeed;    if (hatfaceX > width && hatfaceXspeed > 0) {        hatfaceXspeed = hatfaceXspeed * -1;    }    if (hatfaceX < 0 && hatfaceXspeed < 0) {        hatfaceXspeed = hatfaceXspeed * -1;    }    if (hatfaceY > height && hatfaceYspeed > 0) {        hatfaceYspeed = hatfaceYspeed * -1;    }    if (hatfaceY < 0 && hatfaceYspeed < 0) {        hatfaceYspeed = hatfaceYspeed * -1;    }}',correct
'{    spressed = !spressed;    if (spressed == true) {        for (int i = 0; i < hatfaces.length; i++) {            hatfaces[i].speedupdate(0, 0);        }    } else {        for (int i = 0; i < hatfaces.length; i++) {            hatfaces[i].speedupdate(10, 10);        }    }}',correct
'float hatfaceY;',correct
'key == e',correct
'explode = false',correct
'{    hatfaceXspeed = hatfaceXspeed * -1;}',correct
'h1.display();',correct
'{    for (int i = 0; i < hatfaces.length; i++) {        hatfaces[i].speedupdate(0, 0);    }}',correct
'hatfaceX > width / 2 && hatfaceX < width && hatfaceY > 0',correct
'// Five assignment - My creature Hyeji Yun 2033879',correct
'hatfacecolor = color(0, 0, 255)',correct
'key == s',correct
'void draw() {    background(33, 188, 203);    h1.display();    h1.bounce();    h1.changecolor();    if (explode == true) {        for (int i = 0; i < hatfaces.length; i++) {            hatfaces[i].display();            hatfaces[i].bounce();            hatfaces[i].changecolor();        }    }}',correct
'rect(hatfaceX, hatfaceY - 40, 30, 20);',correct
'spressed',correct
'{    hatfacecolor = color(255, 0, 0);}',correct
'hatfaceYspeed = random(3, 10);',correct
'float hatfaceX;',correct
'display',correct
'ellipse(hatfaceX, hatfaceY, 30, 30);',correct
'hatfaceY < height',correct
'ellipse(hatfaceX, hatfaceY, 70, 80);',correct
'!spressed',correct
'{    explode = true;}',correct
'hatfaceX > 0',correct
'hatfaces[i] = new Hatface(0, 0);',correct
'// Hatface constructor: initialize the variablesHatface(float inithatfaceX, float inithatfaceY) {    hatfaceX = inithatfaceX;    hatfaceY = inithatfaceY;    hatfacecolor = color(252, 218, 46);    hatfaceXspeed = random(3, 10);    hatfaceYspeed = random(3, 10);}',correct
'hatfaceX < 0 && hatfaceXspeed < 0',correct
'Hatface[] hatfaces = new Hatface[9];',correct
'background(33, 188, 203)',correct
'Hatface',correct
'key == e || key == E',correct
'for (int i = 0; i < hatfaces.length; i++) {    hatfaces[i].display();    hatfaces[i].bounce();    hatfaces[i].changecolor();}',correct
'i++',correct
'{    hatfaceYspeed = hatfaceYspeed * -1;}',correct
'if (hatfaceX > width && hatfaceXspeed > 0) {    hatfaceXspeed = hatfaceXspeed * -1;}',correct
'fill(255);',correct
'ellipseMode(CENTER)',correct
'hatfaceYspeed = random(3, 10)',correct
'hatfaceY',correct
'float Yspeed',correct
'hatfaceX',correct
'h1.speedupdate(0, 0);',correct
'hatfaces[i].display()',correct
'hatfaceX > width && hatfaceXspeed > 0',correct
'hatfacecolor = color(255, 0, 0)',correct
'void',correct
'-1',correct
'if (explode == true) {    for (int i = 0; i < hatfaces.length; i++) {        hatfaces[i].display();        hatfaces[i].bounce();        hatfaces[i].changecolor();    }}',SimplifyBooleanExpressions
'hatfacecolor = color(255, 0, 0);',correct
'new Hatface[9]',correct
'if (key == e || key == E) {    explode = true;}',correct
'hatfaces[i]',correct
'true',correct
'if (key == s || key == S) {    spressed = !spressed;    if (spressed == true) {        for (int i = 0; i < hatfaces.length; i++) {            hatfaces[i].speedupdate(0, 0);        }    } else {        for (int i = 0; i < hatfaces.length; i++) {            hatfaces[i].speedupdate(10, 10);        }    }}',correct
'h1.display()',correct
'hatfaceYspeed * -1',correct
'hatfaceY = inithatfaceY;',correct
'float Xspeed',correct
'hatfaceX > width',correct
'h1.speedupdate(10, 10)',correct
'h1 = new Hatface(250, 250);',correct
'hatfaceX = hatfaceX + hatfaceXspeed;',correct
'hatfaces.length',correct
'{    h1.speedupdate(10, 10);}',correct
'Hatface[]',correct
'void bounce() {    hatfaceX = hatfaceX + hatfaceXspeed;    hatfaceY = hatfaceY + hatfaceYspeed;    if (hatfaceX > width && hatfaceXspeed > 0) {        hatfaceXspeed = hatfaceXspeed * -1;    }    if (hatfaceX < 0 && hatfaceXspeed < 0) {        hatfaceXspeed = hatfaceXspeed * -1;    }    if (hatfaceY > height && hatfaceYspeed > 0) {        hatfaceYspeed = hatfaceYspeed * -1;    }    if (hatfaceY < 0 && hatfaceYspeed < 0) {        hatfaceYspeed = hatfaceYspeed * -1;    }}',correct
'new Hatface(250, 250)',correct
'hatfaceXspeed * -1',correct
'hatfaceX > width / 2',correct
'hatfaceY + hatfaceYspeed',correct
'hatfaceY < 0 && hatfaceYspeed < 0',correct
'hatfaces[i] = new Hatface(0, 0)',correct
'for (int i = 0; i < hatfaces.length; i++) {    hatfaces[i].speedupdate(10, 10);}',correct
'hatfaceY > height',correct
'// This creature is based on Korean Character of initial.',correct
'void keyPressed() {    if (key == e || key == E) {        explode = true;    }    if (key == s || key == S) {        spressed = !spressed;        if (spressed == true) {            for (int i = 0; i < hatfaces.length; i++) {                hatfaces[i].speedupdate(0, 0);            }        } else {            for (int i = 0; i < hatfaces.length; i++) {                hatfaces[i].speedupdate(10, 10);            }        }    }}',correct
'width / 2',correct
'hatfaceXspeed = hatfaceXspeed * -1;',correct
'background(33, 188, 203);',correct
'hatfaceXspeed < 0',correct
'hatfaceX = hatfaceX + hatfaceXspeed',correct
'void mousePressed() {    spressed = !spressed;    if (spressed == true) {        h1.speedupdate(0, 0);    } else {        h1.speedupdate(10, 10);    }}',correct
'random(width)',correct
'footColor',correct
'float minDist = others[i].diameter / 2 + diameter / 2',correct
'/*  MaryCaroline Georges S1840711 Creative Technology Programming Assignment 1 */',correct
'ellipse(posX - 11, posY - 20, 8, 25);',correct
'sin(angle) * minDist',correct
'// changing the feet color and mouth heightif (mousePressed) {    footColor = color(0, 255, 0);    mouthposY = 2;} else {    footColor = color(206, 0, 3);    mouthposY = 12;}',correct
'posX + diameter / 2',correct
'/*  MaryCaroline Georges S1840711 Creative Technology Programming Assignment 1 */// GLOBAL VARIABLES (used everywhere)int numCreatures = 30;',correct
'posY = diameter / 2',correct
'fill(footColor)',correct
'creatures[i]',correct
'ellipse(posX - 30, posY + 40, 45, 30)',correct
'velY += gravity',correct
'float angle = atan2(dposY, dposX);',correct
'ellipse(posX - 23, posY, 20, 10);',correct
'// DECLARATION of an array type creatureClass',correct
'{    // color for both hands    fill(255, 173, 241);    // left hand    ellipse(posX - 58, posY, 25, 45);    // right hand    ellipse(posX + 58, posY, 25, 45);    // color for both feet    fill(footColor);    // left foot    ellipse(posX - 30, posY + 40, 45, 30);    // right foot    ellipse(posX + 30, posY + 40, 45, 30);    // body    fill(255, 173, 241);    ellipse(posX, posY, diameter, diameter);    // mouth    fill(219, 0, 33);    ellipse(posX, posY + 10, 12, mouthposY);    // black eye    fill(0, 0, 0);    ellipse(posX - 11, posY - 20, 12, 30);    ellipse(posX + 11, posY - 20, 12, 30);    // blue eye    fill(0, 107, 252);    ellipse(posX - 11, posY - 20, 8, 25);    ellipse(posX + 11, posY - 20, 8, 25);    // small black eye    fill(0, 0, 0);    ellipse(posX - 11, posY - 25, 10, 18);    ellipse(posX + 11, posY - 25, 10, 18);    // white eye    fill(255);    ellipse(posX - 11, posY - 27, 7, 11);    ellipse(posX + 11, posY - 27, 7, 11);    // cheeks    fill(277, 2, 160, 80);    ellipse(posX - 23, posY, 20, 10);    ellipse(posX + 23, posY, 20, 10);}',LongMethodRule
'fill(0, 0, 0)',correct
'dposY * dposY',correct
'// the objects will accelerate once they bounce off each otherfloat aposX = (targetposX - others[i].posX) * spring;',correct
'// color for both handsfill(255, 173, 241);',correct
'float distance = sqrt(dposX * dposX + dposY * dposY);',correct
'background(255);',correct
'ellipse(posX, posY, diameter, diameter);',correct
'footColor = color(206, 0, 3);',correct
'width - diameter / 2',correct
'// mouthfill(219, 0, 33);',correct
'posY = posYin;',correct
'others = oin',correct
'fill(219, 0, 33)',correct
'diameter = din;',correct
'// right footellipse(posX + 30, posY + 40, 45, 30);',correct
'// if the distance between the objects is smaller than the minimum distance allowed, the objects',correct
'// left footellipse(posX - 30, posY + 40, 45, 30);',correct
'creatures = new creatureClass[numCreatures]',correct
'// the posX and posY velocities which start at 0float velX, velY = 0;',correct
'mouthposY = 2',correct
'posX + 11',correct
'float dposY = others[i].posY - posY;',correct
'// created so the mouth height can be updatedint mouthposY;',correct
'// movementvelY += gravity;',correct
'distance < minDist',correct
'float dposY = others[i].posY - posY',correct
'color(0, 255, 0)',correct
'// left handellipse(posX - 58, posY, 25, 45);',correct
'posX + cos(angle) * minDist',correct
'posY - 27',correct
'color(206, 0, 3)',correct
'random(height)',correct
'posY + sin(angle) * minDist',correct
'mouthposY = 12;',correct
'fill(277, 2, 160, 80)',correct
'float angle = atan2(dposY, dposX)',correct
'posY - 25',correct
'// the posX and posY positionsfloat posX, posY;',correct
'footColor = color(0, 255, 0);',correct
'posX = diameter / 2',correct
'velX',correct
'posX + 23',correct
'// DECLARATION of the other objects being named otherscreatureClass[] others;',correct
'creatures[i].update();',correct
'ellipse(posX - 11, posY - 25, 10, 18);',correct
'posY - 20',correct
'others[i].diameter',correct
'others[i]',correct
'// collisionfor (int i = 0; i < numCreatures; i++) {    float dposX = others[i].posX - posX;    float dposY = others[i].posY - posY;    float distance = sqrt(dposX * dposX + dposY * dposY);    float minDist = others[i].diameter / 2 + diameter / 2;    // will bounce off in the opposite direction at an angle    if (distance < minDist) {        float angle = atan2(dposY, dposX);        float targetposX = posX + cos(angle) * minDist;        float targetposY = posY + sin(angle) * minDist;        // the objects will accelerate once they bounce off each other        float aposX = (targetposX - others[i].posX) * spring;        float aposY = (targetposY - others[i].posY) * spring;        velX -= aposX;        velY -= aposY;        others[i].velX += aposX;        others[i].velY += aposY;    }}',correct
'float dposX = others[i].posX - posX',correct
'void update() {    // collision    for (int i = 0; i < numCreatures; i++) {        float dposX = others[i].posX - posX;        float dposY = others[i].posY - posY;        float distance = sqrt(dposX * dposX + dposY * dposY);        float minDist = others[i].diameter / 2 + diameter / 2;        // will bounce off in the opposite direction at an angle        if (distance < minDist) {            float angle = atan2(dposY, dposX);            float targetposX = posX + cos(angle) * minDist;            float targetposY = posY + sin(angle) * minDist;            // the objects will accelerate once they bounce off each other            float aposX = (targetposX - others[i].posX) * spring;            float aposY = (targetposY - others[i].posY) * spring;            velX -= aposX;            velY -= aposY;            others[i].velX += aposX;            others[i].velY += aposY;        }    }    // movement    velY += gravity;    posX += velX;    posY += velY;    // bouncing off the walls    if (posX + diameter / 2 > width) {        posX = width - diameter / 2;        velX *= friction;    } else if (posX - diameter / 2 < 0) {        posX = diameter / 2;        velX *= friction;    }    if (posY + diameter / 2 > height) {        posY = height - diameter / 2;        velY *= friction;    } else if (posY - diameter / 2 < 0) {        posY = diameter / 2;        velY *= friction;    }    // changing the feet color and mouth height    if (mousePressed) {        footColor = color(0, 255, 0);        mouthposY = 2;    } else {        footColor = color(206, 0, 3);        mouthposY = 12;    }}',correct
'friction = -1',correct
'float distance = sqrt(dposX * dposX + dposY * dposY)',correct
'creatures[i] = new creatureClass(random(width), random(height), 100, creatures);',correct
'if (posY + diameter / 2 > height) {    posY = height - diameter / 2;    velY *= friction;} else if (posY - diameter / 2 < 0) {    posY = diameter / 2;    velY *= friction;}',correct
'posX + 30',correct
'diameter',correct
'// a common type of for-loop iterating through the array of objects',correct
'posX + diameter / 2 > width',correct
'others[i].posY - posY',correct
'velY -= aposY',correct
'others',correct
'float targetposX = posX + cos(angle) * minDist',correct
'float targetposX = posX + cos(angle) * minDist;',correct
'velX *= friction',correct
'velY -= aposY;',correct
'velY = 0',correct
'ellipse(posX + 23, posY, 20, 10);',correct
'others[i].diameter / 2 + diameter / 2',correct
'posX',correct
'posY',correct
'posX = posXin;',correct
'{    footColor = color(206, 0, 3);    mouthposY = 12;}',DecentralizedEventHandlingRule
'(targetposX - others[i].posX) * spring',correct
'diameter = din',correct
'ellipse(posX + 11, posY - 27, 7, 11);',correct
'0.03f',correct
'others[i].velY += aposY;',correct
'float targetposY = posY + sin(angle) * minDist;',correct
'// small black eyefill(0, 0, 0);',correct
'footColor = color(206, 0, 3)',correct
'// bodyfill(255, 173, 241);',correct
'i < numCreatures',correct
'update',LongMethodRule
'float din',correct
'new creatureClass[numCreatures]',correct
'posX = posXin',correct
'fill(255)',correct
'ellipse(posX + 11, posY - 20, 8, 25);',correct
'{    // collision    for (int i = 0; i < numCreatures; i++) {        float dposX = others[i].posX - posX;        float dposY = others[i].posY - posY;        float distance = sqrt(dposX * dposX + dposY * dposY);        float minDist = others[i].diameter / 2 + diameter / 2;        // will bounce off in the opposite direction at an angle        if (distance < minDist) {            float angle = atan2(dposY, dposX);            float targetposX = posX + cos(angle) * minDist;            float targetposY = posY + sin(angle) * minDist;            // the objects will accelerate once they bounce off each other            float aposX = (targetposX - others[i].posX) * spring;            float aposY = (targetposY - others[i].posY) * spring;            velX -= aposX;            velY -= aposY;            others[i].velX += aposX;            others[i].velY += aposY;        }    }    // movement    velY += gravity;    posX += velX;    posY += velY;    // bouncing off the walls    if (posX + diameter / 2 > width) {        posX = width - diameter / 2;        velX *= friction;    } else if (posX - diameter / 2 < 0) {        posX = diameter / 2;        velX *= friction;    }    if (posY + diameter / 2 > height) {        posY = height - diameter / 2;        velY *= friction;    } else if (posY - diameter / 2 < 0) {        posY = diameter / 2;        velY *= friction;    }    // changing the feet color and mouth height    if (mousePressed) {        footColor = color(0, 255, 0);        mouthposY = 2;    } else {        footColor = color(206, 0, 3);        mouthposY = 12;    }}',LongMethodRule
'others[i].diameter / 2',correct
'Processing',correct
'background(255)',correct
'ellipse(posX + 11, posY - 20, 12, 30)',correct
'// LOCAL VARIABLES (only used in the class)',correct
'aposY = (targetposY - others[i].posY) * spring',correct
'posX + 58',correct
'// blue eyefill(0, 107, 252);',correct
'float aposY = (targetposY - others[i].posY) * spring',correct
'ellipse(posX - 11, posY - 27, 7, 11);',correct
'posY - diameter / 2',correct
'others = oin;',correct
'posY = height - diameter / 2;',correct
'creatureClass[] oin',correct
'posX += velX',correct
'ellipse(posX - 11, posY - 20, 8, 25)',correct
'ellipse(posX + 11, posY - 25, 10, 18);',correct
'{    creatures[i] = new creatureClass(random(width), random(height), 100, creatures);}',correct
'dposX * dposX',correct
'ellipse(posX + 11, posY - 25, 10, 18)',correct
'ellipse(posX - 58, posY, 25, 45)',correct
'int i = 0',correct
'ellipse(posX, posY + 10, 12, mouthposY)',correct
'0.05f',correct
'posY + 40',correct
'cos(angle) * minDist',correct
'setup',correct
'creatures[i] = new creatureClass(random(width), random(height), 100, creatures)',correct
'others[i].velX += aposX;',correct
'i = 0',correct
'footColor = color(0, 255, 0)',correct
'// color for both feetfill(footColor);',correct
'atan2(dposY, dposX)',correct
'distance = sqrt(dposX * dposX + dposY * dposY)',correct
'posX = width - diameter / 2',correct
'{    creatures[i].display();    creatures[i].update();}',correct
'posY - diameter / 2 < 0',correct
'velY *= friction;',correct
'posX - 11',correct
'mouthposY',correct
'(targetposY - others[i].posY) * spring',correct
'ellipse(posX - 11, posY - 20, 12, 30)',correct
'new creatureClass(random(width), random(height), 100, creatures)',correct
'ellipse(posX + 11, posY - 27, 7, 11)',correct
'mouthposY = 12',correct
'// cheeksfill(277, 2, 160, 80);',correct
'{    posX = diameter / 2;    velX *= friction;}',correct
'sqrt(dposX * dposX + dposY * dposY)',correct
'posY += velY',correct
'if (posX - diameter / 2 < 0) {    posX = diameter / 2;    velX *= friction;}',correct
'fill(0, 107, 252)',correct
'fill(255, 173, 241)',correct
'angle = atan2(dposY, dposX)',correct
'numCreatures = 30',correct
'ellipse(posX - 11, posY - 25, 10, 18)',correct
'// will bounce off in the opposite direction at an angleif (distance < minDist) {    float angle = atan2(dposY, dposX);    float targetposX = posX + cos(angle) * minDist;    float targetposY = posY + sin(angle) * minDist;    // the objects will accelerate once they bounce off each other    float aposX = (targetposX - others[i].posX) * spring;    float aposY = (targetposY - others[i].posY) * spring;    velX -= aposX;    velY -= aposY;    others[i].velX += aposX;    others[i].velY += aposY;}',correct
'posX - 23',correct
'posX = width - diameter / 2;',correct
'ellipse(posX - 11, posY - 27, 7, 11)',correct
'// white eyefill(255);',correct
'dposX = others[i].posX - posX',correct
'float targetposY = posY + sin(angle) * minDist',correct
'minDist = others[i].diameter / 2 + diameter / 2',correct
'velX -= aposX',correct
'posX = diameter / 2;',correct
'mouthposY = 2;',correct
'float aposY = (targetposY - others[i].posY) * spring;',correct
'posY += velY;',correct
'dposY = others[i].posY - posY',correct
'// right handellipse(posX + 58, posY, 25, 45);',correct
'posX - 30',correct
'ellipse(posX, posY + 10, 12, mouthposY);',correct
'void display() {    // color for both hands    fill(255, 173, 241);    // left hand    ellipse(posX - 58, posY, 25, 45);    // right hand    ellipse(posX + 58, posY, 25, 45);    // color for both feet    fill(footColor);    // left foot    ellipse(posX - 30, posY + 40, 45, 30);    // right foot    ellipse(posX + 30, posY + 40, 45, 30);    // body    fill(255, 173, 241);    ellipse(posX, posY, diameter, diameter);    // mouth    fill(219, 0, 33);    ellipse(posX, posY + 10, 12, mouthposY);    // black eye    fill(0, 0, 0);    ellipse(posX - 11, posY - 20, 12, 30);    ellipse(posX + 11, posY - 20, 12, 30);    // blue eye    fill(0, 107, 252);    ellipse(posX - 11, posY - 20, 8, 25);    ellipse(posX + 11, posY - 20, 8, 25);    // small black eye    fill(0, 0, 0);    ellipse(posX - 11, posY - 25, 10, 18);    ellipse(posX + 11, posY - 25, 10, 18);    // white eye    fill(255);    ellipse(posX - 11, posY - 27, 7, 11);    ellipse(posX + 11, posY - 27, 7, 11);    // cheeks    fill(277, 2, 160, 80);    ellipse(posX - 23, posY, 20, 10);    ellipse(posX + 23, posY, 20, 10);}',correct
'if (posY - diameter / 2 < 0) {    posY = diameter / 2;    velY *= friction;}',correct
'ellipse(posX - 23, posY, 20, 10)',correct
'// INITIALIZATION',correct
'posY + 10',correct
'others[i].velY += aposY',correct
'// the loop starts at index 0 and goes up to and EXCLUDING index numCreaturesfor (int i = 0; i < numCreatures; i++) {    creatures[i] = new creatureClass(random(width), random(height), 100, creatures);}',correct
'// DECLARATION of an array type creatureClass// creates a new array of creaturescreatureClass[] creatures = new creatureClass[numCreatures];',correct
'velX -= aposX;',correct
'[numCreatures]',correct
'display',LongMethodRule
'posY = height - diameter / 2',correct
'draw',correct
'{    float angle = atan2(dposY, dposX);    float targetposX = posX + cos(angle) * minDist;    float targetposY = posY + sin(angle) * minDist;    // the objects will accelerate once they bounce off each other    float aposX = (targetposX - others[i].posX) * spring;    float aposY = (targetposY - others[i].posY) * spring;    velX -= aposX;    velY -= aposY;    others[i].velX += aposX;    others[i].velY += aposY;}',correct
'diameter / 2',correct
'posY + diameter / 2 > height',correct
'{    background(255);    // the loop that allows for the name of creatures to be used for display and update functions for all    for (int i = 0; i < numCreatures; i++) {        creatures[i].display();        creatures[i].update();    }}',correct
'aposX = (targetposX - others[i].posX) * spring',correct
'{    footColor = color(0, 255, 0);    mouthposY = 2;}',DecentralizedEventHandlingRule
'dposX * dposX + dposY * dposY',correct
'float aposX = (targetposX - others[i].posX) * spring',correct
'// LOCAL VARIABLES (only used in the class)// causes objects bouncing off each otherfloat spring = 0.05f;',correct
'ellipse(posX + 23, posY, 20, 10)',correct
'{    posX = width - diameter / 2;    velX *= friction;}',correct
'cos(angle)',correct
'// bouncing off the wallsif (posX + diameter / 2 > width) {    posX = width - diameter / 2;    velX *= friction;} else if (posX - diameter / 2 < 0) {    posX = diameter / 2;    velX *= friction;}',correct
'targetposY = posY + sin(angle) * minDist',correct
'ellipse(posX + 58, posY, 25, 45)',correct
'others[i].velX += aposX',correct
'i++',correct
'sin(angle)',correct
'// black eyefill(0, 0, 0);',correct
'// draw function - does multiple timesvoid draw() {    background(255);    // the loop that allows for the name of creatures to be used for display and update functions for all    for (int i = 0; i < numCreatures; i++) {        creatures[i].display();        creatures[i].update();    }}',correct
'others[i].posX',correct
'others[i].posY',correct
'mousePressed',DecentralizedEventHandlingRule
'posX - 58',correct
'posX - diameter / 2',correct
'others[i].posX - posX',correct
'// creates speed once objects bounce off each otherfloat friction = -1;',correct
'float minDist = others[i].diameter / 2 + diameter / 2;',correct
'creatureClass[]',correct
'void',LongMethodRule
'velY *= friction',correct
'float posXin',correct
'-1',correct
'creatures[i].display()',correct
'// the loop that allows for the name of creatures to be used for display and update functions for allfor (int i = 0; i < numCreatures; i++) {    creatures[i].display();    creatures[i].update();}',correct
'ellipse(posX, posY, diameter, diameter)',correct
'creatures[i].display();',correct
'{    float dposX = others[i].posX - posX;    float dposY = others[i].posY - posY;    float distance = sqrt(dposX * dposX + dposY * dposY);    float minDist = others[i].diameter / 2 + diameter / 2;    // will bounce off in the opposite direction at an angle    if (distance < minDist) {        float angle = atan2(dposY, dposX);        float targetposX = posX + cos(angle) * minDist;        float targetposY = posY + sin(angle) * minDist;        // the objects will accelerate once they bounce off each other        float aposX = (targetposX - others[i].posX) * spring;        float aposY = (targetposY - others[i].posY) * spring;        velX -= aposX;        velY -= aposY;        others[i].velX += aposX;        others[i].velY += aposY;    }}',correct
'float dposX = others[i].posX - posX;',correct
'// OBJECT CONSTRUCTORcreatureClass(float posXin, float posYin, float din, creatureClass[] oin) {    posX = posXin;    posY = posYin;    diameter = din;    others = oin;}',correct
'posX - diameter / 2 < 0',correct
'{    posY = height - diameter / 2;    velY *= friction;}',correct
'ellipse(posX - 11, posY - 20, 12, 30);',correct
'targetposX = posX + cos(angle) * minDist',correct
'// creates the classclass creatureClass {    // LOCAL VARIABLES (only used in the class)    // causes objects bouncing off each other    float spring = 0.05f;    // creates gravity once they fall    float gravity = 0.03f;    // creates speed once objects bounce off each other    float friction = -1;    // the posX and posY positions    float posX, posY;    // creates an invisible diameter so that the creatures can collide with each other    float diameter;    // the posX and posY velocities which start at 0    float velX, velY = 0;    // created to the feet color can be updated    int footColor;    // created so the mouth height can be updated    int mouthposY;    // DECLARATION of the other objects being named others    creatureClass[] others;    // OBJECT CONSTRUCTOR    creatureClass(float posXin, float posYin, float din, creatureClass[] oin) {        posX = posXin;        posY = posYin;        diameter = din;        others = oin;    }    void display() {        // color for both hands        fill(255, 173, 241);        // left hand        ellipse(posX - 58, posY, 25, 45);        // right hand        ellipse(posX + 58, posY, 25, 45);        // color for both feet        fill(footColor);        // left foot        ellipse(posX - 30, posY + 40, 45, 30);        // right foot        ellipse(posX + 30, posY + 40, 45, 30);        // body        fill(255, 173, 241);        ellipse(posX, posY, diameter, diameter);        // mouth        fill(219, 0, 33);        ellipse(posX, posY + 10, 12, mouthposY);        // black eye        fill(0, 0, 0);        ellipse(posX - 11, posY - 20, 12, 30);        ellipse(posX + 11, posY - 20, 12, 30);        // blue eye        fill(0, 107, 252);        ellipse(posX - 11, posY - 20, 8, 25);        ellipse(posX + 11, posY - 20, 8, 25);        // small black eye        fill(0, 0, 0);        ellipse(posX - 11, posY - 25, 10, 18);        ellipse(posX + 11, posY - 25, 10, 18);        // white eye        fill(255);        ellipse(posX - 11, posY - 27, 7, 11);        ellipse(posX + 11, posY - 27, 7, 11);        // cheeks        fill(277, 2, 160, 80);        ellipse(posX - 23, posY, 20, 10);        ellipse(posX + 23, posY, 20, 10);    }    void update() {        // collision        for (int i = 0; i < numCreatures; i++) {            float dposX = others[i].posX - posX;            float dposY = others[i].posY - posY;            float distance = sqrt(dposX * dposX + dposY * dposY);            float minDist = others[i].diameter / 2 + diameter / 2;            // will bounce off in the opposite direction at an angle            if (distance < minDist) {                float angle = atan2(dposY, dposX);                float targetposX = posX + cos(angle) * minDist;                float targetposY = posY + sin(angle) * minDist;                // the objects will accelerate once they bounce off each other                float aposX = (targetposX - others[i].posX) * spring;                float aposY = (targetposY - others[i].posY) * spring;                velX -= aposX;                velY -= aposY;                others[i].velX += aposX;                others[i].velY += aposY;            }        }        // movement        velY += gravity;        posX += velX;        posY += velY;        // bouncing off the walls        if (posX + diameter / 2 > width) {            posX = width - diameter / 2;            velX *= friction;        } else if (posX - diameter / 2 < 0) {            posX = diameter / 2;            velX *= friction;        }        if (posY + diameter / 2 > height) {            posY = height - diameter / 2;            velY *= friction;        } else if (posY - diameter / 2 < 0) {            posY = diameter / 2;            velY *= friction;        }        // changing the feet color and mouth height        if (mousePressed) {            footColor = color(0, 255, 0);            mouthposY = 2;        } else {            footColor = color(206, 0, 3);            mouthposY = 12;        }    }}',correct
'spring = 0.05f',correct
'gravity = 0.03f',correct
'{    posY = diameter / 2;    velY *= friction;}',correct
'velX *= friction;',correct
'others[i].velX',correct
'others[i].velY',correct
'// creates an invisible diameter so that the creatures can collide with each otherfloat diameter;',correct
'creatures[i].update()',correct
'ellipse(posX + 11, posY - 20, 12, 30);',correct
'posY + diameter / 2',correct
'// setup function - only does oncevoid setup() {    // the loop starts at index 0 and goes up to and EXCLUDING index numCreatures    for (int i = 0; i < numCreatures; i++) {        creatures[i] = new creatureClass(random(width), random(height), 100, creatures);    }}',correct
'height - diameter / 2',correct
'posY = posYin',correct
'ellipse(posX + 30, posY + 40, 45, 30)',correct
'float posYin',correct
'{    // the loop starts at index 0 and goes up to and EXCLUDING index numCreatures    for (int i = 0; i < numCreatures; i++) {        creatures[i] = new creatureClass(random(width), random(height), 100, creatures);    }}',correct
'// creates gravity once they fallfloat gravity = 0.03f;',correct
'posX += velX;',correct
'posY = diameter / 2;',correct
'ellipse(posX + 11, posY - 20, 8, 25)',correct
'creatureClass',correct
'// created to the feet color can be updatedint footColor;',correct
'{    posX = posXin;    posY = posYin;    diameter = din;    others = oin;}',correct
'skyAutumn = color(18, 98, 226)',correct
'bearY - 60',correct
'dy = -dy;',correct
'Hunny[] hunnys = new Hunny[1];',correct
'ellipse(bearX, bearY + 20, size3, size3)',correct
'{    treeX = initX;    treeY = initY;    trunkColor = color(76, 69, 4);    leafColor = color(0, 132, 22);    leafSpring = color(0, 132, 22);    leafAutumn = color(226, 117, 0);}',correct
'Bear[] bears = new Bear[15];',correct
'// legsfill(bearColor);',correct
'ellipse(bearX - 50, bearY - 90, size2, size2);',correct
'class Bear {    float bearX;    float bearY;    float dx = random(2, 5);    float dy = random(2, 5);    float size1 = 120;    float size2 = 40;    float size3 = 70;    float size4 = 20;    float size5 = 15;    int bearColor;    int bearColor2;    int bodyColor;    int bodyColor2;    Bear(float initX, float initY) {        bearX = initX;        bearY = initY;        bearColor = color(160, 82, 45);        bearColor2 = color(205, 133, 63);        bodyColor = color(160, 82, 45);        bodyColor2 = color(205, 133, 63);    }    void display() {        // legs        fill(bearColor);        ellipse(bearX - 25, bearY + 80, size2, size3);        ellipse(bearX + 25, bearY + 80, size2, size3);        // body        fill(bearColor);        ellipse(bearX, bearY + 20, size1, size1);        fill(bearColor2);        ellipse(bearX, bearY + 20, size3, size3);        // head        fill(bearColor);        ellipse(bearX, bearY - 60, size1, 90);        // snout        fill(255, 182, 193);        arc(bearX, bearY - 37, size5, size5, 0, PI, CHORD);        fill(bearColor2);        ellipse(bearX, bearY - 45, size2, size4);        fill(0, 0, 0);        ellipse(bearX, bearY - 50, size5, 10);        // eyes        fill(255);        ellipse(bearX - 20, bearY - 70, size4, 25);        ellipse(bearX + 20, bearY - 70, size4, 25);        fill(0);        ellipse(bearX - 20, bearY - 70, size5, size5);        ellipse(bearX + 20, bearY - 70, size5, size5);        // ears        fill(bearColor);        noStroke();        ellipse(bearX - 50, bearY - 90, size2, size2);        ellipse(bearX + 50, bearY - 90, size2, size2);        fill(bearColor2);        arc(bearX - 50, bearY - 90, size4, size4, HALF_PI, 2 * PI, CHORD);        arc(bearX + 50, bearY - 90, size4, size4, -PI, PI - HALF_PI, CHORD);        // arms        fill(bearColor);        pushMatrix();        translate(bearX - 75, bearY + 20);        rotate(PI / 10.0f);        ellipse(0, 0, 35, size3);        popMatrix();        pushMatrix();        translate(bearX + 75, bearY + 20);        rotate(-PI / 10.0f);        ellipse(0, 0, 35, size3);        popMatrix();    }    void switchColors() {        bearColor = color(bodyColor2);        bearColor2 = color(bodyColor);    }    void changeToBlack() {        bearColor = color(0);        bearColor2 = color(255);    }    void changeToYellow() {        bearColor = color(0, 0, 255);        bearColor2 = color(255, 255, 0);    }    void changeColorBack() {        bearColor = color(bodyColor);        bearColor2 = color(bodyColor2);    }    void move() {        bearX = bearX + dx;        if (bearX > width - 95 && dx > 0 || (bearX < 95)) {            dx = -dx;        }        bearY = bearY + dy;        if ((bearY > height - 110 && dy > 0) || (bearY < 110)) {            dy = -dy;        }    }}',correct
'hunnyX - 20',correct
'hunnyY + 5',correct
'hunnys = new Hunny[1]',correct
'fill(skyColor)',correct
'float hunnyX;',correct
'bears[i]',correct
'cloudX - 70',correct
'rect(450, 800, 900, 200)',correct
'ellipse(bearX - 20, bearY - 70, size5, size5)',correct
'i < 2 * bears.length / 3',correct
'{    // legs    fill(bearColor);    ellipse(bearX - 25, bearY + 80, size2, size3);    ellipse(bearX + 25, bearY + 80, size2, size3);    // body    fill(bearColor);    ellipse(bearX, bearY + 20, size1, size1);    fill(bearColor2);    ellipse(bearX, bearY + 20, size3, size3);    // head    fill(bearColor);    ellipse(bearX, bearY - 60, size1, 90);    // snout    fill(255, 182, 193);    arc(bearX, bearY - 37, size5, size5, 0, PI, CHORD);    fill(bearColor2);    ellipse(bearX, bearY - 45, size2, size4);    fill(0, 0, 0);    ellipse(bearX, bearY - 50, size5, 10);    // eyes    fill(255);    ellipse(bearX - 20, bearY - 70, size4, 25);    ellipse(bearX + 20, bearY - 70, size4, 25);    fill(0);    ellipse(bearX - 20, bearY - 70, size5, size5);    ellipse(bearX + 20, bearY - 70, size5, size5);    // ears    fill(bearColor);    noStroke();    ellipse(bearX - 50, bearY - 90, size2, size2);    ellipse(bearX + 50, bearY - 90, size2, size2);    fill(bearColor2);    arc(bearX - 50, bearY - 90, size4, size4, HALF_PI, 2 * PI, CHORD);    arc(bearX + 50, bearY - 90, size4, size4, -PI, PI - HALF_PI, CHORD);    // arms    fill(bearColor);    pushMatrix();    translate(bearX - 75, bearY + 20);    rotate(PI / 10.0f);    ellipse(0, 0, 35, size3);    popMatrix();    pushMatrix();    translate(bearX + 75, bearY + 20);    rotate(-PI / 10.0f);    ellipse(0, 0, 35, size3);    popMatrix();}',correct
'skySpring',correct
'bearX + 25',correct
'ellipse(bearX, bearY - 50, size5, 10);',correct
'bearY - 50',correct
'trunkColor = color(76, 69, 4)',correct
'fill(0, 0, 0)',correct
'ellipse(bearX - 25, bearY + 80, size2, size3);',correct
'for (int i = 0; i < bears.length; i++) {    bears[i] = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));}',correct
'bearX = bearX + dx',correct
'{    hunnyX = initX;    hunnyY = initY;    mainColor = color(2, 154, 237);}',correct
'mainColor = color(2, 154, 237);',correct
'hunnys[0]',correct
'bearX + 20',correct
'fill(mainColor);',correct
'{    dy = -dy;}',correct
'treeY = initY;',correct
'int skyAutumn;',correct
'int trunkColor;',correct
'dy = random(2, 5)',correct
'grassColor = color(grassAutumn);',correct
'hunnys[0] = new Hunny(random(width), random(height))',correct
'ellipse(bearX - 50, bearY - 90, size2, size2)',correct
'bg',correct
'tree1.display();',correct
'color(skySpring)',correct
'PI / 10.0f',correct
'fill(0);',correct
'leafSpring = color(0, 132, 22);',correct
'cloudSpring',correct
'hunnys[i].gravity();',correct
'cloud1.display()',correct
'[15]',correct
'bearColor = color(bodyColor)',correct
'bearY = initY',correct
'ellipse(0, 0, 35, size3)',correct
'ellipse(hunnyX, hunnyY + 30, 35, 20);',correct
'random(2, 5)',correct
'bearColor2 = color(bodyColor2)',correct
'int mainColor;',correct
'new Cloud(250, 100)',correct
'fill(trunkColor);',correct
'for (int i = 0; i < bears.length; i++) {    bears[i].changeColorBack();}',correct
'rectMode(CENTER)',correct
'a',correct
'hunnys[i].display();',correct
'b',correct
'random(height)',correct
'cloud2.changeToSpring()',correct
'float speed = 1.5f;',correct
'leafSpring = color(0, 132, 22)',correct
'color(175)',correct
'Hunny[]',correct
'bears.length',correct
'tree3.display();',correct
'Bear[]',correct
'bearY - 70',correct
'l',correct
'// eyesfill(255);',correct
's',correct
'cloudAutumn = color(175);',correct
'float hunnyY;',correct
'bearX > width - 95',correct
'y',correct
'mainColor = color(2, 154, 237)',correct
'{    cloudX = cloudX + speed;    if (cloudX > width + 110)        cloudX = 0 - 100;}',correct
'rectMode(CENTER);',correct
'void mousePressed() {    Hunny n = new Hunny(mouseX, mouseY);    hunnys = (Hunny[]) append(hunnys, n);}',correct
'tree2.changeToAutumn()',correct
'bg = new Background();',correct
'grassColor = color(45, 209, 0);',correct
'rect(450, 350, 900, 700);',correct
'color(2, 154, 237)',correct
'bearY + 80',correct
'bears[i] = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));',correct
'cloudColor = color(255);',correct
'if (key == a) {    bg.changeToAutumn();    tree1.changeToAutumn();    tree2.changeToAutumn();    tree3.changeToAutumn();    cloud1.changeToAutumn();    cloud2.changeToAutumn();}',correct
'translate(bearX - 75, bearY + 20);',correct
'int grassSpring;',correct
'{    skyColor = color(skySpring);    grassColor = color(grassSpring);}',correct
'cloudSpring = color(255)',correct
'cloudColor = color(255)',correct
'color(grassSpring)',correct
'i < hunnys.length',correct
'{    for (int i = 10; i < bears.length; i++) {        bears[i].changeToYellow();    }}',correct
'text("HUNNY", hunnyX - 20, hunnyY + 5);',correct
'if (hunnyY > height) {    speed = speed * -0.95f;}',correct
'leafAutumn',correct
'color(160, 82, 45)',correct
'ellipse(cloudX - 70, cloudY - 10, ellipseSize, ellipseSize)',correct
'n = new Hunny(mouseX, mouseY)',correct
'size1 = 120',correct
'bearColor2',correct
'cloudX - 30',correct
'tree1.changeToSpring()',correct
'{    for (int i = 5; i < 2 * bears.length / 3; i++) {        bears[i].changeToBlack();    }}',correct
'{    speed = speed * -0.95f;}',correct
'cloud2.move();',correct
'int skySpring;',correct
'grassColor',correct
'bearY = bearY + dy;',correct
'bears[i].changeToBlack()',correct
'{    if (key == l) {        for (int i = 0; i < bears.length / 3; i++) {            bears[i].switchColors();        }    }    if (key == b) {        for (int i = 5; i < 2 * bears.length / 3; i++) {            bears[i].changeToBlack();        }    }    if (key == y) {        for (int i = 10; i < bears.length; i++) {            bears[i].changeToYellow();        }    }    if (key == a) {        bg.changeToAutumn();        tree1.changeToAutumn();        tree2.changeToAutumn();        tree3.changeToAutumn();        cloud1.changeToAutumn();        cloud2.changeToAutumn();    }    if (key == s) {        bg.changeToSpring();        tree1.changeToSpring();        tree2.changeToSpring();        tree3.changeToSpring();        cloud1.changeToSpring();        cloud2.changeToSpring();    }}',correct
'new Tree(450, 600)',correct
'0.95f',correct
'size5 = 15',correct
'rect(treeX, treeY, 100, 400);',correct
'hunnyX = initX',correct
'bearY - 45',correct
'color(leafAutumn)',correct
'cloud2.changeToSpring();',correct
'tree3.changeToAutumn();',correct
'hunnyY = hunnyY + speed',correct
'tree2 = new Tree(450, 600);',correct
'float size2 = 40;',correct
'bearColor2 = color(255, 255, 0)',correct
'treeX = initX;',correct
'{    bearColor = color(0, 0, 255);    bearColor2 = color(255, 255, 0);}',correct
'Processing',correct
'ellipse(bearX + 50, bearY - 90, size2, size2);',correct
'tree3.changeToSpring();',correct
'fill(leafColor);',correct
'Background() {    skyColor = color(63, 226, 255);    skySpring = color(63, 226, 255);    skyAutumn = color(18, 98, 226);    grassColor = color(45, 209, 0);    grassSpring = color(45, 209, 0);    grassAutumn = color(0, 132, 22);}',correct
'pushMatrix()',correct
'void changeToBlack() {    bearColor = color(0);    bearColor2 = color(255);}',correct
'bg = new Background()',correct
'hunnys[i].display()',correct
'0.2f',correct
'cloudColor = color(cloudSpring);',correct
'hunnys = (Hunny[]) append(hunnys, n);',correct
'int i = 10',correct
'grassSpring = color(45, 209, 0)',correct
'fill(leafColor)',correct
'color(0, 0, 255)',correct
'// armsfill(bearColor);',correct
'for (int i = 0; i < bears.length / 3; i++) {    bears[i].switchColors();}',correct
'// Keys that do something: l,b,y,a,sBackground bg;',correct
'cloud2.changeToAutumn()',correct
'speed = speed + gravity',correct
'cloud1.move()',correct
'int skyColor;',correct
'bearColor2 = color(255);',correct
'bears[i].changeToYellow()',correct
'void changeToAutumn() {    skyColor = color(skyAutumn);    grassColor = color(grassAutumn);}',correct
'bearY - 37',correct
'grassColor = color(grassSpring);',correct
'leafSpring',correct
'i = 0',correct
'hunnyY - 35',correct
'void display() {    rectMode(CENTER);    fill(trunkColor);    rect(treeX, treeY, 100, 400);    fill(leafColor);    ellipse(treeX, treeY - 200, 300, 300);}',correct
'{    hunnys[i].display();    hunnys[i].gravity();}',correct
'new Cloud(650, 200)',correct
'hunnyY - 30',correct
'float bearX;',correct
'void setup() {    bg = new Background();    for (int i = 0; i < bears.length; i++) {        bears[i] = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    }    cloud1 = new Cloud(250, 100);    cloud2 = new Cloud(650, 200);    hunnys[0] = new Hunny(random(width), random(height));    tree1 = new Tree(100, 500);    tree2 = new Tree(450, 600);    tree3 = new Tree(800, 500);}',correct
'tree1.changeToAutumn();',correct
'i = 5',correct
'{    bearX = bearX + dx;    if (bearX > width - 95 && dx > 0 || (bearX < 95)) {        dx = -dx;    }    bearY = bearY + dy;    if ((bearY > height - 110 && dy > 0) || (bearY < 110)) {        dy = -dy;    }}',correct
'new Background()',correct
'rect(450, 350, 900, 700)',correct
'color(cloudSpring)',correct
'ellipse(bearX + 50, bearY - 90, size2, size2)',correct
'dy = -dy',correct
'trunkColor',correct
'tree2.changeToAutumn();',correct
'if (key == s) {    bg.changeToSpring();    tree1.changeToSpring();    tree2.changeToSpring();    tree3.changeToSpring();    cloud1.changeToSpring();    cloud2.changeToSpring();}',correct
'color(leafSpring)',correct
'fill(trunkColor)',correct
'void display() {    // legs    fill(bearColor);    ellipse(bearX - 25, bearY + 80, size2, size3);    ellipse(bearX + 25, bearY + 80, size2, size3);    // body    fill(bearColor);    ellipse(bearX, bearY + 20, size1, size1);    fill(bearColor2);    ellipse(bearX, bearY + 20, size3, size3);    // head    fill(bearColor);    ellipse(bearX, bearY - 60, size1, 90);    // snout    fill(255, 182, 193);    arc(bearX, bearY - 37, size5, size5, 0, PI, CHORD);    fill(bearColor2);    ellipse(bearX, bearY - 45, size2, size4);    fill(0, 0, 0);    ellipse(bearX, bearY - 50, size5, 10);    // eyes    fill(255);    ellipse(bearX - 20, bearY - 70, size4, 25);    ellipse(bearX + 20, bearY - 70, size4, 25);    fill(0);    ellipse(bearX - 20, bearY - 70, size5, size5);    ellipse(bearX + 20, bearY - 70, size5, size5);    // ears    fill(bearColor);    noStroke();    ellipse(bearX - 50, bearY - 90, size2, size2);    ellipse(bearX + 50, bearY - 90, size2, size2);    fill(bearColor2);    arc(bearX - 50, bearY - 90, size4, size4, HALF_PI, 2 * PI, CHORD);    arc(bearX + 50, bearY - 90, size4, size4, -PI, PI - HALF_PI, CHORD);    // arms    fill(bearColor);    pushMatrix();    translate(bearX - 75, bearY + 20);    rotate(PI / 10.0f);    ellipse(0, 0, 35, size3);    popMatrix();    pushMatrix();    translate(bearX + 75, bearY + 20);    rotate(-PI / 10.0f);    ellipse(0, 0, 35, size3);    popMatrix();}',correct
'float bearY;',correct
'cloud1 = new Cloud(250, 100);',correct
'int bearColor;',correct
'hunnyY + speed',correct
'{    for (int i = 0; i < bears.length / 3; i++) {        bears[i].switchColors();    }}',correct
'width - 800',correct
'cloud1.changeToSpring()',correct
'noStroke();',correct
'ellipse(bearX, bearY - 50, size5, 10)',correct
'PI - HALF_PI',correct
'fill(grassColor);',correct
'ellipse(bearX + 20, bearY - 70, size4, 25)',correct
'bearColor2 = color(bodyColor);',correct
'new Tree(100, 500)',correct
'hunnys[i].gravity()',correct
'ellipse(cloudX, cloudY, ellipseSize, ellipseSize)',correct
'ellipse(0, 0, 35, size3);',correct
'float size5 = 15;',correct
'{    cloudColor = color(cloudAutumn);}',correct
'color(grassAutumn)',correct
'int leafAutumn;',correct
'leafColor = color(leafSpring);',correct
'int grassColor;',correct
'tree2 = new Tree(450, 600)',correct
'tree2.changeToSpring();',correct
'hunnyX = initX;',correct
'grassColor = color(grassSpring)',correct
'append(hunnys, n)',correct
'ellipse(bearX, bearY - 45, size2, size4);',correct
'cloudX = cloudX + speed',correct
'bodyColor = color(160, 82, 45);',correct
'height - 800',correct
'dx = -dx',correct
'cloudX = 0 - 100',correct
'bodyColor2 = color(205, 133, 63);',correct
'float size1 = 120;',correct
'new Hunny(random(width), random(height))',correct
'int value = 0;',correct
'void display() {    fill(cloudColor);    ellipse(cloudX, cloudY, ellipseSize, ellipseSize);    ellipse(cloudX - 30, cloudY - 40, ellipseSize, ellipseSize);    ellipse(cloudX + 40, cloudY - 25, ellipseSize, ellipseSize);    ellipse(cloudX - 70, cloudY - 10, ellipseSize, ellipseSize);}',correct
'-dx',correct
'// snoutfill(255, 182, 193);',correct
'-dy',correct
'tree1.changeToSpring();',correct
'cloudColor',correct
'ellipse(hunnyX, hunnyY, 60, 70);',correct
'{    bears[i].changeToBlack();}',correct
'bearColor = color(0, 0, 255);',correct
'int bearColor2;',correct
'bears[i].switchColors();',correct
'ellipseMode(CENTER)',correct
'cloud1.display();',correct
'bg.display();',correct
'float size4 = 20;',correct
'cloudX = initX;',correct
'color(205, 133, 63)',correct
'bears.length / 3',correct
'ellipse(hunnyX, hunnyY, 60, 70)',correct
'if (key == y) {    for (int i = 10; i < bears.length; i++) {        bears[i].changeToYellow();    }}',correct
'class Cloud {    float cloudX;    float cloudY;    float ellipseSize = 100;    float speed = 1.5f;    int cloudColor;    int cloudSpring;    int cloudAutumn;    Cloud(float initX, float initY) {        cloudX = initX;        cloudY = initY;        cloudColor = color(255);        cloudSpring = color(255);        cloudAutumn = color(175);    }    void display() {        fill(cloudColor);        ellipse(cloudX, cloudY, ellipseSize, ellipseSize);        ellipse(cloudX - 30, cloudY - 40, ellipseSize, ellipseSize);        ellipse(cloudX + 40, cloudY - 25, ellipseSize, ellipseSize);        ellipse(cloudX - 70, cloudY - 10, ellipseSize, ellipseSize);    }    void move() {        cloudX = cloudX + speed;        if (cloudX > width + 110)            cloudX = 0 - 100;    }    void changeToSpring() {        cloudColor = color(cloudSpring);    }    void changeToAutumn() {        cloudColor = color(cloudAutumn);    }}',correct
'ellipse(bearX + 20, bearY - 70, size5, size5)',correct
'void',correct
'skySpring = color(63, 226, 255);',correct
'trunkColor = color(76, 69, 4);',correct
'void switchColors() {    bearColor = color(bodyColor2);    bearColor2 = color(bodyColor);}',correct
'bears[i].display();',correct
'arc(bearX + 50, bearY - 90, size4, size4, -PI, PI - HALF_PI, CHORD)',correct
'speed * -0.95f',correct
'for (int i = 0; i < bears.length; i++) {    bears[i].display();    bears[i].move();}',correct
'new Hunny[1]',correct
'leafAutumn = color(226, 117, 0)',correct
'color(bodyColor)',correct
'bears = new Bear[15]',correct
'1.5f',correct
'ellipse(cloudX + 40, cloudY - 25, ellipseSize, ellipseSize)',correct
'float gravity = 0.2f;',correct
'cloud2.move()',correct
'bears[i].switchColors()',correct
'for (int i = 5; i < 2 * bears.length / 3; i++) {    bears[i].changeToBlack();}',correct
'bearColor = color(bodyColor2);',correct
'popMatrix()',correct
'bearY + 20',correct
'ellipse(bearX, bearY - 60, size1, 90)',correct
'{    skyColor = color(skyAutumn);    grassColor = color(grassAutumn);}',correct
'skyColor = color(skySpring);',correct
'{    cloudX = initX;    cloudY = initY;    cloudColor = color(255);    cloudSpring = color(255);    cloudAutumn = color(175);}',correct
'cloud2 = new Cloud(650, 200);',correct
'new Bear(random(width - 800, width - 100), random(height - 800, height - 100))',correct
'hunnys[0] = new Hunny(random(width), random(height));',correct
'bearX + dx',correct
'ellipse(bearX, bearY + 20, size1, size1);',correct
'translate(bearX - 75, bearY + 20)',correct
'bg.changeToSpring();',correct
'color(skyAutumn)',correct
'{    leafColor = color(leafAutumn);}',correct
'bearColor = color(0, 0, 255)',correct
'ellipse(hunnyX, hunnyY - 35, 20, 20);',correct
'class Tree {    float treeX;    float treeY;    int trunkColor;    int leafColor;    int leafSpring;    int leafAutumn;    Tree(float initX, float initY) {        treeX = initX;        treeY = initY;        trunkColor = color(76, 69, 4);        leafColor = color(0, 132, 22);        leafSpring = color(0, 132, 22);        leafAutumn = color(226, 117, 0);    }    void display() {        rectMode(CENTER);        fill(trunkColor);        rect(treeX, treeY, 100, 400);        fill(leafColor);        ellipse(treeX, treeY - 200, 300, 300);    }    void changeToSpring() {        leafColor = color(leafSpring);    }    void changeToAutumn() {        leafColor = color(leafAutumn);    }}',correct
'2 * bears.length / 3',correct
'ellipse(bearX - 20, bearY - 70, size4, 25)',correct
'bearColor2 = color(205, 133, 63)',correct
'skyAutumn = color(18, 98, 226);',correct
'{    Hunny n = new Hunny(mouseX, mouseY);    hunnys = (Hunny[]) append(hunnys, n);}',correct
'class Background {    int skyColor;    int skySpring;    int skyAutumn;    int grassColor;    int grassSpring;    int grassAutumn;    Background() {        skyColor = color(63, 226, 255);        skySpring = color(63, 226, 255);        skyAutumn = color(18, 98, 226);        grassColor = color(45, 209, 0);        grassSpring = color(45, 209, 0);        grassAutumn = color(0, 132, 22);    }    void display() {        rectMode(CENTER);        fill(skyColor);        rect(450, 350, 900, 700);        fill(grassColor);        rect(450, 800, 900, 200);    }    void changeToSpring() {        skyColor = color(skySpring);        grassColor = color(grassSpring);    }    void changeToAutumn() {        skyColor = color(skyAutumn);        grassColor = color(grassAutumn);    }}',correct
'arc(bearX - 50, bearY - 90, size4, size4, HALF_PI, 2 * PI, CHORD);',correct
'tree2.changeToSpring()',correct
'{    bearColor = color(0);    bearColor2 = color(255);}',correct
'rect(treeX, treeY, 100, 400)',correct
'Cloud',correct
'{    bears[i] = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));}',correct
'void changeToAutumn() {    cloudColor = color(cloudAutumn);}',correct
'skyColor = color(skySpring)',correct
'fill(bearColor2);',correct
'skyColor',correct
'random(width)',correct
'width + 110',correct
'tree1 = new Tree(100, 500);',correct
'fill(skyColor);',correct
'tree3 = new Tree(800, 500);',correct
'ellipse(hunnyX, hunnyY - 30, 50, 20);',correct
'dx > 0',correct
'treeY = initY',correct
'leafColor = color(0, 132, 22);',correct
'{    for (int i = 0; i < bears.length; i++) {        bears[i].changeColorBack();    }}',correct
'ellipse(treeX, treeY - 200, 300, 300);',correct
'bearColor = color(0)',correct
'ellipse(bearX - 20, bearY - 70, size5, size5);',correct
'fill(bearColor2)',correct
'{    fill(cloudColor);    ellipse(cloudX, cloudY, ellipseSize, ellipseSize);    ellipse(cloudX - 30, cloudY - 40, ellipseSize, ellipseSize);    ellipse(cloudX + 40, cloudY - 25, ellipseSize, ellipseSize);    ellipse(cloudX - 70, cloudY - 10, ellipseSize, ellipseSize);}',correct
'bears[i].changeColorBack();',correct
'Background',correct
'float size3 = 70;',correct
'pushMatrix();',correct
'cloudAutumn',correct
'speed = 1.5f',correct
'// earsfill(bearColor);',correct
'cloud1.changeToAutumn()',correct
'// headfill(bearColor);',correct
'cloudX = 0 - 100;',correct
'new Tree(800, 500)',correct
'ellipse(bearX, bearY - 60, size1, 90);',correct
'skyColor = color(skyAutumn);',correct
'grassAutumn = color(0, 132, 22)',correct
'bearColor = color(160, 82, 45)',correct
'cloud2.display()',correct
'Hunny n = new Hunny(mouseX, mouseY);',correct
'void changeToSpring() {    skyColor = color(skySpring);    grassColor = color(grassSpring);}',correct
'Hunny',correct
'Bear(float initX, float initY) {    bearX = initX;    bearY = initY;    bearColor = color(160, 82, 45);    bearColor2 = color(205, 133, 63);    bodyColor = color(160, 82, 45);    bodyColor2 = color(205, 133, 63);}',correct
'bearY = initY;',correct
'void display() {    fill(mainColor);    ellipseMode(CENTER);    ellipse(hunnyX, hunnyY, 60, 70);    ellipse(hunnyX, hunnyY + 30, 35, 20);    ellipse(hunnyX, hunnyY - 35, 20, 20);    ellipse(hunnyX, hunnyY - 30, 50, 20);    fill(0);    text("HUNNY", hunnyX - 20, hunnyY + 5);}',correct
'Tree(float initX, float initY) {    treeX = initX;    treeY = initY;    trunkColor = color(76, 69, 4);    leafColor = color(0, 132, 22);    leafSpring = color(0, 132, 22);    leafAutumn = color(226, 117, 0);}',correct
'bodyColor2',correct
'bears[i].changeToBlack();',correct
'leafColor = color(leafAutumn)',correct
'hunnyY = hunnyY + speed;',correct
'Cloud cloud2;',correct
'hunnyY + 30',correct
'ellipse(bearX, bearY - 45, size2, size4)',correct
'ellipseSize = 100',correct
'bg.changeToAutumn();',correct
'cloudColor = color(cloudSpring)',correct
'mainColor',correct
'rotate(PI / 10.0f)',correct
'cloud1.changeToAutumn();',correct
'void changeToAutumn() {    leafColor = color(leafAutumn);}',correct
'cloudY - 25',correct
'speed = speed * -0.95f',correct
'ellipse(hunnyX, hunnyY - 30, 50, 20)',correct
'skyColor = color(skyAutumn)',correct
'color(45, 209, 0)',correct
'cloud1.move();',correct
'rotate(-PI / 10.0f);',correct
'hunnyY > height',correct
'cloudY - 10',correct
'hunnys.length',correct
'int cloudColor;',correct
'bodyColor = color(160, 82, 45)',correct
'Cloud cloud1;',correct
'void changeColorBack() {    bearColor = color(bodyColor);    bearColor2 = color(bodyColor2);}',correct
'popMatrix();',correct
'void changeToSpring() {    cloudColor = color(cloudSpring);}',correct
'skyColor = color(63, 226, 255)',correct
'cloudX > width + 110',correct
'fill(255, 182, 193)',correct
'color(cloudAutumn)',correct
'ellipse(bearX, bearY + 20, size1, size1)',correct
'int cloudAutumn;',correct
'tree2.display();',correct
'{    bg.changeToAutumn();    tree1.changeToAutumn();    tree2.changeToAutumn();    tree3.changeToAutumn();    cloud1.changeToAutumn();    cloud2.changeToAutumn();}',correct
'-0.95f',correct
'fill(mainColor)',correct
'cloudSpring = color(255);',correct
'noStroke()',correct
'(Hunny[]) append(hunnys, n)',correct
'speed + gravity',correct
'speed = speed + gravity;',correct
'if (cloudX > width + 110)    cloudX = 0 - 100;',correct
'arc(bearX, bearY - 37, size5, size5, 0, PI, CHORD);',correct
'gravity = 0.2f',correct
'skyColor = color(63, 226, 255);',correct
'tree3.display()',correct
'bearX > width - 95 && dx > 0',correct
'2 * bears.length',correct
'for (int i = 10; i < bears.length; i++) {    bears[i].changeToYellow();}',correct
'ellipse(bearX - 25, bearY + 80, size2, size3)',correct
'skySpring = color(63, 226, 255)',correct
'color(0, 132, 22)',correct
'grassAutumn',correct
'void keyReleased() {    if (value == 0) {        for (int i = 0; i < bears.length; i++) {            bears[i].changeColorBack();        }    }}',correct
'translate(bearX + 75, bearY + 20);',correct
'void draw() {    bg.display();    tree1.display();    tree2.display();    tree3.display();    cloud1.display();    cloud1.move();    cloud2.display();    cloud2.move();    for (int i = 0; i < bears.length; i++) {        bears[i].display();        bears[i].move();    }    for (int i = 0; i < hunnys.length; i++) {        hunnys[i].display();        hunnys[i].gravity();    }}',correct
'skyAutumn',correct
'10.0f',correct
'bears[i].changeToYellow();',correct
'bearColor2 = color(255, 255, 0);',correct
'bearX',correct
'size3 = 70',correct
'cloud2 = new Cloud(650, 200)',correct
'bearY',correct
'fill(0)',correct
'float dx = random(2, 5);',correct
'if (key == b) {    for (int i = 5; i < 2 * bears.length / 3; i++) {        bears[i].changeToBlack();    }}',correct
'color(76, 69, 4)',correct
'float ellipseSize = 100;',correct
'grassColor = color(45, 209, 0)',correct
'Cloud(float initX, float initY) {    cloudX = initX;    cloudY = initY;    cloudColor = color(255);    cloudSpring = color(255);    cloudAutumn = color(175);}',correct
'translate(bearX + 75, bearY + 20)',correct
'class Hunny {    float hunnyX;    float hunnyY;    int mainColor;    float gravity = 0.2f;    float speed = 3;    Hunny(float initX, float initY) {        hunnyX = initX;        hunnyY = initY;        mainColor = color(2, 154, 237);    }    void display() {        fill(mainColor);        ellipseMode(CENTER);        ellipse(hunnyX, hunnyY, 60, 70);        ellipse(hunnyX, hunnyY + 30, 35, 20);        ellipse(hunnyX, hunnyY - 35, 20, 20);        ellipse(hunnyX, hunnyY - 30, 50, 20);        fill(0);        text("HUNNY", hunnyX - 20, hunnyY + 5);    }    void gravity() {        hunnyY = hunnyY + speed;        speed = speed + gravity;        if (hunnyY > height) {            speed = speed * -0.95f;        }    }}',correct
'float cloudY;',correct
'cloud2.changeToAutumn();',correct
'fill(grassColor)',correct
'cloudX = cloudX + speed;',correct
'{    leafColor = color(leafSpring);}',correct
'bearX = bearX + dx;',correct
'int bodyColor;',correct
'value == 0',correct
'bearColor = color(bodyColor2)',correct
'new Bear[15]',correct
'i < bears.length',correct
'fill(255)',correct
'tree1',correct
'bodyColor2 = color(205, 133, 63)',correct
'tree2',correct
'Tree tree2;',correct
'tree3',correct
'tree3.changeToAutumn()',correct
'if (value == 0) {    for (int i = 0; i < bears.length; i++) {        bears[i].changeColorBack();    }}',correct
'cloudColor = color(cloudAutumn)',correct
'leafColor = color(leafAutumn);',correct
'bearX - 75',correct
'void gravity() {    hunnyY = hunnyY + speed;    speed = speed + gravity;    if (hunnyY > height) {        speed = speed * -0.95f;    }}',correct
'fill(cloudColor)',correct
'void move() {    cloudX = cloudX + speed;    if (cloudX > width + 110)        cloudX = 0 - 100;}',correct
'hunnys[i]',correct
'cloudY = initY',correct
'treeX',correct
'treeY',correct
'leafColor = color(leafSpring)',correct
'float cloudX;',correct
'-PI',correct
'ellipse(hunnyX, hunnyY - 35, 20, 20)',correct
'{    rectMode(CENTER);    fill(skyColor);    rect(450, 350, 900, 700);    fill(grassColor);    rect(450, 800, 900, 200);}',correct
'dx = -dx;',correct
'int leafSpring;',correct
'Tree tree3;',correct
'{    bearX = initX;    bearY = initY;    bearColor = color(160, 82, 45);    bearColor2 = color(205, 133, 63);    bodyColor = color(160, 82, 45);    bodyColor2 = color(205, 133, 63);}',correct
'bearColor2 = color(255)',correct
'ellipseMode(CENTER);',correct
'int i = 0',correct
'{    fill(mainColor);    ellipseMode(CENTER);    ellipse(hunnyX, hunnyY, 60, 70);    ellipse(hunnyX, hunnyY + 30, 35, 20);    ellipse(hunnyX, hunnyY - 35, 20, 20);    ellipse(hunnyX, hunnyY - 30, 50, 20);    fill(0);    text("HUNNY", hunnyX - 20, hunnyY + 5);}',correct
'ellipse(cloudX - 30, cloudY - 40, ellipseSize, ellipseSize);',correct
'{    bg.display();    tree1.display();    tree2.display();    tree3.display();    cloud1.display();    cloud1.move();    cloud2.display();    cloud2.move();    for (int i = 0; i < bears.length; i++) {        bears[i].display();        bears[i].move();    }    for (int i = 0; i < hunnys.length; i++) {        hunnys[i].display();        hunnys[i].gravity();    }}',correct
'int i = 5',correct
'treeY - 200',correct
'int leafColor;',correct
'if ((bearY > height - 110 && dy > 0) || (bearY < 110)) {    dy = -dy;}',correct
'float treeX;',correct
'color(255)',correct
'cloudAutumn = color(175)',correct
'int bodyColor2;',correct
'bearX > width - 95 && dx > 0 || (bearX < 95)',correct
'{    bg.changeToSpring();    tree1.changeToSpring();    tree2.changeToSpring();    tree3.changeToSpring();    cloud1.changeToSpring();    cloud2.changeToSpring();}',correct
'int cloudSpring;',correct
'random(width - 800, width - 100)',correct
'bearX = initX',correct
'hunnys = (Hunny[]) append(hunnys, n)',correct
'if (keyPressed) {    if (key == l) {        for (int i = 0; i < bears.length / 3; i++) {            bears[i].switchColors();        }    }    if (key == b) {        for (int i = 5; i < 2 * bears.length / 3; i++) {            bears[i].changeToBlack();        }    }    if (key == y) {        for (int i = 10; i < bears.length; i++) {            bears[i].changeToYellow();        }    }    if (key == a) {        bg.changeToAutumn();        tree1.changeToAutumn();        tree2.changeToAutumn();        tree3.changeToAutumn();        cloud1.changeToAutumn();        cloud2.changeToAutumn();    }    if (key == s) {        bg.changeToSpring();        tree1.changeToSpring();        tree2.changeToSpring();        tree3.changeToSpring();        cloud1.changeToSpring();        cloud2.changeToSpring();    }}',correct
'bears[i].display()',correct
'float speed = 3;',correct
'cloudColor = color(cloudAutumn);',correct
'bearColor2 = color(bodyColor2);',correct
'bearX - 50',correct
'void display() {    rectMode(CENTER);    fill(skyColor);    rect(450, 350, 900, 700);    fill(grassColor);    rect(450, 800, 900, 200);}',correct
'{    bears[i].changeColorBack();}',correct
'bg.display()',correct
'ellipse(cloudX + 40, cloudY - 25, ellipseSize, ellipseSize);',correct
'float treeY;',correct
'{    bearColor = color(bodyColor2);    bearColor2 = color(bodyColor);}',correct
'{    if (keyPressed) {        if (key == l) {            for (int i = 0; i < bears.length / 3; i++) {                bears[i].switchColors();            }        }        if (key == b) {            for (int i = 5; i < 2 * bears.length / 3; i++) {                bears[i].changeToBlack();            }        }        if (key == y) {            for (int i = 10; i < bears.length; i++) {                bears[i].changeToYellow();            }        }        if (key == a) {            bg.changeToAutumn();            tree1.changeToAutumn();            tree2.changeToAutumn();            tree3.changeToAutumn();            cloud1.changeToAutumn();            cloud2.changeToAutumn();        }        if (key == s) {            bg.changeToSpring();            tree1.changeToSpring();            tree2.changeToSpring();            tree3.changeToSpring();            cloud1.changeToSpring();            cloud2.changeToSpring();        }    }}',correct
'{    bearColor = color(bodyColor);    bearColor2 = color(bodyColor2);}',correct
'tree3 = new Tree(800, 500)',correct
'grassSpring = color(45, 209, 0);',correct
'cloudX = initX',correct
'Tree tree1;',correct
'cloud1 = new Cloud(250, 100)',correct
'i < bears.length / 3',correct
'leafAutumn = color(226, 117, 0);',correct
'treeX = initX',correct
'i = 10',correct
'cloudX + 40',correct
'void changeToSpring() {    leafColor = color(leafSpring);}',correct
'key == l',correct
'leafColor',correct
'bg.changeToAutumn()',correct
'if (key == l) {    for (int i = 0; i < bears.length / 3; i++) {        bears[i].switchColors();    }}',correct
'bearY = bearY + dy',correct
'tree3.changeToSpring()',correct
'key == b',correct
'fill(bearColor)',correct
'bearColor2 = color(205, 133, 63);',correct
'key == a',correct
'grassAutumn = color(0, 132, 22);',correct
'rotate(PI / 10.0f);',correct
'hunnyX',correct
'hunnyY',correct
'fill(cloudColor);',correct
'key == y',correct
'color(18, 98, 226)',correct
'key == s',correct
'color(0)',correct
'int grassAutumn;',correct
'{    bears[i].display();    bears[i].move();}',correct
'grassSpring',correct
'ellipse(cloudX - 30, cloudY - 40, ellipseSize, ellipseSize)',correct
'size4 = 20',correct
'void changeToYellow() {    bearColor = color(0, 0, 255);    bearColor2 = color(255, 255, 0);}',correct
'bearX - 25',correct
'display',correct
'{    hunnyY = hunnyY + speed;    speed = speed + gravity;    if (hunnyY > height) {        speed = speed * -0.95f;    }}',correct
'bears[i] = new Bear(random(width - 800, width - 100), random(height - 800, height - 100))',correct
'bearY + dy',correct
'cloudX + speed',correct
'ellipse(bearX + 20, bearY - 70, size4, 25);',correct
'rotate(-PI / 10.0f)',correct
'{    skyColor = color(63, 226, 255);    skySpring = color(63, 226, 255);    skyAutumn = color(18, 98, 226);    grassColor = color(45, 209, 0);    grassSpring = color(45, 209, 0);    grassAutumn = color(0, 132, 22);}',correct
'bears[i].move();',correct
'cloud2.display();',correct
'width - 100',correct
'Hunny(float initX, float initY) {    hunnyX = initX;    hunnyY = initY;    mainColor = color(2, 154, 237);}',correct
'bearX - 20',correct
'ellipse(bearX + 25, bearY + 80, size2, size3)',correct
'tree1 = new Tree(100, 500)',correct
'hunnyY = initY',correct
'cloud1.changeToSpring();',correct
'ellipse(bearX, bearY + 20, size3, size3);',correct
'ellipse(bearX + 20, bearY - 70, size5, size5);',correct
'text("HUNNY", hunnyX - 20, hunnyY + 5)',correct
'cloudY = initY;',correct
'{    bears[i].changeToYellow();}',correct
'-PI / 10.0f',correct
'cloudY - 40',correct
'float initX',correct
'float initY',correct
'i++',correct
'ellipse(bearX + 25, bearY + 80, size2, size3);',correct
'cloud2',correct
'cloud1',correct
'dx = random(2, 5)',correct
'rect(450, 800, 900, 200);',correct
'ellipse(treeX, treeY - 200, 300, 300)',correct
'bears[i].move()',correct
'Tree',correct
'bearX + 75',correct
'leafColor = color(0, 132, 22)',correct
'"HUNNY"',correct
'value = 0',correct
'ellipse(cloudX, cloudY, ellipseSize, ellipseSize);',correct
'(bearY > height - 110 && dy > 0) || (bearY < 110)',correct
'bearY - 90',correct
'tree1.changeToAutumn()',correct
'ellipse(hunnyX, hunnyY + 30, 35, 20)',correct
'// bodyfill(bearColor);',correct
'{    bg = new Background();    for (int i = 0; i < bears.length; i++) {        bears[i] = new Bear(random(width - 800, width - 100), random(height - 800, height - 100));    }    cloud1 = new Cloud(250, 100);    cloud2 = new Cloud(650, 200);    hunnys[0] = new Hunny(random(width), random(height));    tree1 = new Tree(100, 500);    tree2 = new Tree(450, 600);    tree3 = new Tree(800, 500);}',correct
'color(bodyColor2)',correct
'speed = 3',correct
'{    cloudColor = color(cloudSpring);}',correct
'height - 100',correct
'bearColor',correct
'void move() {    bearX = bearX + dx;    if (bearX > width - 95 && dx > 0 || (bearX < 95)) {        dx = -dx;    }    bearY = bearY + dy;    if ((bearY > height - 110 && dy > 0) || (bearY < 110)) {        dy = -dy;    }}',correct
'tree2.display()',correct
'{    rectMode(CENTER);    fill(trunkColor);    rect(treeX, treeY, 100, 400);    fill(leafColor);    ellipse(treeX, treeY - 200, 300, 300);}',correct
'0 - 100',correct
'bearColor = color(bodyColor);',correct
'bodyColor',correct
'width - 95',correct
'bearColor = color(160, 82, 45);',correct
'bg.changeToSpring()',correct
'size2 = 40',correct
'Bear',correct
'fill(0, 0, 0);',correct
'float dy = random(2, 5);',correct
'bearColor2 = color(bodyColor)',correct
'bears[i].changeColorBack()',correct
'cloudY',correct
'if (bearX > width - 95 && dx > 0 || (bearX < 95)) {    dx = -dx;}',correct
'color(255, 255, 0)',correct
'speed = speed * -0.95f;',correct
'random(height - 800, height - 100)',correct
'cloudX',correct
'bearX + 50',correct
'bearX = initX;',correct
'tree1.display()',correct
'arc(bearX, bearY - 37, size5, size5, 0, PI, CHORD)',correct
'ellipse(cloudX - 70, cloudY - 10, ellipseSize, ellipseSize);',correct
'for (int i = 0; i < hunnys.length; i++) {    hunnys[i].display();    hunnys[i].gravity();}',correct
'hunnyY = initY;',correct
'[1]',correct
'Hunny n = new Hunny(mouseX, mouseY)',correct
'arc(bearX - 50, bearY - 90, size4, size4, HALF_PI, 2 * PI, CHORD)',correct
'ellipse(bearX - 20, bearY - 70, size4, 25);',correct
'new Hunny(mouseX, mouseY)',correct
'color(63, 226, 255)',correct
'{    bears[i].switchColors();}',correct
'arc(bearX + 50, bearY - 90, size4, size4, -PI, PI - HALF_PI, CHORD);',correct
'void keyPressed() {    if (keyPressed) {        if (key == l) {            for (int i = 0; i < bears.length / 3; i++) {                bears[i].switchColors();            }        }        if (key == b) {            for (int i = 5; i < 2 * bears.length / 3; i++) {                bears[i].changeToBlack();            }        }        if (key == y) {            for (int i = 10; i < bears.length; i++) {                bears[i].changeToYellow();            }        }        if (key == a) {            bg.changeToAutumn();            tree1.changeToAutumn();            tree2.changeToAutumn();            tree3.changeToAutumn();            cloud1.changeToAutumn();            cloud2.changeToAutumn();        }        if (key == s) {            bg.changeToSpring();            tree1.changeToSpring();            tree2.changeToSpring();            tree3.changeToSpring();            cloud1.changeToSpring();            cloud2.changeToSpring();        }    }}',correct
'2 * PI',correct
'{    if (value == 0) {        for (int i = 0; i < bears.length; i++) {            bears[i].changeColorBack();        }    }}',correct
'color(226, 117, 0)',correct
'{    dx = -dx;}',correct
'grassColor = color(grassAutumn)',correct
'bearColor = color(0);',correct
'ship shipD;',correct
'shipY + 100',correct
'keycount',correct
'"turned controls"',correct
'cloudX + 700',correct
'line(shipX - 30, shipY + 74, shipX - 45, shipY + 99);',correct
'line(shipX, shipY - 30, shipX, shipY - 42)',correct
'shipB.keyPressed();',correct
'stroke(0);',correct
'stroke(0)',correct
'random(0, 256)',correct
'keycount = keycount + 1',correct
'{    shipX = initX;    shipY = initY;    int redValue = PApplet.parseInt(random(0, 256));    int blueValue = PApplet.parseInt(random(0, 256));    int greenValue = PApplet.parseInt(random(0, 256));    shipColor = color(redValue, greenValue, blueValue);    speedX = 5;    speedY = 5;    candleA = new candle(shipX, shipY);}',correct
'cloudY + 365',correct
'ellipse(cloudX + 500, cloudY, 120, 120)',correct
'class candle {    float shipX;    float shipY;    int speedX;    int speedY;    int z;    float initX;    float initY;    candle(float initX, float initY) {        shipX = initX;        shipY = initY;        speedX = 5;        speedY = 5;    }    void display() {        stroke(0);        line(shipX, shipY - 30, shipX, shipY - 42);        fill(255);        noStroke();        rect(shipX, shipY, 20, 60);    }    void isBurning() {        fill(255, 145, 0);        ellipse(shipX, shipY - 45, 20, 20);        // light lines        // 11 - 8 downleft        line(shipX - 22, shipY - 27, shipX - 33, shipY - 19);        // 15 left        line(shipX - 27, shipY - 45, shipX - 42, shipY - 45);        // 13 - 8 upleft        line(shipX - 22, shipY - 60, shipX - 33, shipY - 68);        // 15 up        line(shipX, shipY - 65, shipX, shipY - 80);        // 11 - 8 upright        line(shipX + 22, shipY - 60, shipX + 33, shipY - 68);        // 15 right        line(shipX + 27, shipY - 45, shipX + 42, shipY - 45);        // 11 - 8 downright        line(shipX + 22, shipY - 27, shipX + 33, shipY - 19);        // 15 down        line(shipX, shipY - 17, shipX, shipY - 2);    }    void updatePosition(float initX, float initY) {        shipX = initX;        shipY = initY;    }}',correct
'greenValue = PApplet.parseInt(random(0, 256))',correct
'{    shipX = shipX - speedX;}',correct
'cloudA.display();',correct
'speedX = 5',correct
'cloudA.mouseDragged()',correct
'{    shipY = shipY + speedY;}',correct
'ellipse(cloudX + 1065, cloudY + 200, 80, 80);',correct
'ellipse(cloudX - 100, cloudY + 450, 100, 100)',correct
'new ship(1000, 350)',correct
'shipB.lit()',correct
'if (keyCode == RIGHT) {    shipX = shipX - speedX;}',DecentralizedEventHandlingRule
'shipA.update()',correct
'rectMode(CENTER)',correct
'a',correct
'float shipX;',StdCyclomaticComplexity
'void mouseDragged() {    cloudX = mouseX;}',correct
'd',correct
'cloudX - 100',correct
'{    stroke(0);    line(shipX, shipY - 30, shipX, shipY - 42);    fill(255);    noStroke();    rect(shipX, shipY, 20, 60);}',correct
'{    if (framecount > 40) {        rcol = random(255);        gcol = random(100);        bcol = random(255);        framecount = 0;    } else {        framecount = framecount + 1;    }    if (isBurning) {        candleA.isBurning();    }}',correct
'keycount = 0;',correct
'ellipse(cloudX + 80, cloudY + 160, 100, 100);',correct
'shipA.lit();',correct
'shipA.keyPressed();',correct
'rectMode(CENTER);',correct
'z',correct
'cloudX - 40',correct
'cloudX - 35',correct
'ellipse(cloudX + 80, cloudY + 160, 100, 100)',correct
'float shipY;',correct
'// 15 upline(shipX, shipY - 65, shipX, shipY - 80);',correct
'line(shipX + 30, shipY + 74, shipX + 40, shipY + 99);',correct
'// 15 leftline(shipX - 27, shipY - 45, shipX - 42, shipY - 45);',correct
'// light candlevoid mouseClicked() {    shipA.lit();    shipB.lit();    shipC.lit();    shipD.lit();}',correct
'cloudX + 500',correct
'stroke(246, 40, 23)',correct
'cloudX + 1100',correct
'cloudY + 160',correct
'speedX = 5;',correct
'line(shipX, shipY - 65, shipX, shipY - 80)',correct
'isBurning',correct
'fill(rcol, gcol, bcol)',correct
'ellipse(shipX + 37, shipY + 47, 15, 15);',correct
'keycount >= 120',correct
'"controls change back"',correct
'// powerlines downsidestroke(246, 40, 23);',correct
'ellipse(shipX - 44, shipY + 47, 15, 15);',correct
'if (key == a) {    shipX = shipX + speedX;    shipY = shipY - speedY;}',correct
'shipA = new ship(100, 200);',correct
'initY',correct
'initX',correct
'rect(shipX, shipY, 20, 60);',correct
'shipX = shipX - speedX',correct
'void display() {    // upperpart spaceship    fill(128, 179, 255, 40);    stroke(100, 150, 200);    arc(shipX, shipY + 32, 100, 250, PI, TWO_PI);    candleA.display();    // downside of spaceship    fill(shipColor);    quad(shipX - 50, shipY + 30, shipX + 50, shipY + 30, shipX + 80, shipY + 64, shipX - 80, shipY + 64);    fill(rcol, gcol, bcol);    ellipse(shipX - 44, shipY + 47, 15, 15);    ellipse(shipX - 17, shipY + 47, 15, 15);    ellipse(shipX + 10, shipY + 47, 15, 15);    ellipse(shipX + 37, shipY + 47, 15, 15);    // powerlines downside    stroke(246, 40, 23);    line(shipX - 60, shipY + 72, shipX - 80, shipY + 97);    line(shipX - 30, shipY + 74, shipX - 45, shipY + 99);    line(shipX, shipY + 75, shipX, shipY + 100);    line(shipX + 30, shipY + 74, shipX + 40, shipY + 99);    line(shipX + 60, shipY + 72, shipX + 80, shipY + 97);}',StdCyclomaticComplexity
'shipY - speedY',correct
'cloudX + 80',correct
'shipC.keyPressed();',correct
'shipY = initY;',correct
'ellipse(cloudX, cloudY, 100, 100);',correct
'ellipse(shipX + 10, shipY + 47, 15, 15);',correct
'cloudX + 720',correct
'framecount = framecount + 1',correct
'ellipse(cloudX + 440, cloudY + 20, 100, 100);',correct
'cloudY + 260',correct
'Processing',correct
'ellipse(cloudX + 830, cloudY + 320, 90, 90)',correct
'// changeif (keycount >= 60) {    if (key == CODED) {        if (keyCode == DOWN) {            shipY = shipY - speedY;        } else {            shipY = shipY + speedY;        }        if (keyCode == LEFT) {            shipX = shipX + speedX;        }        if (keyCode == RIGHT) {            shipX = shipX - speedX;        }    }    if (key == a) {        shipX = shipX + speedX;        shipY = shipY - speedY;    }    if (key == d) {        shipX = shipX - speedX;        shipY = shipY - speedY;        println("turned controls");    }// changed controls} else {    if (key == CODED) {        if (keyCode == DOWN) {            shipY = shipY + speedY;        } else {            shipY = shipY - speedY;        }        if (keyCode == LEFT) {            shipX = shipX - speedX;        }        if (keyCode == RIGHT) {            shipX = shipX + speedX;        }    }    if (key == a) {        shipX = shipX - speedX;        shipY = shipY + speedY;    }    if (key == d) {        shipX = shipX + speedX;        shipY = shipY + speedY;    }}',correct
'ellipse(cloudX + 1090, cloudY + 135, 70, 70)',correct
'cloudY + 135',correct
'void setup() {    rectMode(CENTER);    shipA = new ship(100, 200);    shipB = new ship(500, 600);    shipC = new ship(1000, 350);    shipD = new ship(800, 300);    cloudA = new cloud(500, 100);}',correct
'shipD.keyPressed();',correct
'new cloud(500, 100)',correct
'int redValue = PApplet.parseInt(random(0, 256))',correct
'shipD.keyPressed()',correct
'cloudA = new cloud(500, 100)',correct
'cloudX + 830',correct
'ellipse(shipX - 17, shipY + 47, 15, 15);',correct
'line(shipX + 60, shipY + 72, shipX + 80, shipY + 97);',correct
'quad(shipX - 50, shipY + 30, shipX + 50, shipY + 30, shipX + 80, shipY + 64, shipX - 80, shipY + 64);',correct
'cloud cloudA;',correct
'shipA.update();',correct
'cloudX + 60',correct
'shipY + 75',correct
'shipY + 74',correct
'shipD.lit()',correct
'cloudX = mouseX',correct
'!isBurning',correct
'if (key == d) {    shipX = shipX - speedX;    shipY = shipY - speedY;    println("turned controls");}',correct
'shipY + 72',correct
'println(keycount)',correct
'shipY - 19',correct
'{    cloudX = initX;    cloudY = initY;}',correct
'shipY - 17',correct
'{    // upperpart spaceship    fill(128, 179, 255, 40);    stroke(100, 150, 200);    arc(shipX, shipY + 32, 100, 250, PI, TWO_PI);    candleA.display();    // downside of spaceship    fill(shipColor);    quad(shipX - 50, shipY + 30, shipX + 50, shipY + 30, shipX + 80, shipY + 64, shipX - 80, shipY + 64);    fill(rcol, gcol, bcol);    ellipse(shipX - 44, shipY + 47, 15, 15);    ellipse(shipX - 17, shipY + 47, 15, 15);    ellipse(shipX + 10, shipY + 47, 15, 15);    ellipse(shipX + 37, shipY + 47, 15, 15);    // powerlines downside    stroke(246, 40, 23);    line(shipX - 60, shipY + 72, shipX - 80, shipY + 97);    line(shipX - 30, shipY + 74, shipX - 45, shipY + 99);    line(shipX, shipY + 75, shipX, shipY + 100);    line(shipX + 30, shipY + 74, shipX + 40, shipY + 99);    line(shipX + 60, shipY + 72, shipX + 80, shipY + 97);}',correct
'shipX = shipX + speedX;',correct
'framecount = framecount + 1;',correct
'float initY;',correct
'ellipse(cloudX + 1090, cloudY + 135, 70, 70);',correct
'int greenValue = PApplet.parseInt(random(0, 256))',correct
'shipD = new ship(800, 300)',correct
'{    rcol = random(255);    gcol = random(100);    bcol = random(255);    framecount = 0;}',correct
'if (framecount > 40) {    rcol = random(255);    gcol = random(100);    bcol = random(255);    framecount = 0;} else {    framecount = framecount + 1;}',correct
'shipY - 27',correct
'ellipse(shipX - 44, shipY + 47, 15, 15)',correct
'new ship(800, 300)',correct
'float rcol, bcol, gcol;',correct
'shipColor',correct
'{    shipX = shipX - speedX;    shipY = shipY + speedY;}',correct
'cloudX + 1130',correct
'ellipse(cloudX + 400, cloudY - 50, 110, 110);',correct
'noStroke();',correct
'shipY = shipY + speedY;',correct
'line(shipX - 22, shipY - 60, shipX - 33, shipY - 68)',correct
'line(shipX + 30, shipY + 74, shipX + 40, shipY + 99)',correct
'shipY + 97',correct
'ellipse(cloudX + 760, cloudY + 330, 110, 110)',correct
'class ship {    boolean isBurning;    float shipX;    float shipY;    int shipColor;    float rcol, bcol, gcol;    int framecount;    int keycount;    candle candleA;    int speedY;    int speedX;    ship(float initX, float initY) {        shipX = initX;        shipY = initY;        int redValue = PApplet.parseInt(random(0, 256));        int blueValue = PApplet.parseInt(random(0, 256));        int greenValue = PApplet.parseInt(random(0, 256));        shipColor = color(redValue, greenValue, blueValue);        speedX = 5;        speedY = 5;        candleA = new candle(shipX, shipY);    }    void display() {        // upperpart spaceship        fill(128, 179, 255, 40);        stroke(100, 150, 200);        arc(shipX, shipY + 32, 100, 250, PI, TWO_PI);        candleA.display();        // downside of spaceship        fill(shipColor);        quad(shipX - 50, shipY + 30, shipX + 50, shipY + 30, shipX + 80, shipY + 64, shipX - 80, shipY + 64);        fill(rcol, gcol, bcol);        ellipse(shipX - 44, shipY + 47, 15, 15);        ellipse(shipX - 17, shipY + 47, 15, 15);        ellipse(shipX + 10, shipY + 47, 15, 15);        ellipse(shipX + 37, shipY + 47, 15, 15);        // powerlines downside        stroke(246, 40, 23);        line(shipX - 60, shipY + 72, shipX - 80, shipY + 97);        line(shipX - 30, shipY + 74, shipX - 45, shipY + 99);        line(shipX, shipY + 75, shipX, shipY + 100);        line(shipX + 30, shipY + 74, shipX + 40, shipY + 99);        line(shipX + 60, shipY + 72, shipX + 80, shipY + 97);    }    void update() {        if (framecount > 40) {            rcol = random(255);            gcol = random(100);            bcol = random(255);            framecount = 0;        } else {            framecount = framecount + 1;        }        if (isBurning) {            candleA.isBurning();        }    }    void lit() {        isBurning = !isBurning;    }    void keyPressed() {        // change back        if (keycount >= 120) {            keycount = 0;            println("controls change back");        }        // change        if (keycount >= 60) {            if (key == CODED) {                if (keyCode == DOWN) {                    shipY = shipY - speedY;                } else {                    shipY = shipY + speedY;                }                if (keyCode == LEFT) {                    shipX = shipX + speedX;                }                if (keyCode == RIGHT) {                    shipX = shipX - speedX;                }            }            if (key == a) {                shipX = shipX + speedX;                shipY = shipY - speedY;            }            if (key == d) {                shipX = shipX - speedX;                shipY = shipY - speedY;                println("turned controls");            }        // changed controls        } else {            if (key == CODED) {                if (keyCode == DOWN) {                    shipY = shipY + speedY;                } else {                    shipY = shipY - speedY;                }                if (keyCode == LEFT) {                    shipX = shipX - speedX;                }                if (keyCode == RIGHT) {                    shipX = shipX + speedX;                }            }            if (key == a) {                shipX = shipX - speedX;                shipY = shipY + speedY;            }            if (key == d) {                shipX = shipX + speedX;                shipY = shipY + speedY;            }        }        keycount = keycount + 1;        println(keycount);        candleA.updatePosition(shipX, shipY);    }}',correct
'shipY - 30',correct
'{    shipX = initX;    shipY = initY;    speedX = 5;    speedY = 5;}',correct
'cloudY + 180',correct
'shipY + 99',correct
'line(shipX, shipY + 75, shipX, shipY + 100)',correct
'if (key == CODED) {    if (keyCode == DOWN) {        shipY = shipY + speedY;    } else {        shipY = shipY - speedY;    }    if (keyCode == LEFT) {        shipX = shipX - speedX;    }    if (keyCode == RIGHT) {        shipX = shipX + speedX;    }}',DecentralizedEventHandlingRule
'ellipse(cloudX + 720, cloudY + 365, 80, 80)',correct
'// spacecandle charactership shipA;',correct
'shipY - 45',correct
'quad(shipX - 50, shipY + 30, shipX + 50, shipY + 30, shipX + 80, shipY + 64, shipX - 80, shipY + 64)',correct
'shipY - 42',correct
'// spacecandle character',correct
'ellipse(cloudX + 760, cloudY + 330, 110, 110);',correct
'isBurning = !isBurning',correct
'new ship(100, 200)',correct
'shipD = new ship(800, 300);',correct
'background(128, 179, 255)',correct
'float initX;',correct
'if (keyCode == RIGHT) {    shipX = shipX + speedX;}',DecentralizedEventHandlingRule
'shipC.display()',correct
'ellipse(cloudX + 550, cloudY + 30, 110, 110);',correct
'{    background(128, 179, 255);    cloudA.display();    shipA.display();    shipB.display();    shipC.display();    shipD.display();    shipA.update();    shipB.update();    shipC.update();    shipD.update();}',correct
'candle',correct
'ellipse(cloudX - 35, cloudY + 510, 100, 100);',correct
'if (keyCode == DOWN) {    shipY = shipY + speedY;} else {    shipY = shipY - speedY;}',DecentralizedEventHandlingRule
'shipY + 32',correct
'shipY + 30',correct
'ellipse(cloudX - 40, cloudY + 440, 80, 80)',correct
'{    candleA.isBurning();}',correct
'cloudA = new cloud(500, 100);',correct
'shipD.display()',correct
'keycount >= 60',correct
'{    shipY = shipY - speedY;}',correct
'cloudX + 1065',correct
'ship(float initX, float initY) {    shipX = initX;    shipY = initY;    int redValue = PApplet.parseInt(random(0, 256));    int blueValue = PApplet.parseInt(random(0, 256));    int greenValue = PApplet.parseInt(random(0, 256));    shipColor = color(redValue, greenValue, blueValue);    speedX = 5;    speedY = 5;    candleA = new candle(shipX, shipY);}',StdCyclomaticComplexity
'bcol = random(255)',correct
'ellipse(cloudX + 100, cloudY, 120, 120)',correct
'ellipse(cloudX + 720, cloudY + 365, 80, 80);',correct
'shipB.display();',correct
'int greenValue = PApplet.parseInt(random(0, 256));',correct
'cloudX = initX;',correct
'candleA = new candle(shipX, shipY)',correct
'int z;',ShortVariable
'void',correct
'shipY + speedY',correct
'bcol = random(255);',correct
'void lit() {    isBurning = !isBurning;}',StdCyclomaticComplexity
'shipY + 47',correct
'keycount = keycount + 1;',correct
'candleA = new candle(shipX, shipY);',correct
'shipD.lit();',correct
'int shipColor;',StdCyclomaticComplexity
'framecount + 1',correct
'if (key == a) {    shipX = shipX - speedX;    shipY = shipY + speedY;}',DecentralizedEventHandlingRule
'shipX - speedX',correct
'speedY = 5',correct
'shipY + 64',correct
'class cloud {    float cloudX;    float cloudY;    float initX;    float initY;    cloud(float initX, float initY) {        cloudX = initX;        cloudY = initY;    }    void display() {        // clouds        fill(255);        noStroke();        ellipse(cloudX, cloudY, 100, 100);        ellipse(cloudX + 60, cloudY + 80, 130, 130);        ellipse(cloudX + 80, cloudY + 160, 100, 100);        ellipse(cloudX + 100, cloudY, 120, 120);        ellipse(cloudX + 400, cloudY - 50, 110, 110);        ellipse(cloudX + 500, cloudY, 120, 120);        ellipse(cloudX + 550, cloudY + 30, 110, 110);        ellipse(cloudX + 440, cloudY + 20, 100, 100);        ellipse(cloudX - 100, cloudY + 450, 100, 100);        ellipse(cloudX - 40, cloudY + 440, 80, 80);        ellipse(cloudX - 35, cloudY + 510, 100, 100);        ellipse(cloudX - 110, cloudY + 500, 90, 90);        ellipse(cloudX + 700, cloudY + 300, 100, 100);        ellipse(cloudX + 760, cloudY + 330, 110, 110);        ellipse(cloudX + 830, cloudY + 320, 90, 90);        ellipse(cloudX + 720, cloudY + 365, 80, 80);        ellipse(cloudX + 1100, cloudY + 260, 100, 100);        ellipse(cloudX + 1065, cloudY + 200, 80, 80);        ellipse(cloudX + 1130, cloudY + 180, 90, 90);        ellipse(cloudX + 1090, cloudY + 135, 70, 70);    }    void mouseDragged() {        cloudX = mouseX;    }}',correct
'// 15 downline(shipX, shipY - 17, shipX, shipY - 2);',correct
'candleA.display()',correct
'line(shipX, shipY - 30, shipX, shipY - 42);',correct
'bcol',correct
'{    // change back    if (keycount >= 120) {        keycount = 0;        println("controls change back");    }    // change    if (keycount >= 60) {        if (key == CODED) {            if (keyCode == DOWN) {                shipY = shipY - speedY;            } else {                shipY = shipY + speedY;            }            if (keyCode == LEFT) {                shipX = shipX + speedX;            }            if (keyCode == RIGHT) {                shipX = shipX - speedX;            }        }        if (key == a) {            shipX = shipX + speedX;            shipY = shipY - speedY;        }        if (key == d) {            shipX = shipX - speedX;            shipY = shipY - speedY;            println("turned controls");        }    // changed controls    } else {        if (key == CODED) {            if (keyCode == DOWN) {                shipY = shipY + speedY;            } else {                shipY = shipY - speedY;            }            if (keyCode == LEFT) {                shipX = shipX - speedX;            }            if (keyCode == RIGHT) {                shipX = shipX + speedX;            }        }        if (key == a) {            shipX = shipX - speedX;            shipY = shipY + speedY;        }        if (key == d) {            shipX = shipX + speedX;            shipY = shipY + speedY;        }    }    keycount = keycount + 1;    println(keycount);    candleA.updatePosition(shipX, shipY);}',LongMethodRule
'// light lines// 11 - 8 downleftline(shipX - 22, shipY - 27, shipX - 33, shipY - 19);',correct
'ellipse(cloudX + 60, cloudY + 80, 130, 130);',correct
'if (keyCode == DOWN) {    shipY = shipY - speedY;} else {    shipY = shipY + speedY;}',DecentralizedEventHandlingRule
'shipB = new ship(500, 600);',correct
'line(shipX - 60, shipY + 72, shipX - 80, shipY + 97)',correct
'{    if (keyCode == DOWN) {        shipY = shipY - speedY;    } else {        shipY = shipY + speedY;    }    if (keyCode == LEFT) {        shipX = shipX + speedX;    }    if (keyCode == RIGHT) {        shipX = shipX - speedX;    }}',correct
'// changed controls',correct
'// change backif (keycount >= 120) {    keycount = 0;    println("controls change back");}',correct
'ship',correct
'ellipse(shipX + 10, shipY + 47, 15, 15)',correct
'shipA.lit()',correct
'ellipse(cloudX + 550, cloudY + 30, 110, 110)',correct
'candleA',correct
'gcol = random(100);',correct
'ellipse(cloudX - 110, cloudY + 500, 90, 90)',correct
'ellipse(cloudX + 700, cloudY + 300, 100, 100)',correct
'// 11 - 8 uprightline(shipX + 22, shipY - 60, shipX + 33, shipY - 68);',correct
'shipX - 17',correct
'// cloudsfill(255);',correct
'shipC.update()',correct
'shipX + 60',correct
'cloudX + 1090',correct
'shipB = new ship(500, 600)',correct
'{    shipX = shipX - speedX;    shipY = shipY - speedY;    println("turned controls");}',correct
'cloudA.mouseDragged();',correct
'void display() {    stroke(0);    line(shipX, shipY - 30, shipX, shipY - 42);    fill(255);    noStroke();    rect(shipX, shipY, 20, 60);}',correct
'line(shipX - 27, shipY - 45, shipX - 42, shipY - 45)',correct
'cloudY + 80',correct
'framecount > 40',correct
'shipX + 50',correct
'keycount = 0',correct
'int keycount;',StdCyclomaticComplexity
'ellipse(cloudX + 1100, cloudY + 260, 100, 100);',correct
'line(shipX - 60, shipY + 72, shipX - 80, shipY + 97);',correct
'PApplet.parseInt(random(0, 256))',correct
'speedY',correct
'speedX',correct
'rect(shipX, shipY, 20, 60)',correct
'new candle(shipX, shipY)',correct
'shipX + 40',correct
'framecount = 0',correct
'shipX + 42',correct
'isBurning = !isBurning;',correct
'random(255)',correct
'shipY = initY',correct
'line(shipX + 22, shipY - 27, shipX + 33, shipY - 19)',correct
'noStroke()',correct
'shipX = shipX - speedX;',correct
'stroke(100, 150, 200)',correct
'shipC = new ship(1000, 350)',correct
'cloudY + 20',correct
'{    shipX = shipX + speedX;    shipY = shipY - speedY;}',correct
'cloudX = mouseX;',DecentralizedEventHandlingRule
'shipB.update();',correct
'int framecount;',correct
'int speedY;',StdCyclomaticComplexity
'line(shipX - 22, shipY - 27, shipX - 33, shipY - 19)',correct
'shipX + 30',correct
'shipX + 33',correct
'line(shipX + 22, shipY - 60, shipX + 33, shipY - 68)',correct
'void keyPressed() {    // change back    if (keycount >= 120) {        keycount = 0;        println("controls change back");    }    // change    if (keycount >= 60) {        if (key == CODED) {            if (keyCode == DOWN) {                shipY = shipY - speedY;            } else {                shipY = shipY + speedY;            }            if (keyCode == LEFT) {                shipX = shipX + speedX;            }            if (keyCode == RIGHT) {                shipX = shipX - speedX;            }        }        if (key == a) {            shipX = shipX + speedX;            shipY = shipY - speedY;        }        if (key == d) {            shipX = shipX - speedX;            shipY = shipY - speedY;            println("turned controls");        }    // changed controls    } else {        if (key == CODED) {            if (keyCode == DOWN) {                shipY = shipY + speedY;            } else {                shipY = shipY - speedY;            }            if (keyCode == LEFT) {                shipX = shipX - speedX;            }            if (keyCode == RIGHT) {                shipX = shipX + speedX;            }        }        if (key == a) {            shipX = shipX - speedX;            shipY = shipY + speedY;        }        if (key == d) {            shipX = shipX + speedX;            shipY = shipY + speedY;        }    }    keycount = keycount + 1;    println(keycount);    candleA.updatePosition(shipX, shipY);}',StdCyclomaticComplexity
'shipX + 37',correct
'void draw() {    background(128, 179, 255);    cloudA.display();    shipA.display();    shipB.display();    shipC.display();    shipD.display();    shipA.update();    shipB.update();    shipC.update();    shipD.update();}',correct
'// downside of spaceshipfill(shipColor);',correct
'{    shipA.lit();    shipB.lit();    shipC.lit();    shipD.lit();}',correct
'candleA.updatePosition(shipX, shipY)',correct
'fill(255, 145, 0);',correct
'shipY - 65',correct
'shipX = shipX + speedX',correct
'ellipse(cloudX + 500, cloudY, 120, 120);',correct
'shipY - 60',correct
'key == CODED',correct
'candle(float initX, float initY) {    shipX = initX;    shipY = initY;    speedX = 5;    speedY = 5;}',correct
'shipY - 68',correct
'color(redValue, greenValue, blueValue)',correct
'speedY = 5;',correct
'ellipse(cloudX + 1065, cloudY + 200, 80, 80)',correct
'shipX + 22',correct
'{    framecount = framecount + 1;}',correct
'random(100)',correct
'shipC.lit()',correct
'fill(rcol, gcol, bcol);',correct
'shipX + 27',correct
'new ship(500, 600)',correct
'void keyPressed() {    shipA.keyPressed();    shipB.keyPressed();    shipC.keyPressed();    shipD.keyPressed();}',correct
'float cloudY;',correct
'{    fill(255, 145, 0);    ellipse(shipX, shipY - 45, 20, 20);    // light lines    // 11 - 8 downleft    line(shipX - 22, shipY - 27, shipX - 33, shipY - 19);    // 15 left    line(shipX - 27, shipY - 45, shipX - 42, shipY - 45);    // 13 - 8 upleft    line(shipX - 22, shipY - 60, shipX - 33, shipY - 68);    // 15 up    line(shipX, shipY - 65, shipX, shipY - 80);    // 11 - 8 upright    line(shipX + 22, shipY - 60, shipX + 33, shipY - 68);    // 15 right    line(shipX + 27, shipY - 45, shipX + 42, shipY - 45);    // 11 - 8 downright    line(shipX + 22, shipY - 27, shipX + 33, shipY - 19);    // 15 down    line(shipX, shipY - 17, shipX, shipY - 2);}',correct
'shipA.display();',correct
'line(shipX, shipY - 17, shipX, shipY - 2)',correct
'fill(255)',correct
'candle candleA;',StdCyclomaticComplexity
'int blueValue = PApplet.parseInt(random(0, 256))',correct
'shipB.display()',correct
'redValue = PApplet.parseInt(random(0, 256))',correct
'if (keyCode == LEFT) {    shipX = shipX + speedX;}',DecentralizedEventHandlingRule
'shipX + 10',correct
'shipY = shipY - speedY',correct
'ellipse(cloudX, cloudY, 100, 100)',correct
'shipColor = color(redValue, greenValue, blueValue)',correct
'cloudY = initY',correct
'// 11 - 8 downrightline(shipX + 22, shipY - 27, shipX + 33, shipY - 19);',correct
'rcol = random(255)',correct
'{    shipA.keyPressed();    shipB.keyPressed();    shipC.keyPressed();    shipD.keyPressed();}',correct
'{    if (keyCode == DOWN) {        shipY = shipY + speedY;    } else {        shipY = shipY - speedY;    }    if (keyCode == LEFT) {        shipX = shipX - speedX;    }    if (keyCode == RIGHT) {        shipX = shipX + speedX;    }}',correct
'void isBurning() {    fill(255, 145, 0);    ellipse(shipX, shipY - 45, 20, 20);    // light lines    // 11 - 8 downleft    line(shipX - 22, shipY - 27, shipX - 33, shipY - 19);    // 15 left    line(shipX - 27, shipY - 45, shipX - 42, shipY - 45);    // 13 - 8 upleft    line(shipX - 22, shipY - 60, shipX - 33, shipY - 68);    // 15 up    line(shipX, shipY - 65, shipX, shipY - 80);    // 11 - 8 upright    line(shipX + 22, shipY - 60, shipX + 33, shipY - 68);    // 15 right    line(shipX + 27, shipY - 45, shipX + 42, shipY - 45);    // 11 - 8 downright    line(shipX + 22, shipY - 27, shipX + 33, shipY - 19);    // 15 down    line(shipX, shipY - 17, shipX, shipY - 2);}',correct
'float cloudX;',correct
'// light lines',correct
'{    keycount = 0;    println("controls change back");}',correct
'cloudY + 30',correct
'{    shipX = shipX + speedX;    shipY = shipY + speedY;}',correct
'ellipse(cloudX - 110, cloudY + 500, 90, 90);',correct
'cloudA.display()',correct
'shipC.lit();',correct
'if (keyCode == LEFT) {    shipX = shipX - speedX;}',DecentralizedEventHandlingRule
'int speedX;',StdCyclomaticComplexity
'arc(shipX, shipY + 32, 100, 250, PI, TWO_PI);',correct
'ellipse(cloudX + 100, cloudY, 120, 120);',correct
'shipY - 80',correct
'int blueValue = PApplet.parseInt(random(0, 256));',correct
'rcol = random(255);',correct
'shipA',correct
'cloud(float initX, float initY) {    cloudX = initX;    cloudY = initY;}',correct
'framecount = 0;',correct
'shipC',correct
'shipB',correct
'fill(128, 179, 255, 40)',correct
'shipD',correct
'ellipse(cloudX + 1100, cloudY + 260, 100, 100)',correct
'ellipse(cloudX + 400, cloudY - 50, 110, 110)',correct
'cloudX + 550',correct
'cloudY + 510',correct
'shipC.display();',correct
'shipY',correct
'shipX',correct
'candleA.isBurning()',correct
'shipB.update()',correct
'{    shipX = shipX + speedX;}',correct
'{    cloudX = mouseX;}',correct
'keyCode == LEFT',correct
'{    if (key == CODED) {        if (keyCode == DOWN) {            shipY = shipY - speedY;        } else {            shipY = shipY + speedY;        }        if (keyCode == LEFT) {            shipX = shipX + speedX;        }        if (keyCode == RIGHT) {            shipX = shipX - speedX;        }    }    if (key == a) {        shipX = shipX + speedX;        shipY = shipY - speedY;    }    if (key == d) {        shipX = shipX - speedX;        shipY = shipY - speedY;        println("turned controls");    }// changed controls}',correct
'if (isBurning) {    candleA.isBurning();}',correct
'shipX - 80',correct
'cloudX = initX',correct
'shipColor = color(redValue, greenValue, blueValue);',correct
'if (key == CODED) {    if (keyCode == DOWN) {        shipY = shipY - speedY;    } else {        shipY = shipY + speedY;    }    if (keyCode == LEFT) {        shipX = shipX + speedX;    }    if (keyCode == RIGHT) {        shipX = shipX - speedX;    }}',correct
'shipX = initX',correct
'ellipse(cloudX + 700, cloudY + 300, 100, 100);',correct
'{    // clouds    fill(255);    noStroke();    ellipse(cloudX, cloudY, 100, 100);    ellipse(cloudX + 60, cloudY + 80, 130, 130);    ellipse(cloudX + 80, cloudY + 160, 100, 100);    ellipse(cloudX + 100, cloudY, 120, 120);    ellipse(cloudX + 400, cloudY - 50, 110, 110);    ellipse(cloudX + 500, cloudY, 120, 120);    ellipse(cloudX + 550, cloudY + 30, 110, 110);    ellipse(cloudX + 440, cloudY + 20, 100, 100);    ellipse(cloudX - 100, cloudY + 450, 100, 100);    ellipse(cloudX - 40, cloudY + 440, 80, 80);    ellipse(cloudX - 35, cloudY + 510, 100, 100);    ellipse(cloudX - 110, cloudY + 500, 90, 90);    ellipse(cloudX + 700, cloudY + 300, 100, 100);    ellipse(cloudX + 760, cloudY + 330, 110, 110);    ellipse(cloudX + 830, cloudY + 320, 90, 90);    ellipse(cloudX + 720, cloudY + 365, 80, 80);    ellipse(cloudX + 1100, cloudY + 260, 100, 100);    ellipse(cloudX + 1065, cloudY + 200, 80, 80);    ellipse(cloudX + 1130, cloudY + 180, 90, 90);    ellipse(cloudX + 1090, cloudY + 135, 70, 70);}',correct
'ellipse(cloudX - 40, cloudY + 440, 80, 80);',correct
'shipA.display()',correct
'shipC = new ship(1000, 350);',correct
'ellipse(shipX + 37, shipY + 47, 15, 15)',correct
'shipY = shipY + speedY',correct
'shipY - 2',correct
'line(shipX - 30, shipY + 74, shipX - 45, shipY + 99)',correct
'key == d',correct
'// 13 - 8 upleftline(shipX - 22, shipY - 60, shipX - 33, shipY - 68);',correct
'void display() {    // clouds    fill(255);    noStroke();    ellipse(cloudX, cloudY, 100, 100);    ellipse(cloudX + 60, cloudY + 80, 130, 130);    ellipse(cloudX + 80, cloudY + 160, 100, 100);    ellipse(cloudX + 100, cloudY, 120, 120);    ellipse(cloudX + 400, cloudY - 50, 110, 110);    ellipse(cloudX + 500, cloudY, 120, 120);    ellipse(cloudX + 550, cloudY + 30, 110, 110);    ellipse(cloudX + 440, cloudY + 20, 100, 100);    ellipse(cloudX - 100, cloudY + 450, 100, 100);    ellipse(cloudX - 40, cloudY + 440, 80, 80);    ellipse(cloudX - 35, cloudY + 510, 100, 100);    ellipse(cloudX - 110, cloudY + 500, 90, 90);    ellipse(cloudX + 700, cloudY + 300, 100, 100);    ellipse(cloudX + 760, cloudY + 330, 110, 110);    ellipse(cloudX + 830, cloudY + 320, 90, 90);    ellipse(cloudX + 720, cloudY + 365, 80, 80);    ellipse(cloudX + 1100, cloudY + 260, 100, 100);    ellipse(cloudX + 1065, cloudY + 200, 80, 80);    ellipse(cloudX + 1130, cloudY + 180, 90, 90);    ellipse(cloudX + 1090, cloudY + 135, 70, 70);}',correct
'shipA = new ship(100, 200)',correct
'fill(255, 145, 0)',correct
'cloudX + 400',correct
'shipX + speedX',correct
'key == a',correct
'shipX = initX;',correct
'shipD.update()',correct
'arc(shipX, shipY + 32, 100, 250, PI, TWO_PI)',correct
'keyCode == RIGHT',correct
'ellipse(cloudX - 35, cloudY + 510, 100, 100)',correct
'{    cloudA.mouseDragged();}',correct
'ellipse(cloudX + 440, cloudY + 20, 100, 100)',correct
'shipA.keyPressed()',correct
'display',correct
'boolean isBurning;',StdCyclomaticComplexity
'shipC.keyPressed()',correct
'cloudX + 760',correct
'cloudY + 500',correct
'shipX - 60',correct
'ellipse(shipX, shipY - 45, 20, 20);',correct
'stroke(100, 150, 200);',correct
'// upperpart spaceshipfill(128, 179, 255, 40);',correct
'cloudY = initY;',correct
'ellipse(cloudX + 830, cloudY + 320, 90, 90);',correct
'{    if (key == CODED) {        if (keyCode == DOWN) {            shipY = shipY + speedY;        } else {            shipY = shipY - speedY;        }        if (keyCode == LEFT) {            shipX = shipX - speedX;        }        if (keyCode == RIGHT) {            shipX = shipX + speedX;        }    }    if (key == a) {        shipX = shipX - speedX;        shipY = shipY + speedY;    }    if (key == d) {        shipX = shipX + speedX;        shipY = shipY + speedY;    }}',correct
'float initX',correct
'float initY',correct
'line(shipX, shipY + 75, shipX, shipY + 100);',correct
'gcol',correct
'{    isBurning = !isBurning;}',correct
'cloudY + 440',correct
'cloudX - 110',correct
'ellipse(cloudX + 1130, cloudY + 180, 90, 90);',correct
'cloud',correct
'shipX - 50',correct
'blueValue = PApplet.parseInt(random(0, 256))',correct
'fill(255);',correct
'gcol = random(100)',correct
'keyCode == DOWN',correct
'fill(shipColor)',correct
'keyPressed',LongMethodRule
'void mouseDragged() {    cloudA.mouseDragged();}',correct
'cloudY + 330',correct
'background(128, 179, 255);',correct
'ellipse(cloudX - 100, cloudY + 450, 100, 100);',correct
'line(shipX + 27, shipY - 45, shipX + 42, shipY - 45)',correct
'cloudY + 450',correct
'candleA.updatePosition(shipX, shipY);',correct
'candleA.display();',correct
'line(shipX + 60, shipY + 72, shipX + 80, shipY + 97)',correct
'cloudX + 100',correct
'shipY = shipY - speedY;',correct
'void update() {    if (framecount > 40) {        rcol = random(255);        gcol = random(100);        bcol = random(255);        framecount = 0;    } else {        framecount = framecount + 1;    }    if (isBurning) {        candleA.isBurning();    }}',StdCyclomaticComplexity
'shipB.lit();',correct
'cloudY + 200',correct
'shipC.update();',correct
'shipX - 44',correct
'cloudY + 320',correct
'shipX - 42',correct
'mouseClicked',correct
'println(keycount);',correct
'ellipse(cloudX + 1130, cloudY + 180, 90, 90)',correct
'cloudA',correct
'shipX - 45',correct
'println("turned controls")',correct
'int redValue = PApplet.parseInt(random(0, 256));',correct
'ellipse(cloudX + 60, cloudY + 80, 130, 130)',correct
'void updatePosition(float initX, float initY) {    shipX = initX;    shipY = initY;}',correct
'ellipse(shipX - 17, shipY + 47, 15, 15)',correct
'if (key == d) {    shipX = shipX + speedX;    shipY = shipY + speedY;}',DecentralizedEventHandlingRule
'keycount + 1',correct
'shipD.display();',correct
'ship shipB;',correct
'cloudY',correct
'// 15 rightline(shipX + 27, shipY - 45, shipX + 42, shipY - 45);',correct
'ellipse(shipX, shipY - 45, 20, 20)',correct
'framecount',correct
'shipX - 33',correct
'cloudX',correct
'shipX - 30',correct
'println("controls change back")',correct
'cloudY - 50',correct
'{    shipX = initX;    shipY = initY;}',correct
'shipD.update();',correct
'shipB.keyPressed()',correct
'{    rectMode(CENTER);    shipA = new ship(100, 200);    shipB = new ship(500, 600);    shipC = new ship(1000, 350);    shipD = new ship(800, 300);    cloudA = new cloud(500, 100);}',correct
'println("turned controls");',correct
'ship shipC;',correct
'shipX + 80',correct
'cloudX + 440',correct
'shipX - 22',correct
'cloudY + 300',correct
'candleA.isBurning();',correct
'rcol',correct
'println("controls change back");',correct
'shipX - 27',correct
'sunColor = tempsunColor',correct
'cY = tempY;',correct
'Rayx + 30',correct
'scream',correct
'[12]',correct
'Bird(float Xpos, float Ypos, int bodyColor1, int bodyColor2) {    Rayx = Xpos;    Rayy = Ypos;    // random color    bc1 = bodyColor1;    // white    bc2 = bodyColor2;}',correct
'void talk() {    // make the bird scream    scream.play();}',correct
'float Rayy;',correct
'bc2',correct
'bc1',correct
'triangle(Rayx + 20, Rayy + 30, Rayx + 45, Rayy + 40, Rayx + 60, Rayy + 20);',correct
'PApplet.parseInt(random(0, height))',correct
'fill(sunColor)',correct
'float sunY;',correct
'Rayx + 20',correct
'random(0, 256)',correct
'ellipse(cX + 40, cY + 10, 50, 50);',correct
'cX + 15',correct
'{    birds[i].display();    birds[i].update();}',correct
'// Rayx+20,Rayy+30 (friendly reminder for positions)// Rayx-20,Rayy+30// bc2 is white and bc1 is the random color// head of the birdfill(bc1);',correct
'int tempsunColor',correct
'{    // draws the clouds    stroke(cc);    fill(cc);    ellipse(cX, cY, 65, 65);    ellipse(cX + 40, cY + 10, 50, 50);    ellipse(cX + 15, cY + 40, 45, 45);    ellipse(cX - 25, cY + 40, 40, 40);    ellipse(cX - 40, cY + 10, 50, 50);}',correct
'triangle(Rayx - 20, Rayy + 30, Rayx - 60, Rayy + 20, Rayx - 65, Rayy);',correct
'cc = tempCC;',correct
'void update() {    // making the clouds go to the right    cX++;    // making the clouds reappear at cX=-100 with a random height    if (cX > width + 150) {        cY = random(0, height + 1);        cX = -100;    }}',correct
'changeColor',correct
'Rayy < -100',correct
'cX = -100',correct
'// background color set to sky bluebackground(135, 206, 250);',correct
'// left arm// triangle(joint, feather,edge)fill(bc1);',correct
'sun',correct
'{    Rayx = Xpos;    Rayy = Ypos;    // random color    bc1 = bodyColor1;    // white    bc2 = bodyColor2;}',VariableNamingConventions
'{    clouds[j].display();    clouds[j].update();}',correct
'cX',correct
'cY',correct
'fill(bc2);',correct
'ellipse(cX + 15, cY + 40, 45, 45)',correct
'cX++',correct
'// making the clouds go to the rightcX++;',correct
'cc',correct
'bc2 = bodyColor2',correct
'birds[i].display()',correct
'Rayx + 45',correct
'SoundFile',correct
's',correct
'ellipse(cX, cY, 65, 65);',correct
'cX + 40',correct
'// import soundfileSoundFile scream;',correct
'// define the variablesfloat Rayx;',correct
'Rayx = Xpos',correct
'fill(cc);',correct
'Rayy = Ypos;',correct
'{    // draw the sun    fill(sunColor);    stroke(sunColor);    ellipse(sunX, sunY, sunSize, sunSize);}',correct
'cY = random(0, height + 1);',correct
'stroke(bc2);',correct
'{    birds[i].talk();}',correct
'triangle(Rayx + 20, Rayy + 30, Rayx + 60, Rayy + 20, Rayx + 65, Rayy);',correct
'// draws the cloudsstroke(cc);',correct
'sunY = tempsunY',correct
'// display the sunsun.display();',correct
'stroke(cc)',correct
'cX = tempX',correct
'int tempCC',correct
'sunColor',correct
'void update() {    // birds will go up    Rayy--;    // make birds reappear from the bottom at random x positions and random y position (height+50+random between 0 and height)    if (Rayy < -100) {        bc1 = color(random(0, 256), random(0, 256), random(0, 256));        Rayy = height + 50 + PApplet.parseInt(random(0, height));        Rayx = random(0, width - 100);    }}',correct
'Rayx + 7',correct
'cX > width + 150',correct
'Rayx = random(0, width - 100)',correct
'/*link to soundfile: https://www.zapsplat.com/?s=hawk*/',correct
'triangle(Rayx - 20, Rayy + 30, Rayx, Rayy + 75, Rayx + 20, Rayy + 30)',correct
'{    cX = tempX;    cY = tempY;    cc = tempCC;}',correct
'triangle(Rayx - 7, Rayy - 20, Rayx + 7, Rayy - 20, Rayx, Rayy + 13)',correct
'talk',correct
'cY + 40',correct
'this',correct
'birds.length',correct
'// defining the variablesfloat sunX;',correct
'int sunColor;',correct
'// birds will go upRayy--;',correct
'class Cloud {    // defining the variables    float cX;    float cY;    int cc;    Cloud(float tempX, float tempY, int tempCC) {        cX = tempX;        cY = tempY;        cc = tempCC;    }    void display() {        // draws the clouds        stroke(cc);        fill(cc);        ellipse(cX, cY, 65, 65);        ellipse(cX + 40, cY + 10, 50, 50);        ellipse(cX + 15, cY + 40, 45, 45);        ellipse(cX - 25, cY + 40, 40, 40);        ellipse(cX - 40, cY + 10, 50, 50);    }    void update() {        // making the clouds go to the right        cX++;        // making the clouds reappear at cX=-100 with a random height        if (cX > width + 150) {            cY = random(0, height + 1);            cX = -100;        }    }}',correct
'new sun(100, 100, color(245, 169, 56), 75)',correct
'-100',correct
'float sunSize;',correct
'{    bc1 = color(random(0, 256), random(0, 256), random(0, 256));    Rayy = height + 50 + PApplet.parseInt(random(0, height));    Rayx = random(0, width - 100);}',correct
'Rayy = height + 50 + PApplet.parseInt(random(0, height))',correct
'bc1 = color(random(0, 256), random(0, 256), random(0, 256))',correct
'sunX = tempsunX;',correct
'sun(float tempsunX, float tempsunY, int tempsunColor, float tempsunSize) {    sunX = tempsunX;    sunY = tempsunY;    sunColor = tempsunColor;    sunSize = tempsunSize;}',correct
'triangle(Rayx - 20, Rayy + 30, Rayx - 65, Rayy, Rayx - 75, Rayy - 90)',correct
'triangle(Rayx - 20, Rayy + 30, Rayx - 45, Rayy + 40, Rayx - 60, Rayy + 20)',correct
'int cc;',ShortVariable
'random(0, height + 1)',correct
'cc = tempCC',correct
'Rayy = height + 50 + PApplet.parseInt(random(0, height));',correct
'background(135, 206, 250)',correct
'stroke(bc1);',correct
'// make birds reappear from the bottom at random x positions and random y position (height+50+random between 0 and height)if (Rayy < -100) {    bc1 = color(random(0, 256), random(0, 256), random(0, 256));    Rayy = height + 50 + PApplet.parseInt(random(0, height));    Rayx = random(0, width - 100);}',correct
'Bird',correct
'Rayx + 15',correct
'update',correct
'random(0, height)',correct
'scream = new SoundFile(this, "hawk.mp3");',correct
'int bodyColor2',VariableNamingConventions
'ellipse(cX - 40, cY + 10, 50, 50);',correct
'clouds[j] = new Cloud(random(-100, 900), random(0, height), 240);',correct
'{    for (int i = 0; i < birds.length; i++) {        birds[i].changeColor();    }}',correct
'Processing',correct
'// Array of 10 birds and 12 clouds (initialize)for (int i = 0; i < birds.length; i++) {    birds[i] = new Bird(random(100, 700), random(100, 700), color(random(0, 256), random(0, 256), random(0, 256)), color(255));}',correct
'int bodyColor1',VariableNamingConventions
'fill(bc2)',correct
'random(0, width - 100)',correct
'fill(cc)',correct
'for (int i = 0; i < birds.length; i++) {    birds[i].changeColor();}',correct
'height + 50',correct
'Rayy - 90',correct
'// right arm',correct
'void setup() {    // Array of 10 birds and 12 clouds (initialize)    for (int i = 0; i < birds.length; i++) {        birds[i] = new Bird(random(100, 700), random(100, 700), color(random(0, 256), random(0, 256), random(0, 256)), color(255));    }    for (int j = 0; j < clouds.length; j++) {        clouds[j] = new Cloud(random(-100, 900), random(0, height), 240);    }    scream = new SoundFile(this, "hawk.mp3");/*link to soundfile: https://www.zapsplat.com/?s=hawk*/}',correct
'sunSize = tempsunSize;',correct
'scream.play()',correct
'triangle(Rayx - 20, Rayy + 30, Rayx - 30, Rayy + 60, Rayx - 45, Rayy + 40);',correct
'clouds[j].update();',correct
'triangle(Rayx - 15, Rayy + 90, Rayx, Rayy + 75, Rayx + 15, Rayy + 90)',correct
'{    // Array of 10 birds and 12 clouds (initialize)    for (int i = 0; i < birds.length; i++) {        birds[i] = new Bird(random(100, 700), random(100, 700), color(random(0, 256), random(0, 256), random(0, 256)), color(255));    }    for (int j = 0; j < clouds.length; j++) {        clouds[j] = new Cloud(random(-100, 900), random(0, height), 240);    }    scream = new SoundFile(this, "hawk.mp3");/*link to soundfile: https://www.zapsplat.com/?s=hawk*/}',correct
'triangle(Rayx - 20, Rayy + 30, Rayx - 65, Rayy, Rayx - 75, Rayy - 90);',correct
'Cloud[]',correct
'// display function of the birdvoid display() {    // body bird    stroke(bc2);    fill(bc2);    triangle(Rayx - 20, Rayy + 30, Rayx, Rayy + 75, Rayx + 20, Rayy + 30);    quad(Rayx - 20, Rayy + 30, Rayx - 7, Rayy - 20, Rayx + 7, Rayy - 20, Rayx + 20, Rayy + 30);    // Rayx+20,Rayy+30 (friendly reminder for positions)    // Rayx-20,Rayy+30    // bc2 is white and bc1 is the random color    // head of the bird    fill(bc1);    stroke(bc1);    triangle(Rayx - 7, Rayy - 20, Rayx + 7, Rayy - 20, Rayx, Rayy + 13);    // feather tail    triangle(Rayx - 15, Rayy + 90, Rayx, Rayy + 75, Rayx + 15, Rayy + 90);    // right arm    // Triangle(Joint, feather, edge)    triangle(Rayx + 20, Rayy + 30, Rayx + 65, Rayy, Rayx + 75, Rayy - 90);    triangle(Rayx + 20, Rayy + 30, Rayx + 45, Rayy + 40, Rayx + 60, Rayy + 20);    fill(bc2);    stroke(bc2);    triangle(Rayx + 20, Rayy + 30, Rayx + 30, Rayy + 60, Rayx + 45, Rayy + 40);    triangle(Rayx + 20, Rayy + 30, Rayx + 60, Rayy + 20, Rayx + 65, Rayy);    // left arm    // triangle(joint, feather,edge)    fill(bc1);    stroke(bc1);    triangle(Rayx - 20, Rayy + 30, Rayx - 65, Rayy, Rayx - 75, Rayy - 90);    triangle(Rayx - 20, Rayy + 30, Rayx - 45, Rayy + 40, Rayx - 60, Rayy + 20);    fill(bc2);    stroke(bc2);    triangle(Rayx - 20, Rayy + 30, Rayx - 30, Rayy + 60, Rayx - 45, Rayy + 40);    triangle(Rayx - 20, Rayy + 30, Rayx - 60, Rayy + 20, Rayx - 65, Rayy);}',correct
'// whitebc2 = bodyColor2;',correct
'float cY;',ShortVariable
'clouds = new Cloud[12]',correct
'ellipse(cX - 25, cY + 40, 40, 40);',correct
'color(random(0, 256), random(0, 256), random(0, 256))',correct
'random(100, 700)',correct
'// array of cloudsCloud[] clouds = new Cloud[12];',correct
'Rayy--',correct
'int i = 0',correct
'// making the clouds reappear at cX=-100 with a random heightif (cX > width + 150) {    cY = random(0, height + 1);    cX = -100;}',correct
'fill(bc1)',correct
'void changeColor() {    // make the birds change color    bc1 = color(random(0, 256), random(0, 256), random(0, 256));}',correct
'quad(Rayx - 20, Rayy + 30, Rayx - 7, Rayy - 20, Rayx + 7, Rayy - 20, Rayx + 20, Rayy + 30);',correct
'setup',correct
'ellipse(sunX, sunY, sunSize, sunSize)',correct
'new SoundFile(this, "hawk.mp3")',correct
'triangle(Rayx + 20, Rayy + 30, Rayx + 65, Rayy, Rayx + 75, Rayy - 90)',correct
'i = 0',correct
'cY + 10',correct
'j < clouds.length',correct
'Rayy + 40',correct
'mousePressed == true',SimplifyBooleanExpressions
'cX = tempX;',correct
'color(255)',correct
'// feather tailtriangle(Rayx - 15, Rayy + 90, Rayx, Rayy + 75, Rayx + 15, Rayy + 90);',correct
'cX - 25',correct
'{    // make the birds change color    bc1 = color(random(0, 256), random(0, 256), random(0, 256));}',correct
'new Bird(random(100, 700), random(100, 700), color(random(0, 256), random(0, 256), random(0, 256)), color(255))',correct
'void keyPressed() {    // make the birds change color when s is pressed    if (key == s) {        for (int i = 0; i < birds.length; i++) {            birds[i].changeColor();        }    }}',correct
'// import soundfile',correct
'ellipse(cX, cY, 65, 65)',correct
'stroke(sunColor)',correct
'birds[i].update()',correct
'Rayx - 60',correct
'Rayx - 7',correct
'i < birds.length',correct
'stroke(bc1)',correct
'sun = new sun(100, 100, color(245, 169, 56), 75)',correct
'{    clouds[j] = new Cloud(random(-100, 900), random(0, height), 240);}',correct
'birds[i].changeColor()',correct
'Rayy + 30',correct
'sunSize',correct
'// right arm// Triangle(Joint, feather, edge)triangle(Rayx + 20, Rayy + 30, Rayx + 65, Rayy, Rayx + 75, Rayy - 90);',correct
'ellipse(cX - 40, cY + 10, 50, 50)',correct
'"hawk.mp3"',correct
'{    // make the birds change color when s is pressed    if (key == s) {        for (int i = 0; i < birds.length; i++) {            birds[i].changeColor();        }    }}',correct
'{    // background color set to sky blue    background(135, 206, 250);    // display the sun    sun.display();    // calls constructor to display+update the array of clouds    for (int j = 0; j < clouds.length; j++) {        clouds[j].display();        clouds[j].update();    }    // calls constructor to display+update the array of birds    for (int i = 0; i < birds.length; i++) {        birds[i].display();        birds[i].update();    }}',correct
'{    // making the clouds go to the right    cX++;    // making the clouds reappear at cX=-100 with a random height    if (cX > width + 150) {        cY = random(0, height + 1);        cX = -100;    }}',correct
'triangle(Rayx + 20, Rayy + 30, Rayx + 30, Rayy + 60, Rayx + 45, Rayy + 40);',correct
'Rayx - 45',correct
'class sun {    // defining the variables    float sunX;    float sunY;    float sunSize;    int sunColor;    sun(float tempsunX, float tempsunY, int tempsunColor, float tempsunSize) {        sunX = tempsunX;        sunY = tempsunY;        sunColor = tempsunColor;        sunSize = tempsunSize;    }    void display() {        // draw the sun        fill(sunColor);        stroke(sunColor);        ellipse(sunX, sunY, sunSize, sunSize);    }}',correct
'clouds[j] = new Cloud(random(-100, 900), random(0, height), 240)',correct
'cX - 40',correct
'for (int j = 0; j < clouds.length; j++) {    clouds[j] = new Cloud(random(-100, 900), random(0, height), 240);}',correct
'sunColor = tempsunColor;',correct
'stroke(bc2)',correct
'int j = 0',correct
'Rayy + 20',correct
'birds[i].changeColor();',correct
'clouds[j].display()',correct
'Rayy = Ypos',correct
'clouds[j].update()',correct
'j++',correct
'new Bird[10]',correct
'ellipse(sunX, sunY, sunSize, sunSize);',correct
'Rayx - 75',correct
'clouds.length',correct
'triangle(Rayx - 20, Rayy + 30, Rayx - 45, Rayy + 40, Rayx - 60, Rayy + 20);',correct
'// Rayx+20,Rayy+30 (friendly reminder for positions)',correct
'height + 50 + PApplet.parseInt(random(0, height))',correct
'triangle(Rayx - 20, Rayy + 30, Rayx - 60, Rayy + 20, Rayx - 65, Rayy)',correct
'key == s',correct
'scream = new SoundFile(this, "hawk.mp3")',correct
'// defining the variablesfloat cX;',correct
'Cloud(float tempX, float tempY, int tempCC) {    cX = tempX;    cY = tempY;    cc = tempCC;}',correct
'birds[i].talk()',correct
'sun.display()',correct
'color(245, 169, 56)',correct
'display',correct
'Bird[]',correct
'Rayx - 65',correct
'// Rayx-20,Rayy+30',correct
'Rayy + 13',correct
'draw',correct
'stroke(sunColor);',correct
'triangle(Rayx - 20, Rayy + 30, Rayx, Rayy + 75, Rayx + 20, Rayy + 30);',correct
'triangle(Rayx + 20, Rayy + 30, Rayx + 60, Rayy + 20, Rayx + 65, Rayy)',correct
'birds[i]',correct
'width - 100',correct
'{    cY = random(0, height + 1);    cX = -100;}',correct
'ellipse(cX + 15, cY + 40, 45, 45);',correct
'birds[i] = new Bird(random(100, 700), random(100, 700), color(random(0, 256), random(0, 256), random(0, 256)), color(255))',correct
'float Ypos',VariableNamingConventions
'birds[i].update();',correct
'{    // plays scream when mousepressed is true    if (mousePressed == true) {        for (int i = 0; i < birds.length; i++) {            birds[i].talk();        }    }}',correct
'quad(Rayx - 20, Rayy + 30, Rayx - 7, Rayy - 20, Rayx + 7, Rayy - 20, Rayx + 20, Rayy + 30)',correct
'birds = new Bird[10]',correct
'Rayy - 20',correct
'Rayx - 15',correct
'// body birdstroke(bc2);',correct
'i++',correct
'Rayx',correct
'Rayy',correct
'Rayx + 75',correct
'ellipse(cX - 25, cY + 40, 40, 40)',correct
'// left arm',correct
'mousePressed',correct
'triangle(Rayx - 7, Rayy - 20, Rayx + 7, Rayy - 20, Rayx, Rayy + 13);',correct
'cY = random(0, height + 1)',correct
'clouds[j]',correct
'{    // body bird    stroke(bc2);    fill(bc2);    triangle(Rayx - 20, Rayy + 30, Rayx, Rayy + 75, Rayx + 20, Rayy + 30);    quad(Rayx - 20, Rayy + 30, Rayx - 7, Rayy - 20, Rayx + 7, Rayy - 20, Rayx + 20, Rayy + 30);    // Rayx+20,Rayy+30 (friendly reminder for positions)    // Rayx-20,Rayy+30    // bc2 is white and bc1 is the random color    // head of the bird    fill(bc1);    stroke(bc1);    triangle(Rayx - 7, Rayy - 20, Rayx + 7, Rayy - 20, Rayx, Rayy + 13);    // feather tail    triangle(Rayx - 15, Rayy + 90, Rayx, Rayy + 75, Rayx + 15, Rayy + 90);    // right arm    // Triangle(Joint, feather, edge)    triangle(Rayx + 20, Rayy + 30, Rayx + 65, Rayy, Rayx + 75, Rayy - 90);    triangle(Rayx + 20, Rayy + 30, Rayx + 45, Rayy + 40, Rayx + 60, Rayy + 20);    fill(bc2);    stroke(bc2);    triangle(Rayx + 20, Rayy + 30, Rayx + 30, Rayy + 60, Rayx + 45, Rayy + 40);    triangle(Rayx + 20, Rayy + 30, Rayx + 60, Rayy + 20, Rayx + 65, Rayy);    // left arm    // triangle(joint, feather,edge)    fill(bc1);    stroke(bc1);    triangle(Rayx - 20, Rayy + 30, Rayx - 65, Rayy, Rayx - 75, Rayy - 90);    triangle(Rayx - 20, Rayy + 30, Rayx - 45, Rayy + 40, Rayx - 60, Rayy + 20);    fill(bc2);    stroke(bc2);    triangle(Rayx - 20, Rayy + 30, Rayx - 30, Rayy + 60, Rayx - 45, Rayy + 40);    triangle(Rayx - 20, Rayy + 30, Rayx - 60, Rayy + 20, Rayx - 65, Rayy);}',correct
'int bc1;',correct
'triangle(Rayx + 20, Rayy + 30, Rayx + 30, Rayy + 60, Rayx + 45, Rayy + 40)',correct
'class Bird {    // define the variables    float Rayx;    float Rayy;    int bc1;    int bc2;    Bird(float Xpos, float Ypos, int bodyColor1, int bodyColor2) {        Rayx = Xpos;        Rayy = Ypos;        // random color        bc1 = bodyColor1;        // white        bc2 = bodyColor2;    }    // display function of the bird    void display() {        // body bird        stroke(bc2);        fill(bc2);        triangle(Rayx - 20, Rayy + 30, Rayx, Rayy + 75, Rayx + 20, Rayy + 30);        quad(Rayx - 20, Rayy + 30, Rayx - 7, Rayy - 20, Rayx + 7, Rayy - 20, Rayx + 20, Rayy + 30);        // Rayx+20,Rayy+30 (friendly reminder for positions)        // Rayx-20,Rayy+30        // bc2 is white and bc1 is the random color        // head of the bird        fill(bc1);        stroke(bc1);        triangle(Rayx - 7, Rayy - 20, Rayx + 7, Rayy - 20, Rayx, Rayy + 13);        // feather tail        triangle(Rayx - 15, Rayy + 90, Rayx, Rayy + 75, Rayx + 15, Rayy + 90);        // right arm        // Triangle(Joint, feather, edge)        triangle(Rayx + 20, Rayy + 30, Rayx + 65, Rayy, Rayx + 75, Rayy - 90);        triangle(Rayx + 20, Rayy + 30, Rayx + 45, Rayy + 40, Rayx + 60, Rayy + 20);        fill(bc2);        stroke(bc2);        triangle(Rayx + 20, Rayy + 30, Rayx + 30, Rayy + 60, Rayx + 45, Rayy + 40);        triangle(Rayx + 20, Rayy + 30, Rayx + 60, Rayy + 20, Rayx + 65, Rayy);        // left arm        // triangle(joint, feather,edge)        fill(bc1);        stroke(bc1);        triangle(Rayx - 20, Rayy + 30, Rayx - 65, Rayy, Rayx - 75, Rayy - 90);        triangle(Rayx - 20, Rayy + 30, Rayx - 45, Rayy + 40, Rayx - 60, Rayy + 20);        fill(bc2);        stroke(bc2);        triangle(Rayx - 20, Rayy + 30, Rayx - 30, Rayy + 60, Rayx - 45, Rayy + 40);        triangle(Rayx - 20, Rayy + 30, Rayx - 60, Rayy + 20, Rayx - 65, Rayy);    }    void update() {        // birds will go up        Rayy--;        // make birds reappear from the bottom at random x positions and random y position (height+50+random between 0 and height)        if (Rayy < -100) {            bc1 = color(random(0, 256), random(0, 256), random(0, 256));            Rayy = height + 50 + PApplet.parseInt(random(0, height));            Rayx = random(0, width - 100);        }    }    void talk() {        // make the bird scream        scream.play();    }    void changeColor() {        // make the birds change color        bc1 = color(random(0, 256), random(0, 256), random(0, 256));    }}',correct
'birds[i].talk();',correct
'Rayy + 90',correct
'float Xpos',VariableNamingConventions
'birds[i].display();',correct
'void',correct
'triangle(Rayx - 20, Rayy + 30, Rayx - 30, Rayy + 60, Rayx - 45, Rayy + 40)',correct
'keyPressed',correct
'Rayy + 75',correct
'// bc2 is white and bc1 is the random color',correct
'// calls constructor to display+update the array of cloudsfor (int j = 0; j < clouds.length; j++) {    clouds[j].display();    clouds[j].update();}',correct
'Rayx = Xpos;',correct
'Rayx + 65',correct
'{    birds[i] = new Bird(random(100, 700), random(100, 700), color(random(0, 256), random(0, 256), random(0, 256)), color(255));}',correct
'birds[i] = new Bird(random(100, 700), random(100, 700), color(random(0, 256), random(0, 256), random(0, 256)), color(255));',correct
'Rayx + 60',correct
'{    for (int i = 0; i < birds.length; i++) {        birds[i].talk();    }}',correct
'// draw the sunfill(sunColor);',correct
'// calls constructor to display+update the array of birdsfor (int i = 0; i < birds.length; i++) {    birds[i].display();    birds[i].update();}',correct
'{    sunX = tempsunX;    sunY = tempsunY;    sunColor = tempsunColor;    sunSize = tempsunSize;}',correct
'j = 0',correct
'cX = -100;',correct
'triangle(Rayx + 20, Rayy + 30, Rayx + 45, Rayy + 40, Rayx + 60, Rayy + 20)',correct
'void draw() {    // background color set to sky blue    background(135, 206, 250);    // display the sun    sun.display();    // calls constructor to display+update the array of clouds    for (int j = 0; j < clouds.length; j++) {        clouds[j].display();        clouds[j].update();    }    // calls constructor to display+update the array of birds    for (int i = 0; i < birds.length; i++) {        birds[i].display();        birds[i].update();    }}',correct
'void mousePressed() {    // plays scream when mousepressed is true    if (mousePressed == true) {        for (int i = 0; i < birds.length; i++) {            birds[i].talk();        }    }}',correct
'random(-100, 900)',correct
'true',correct
'// new sunsun sun = new sun(100, 100, color(245, 169, 56), 75);',correct
'sunX',correct
'sunY',correct
'height + 1',correct
'{    // birds will go up    Rayy--;    // make birds reappear from the bottom at random x positions and random y position (height+50+random between 0 and height)    if (Rayy < -100) {        bc1 = color(random(0, 256), random(0, 256), random(0, 256));        Rayy = height + 50 + PApplet.parseInt(random(0, height));        Rayx = random(0, width - 100);    }}',correct
'Rayy + 60',correct
'float tempsunX',correct
'float tempsunY',correct
'void display() {    // draw the sun    fill(sunColor);    stroke(sunColor);    ellipse(sunX, sunY, sunSize, sunSize);}',correct
'[10]',correct
'clouds[j].display();',correct
'Rayx - 30',correct
'Rayx = random(0, width - 100);',correct
'float tempsunSize',correct
'new Cloud(random(-100, 900), random(0, height), 240)',correct
'sunY = tempsunY;',correct
'float tempY',correct
'new Cloud[12]',correct
'float tempX',correct
'sunX = tempsunX',correct
'{    // make the bird scream    scream.play();}',correct
'bc1 = color(random(0, 256), random(0, 256), random(0, 256));',correct
'for (int i = 0; i < birds.length; i++) {    birds[i].talk();}',correct
'sunSize = tempsunSize',correct
'void display() {    // draws the clouds    stroke(cc);    fill(cc);    ellipse(cX, cY, 65, 65);    ellipse(cX + 40, cY + 10, 50, 50);    ellipse(cX + 15, cY + 40, 45, 45);    ellipse(cX - 25, cY + 40, 40, 40);    ellipse(cX - 40, cY + 10, 50, 50);}',correct
'bc1 = bodyColor1',correct
'{    birds[i].changeColor();}',correct
'// random colorbc1 = bodyColor1;',correct
'Rayx - 20',correct
'int bc2;',correct
'Cloud',correct
'cY = tempY',correct
'// array of birdsBird[] birds = new Bird[10];',correct
'ellipse(cX + 40, cY + 10, 50, 50)',correct
'width + 150',correct
'fill(innerEarColor)',correct
'random(1200)',correct
'eyeColor = initEyeColor;',correct
'wolfies.length',correct
'ellipse(xPos, yPos, 300, 250);',correct
'xPos - 55',correct
'rotate(0.5f);',correct
'{    xPos = initX;    yPos = initY;    eyeColor = initEyeColor;    innerEarColor = initInnerEarColor;}',correct
'',correct
'stroke(0);',correct
'stroke(0)',correct
'pushMatrix();',correct
'xPos - 62',correct
'xPos - 60',correct
'// mouthnoFill();',correct
'strokeWeight(6)',correct
'background(255);',correct
'wolfies[i]',correct
'line(xPos, yPos + 30, xPos, yPos + 95);',correct
'textSize(20)',correct
'xPos - 116',correct
'translate(xPos + 65, yPos - 50)',correct
'xPos - 119',correct
'fill(innerEarColor);',correct
'yPos + 75',correct
'void keyPressed() {    if (key ==  ) {        reset();    }    if (key == r) {        background(255);    }}',correct
'color(random(255), random(255), random(255))',correct
'fill(0);',correct
'stroke(128, 0, 0);',correct
'yPos + 70',correct
'triangle(xPos + 16, yPos + 94, xPos + 27, yPos + 111, xPos + 28, yPos + 88)',correct
'fill(160, 82, 45)',correct
'yPos - 177',correct
'xPos - 125',correct
'xPos - 45',correct
'yPos + 88',correct
'xPos = initX;',correct
'strokeCap(SQUARE)',correct
'yPos + 111',correct
'Wolfie[] wolfies = new Wolfie[1];',correct
'fill(128, 0, 0);',correct
'"Press r to shut down the party..."',correct
'strokeCap(SQUARE);',correct
'float yPos;',correct
'popMatrix();',correct
'r',correct
'random(720)',correct
'new Wolfie[1]',correct
'xPos - 130',correct
'Wolfie(float initX, float initY, int initEyeColor, int initInnerEarColor) {    xPos = initX;    yPos = initY;    eyeColor = initEyeColor;    innerEarColor = initInnerEarColor;}',correct
'random(255)',correct
'fill(245, 222, 179)',correct
'for (int i = 0; i < wolfies.length; i++) {    wolfies[i] = new Wolfie(random(1200), random(720), color(random(255), random(255), random(255)), color(random(255), random(255), random(255)));    wolfies[i].display();}',correct
'noStroke()',correct
'// interearnoStroke();',correct
'xPos',correct
'key ==',correct
'int initEyeColor',correct
'fill(color(0, 0, 128))',correct
'xPos + 130',correct
'ellipse(xPos + 55, yPos - 35, 70, 70);',DecentralizedDrawingRule
'void setup() {    background(255);    reset();}',correct
'void reset() {    for (int i = 0; i < wolfies.length; i++) {        wolfies[i] = new Wolfie(random(1200), random(720), color(random(255), random(255), random(255)), color(random(255), random(255), random(255)));        wolfies[i].display();    }}',correct
'xPos + 119',correct
'xPos = initX',correct
'strokeWeight(3);',correct
'i < wolfies.length',correct
'translate(xPos - 45, yPos - 50);',correct
'fill(0)',correct
'reset();',correct
'// undernosefill(245, 222, 179);',correct
'triangle(xPos + 130, yPos - 56, xPos + 125, yPos - 177, xPos + 62, yPos - 109)',correct
'fill(128, 0, 0)',correct
'xPos + 125',correct
'{    for (int i = 0; i < wolfies.length; i++) {        wolfies[i] = new Wolfie(random(1200), random(720), color(random(255), random(255), random(255)), color(random(255), random(255), random(255)));        wolfies[i].display();    }}',correct
'yPos + 35',correct
'ellipse(xPos - 60, yPos - 35, 110, 110)',correct
'text("Press r to shut down the party...", 450, 100);',PixelHardcodeIgnoranceRule
'yPos + 30',correct
'fill(255)',correct
'background(255)',correct
'Processing',correct
'ellipse(xPos + 60, yPos - 35, 110, 110)',correct
'textSize(20);',correct
'pushMatrix()',correct
'xPos + 116',correct
'{    background(255);}',correct
'"Press spacebar to make it more cosy in here!"',correct
'{    reset();}',correct
'0.2f',correct
'noFill()',correct
'ellipse(xPos - 55, yPos - 35, 70, 70)',correct
'{    wolfies[i] = new Wolfie(random(1200), random(720), color(random(255), random(255), random(255)), color(random(255), random(255), random(255)));    wolfies[i].display();}',correct
'int i = 0',correct
'ellipse(xPos - 55, yPos - 35, 70, 70);',DecentralizedDrawingRule
'stroke(128, 0, 0)',correct
'xPos - 80',correct
'triangle(xPos + 119, yPos - 72, xPos + 116, yPos - 145, xPos + 80, yPos - 102)',correct
'arc(xPos, yPos + 75, 75, 40, 0.2f, PI - 0.2f)',correct
'ellipse(xPos, yPos + 35, 55, 35);',DecentralizedDrawingRule
'arc(xPos, yPos + 75, 75, 40, 0.2f, PI - 0.2f);',DecentralizedDrawingRule
'triangle(xPos + 16, yPos + 94, xPos + 27, yPos + 111, xPos + 28, yPos + 88);',DecentralizedDrawingRule
'triangle(xPos - 16, yPos + 94, xPos - 27, yPos + 111, xPos - 28, yPos + 88)',correct
'i = 0',correct
'{    background(255);    reset();}',correct
'text("Press r to shut down the party...", 450, 100)',correct
'int innerEarColor;',correct
'innerEarColor',correct
'yPos - 72',correct
'yPos - 109',correct
'PI - 0.2f',correct
'int eyeColor;',correct
'innerEarColor = initInnerEarColor;',correct
'translate(xPos - 45, yPos - 50)',correct
'triangle(xPos - 130, yPos - 56, xPos - 125, yPos - 177, xPos - 62, yPos - 109)',correct
'ellipse(xPos, yPos + 70, 110, 80)',correct
'yPos',correct
'ellipse(xPos + 55, yPos - 35, 70, 70)',correct
'strokeWeight(5);',correct
'noStroke();',correct
'ellipse(0, 0, 30, 20)',correct
'strokeCap(ROUND);',correct
'yPos = initY',correct
'eyeColor = initEyeColor',correct
'triangle(xPos + 119, yPos - 72, xPos + 116, yPos - 145, xPos + 80, yPos - 102);',DecentralizedDrawingRule
'xPos + 16',correct
'wolfies[i].display()',correct
'{    fill(color(0, 0, 128));    textSize(50);    text("Press spacebar to make it more cosy in here!", 95, 50);    textSize(20);    text("Press r to shut down the party...", 450, 100);}',correct
'int initInnerEarColor',correct
'// linestrokeWeight(6);',correct
'eyeColor',correct
'translate(xPos + 65, yPos - 50);',correct
'0.5f',correct
'key == r',correct
'// earsfill(160, 82, 45);',correct
'xPos + 27',correct
'xPos + 28',correct
'display',LongMethodRule
'// headstroke(0);',correct
'void draw() {    fill(color(0, 0, 128));    textSize(50);    text("Press spacebar to make it more cosy in here!", 95, 50);    textSize(20);    text("Press r to shut down the party...", 450, 100);}',correct
'yPos - 102',correct
'Wolfie[]',correct
'yPos - 35',correct
'float initX',correct
'xPos - 16',correct
'float initY',correct
'ellipse(xPos + 60, yPos - 35, 110, 110);',DecentralizedDrawingRule
'i++',correct
'yPos + 95',correct
'yPos + 94',correct
'fill(160, 82, 45);',correct
'fill(255);',correct
'ellipse(xPos, yPos + 70, 110, 80);',DecentralizedDrawingRule
'strokeWeight(3)',correct
'innerEarColor = initInnerEarColor',correct
'// fangsstroke(0);',correct
'triangle(xPos - 119, yPos - 72, xPos - 116, yPos - 145, xPos - 80, yPos - 102)',correct
'void',correct
'{    if (key ==  ) {        reset();    }    if (key == r) {        background(255);    }}',correct
'xPos - 27',correct
'xPos - 28',correct
'xPos + 80',correct
'class Wolfie {    float xPos;    float yPos;    int eyeColor;    int innerEarColor;    Wolfie(float initX, float initY, int initEyeColor, int initInnerEarColor) {        xPos = initX;        yPos = initY;        eyeColor = initEyeColor;        innerEarColor = initInnerEarColor;    }    void display() {        stroke(0);        strokeWeight(5);        // ears        fill(160, 82, 45);        triangle(xPos - 130, yPos - 56, xPos - 125, yPos - 177, xPos - 62, yPos - 109);        triangle(xPos + 130, yPos - 56, xPos + 125, yPos - 177, xPos + 62, yPos - 109);        // interear        noStroke();        fill(innerEarColor);        triangle(xPos - 119, yPos - 72, xPos - 116, yPos - 145, xPos - 80, yPos - 102);        triangle(xPos + 119, yPos - 72, xPos + 116, yPos - 145, xPos + 80, yPos - 102);        // head        stroke(0);        fill(160, 82, 45);        ellipse(xPos, yPos, 300, 250);        // eyes        fill(eyeColor);        ellipse(xPos - 60, yPos - 35, 110, 110);        ellipse(xPos + 60, yPos - 35, 110, 110);        fill(0);        ellipse(xPos - 55, yPos - 35, 70, 70);        ellipse(xPos + 55, yPos - 35, 70, 70);        fill(255);        noStroke();        pushMatrix();        translate(xPos - 45, yPos - 50);        rotate(0.5f);        ellipse(0, 0, 30, 20);        popMatrix();        pushMatrix();        translate(xPos + 65, yPos - 50);        rotate(0.5f);        ellipse(0, 0, 30, 20);        popMatrix();        // undernose        fill(245, 222, 179);        ellipse(xPos, yPos + 70, 110, 80);        // fangs        stroke(0);        strokeWeight(3);        fill(255);        triangle(xPos + 16, yPos + 94, xPos + 27, yPos + 111, xPos + 28, yPos + 88);        triangle(xPos - 16, yPos + 94, xPos - 27, yPos + 111, xPos - 28, yPos + 88);        // line        strokeWeight(6);        stroke(128, 0, 0);        strokeCap(SQUARE);        line(xPos, yPos + 30, xPos, yPos + 95);        // nose        stroke(0);        fill(128, 0, 0);        ellipse(xPos, yPos + 35, 55, 35);        // mouth        noFill();        strokeCap(ROUND);        arc(xPos, yPos + 75, 75, 40, 0.2f, PI - 0.2f);    }}',correct
'void display() {    stroke(0);    strokeWeight(5);    // ears    fill(160, 82, 45);    triangle(xPos - 130, yPos - 56, xPos - 125, yPos - 177, xPos - 62, yPos - 109);    triangle(xPos + 130, yPos - 56, xPos + 125, yPos - 177, xPos + 62, yPos - 109);    // interear    noStroke();    fill(innerEarColor);    triangle(xPos - 119, yPos - 72, xPos - 116, yPos - 145, xPos - 80, yPos - 102);    triangle(xPos + 119, yPos - 72, xPos + 116, yPos - 145, xPos + 80, yPos - 102);    // head    stroke(0);    fill(160, 82, 45);    ellipse(xPos, yPos, 300, 250);    // eyes    fill(eyeColor);    ellipse(xPos - 60, yPos - 35, 110, 110);    ellipse(xPos + 60, yPos - 35, 110, 110);    fill(0);    ellipse(xPos - 55, yPos - 35, 70, 70);    ellipse(xPos + 55, yPos - 35, 70, 70);    fill(255);    noStroke();    pushMatrix();    translate(xPos - 45, yPos - 50);    rotate(0.5f);    ellipse(0, 0, 30, 20);    popMatrix();    pushMatrix();    translate(xPos + 65, yPos - 50);    rotate(0.5f);    ellipse(0, 0, 30, 20);    popMatrix();    // undernose    fill(245, 222, 179);    ellipse(xPos, yPos + 70, 110, 80);    // fangs    stroke(0);    strokeWeight(3);    fill(255);    triangle(xPos + 16, yPos + 94, xPos + 27, yPos + 111, xPos + 28, yPos + 88);    triangle(xPos - 16, yPos + 94, xPos - 27, yPos + 111, xPos - 28, yPos + 88);    // line    strokeWeight(6);    stroke(128, 0, 0);    strokeCap(SQUARE);    line(xPos, yPos + 30, xPos, yPos + 95);    // nose    stroke(0);    fill(128, 0, 0);    ellipse(xPos, yPos + 35, 55, 35);    // mouth    noFill();    strokeCap(ROUND);    arc(xPos, yPos + 75, 75, 40, 0.2f, PI - 0.2f);}',correct
'ellipse(0, 0, 30, 20);',DecentralizedDrawingRule
'ellipse(xPos - 60, yPos - 35, 110, 110);',DecentralizedDrawingRule
'yPos = initY;',correct
'fill(eyeColor)',correct
'color(0, 0, 128)',correct
'ellipse(xPos, yPos, 300, 250)',correct
'wolfies[i].display();',correct
'xPos + 55',correct
'popMatrix()',correct
'ellipse(xPos, yPos + 35, 55, 35)',correct
'yPos - 56',correct
'wolfies[i] = new Wolfie(random(1200), random(720), color(random(255), random(255), random(255)), color(random(255), random(255), random(255)))',correct
'text("Press spacebar to make it more cosy in here!", 95, 50)',correct
'triangle(xPos + 130, yPos - 56, xPos + 125, yPos - 177, xPos + 62, yPos - 109);',DecentralizedDrawingRule
'Wolfie',correct
'yPos - 50',correct
'triangle(xPos - 119, yPos - 72, xPos - 116, yPos - 145, xPos - 80, yPos - 102);',DecentralizedDrawingRule
'// eyesfill(eyeColor);',correct
'// nosestroke(0);',correct
'strokeWeight(5)',correct
'triangle(xPos - 130, yPos - 56, xPos - 125, yPos - 177, xPos - 62, yPos - 109);',DecentralizedDrawingRule
'wolfies[i] = new Wolfie(random(1200), random(720), color(random(255), random(255), random(255)), color(random(255), random(255), random(255)));',correct
'{    stroke(0);    strokeWeight(5);    // ears    fill(160, 82, 45);    triangle(xPos - 130, yPos - 56, xPos - 125, yPos - 177, xPos - 62, yPos - 109);    triangle(xPos + 130, yPos - 56, xPos + 125, yPos - 177, xPos + 62, yPos - 109);    // interear    noStroke();    fill(innerEarColor);    triangle(xPos - 119, yPos - 72, xPos - 116, yPos - 145, xPos - 80, yPos - 102);    triangle(xPos + 119, yPos - 72, xPos + 116, yPos - 145, xPos + 80, yPos - 102);    // head    stroke(0);    fill(160, 82, 45);    ellipse(xPos, yPos, 300, 250);    // eyes    fill(eyeColor);    ellipse(xPos - 60, yPos - 35, 110, 110);    ellipse(xPos + 60, yPos - 35, 110, 110);    fill(0);    ellipse(xPos - 55, yPos - 35, 70, 70);    ellipse(xPos + 55, yPos - 35, 70, 70);    fill(255);    noStroke();    pushMatrix();    translate(xPos - 45, yPos - 50);    rotate(0.5f);    ellipse(0, 0, 30, 20);    popMatrix();    pushMatrix();    translate(xPos + 65, yPos - 50);    rotate(0.5f);    ellipse(0, 0, 30, 20);    popMatrix();    // undernose    fill(245, 222, 179);    ellipse(xPos, yPos + 70, 110, 80);    // fangs    stroke(0);    strokeWeight(3);    fill(255);    triangle(xPos + 16, yPos + 94, xPos + 27, yPos + 111, xPos + 28, yPos + 88);    triangle(xPos - 16, yPos + 94, xPos - 27, yPos + 111, xPos - 28, yPos + 88);    // line    strokeWeight(6);    stroke(128, 0, 0);    strokeCap(SQUARE);    line(xPos, yPos + 30, xPos, yPos + 95);    // nose    stroke(0);    fill(128, 0, 0);    ellipse(xPos, yPos + 35, 55, 35);    // mouth    noFill();    strokeCap(ROUND);    arc(xPos, yPos + 75, 75, 40, 0.2f, PI - 0.2f);}',LongMethodRule
'xPos + 65',correct
'[1]',correct
'text("Press spacebar to make it more cosy in here!", 95, 50);',PixelHardcodeIgnoranceRule
'if (key ==  ) {    reset();}',correct
'xPos + 60',correct
'xPos + 62',correct
'new Wolfie(random(1200), random(720), color(random(255), random(255), random(255)), color(random(255), random(255), random(255)))',correct
'wolfies = new Wolfie[1]',correct
'triangle(xPos - 16, yPos + 94, xPos - 27, yPos + 111, xPos - 28, yPos + 88);',correct
'if (key == r) {    background(255);}',correct
'float xPos;',correct
'reset()',correct
'yPos - 145',correct
'fill(color(0, 0, 128));',correct
'rotate(0.5f)',correct
'strokeCap(ROUND)',correct
'line(xPos, yPos + 30, xPos, yPos + 95)',correct
'textSize(50)',correct
'textSize(50);',correct
'bubblecolorhit = color(227, 39, 37);',correct
'i = 0',correct
'Creature',correct
'{    speedx = -speedx;}',correct
'angryarms',correct
'// made by Leon Groothaar, student number: 2190206// the program displays my creatures moving.// the bubble that the creatures is in can change of color when you click on it.// when you press a key all the creatures stop moving.// array of new bubbles.Creature[] bubble = new Creature[10];',correct
'bubblecolorhit',correct
'void move() {    if (keyPressed == false) {        // if the the key is pressed the creatures stop moving.        creaturex += speedx;        creaturey += speedy;        if (creaturey + 95 > height || creaturey < 0) {            // Reverse speed            speedy = -speedy;        }        if (creaturex + 75 > width || creaturex < 0) {            speedx = -speedx;        }    }}',correct
'void display() {    ellipseMode(CENTER);    fill(bubblecolor);    ellipse(creaturex, creaturey + 20, bubblesize, bubblesize);    // Display the circle    fill(0, 255);    // body    stroke(0, 255);    fill(0);    rect(creaturex - 20, creaturey, 40, 60);    // legs    noStroke();    fill(0);    triangle(creaturex - 20, creaturey + 60, creaturex - 20, creaturey + 80, creaturex, creaturey + 60);    triangle(creaturex + 20, creaturey + 60, creaturex, creaturey + 60, creaturex + 20, creaturey + 80);    // arms    noStroke();    fill(0);    triangle(creaturex - 20, creaturey + 10, creaturex - 20, creaturey + 20, creaturex - 50, creaturey + 50 - angryarms);    triangle(creaturex + 20, creaturey + 10, creaturex + 20, creaturey + 20, creaturex + 50, creaturey + 50 - angryarms);    // head /eyes    stroke(1);    fill(255);    ellipse(creaturex, creaturey, 40, 40);    ellipse(creaturex, creaturey, 20, 20);    fill(0, 255);    ellipse(creaturex, creaturey, 10, 10);}',correct
'creaturex + 75 > width || creaturex < 0',correct
'background(0)',correct
'float speedx;',correct
'// legsnoStroke();',correct
'// head /eyesstroke(1);',correct
'creaturey < 0',correct
'creaturey + 50',correct
'{    bubblecolor = bubblecolorhit;    angryarms = 70;}',correct
'changecolor',correct
'// made by Leon Groothaar, student number: 2190206',correct
'ellipse(creaturex, creaturey + 20, bubblesize, bubblesize);',correct
'float speedy;',correct
'fill(bubblecolor)',correct
'triangle(creaturex + 20, creaturey + 10, creaturex + 20, creaturey + 20, creaturex + 50, creaturey + 50 - angryarms)',correct
'void mousePressed() {    // when the mouse is pressed the function changecolor activates    for (int i = 0; i < 10; i++) {        bubble[i].changecolor();    }}',correct
'{    bubble[i].display();    bubble[i].move();}',correct
'creaturex - 50',correct
'bubble[i]',correct
'ellipse(creaturex, creaturey, 20, 20);',correct
'new Creature[10]',correct
'fill(bubblecolor);',correct
'bubble[i].move()',correct
'bubble[i].changecolor()',correct
'triangle(creaturex + 20, creaturey + 60, creaturex, creaturey + 60, creaturex + 20, creaturey + 80);',correct
'bubblesize = 150',correct
'{    // if the the key is pressed the creatures stop moving.    creaturex += speedx;    creaturey += speedy;    if (creaturey + 95 > height || creaturey < 0) {        // Reverse speed        speedy = -speedy;    }    if (creaturex + 75 > width || creaturex < 0) {        speedx = -speedx;    }}',DecentralizedEventHandlingRule
'speedx = -speedx;',correct
'bubblecolorhit = color(227, 39, 37)',correct
'bubblesize',correct
'fill(0);',correct
'class Creature {    float creaturex;    float creaturey;    float speedx;    float speedy;    float bubblesize;    int bubblecolor;    int bubblecolorhit;    int angryarms;    Creature(float tempX, float tempY) {        creaturex = tempX;        creaturey = tempY;        speedx = 5;        speedy = speedx;        bubblesize = 150;        bubblecolor = color(4, 194, 251);        bubblecolorhit = color(227, 39, 37);        angryarms = 0;    }    void move() {        if (keyPressed == false) {            // if the the key is pressed the creatures stop moving.            creaturex += speedx;            creaturey += speedy;            if (creaturey + 95 > height || creaturey < 0) {                // Reverse speed                speedy = -speedy;            }            if (creaturex + 75 > width || creaturex < 0) {                speedx = -speedx;            }        }    }    // this boolean is true when the mouse is over the Creature.    boolean isOver() {        return (dist(mouseX, mouseY, creaturex, creaturey + 20) <= 75);    }    // when the mouse is pressed and the boolean is over is true the bubblecolor changes to bubblecolorhit.    void changecolor() {        if (isOver()) {            bubblecolor = bubblecolorhit;            angryarms = 70;        }    }    void display() {        ellipseMode(CENTER);        fill(bubblecolor);        ellipse(creaturex, creaturey + 20, bubblesize, bubblesize);        // Display the circle        fill(0, 255);        // body        stroke(0, 255);        fill(0);        rect(creaturex - 20, creaturey, 40, 60);        // legs        noStroke();        fill(0);        triangle(creaturex - 20, creaturey + 60, creaturex - 20, creaturey + 80, creaturex, creaturey + 60);        triangle(creaturex + 20, creaturey + 60, creaturex, creaturey + 60, creaturex + 20, creaturey + 80);        // arms        noStroke();        fill(0);        triangle(creaturex - 20, creaturey + 10, creaturex - 20, creaturey + 20, creaturex - 50, creaturey + 50 - angryarms);        triangle(creaturex + 20, creaturey + 10, creaturex + 20, creaturey + 20, creaturex + 50, creaturey + 50 - angryarms);        // head /eyes        stroke(1);        fill(255);        ellipse(creaturex, creaturey, 40, 40);        ellipse(creaturex, creaturey, 20, 20);        fill(0, 255);        ellipse(creaturex, creaturey, 10, 10);    }}',correct
'{    // when the mouse is pressed the function changecolor activates    for (int i = 0; i < 10; i++) {        bubble[i].changecolor();    }}',correct
'angryarms = 70;',correct
'speedx = -speedx',correct
'bubble[i].move();',correct
'creaturey + 20',correct
'Creature(float tempX, float tempY) {    creaturex = tempX;    creaturey = tempY;    speedx = 5;    speedy = speedx;    bubblesize = 150;    bubblecolor = color(4, 194, 251);    bubblecolorhit = color(227, 39, 37);    angryarms = 0;}',correct
'speedx = 5;',correct
'for (int i = 0; i < 10; i++) {    bubble[i].display();    bubble[i].move();}',correct
'creaturey += speedy;',correct
'triangle(creaturex - 20, creaturey + 60, creaturex - 20, creaturey + 80, creaturex, creaturey + 60)',correct
'if (isOver()) {    bubblecolor = bubblecolorhit;    angryarms = 70;}',correct
'Creature[]',correct
'bubble = new Creature[10]',correct
'ballWidth = 48',correct
'{    return (dist(mouseX, mouseY, creaturex, creaturey + 20) <= 75);}',correct
'triangle(creaturex + 20, creaturey + 10, creaturex + 20, creaturey + 20, creaturex + 50, creaturey + 50 - angryarms);',correct
'color(4, 194, 251)',correct
'display',correct
'// when you press a key all the creatures stop moving.',correct
'background(0);',correct
'bubblecolor = bubblecolorhit;',correct
'bubble[i].changecolor();',correct
'// bodystroke(0, 255);',correct
'speedx = 5',correct
'return (dist(mouseX, mouseY, creaturex, creaturey + 20) <= 75);',correct
'-speedy',correct
'-speedx',correct
'creaturey = tempY',correct
'{    bubble[i].changecolor();}',correct
'int bubblecolorhit;',correct
'creaturex + 50',correct
'int ballWidth = 48;',correct
'width - 100',correct
'rect(creaturex - 20, creaturey, 40, 60);',correct
'creaturex += speedx',correct
'if (creaturex + 75 > width || creaturex < 0) {    speedx = -speedx;}',correct
'noStroke()',correct
'creaturey = tempY;',correct
'ellipse(creaturex, creaturey + 20, bubblesize, bubblesize)',correct
'{    creaturex = tempX;    creaturey = tempY;    speedx = 5;    speedy = speedx;    bubblesize = 150;    bubblecolor = color(4, 194, 251);    bubblecolorhit = color(227, 39, 37);    angryarms = 0;}',correct
'rect(creaturex - 20, creaturey, 40, 60)',correct
'angryarms = 0;',correct
'keyPressed == false',DecentralizedEventHandlingRule
'creaturey + 80',correct
'speedy',correct
'triangle(creaturex - 20, creaturey + 10, creaturex - 20, creaturey + 20, creaturex - 50, creaturey + 50 - angryarms)',correct
'creaturey + 95 > height',correct
'speedx',correct
'i++',correct
'stroke(0, 255)',correct
'void draw() {    background(0);    for (int i = 0; i < 10; i++) {        bubble[i].display();        bubble[i].move();    }}',correct
'creaturex < 0',correct
'mousePressed',correct
'fill(255);',correct
'ellipseMode(CENTER)',correct
'ellipse(creaturex, creaturey, 20, 20)',correct
'float creaturex;',correct
'creaturex - 20',correct
'fill(0, 255);',correct
'ellipse(creaturex, creaturey, 10, 10);',correct
'creaturey + 95',correct
'triangle(creaturex - 20, creaturey + 10, creaturex - 20, creaturey + 20, creaturex - 50, creaturey + 50 - angryarms);',correct
'void',correct
'speedy = speedx',correct
'// armsnoStroke();',correct
'creaturex',correct
'creaturex + 75 > width',correct
'bubblecolor = bubblecolorhit',correct
'creaturey',correct
'creaturey + 10',correct
'{    if (keyPressed == false) {        // if the the key is pressed the creatures stop moving.        creaturex += speedx;        creaturey += speedy;        if (creaturey + 95 > height || creaturey < 0) {            // Reverse speed            speedy = -speedy;        }        if (creaturex + 75 > width || creaturex < 0) {            speedx = -speedx;        }    }}',correct
'fill(0, 255)',correct
'int bubblecolor;',correct
'angryarms = 70',correct
'fill(0)',correct
'bubble[i] = new Creature(random(0, width - 100) - mouseX, random(0, height - 100))',correct
'triangle(creaturex + 20, creaturey + 60, creaturex, creaturey + 60, creaturex + 20, creaturey + 80)',correct
'{    for (int i = 0; i < 10; i++) {        // the creatures are placed on random locations.        bubble[i] = new Creature(random(0, width - 100) - mouseX, random(0, height - 100));    }}',correct
'creaturex = tempX;',correct
'ellipse(creaturex, creaturey, 40, 40)',correct
'creaturex = tempX',correct
'isOver',correct
'float creaturey;',correct
'height - 100',correct
'creaturex + 75',correct
'void setup() {    for (int i = 0; i < 10; i++) {        // the creatures are placed on random locations.        bubble[i] = new Creature(random(0, width - 100) - mouseX, random(0, height - 100));    }}',correct
'// the program displays my creatures moving.',correct
'{    if (isOver()) {        bubblecolor = bubblecolorhit;        angryarms = 70;    }}',correct
'stroke(1)',correct
'// this boolean is true when the mouse is over the Creature.boolean isOver() {    return (dist(mouseX, mouseY, creaturex, creaturey + 20) <= 75);}',correct
'creaturey + 60',correct
'new Creature(random(0, width - 100) - mouseX, random(0, height - 100))',correct
'random(0, width - 100) - mouseX',correct
'{    // Reverse speed    speedy = -speedy;}',correct
'[10]',correct
'fill(255)',correct
'{    ellipseMode(CENTER);    fill(bubblecolor);    ellipse(creaturex, creaturey + 20, bubblesize, bubblesize);    // Display the circle    fill(0, 255);    // body    stroke(0, 255);    fill(0);    rect(creaturex - 20, creaturey, 40, 60);    // legs    noStroke();    fill(0);    triangle(creaturex - 20, creaturey + 60, creaturex - 20, creaturey + 80, creaturex, creaturey + 60);    triangle(creaturex + 20, creaturey + 60, creaturex, creaturey + 60, creaturex + 20, creaturey + 80);    // arms    noStroke();    fill(0);    triangle(creaturex - 20, creaturey + 10, creaturex - 20, creaturey + 20, creaturex - 50, creaturey + 50 - angryarms);    triangle(creaturex + 20, creaturey + 10, creaturex + 20, creaturey + 20, creaturex + 50, creaturey + 50 - angryarms);    // head /eyes    stroke(1);    fill(255);    ellipse(creaturex, creaturey, 40, 40);    ellipse(creaturex, creaturey, 20, 20);    fill(0, 255);    ellipse(creaturex, creaturey, 10, 10);}',correct
'Processing',correct
'i < 10',correct
'random(0, width - 100)',correct
'// when the mouse is pressed and the boolean is over is true the bubblecolor changes to bubblecolorhit.void changecolor() {    if (isOver()) {        bubblecolor = bubblecolorhit;        angryarms = 70;    }}',correct
'triangle(creaturex - 20, creaturey + 60, creaturex - 20, creaturey + 80, creaturex, creaturey + 60);',correct
'random(0, height - 100)',correct
'float tempY',correct
'float tempX',correct
'bubblesize = 150;',correct
'isOver()',correct
'creaturex + 20',correct
'creaturey += speedy',correct
'color(227, 39, 37)',correct
'angryarms = 0',correct
'move',correct
'{    // the creatures are placed on random locations.    bubble[i] = new Creature(random(0, width - 100) - mouseX, random(0, height - 100));}',correct
'bubblecolor = color(4, 194, 251)',correct
'false',correct
'speedy = -speedy',correct
'{    background(0);    for (int i = 0; i < 10; i++) {        bubble[i].display();        bubble[i].move();    }}',correct
'int angryarms;',correct
'bubblecolor = color(4, 194, 251);',correct
'float bubblesize;',correct
'ellipse(creaturex, creaturey, 40, 40);',correct
'int i = 0',correct
'ellipseMode(CENTER);',correct
'bubblecolor',correct
'boolean',correct
'creaturey + 95 > height || creaturey < 0',correct
'bubble[i].display()',correct
'// the bubble that the creatures is in can change of color when you click on it.',correct
'setup',correct
'// if the the key is pressed the creatures stop moving.creaturex += speedx;',correct
'speedy = speedx;',correct
'ellipse(creaturex, creaturey, 10, 10)',correct
'creaturey + 50 - angryarms',correct
'bubble[i].display();',correct
'if (creaturey + 95 > height || creaturey < 0) {    // Reverse speed    speedy = -speedy;}',correct
'// Display the circlefill(0, 255);',correct
'carrot.GetPostition().x',correct
'carrot.GetPostition().y',correct
'{    return position;}',correct
'float posy1',correct
'carrot = car',correct
'carrot.showCarrot()',correct
'G1 = 178',correct
'// y distance between bunniesfloat dy = bunnies[i].posy - posy;',correct
'PImage bg;',ShortVariable
'float posy;',TooManyFields
'mouth2',correct
'mouth1',correct
'{}',correct
'void drawBunny() {    // update position of bunny    posx = posx + (xspeed * xdirection);    // update position of bunny    posy = posy + (yspeed * ydirection);    // If it does, reverse its direction by multiplying by -1    if (posx > width - rad || posx < rad) {        xdirection *= -1;    }    if (posy > height - rad || posy < rad) {        ydirection *= -1;    }    // set imagemode to center    imageMode(CENTER);    fill(R, G, B);    // head    float carrotX = carrot.GetPostition().x;    float carrotY = carrot.GetPostition().y;    if (carrotX < posx + 50 && carrotX > posx - 50 && carrotY < posy - 20 && carrotY > posy - 70 && carrot.isVisable()) {        // if the carrot is near the rabbit        xspeed = 1.2f;        yspeed = 0.8f;        R = 242;        G = 159;        B = 159;        R1 = 255;        G1 = 255;        B1 = 255;    } else {        R = 149;        G = 35;        B = 138;        R1 = 178;        G1 = 178;        B1 = 178;        xspeed = 2.8f;        yspeed = 2.2f;    }    // draws a circle that shifts colour according to the mood of the bunny    ellipse(posx, posy - 75, 55, 55);    // body    ellipse(posx - 50, posy - 50, 80, 55);    // eyes    fill(255);    ellipse(posx - 8, posy - 75, 12, 17);    ellipse(posx + 8, posy - 75, 12, 17);    fill(0);    ellipse(posx - 8, posy - 75, 5, 7);    ellipse(posx + 8, posy - 75, 5, 7);    noStroke();    // nose    image(nose, posx + 1, posy - 70, 50, 20);    fill(R, G, B);    // draws an ear that shifts colour according to the mood of the bunny    ellipse(posx + 23, posy - 115, 20, 55);    // draws an ear that shifts colour according to the mood of the bunny    ellipse(posx - 23, posy - 115, 20, 55);    // legs    // leg    ellipse(posx - 68, posy - 30, 30, 40);    // leg    ellipse(posx - 28, posy - 30, 30, 40);    // foot    ellipse(posx - 65, posy - 16, 30, 12);    // foot    ellipse(posx - 26, posy - 16, 30, 12);    // ears filling    fill(R1, G1, B1);    // draws inside of the ear that shifts colour according to the mood of the bunny    ellipse(posx + 23, posy - 115, 12, 40);    // draws inside of the ear that shifts colour according to the mood of the bunny    ellipse(posx - 23, posy - 115, 12, 40);    // tummy that shifts colour (not sure if I want this in it looks odd)    ellipse(posx - 50, posy - 39, 70, 30);    // tail    ellipse(posx - 84, posy - 64, 23, 23);    // mouth sad    image(mouth, posx - 3, posy - 55, 17, 10);    if (carrotX < posx + 50 && carrotX > posx - 50 && carrotY < posy - 20 && carrotY > posy - 70 && carrot.isVisable()) {        // if the carrot is near the rabbit        mouth = mouth2;    } else {        mouth = mouth1;    }// this statements makes the bunny smile or be angry according to the mood of the bunny}',TooManyFields
'float posx1',correct
'B1',correct
'Bunny(float posx1, float posy1, float xdirection1, float ydirection1, Carrot car, int i) {    // loads image into the program    nose = loadImage("nose.png");    // loads image into the program    mouth1 = loadImage("chew.png");    mouth2 = loadImage("smile.png");    mouth = mouth1;    posx = posx1;    posy = posy1;    xdirection = xdirection1;    ydirection = ydirection1;    carrot = car;    id = i;// Bunny [] others;}',TooManyFields
'fill(0xffFF0307);',correct
'// float distance = dist(posx, posy, posx1, posy1);boolean mouseIsPressed;',TooManyFields
'counter = 6;',correct
'float posx;',TooManyFields
'ellipse(posx + 8, posy - 75, 5, 7)',correct
'carrot = new Carrot(width / 2, height / 2);',correct
'ellipse(posx - 26, posy - 16, 30, 12)',correct
'posy = posy1',correct
'PImage mouth1;',TooManyFields
'B',correct
'bunnies[i].posy',correct
'bg',correct
'G',correct
'posy + sin(angle) * minDist',correct
'posy < rad',correct
'id + 1',correct
'fill(0);',correct
'bunnies[i].posx',correct
'carrotX > posx - 50',correct
'dy = bunnies[i].posy - posy',correct
'{    carrot.showCarrot();    counter += 1;    if (counter > 6) {        counter = 6;    }}',correct
'xspeed = 0',correct
'R',correct
'textAlign(CENTER)',correct
'distance < minDist',correct
'fed = 0',correct
'ellipse(posx - 50, posy - 50, 80, 55)',correct
'G1 = 192',correct
'"carrot.png"',correct
'float targetY = posy + sin(angle) * minDist',correct
'B = 60;',correct
'void Collision() {    float carrotX = carrot.GetPostition().x;    float carrotY = carrot.GetPostition().y;    if (carrotX < posx + 50 && carrotX > posx - 50 && carrotY < posy - 20 && carrotY > posy - 70 && carrot.isVisable()) {        carrot.showCarrot();    }}',TooManyFields
'for (int i = 0; i < bunnies.length; i++) {    bunnies[i].drawBunny();    bunnies[i].collide();    bunnies[i].counting();}',correct
'mouseIsPressed',correct
'void mouseMoved() {    // sets carrot location equal to the mouse location when mouse is being moved    carrot.updatePosition(mouseX, mouseY);}',correct
'height - rad',correct
'random(0, width)',correct
'PImage nose;',TooManyFields
'i < bunnies.length',correct
'n',correct
'carrot.updatePosition(mouseX, mouseY)',correct
'// eyesfill(255);',correct
'float carrotX = carrot.GetPostition().x;',correct
'posx + (xspeed * xdirection)',correct
'R1 = 178;',correct
'xdirection * (-1)',correct
'carrot = loadImage("carrot.png")',correct
'image(mouth, posx - 3, posy - 55, 17, 10)',correct
'text("Click to feed the rabbit. When it is hungry again, press n to generate a new carrot. \nYou have 6 carrots in store. \nCarrots used :" + counter, 10, 30);',correct
'yspeed = 0;',correct
'carrotX = carrot.GetPostition().x',correct
'fill(R, G, B);',correct
'id = i',correct
'angle = atan2(dy, dx)',correct
'// ears filling',correct
'{    bunnies[i].drawBunny();    bunnies[i].collide();    bunnies[i].counting();}',correct
'// tailellipse(posx - 84, posy - 64, 23, 23);',correct
'{    // sets carrot location equal to the mouse location when mouse is being moved    carrot.updatePosition(mouseX, mouseY);}',correct
'background(bg)',correct
'ellipse(posx - 84, posy - 64, 23, 23)',correct
'// bodyellipse(posx - 50, posy - 50, 80, 55);',correct
'posx',correct
'// speed of bunnyfloat xspeed = 2.8f;',TooManyFields
'posy',correct
'PVector position;',correct
'G1 = 255',correct
'void mousePressed() {    for (int i = 0; i < bunnies.length; i++) {        bunnies[i].Collision();    }}',correct
'ellipse(posx + 8, posy - 75, 12, 17)',correct
'carrotX < posx + 50 && carrotX > posx - 50 && carrotY < posy - 20',correct
'bunnies = new Bunny[10]',correct
'// footellipse(posx - 26, posy - 16, 30, 12);',correct
'carrotX < posx + 50 && carrotX > posx - 50',correct
'// draws inside of the ear that shifts colour according to the mood of the bunnyellipse(posx + 23, posy - 115, 12, 40);',correct
'collide',correct
'mouth = mouth1;',correct
'// If it does, reverse its direction by multiplying by -1if (posx > width - rad || posx < rad) {    xdirection *= -1;}',correct
'xdirection = xdirection1;',correct
'Carrot(float x, float y) {    position = new PVector(x, y);    // loads image into the program    carrot = loadImage("carrot.png");    showimage = true;}',correct
'"chew.png"',correct
'// legs// legellipse(posx - 68, posy - 30, 30, 40);',correct
'ellipse(posx - 65, posy - 16, 30, 12)',correct
'showimage = true;',correct
'if (carrotX < posx + 50 && carrotX > posx - 50 && carrotY < posy - 20 && carrotY > posy - 70 && carrot.isVisable()) {    // if the carrot is near the rabbit    mouth = mouth2;} else {    mouth = mouth1;}',correct
'rad = 70',correct
'i = id + 1',correct
'ellipse(posx - 68, posy - 30, 30, 40)',correct
'G1',correct
'B1 = 178;',correct
'float distance = sqrt(dx * dx + dy * dy)',correct
'float targetY = posy + sin(angle) * minDist;',correct
'Processing',correct
'image(carrot, position.x, position.y, 70, 60)',correct
'if (counter > 6) {    counter = 6;}',correct
'{    // * based on code from Keith Peters.    for (int i = id + 1; i < bunnies.length; i++) {        // x distance between bunnies        float dx = bunnies[i].posx - posx;        // y distance between bunnies        float dy = bunnies[i].posy - posy;        // square hitbox around  bunny        float distance = sqrt(dx * dx + dy * dy);        // Max distance between bunnies        float minDist = 50;        if (distance < minDist) {            // calculates the angle between dy and dx            float angle = atan2(dy, dx);            float targetX = posx + cos(angle) * minDist;            float targetY = posy + sin(angle) * minDist;            float ax = (targetX - bunnies[i].posx);            float ay = (targetY - bunnies[i].posy);            xdirection = xdirection * (-1);            // or -=ay but then it speeds up            ydirection = ydirection * (-1);            R = 51;            G = 219;            B = 60;        }    }}',correct
'textSize(20);',correct
'// noseimage(nose, posx + 1, posy - 70, 50, 20);',correct
'bunnies[i] = new Bunny(random(0, width), random(0, height), random(-1, 1), random(-1, 1), carrot, i)',correct
'dx * dx',correct
'B = 60',correct
'// top or bottomfloat ydirection = 1;',TooManyFields
'bunnies[i].collide();',correct
'// reference',correct
'ydirection = ydirection1;',correct
'R1 = 198;',correct
'carrot.display();',correct
'ellipse(posx + 23, posy - 115, 12, 40)',correct
'loadImage("smile.png")',correct
'targetY = posy + sin(angle) * minDist',correct
'setup',correct
'posx = posx1;',correct
'R = 149',correct
'i = 0',correct
'showimage = !showimage',correct
'R = 144',correct
'nose = loadImage("nose.png")',correct
'class Bunny {    float posx;    float posy;    // float distance = dist(posx, posy, posx1, posy1);    boolean mouseIsPressed;    PImage nose;    PImage mouth;    PImage mouth1;    PImage mouth2;    // for colourswich body    int R;    // for colourswich body    int G;    // for colourswich body    int B;    // for colourswich fur    int R1;    // for colourswich fur    int G1;    // for colourswich fur    int B1;    // width of bunny    int rad = 70;    int id;    // speed of bunny    float xspeed = 2.8f;    // speed of bunny    float yspeed = 2.2f;    // left or right    float xdirection = 1;    // top or bottom    float ydirection = 1;    Carrot carrot;    Bunny(float posx1, float posy1, float xdirection1, float ydirection1, Carrot car, int i) {        // loads image into the program        nose = loadImage("nose.png");        // loads image into the program        mouth1 = loadImage("chew.png");        mouth2 = loadImage("smile.png");        mouth = mouth1;        posx = posx1;        posy = posy1;        xdirection = xdirection1;        ydirection = ydirection1;        carrot = car;        id = i;    // Bunny [] others;    }    void drawBunny() {        // update position of bunny        posx = posx + (xspeed * xdirection);        // update position of bunny        posy = posy + (yspeed * ydirection);        // If it does, reverse its direction by multiplying by -1        if (posx > width - rad || posx < rad) {            xdirection *= -1;        }        if (posy > height - rad || posy < rad) {            ydirection *= -1;        }        // set imagemode to center        imageMode(CENTER);        fill(R, G, B);        // head        float carrotX = carrot.GetPostition().x;        float carrotY = carrot.GetPostition().y;        if (carrotX < posx + 50 && carrotX > posx - 50 && carrotY < posy - 20 && carrotY > posy - 70 && carrot.isVisable()) {            // if the carrot is near the rabbit            xspeed = 1.2f;            yspeed = 0.8f;            R = 242;            G = 159;            B = 159;            R1 = 255;            G1 = 255;            B1 = 255;        } else {            R = 149;            G = 35;            B = 138;            R1 = 178;            G1 = 178;            B1 = 178;            xspeed = 2.8f;            yspeed = 2.2f;        }        // draws a circle that shifts colour according to the mood of the bunny        ellipse(posx, posy - 75, 55, 55);        // body        ellipse(posx - 50, posy - 50, 80, 55);        // eyes        fill(255);        ellipse(posx - 8, posy - 75, 12, 17);        ellipse(posx + 8, posy - 75, 12, 17);        fill(0);        ellipse(posx - 8, posy - 75, 5, 7);        ellipse(posx + 8, posy - 75, 5, 7);        noStroke();        // nose        image(nose, posx + 1, posy - 70, 50, 20);        fill(R, G, B);        // draws an ear that shifts colour according to the mood of the bunny        ellipse(posx + 23, posy - 115, 20, 55);        // draws an ear that shifts colour according to the mood of the bunny        ellipse(posx - 23, posy - 115, 20, 55);        // legs        // leg        ellipse(posx - 68, posy - 30, 30, 40);        // leg        ellipse(posx - 28, posy - 30, 30, 40);        // foot        ellipse(posx - 65, posy - 16, 30, 12);        // foot        ellipse(posx - 26, posy - 16, 30, 12);        // ears filling        fill(R1, G1, B1);        // draws inside of the ear that shifts colour according to the mood of the bunny        ellipse(posx + 23, posy - 115, 12, 40);        // draws inside of the ear that shifts colour according to the mood of the bunny        ellipse(posx - 23, posy - 115, 12, 40);        // tummy that shifts colour (not sure if I want this in it looks odd)        ellipse(posx - 50, posy - 39, 70, 30);        // tail        ellipse(posx - 84, posy - 64, 23, 23);        // mouth sad        image(mouth, posx - 3, posy - 55, 17, 10);        if (carrotX < posx + 50 && carrotX > posx - 50 && carrotY < posy - 20 && carrotY > posy - 70 && carrot.isVisable()) {            // if the carrot is near the rabbit            mouth = mouth2;        } else {            mouth = mouth1;        }    // this statements makes the bunny smile or be angry according to the mood of the bunny    }    void Collision() {        float carrotX = carrot.GetPostition().x;        float carrotY = carrot.GetPostition().y;        if (carrotX < posx + 50 && carrotX > posx - 50 && carrotY < posy - 20 && carrotY > posy - 70 && carrot.isVisable()) {            carrot.showCarrot();        }    }    void collide() {        // * based on code from Keith Peters.        for (int i = id + 1; i < bunnies.length; i++) {            // x distance between bunnies            float dx = bunnies[i].posx - posx;            // y distance between bunnies            float dy = bunnies[i].posy - posy;            // square hitbox around  bunny            float distance = sqrt(dx * dx + dy * dy);            // Max distance between bunnies            float minDist = 50;            if (distance < minDist) {                // calculates the angle between dy and dx                float angle = atan2(dy, dx);                float targetX = posx + cos(angle) * minDist;                float targetY = posy + sin(angle) * minDist;                float ax = (targetX - bunnies[i].posx);                float ay = (targetY - bunnies[i].posy);                xdirection = xdirection * (-1);                // or -=ay but then it speeds up                ydirection = ydirection * (-1);                R = 51;                G = 219;                B = 60;            }        }    }    void counting() {        if (counter > 5) {            xspeed = 0;            yspeed = 0;            textSize(50);            textAlign(CENTER);            fill(0xffFF0307);            text("Out of carrots", width / 2, height / 2);            // make it all a grey tint. Bunnies stop moving and background is white/grey ish            // bunnies will be a darker tint of grey            R = 144;            G = 138;            B = 138;            R1 = 198;            G1 = 192;            B1 = 192;        }    }}',correct
'posx > width - rad',correct
'loadImage("cage.jpg")',correct
'text("Click to feed the rabbit. When it is hungry again, press n to generate a new carrot. \nYou have 6 carrots in store. \nCarrots used :" + counter, 10, 30)',correct
'{    if (showimage) {        // draw a carrot        image(carrot, position.x, position.y, 70, 60);    }}',correct
'distance = sqrt(dx * dx + dy * dy)',correct
'xdirection = xdirection * (-1);',correct
'yspeed = 0.8f;',correct
'width - rad',correct
'carrotY = carrot.GetPostition().y',correct
'new PVector(x, y)',correct
'id',correct
'carrot = new Carrot(width / 2, height / 2)',correct
'if (carrotX < posx + 50 && carrotX > posx - 50 && carrotY < posy - 20 && carrotY > posy - 70 && carrot.isVisable()) {    // if the carrot is near the rabbit    xspeed = 1.2f;    yspeed = 0.8f;    R = 242;    G = 159;    B = 159;    R1 = 255;    G1 = 255;    B1 = 255;} else {    R = 149;    G = 35;    B = 138;    R1 = 178;    G1 = 178;    B1 = 178;    xspeed = 2.8f;    yspeed = 2.2f;}',correct
'void keyPressed() {    // when you press n a new carrot spawns at the mouselocation    if (key == n && !carrot.isVisable()) {        carrot.showCarrot();        counter += 1;        if (counter > 6) {            counter = 6;        }    }}',correct
'{    // draw a carrot    image(carrot, position.x, position.y, 70, 60);}',correct
'B = 159;',correct
'fed += 1;',correct
'for (int i = 0; i < bunnies.length; i++) {    bunnies[i].Collision();}',correct
'xspeed = 1.2f',correct
'void mouseReleased() {}',correct
'position = new PVector(x, y);',correct
'noStroke();',correct
'posy = posy + (yspeed * ydirection)',correct
'posx + 8',correct
'// make sure background is loadedbackground(bg);',correct
'// for colourswich furint G1;',TooManyFields
'void mouseDragged() {    carrot.updatePosition(mouseX, mouseY);}',correct
'posx + 1',correct
'R = 242;',correct
'1.2f',correct
'B1 = 255;',correct
'counter += 1;',correct
'// tummy that shifts colour (not sure if I want this in it looks odd)ellipse(posx - 50, posy - 39, 70, 30);',correct
'PImage carrot;',AvoidFieldNameMatchingTypeName
'bunnies[i].Collision();',correct
'ydirection = ydirection1',correct
'"Click to feed the rabbit. When it is hungry again, press n to generate a new carrot. \nYou have 6 carrots in store. \nCarrots used :"',correct
'ellipse(posx - 8, posy - 75, 5, 7);',correct
'boolean showimage;',correct
'{    if (counter > 5) {        xspeed = 0;        yspeed = 0;        textSize(50);        textAlign(CENTER);        fill(0xffFF0307);        text("Out of carrots", width / 2, height / 2);        // make it all a grey tint. Bunnies stop moving and background is white/grey ish        // bunnies will be a darker tint of grey        R = 144;        G = 138;        B = 138;        R1 = 198;        G1 = 192;        B1 = 192;    }}',correct
'return showimage;',correct
'bg = loadImage("cage.jpg")',correct
'// this statements makes the bunny smile or be angry according to the mood of the bunny',correct
'id = i;',correct
'draw',correct
'!carrot.isVisable()',correct
'// ears fillingfill(R1, G1, B1);',correct
'float ydirection1',correct
'ydirection *= -1',correct
'float minDist = 50',correct
'{    // loads image into the program    nose = loadImage("nose.png");    // loads image into the program    mouth1 = loadImage("chew.png");    mouth2 = loadImage("smile.png");    mouth = mouth1;    posx = posx1;    posy = posy1;    xdirection = xdirection1;    ydirection = ydirection1;    carrot = car;    id = i;// Bunny [] others;}',LongParameterListRule
'PVector GetPostition() {    return position;}',correct
'random(-1, 1)',correct
'loadImage("chew.png")',correct
'int i',correct
'posy - 39',correct
'drawBunny',LongMethodRule
'{    // update position of bunny    posx = posx + (xspeed * xdirection);    // update position of bunny    posy = posy + (yspeed * ydirection);    // If it does, reverse its direction by multiplying by -1    if (posx > width - rad || posx < rad) {        xdirection *= -1;    }    if (posy > height - rad || posy < rad) {        ydirection *= -1;    }    // set imagemode to center    imageMode(CENTER);    fill(R, G, B);    // head    float carrotX = carrot.GetPostition().x;    float carrotY = carrot.GetPostition().y;    if (carrotX < posx + 50 && carrotX > posx - 50 && carrotY < posy - 20 && carrotY > posy - 70 && carrot.isVisable()) {        // if the carrot is near the rabbit        xspeed = 1.2f;        yspeed = 0.8f;        R = 242;        G = 159;        B = 159;        R1 = 255;        G1 = 255;        B1 = 255;    } else {        R = 149;        G = 35;        B = 138;        R1 = 178;        G1 = 178;        B1 = 178;        xspeed = 2.8f;        yspeed = 2.2f;    }    // draws a circle that shifts colour according to the mood of the bunny    ellipse(posx, posy - 75, 55, 55);    // body    ellipse(posx - 50, posy - 50, 80, 55);    // eyes    fill(255);    ellipse(posx - 8, posy - 75, 12, 17);    ellipse(posx + 8, posy - 75, 12, 17);    fill(0);    ellipse(posx - 8, posy - 75, 5, 7);    ellipse(posx + 8, posy - 75, 5, 7);    noStroke();    // nose    image(nose, posx + 1, posy - 70, 50, 20);    fill(R, G, B);    // draws an ear that shifts colour according to the mood of the bunny    ellipse(posx + 23, posy - 115, 20, 55);    // draws an ear that shifts colour according to the mood of the bunny    ellipse(posx - 23, posy - 115, 20, 55);    // legs    // leg    ellipse(posx - 68, posy - 30, 30, 40);    // leg    ellipse(posx - 28, posy - 30, 30, 40);    // foot    ellipse(posx - 65, posy - 16, 30, 12);    // foot    ellipse(posx - 26, posy - 16, 30, 12);    // ears filling    fill(R1, G1, B1);    // draws inside of the ear that shifts colour according to the mood of the bunny    ellipse(posx + 23, posy - 115, 12, 40);    // draws inside of the ear that shifts colour according to the mood of the bunny    ellipse(posx - 23, posy - 115, 12, 40);    // tummy that shifts colour (not sure if I want this in it looks odd)    ellipse(posx - 50, posy - 39, 70, 30);    // tail    ellipse(posx - 84, posy - 64, 23, 23);    // mouth sad    image(mouth, posx - 3, posy - 55, 17, 10);    if (carrotX < posx + 50 && carrotX > posx - 50 && carrotY < posy - 20 && carrotY > posy - 70 && carrot.isVisable()) {        // if the carrot is near the rabbit        mouth = mouth2;    } else {        mouth = mouth1;    }// this statements makes the bunny smile or be angry according to the mood of the bunny}',LongMethodRule
'// * Bouncy Bubbles',correct
'posy - 115',correct
'{    showimage = !showimage;    fed += 1;}',correct
'G1 = 255;',correct
'bunnies[i]',correct
'carrot.isVisable()',correct
'position = new PVector(x, y)',correct
'posy - 30',correct
'{    carrot.showCarrot();}',correct
'minDist = 50',correct
'counting',correct
'R = 51',correct
'void',correct
'// or -=ay but then it speeds upydirection = ydirection * (-1);',correct
'-1',correct
'bunnies[i].collide()',correct
'// for colourswich bodyint R;',TooManyFields
'void counting() {    if (counter > 5) {        xspeed = 0;        yspeed = 0;        textSize(50);        textAlign(CENTER);        fill(0xffFF0307);        text("Out of carrots", width / 2, height / 2);        // make it all a grey tint. Bunnies stop moving and background is white/grey ish        // bunnies will be a darker tint of grey        R = 144;        G = 138;        B = 138;        R1 = 198;        G1 = 192;        B1 = 192;    }}',TooManyFields
'ellipse(posx - 28, posy - 30, 30, 40)',correct
'2.2f',correct
'// Natasja Schaafsma',correct
'{    ydirection *= -1;}',correct
'{    // when you press n a new carrot spawns at the mouselocation    if (key == n && !carrot.isVisable()) {        carrot.showCarrot();        counter += 1;        if (counter > 6) {            counter = 6;        }    }}',correct
'// footellipse(posx - 65, posy - 16, 30, 12);',correct
'counter += 1',correct
'void showCarrot() {    showimage = !showimage;    fed += 1;}',correct
'true',correct
'counter = 1',correct
'0.8f',correct
'position',correct
'R = 242',correct
'"Click to feed the rabbit. When it is hungry again, press n to generate a new carrot. \nYou have 6 carrots in store. \nCarrots used :" + counter',correct
'counter = 6',correct
'PVector',correct
'posy - 16',correct
'float ay = (targetY - bunnies[i].posy);',correct
'// update position of bunnyposx = posx + (xspeed * xdirection);',correct
'float xdirection1',correct
'// loads image into the programnose = loadImage("nose.png");',correct
'float dx = bunnies[i].posx - posx',correct
'// Test to see if the shape exceeds the boundaries of the screen',correct
'PImage mouth2;',TooManyFields
'// Max distance between bunniesfloat minDist = 50;',correct
'xdirection = xdirection * (-1)',correct
'bunnies[i].posy - posy',correct
'{    xspeed = 0;    yspeed = 0;    textSize(50);    textAlign(CENTER);    fill(0xffFF0307);    text("Out of carrots", width / 2, height / 2);    // make it all a grey tint. Bunnies stop moving and background is white/grey ish    // bunnies will be a darker tint of grey    R = 144;    G = 138;    B = 138;    R1 = 198;    G1 = 192;    B1 = 192;}',correct
'counter > 6',correct
'float x',correct
'float y',correct
'xdirection *= -1',correct
'// set imagemode to centerimageMode(CENTER);',correct
'// legellipse(posx - 28, posy - 30, 30, 40);',correct
'// Angry.draw();fill(0);',correct
'yspeed = 0',correct
'xspeed = 2.8f;',correct
'R1 = 255;',correct
'!showimage',correct
'"Out of carrots"',correct
'posx > width - rad || posx < rad',correct
'counter > 5',correct
'posy - 20',correct
'textSize(50);',correct
'textSize(50)',correct
'Bunny[]',correct
'sin(angle) * minDist',correct
'G1 = 178;',correct
'boolean isVisable() {    return showimage;}',correct
'posy - 70',correct
'fill(0xffFF0307)',correct
'Carrot car',correct
'mouseMoved',correct
'posy - 75',correct
'R1',correct
'dx * dx + dy * dy',correct
'// draws an ear that shifts colour according to the mood of the bunnyellipse(posx - 23, posy - 115, 20, 55);',correct
'bunnies[i] = new Bunny(random(0, width), random(0, height), random(-1, 1), random(-1, 1), carrot, i);',correct
'// left or rightfloat xdirection = 1;',TooManyFields
'posy + (yspeed * ydirection)',correct
'carrot = car;',correct
'new Bunny[10]',correct
'xspeed = 0;',correct
'posx = posx + (xspeed * xdirection)',correct
'posx + 50',correct
'xspeed = 2.8f',correct
'// S1914820',correct
'Carrot carrot;',correct
'int counter = 1;',correct
'float angle = atan2(dy, dx)',correct
'textSize(20)',correct
'"nose.png"',correct
'// if the carrot is near the rabbitxspeed = 1.2f;',correct
'{    R = 149;    G = 35;    B = 138;    R1 = 178;    G1 = 178;    B1 = 178;    xspeed = 2.8f;    yspeed = 2.2f;}',correct
'// write user instructions on screentextSize(30);',correct
'Carrot',correct
'// for colourswich bodyint G;',TooManyFields
'// speed of bunnyfloat yspeed = 2.2f;',TooManyFields
'PImage',correct
'ellipse(posx - 23, posy - 115, 12, 40)',correct
'class Carrot {    PVector position;    PImage carrot;    boolean showimage;    Carrot(float x, float y) {        position = new PVector(x, y);        // loads image into the program        carrot = loadImage("carrot.png");        showimage = true;    }    PVector GetPostition() {        return position;    }    void display() {        if (showimage) {            // draw a carrot            image(carrot, position.x, position.y, 70, 60);        }    }    void showCarrot() {        showimage = !showimage;        fed += 1;    }    void updatePosition(float x, float y) {        position = new PVector(x, y);    }    boolean isVisable() {        return showimage;    }}',correct
'// draws inside of the ear that shifts colour according to the mood of the bunnyellipse(posx - 23, posy - 115, 12, 40);',correct
'posy - 50',correct
'carrot.updatePosition(mouseX, mouseY);',correct
'G = 35',correct
'int id;',ShortVariable
'{    bunnies[i] = new Bunny(random(0, width), random(0, height), random(-1, 1), random(-1, 1), carrot, i);}',correct
'bunnies[i].Collision()',correct
'posy - 55',correct
'float targetX = posx + cos(angle) * minDist',correct
'posx < rad',correct
'ellipse(posx - 8, posy - 75, 5, 7)',correct
'// headfloat carrotX = carrot.GetPostition().x;',correct
'G = 159;',correct
'carrot.GetPostition()',correct
'return position;',correct
'text("Out of carrots", width / 2, height / 2)',correct
'loadImage("nose.png")',correct
'showimage = true',correct
'posy > height - rad',correct
'// x distance between bunniesfloat dx = bunnies[i].posx - posx;',correct
'if (distance < minDist) {    // calculates the angle between dy and dx    float angle = atan2(dy, dx);    float targetX = posx + cos(angle) * minDist;    float targetY = posy + sin(angle) * minDist;    float ax = (targetX - bunnies[i].posx);    float ay = (targetY - bunnies[i].posy);    xdirection = xdirection * (-1);    // or -=ay but then it speeds up    ydirection = ydirection * (-1);    R = 51;    G = 219;    B = 60;}',correct
'textSize(30)',correct
'carrot.showCarrot();',correct
'ellipse(posx - 50, posy - 39, 70, 30)',correct
'posy - 64',correct
'2.8f',correct
'noStroke()',correct
'B = 138;',correct
'{    // x distance between bunnies    float dx = bunnies[i].posx - posx;    // y distance between bunnies    float dy = bunnies[i].posy - posy;    // square hitbox around  bunny    float distance = sqrt(dx * dx + dy * dy);    // Max distance between bunnies    float minDist = 50;    if (distance < minDist) {        // calculates the angle between dy and dx        float angle = atan2(dy, dx);        float targetX = posx + cos(angle) * minDist;        float targetY = posy + sin(angle) * minDist;        float ax = (targetX - bunnies[i].posx);        float ay = (targetY - bunnies[i].posy);        xdirection = xdirection * (-1);        // or -=ay but then it speeds up        ydirection = ydirection * (-1);        R = 51;        G = 219;        B = 60;    }}',correct
'dx = bunnies[i].posx - posx',correct
'G = 138;',correct
'ellipse(posx + 23, posy - 115, 20, 55)',correct
'float ax = (targetX - bunnies[i].posx)',correct
'R1 = 255',correct
'B1 = 255',correct
'targetX = posx + cos(angle) * minDist',correct
'carrotY < posy - 20',correct
'int fed = 0;',correct
'bunnies[i].posx - posx',correct
'position.x',correct
'position.y',correct
'R = 51;',correct
'// Bunny [] others;',correct
'ydirection * (-1)',correct
'fill(0)',correct
'// draws a circle that shifts colour according to the mood of the bunnyellipse(posx, posy - 75, 55, 55);',correct
'void setup() {    // sets screen size    bg = loadImage("cage.jpg");    carrot = new Carrot(width / 2, height / 2);    for (int i = 0; i < bunnies.length; i++) {        bunnies[i] = new Bunny(random(0, width), random(0, height), random(-1, 1), random(-1, 1), carrot, i);    }}',correct
'mouth2 = loadImage("smile.png")',correct
'height / 2',correct
'dy * dy',correct
'posx - 8',correct
'posy > height - rad || posy < rad',correct
'bunnies[i].counting()',correct
'posx - 3',correct
'Bunny',correct
'random(0, height)',correct
'{    mouth = mouth1;}',correct
'fill(255)',correct
'xdirection *= -1;',correct
'{    // if the carrot is near the rabbit    mouth = mouth2;}',correct
'posx + 23',correct
'R = 149;',correct
'new Carrot(width / 2, height / 2)',correct
'int i = id + 1',correct
'{    float carrotX = carrot.GetPostition().x;    float carrotY = carrot.GetPostition().y;    if (carrotX < posx + 50 && carrotX > posx - 50 && carrotY < posy - 20 && carrotY > posy - 70 && carrot.isVisable()) {        carrot.showCarrot();    }}',correct
'float carrotX = carrot.GetPostition().x',correct
'carrot.display()',correct
'ellipse(posx + 8, posy - 75, 12, 17);',correct
'float carrotY = carrot.GetPostition().y',correct
'// make it all a grey tint. Bunnies stop moving and background is white/grey ish',correct
'fill(R1, G1, B1)',correct
'// Natasja Schaafsma// S1914820// Program called: Monster Bunny (eat a snickers...carrot)Bunny[] bunnies = new Bunny[10];',correct
'{    position = new PVector(x, y);}',correct
'float targetX = posx + cos(angle) * minDist;',correct
'showimage = !showimage;',correct
'textAlign(CENTER);',correct
'mouth = mouth1',correct
'carrotY > posy - 70',correct
'ax = (targetX - bunnies[i].posx)',correct
'mouth = mouth2',correct
'int i = 0',correct
'mouth',correct
'ydirection = ydirection * (-1)',correct
'sqrt(dx * dx + dy * dy)',correct
'cos(angle) * minDist',correct
'G = 159',correct
'yspeed = 2.2f;',correct
'carrotX < posx + 50 && carrotX > posx - 50 && carrotY < posy - 20 && carrotY > posy - 70',correct
'posx = posx1',correct
'float dy = bunnies[i].posy - posy',correct
'posx - 68',correct
'ay = (targetY - bunnies[i].posy)',correct
'posx - 65',correct
'ellipse(posx + 8, posy - 75, 5, 7);',correct
'R1 = 178',correct
'B1 = 178',correct
'key == n && !carrot.isVisable()',correct
'{    // sets screen size    bg = loadImage("cage.jpg");    carrot = new Carrot(width / 2, height / 2);    for (int i = 0; i < bunnies.length; i++) {        bunnies[i] = new Bunny(random(0, width), random(0, height), random(-1, 1), random(-1, 1), carrot, i);    }}',correct
'new Bunny(random(0, width), random(0, height), random(-1, 1), random(-1, 1), carrot, i)',correct
'imageMode(CENTER)',correct
'{    counter = 6;}',correct
'text("Out of carrots", width / 2, height / 2);',correct
'void display() {    if (showimage) {        // draw a carrot        image(carrot, position.x, position.y, 70, 60);    }}',correct
'ellipse(posx - 8, posy - 75, 12, 17);',correct
'ellipse(posx - 23, posy - 115, 20, 55)',correct
'ydirection = 1',correct
'{    bunnies[i].Collision();}',correct
'// sets screen sizebg = loadImage("cage.jpg");',correct
'G = 138',correct
'xdirection = 1',correct
'float carrotY = carrot.GetPostition().y;',correct
'key == n',correct
'if (carrotX < posx + 50 && carrotX > posx - 50 && carrotY < posy - 20 && carrotY > posy - 70 && carrot.isVisable()) {    carrot.showCarrot();}',correct
'G1 = 192;',correct
'{    return showimage;}',correct
'"cage.jpg"',correct
'B1 = 192',correct
'carrotX < posx + 50',correct
'// calculates the angle between dy and dxfloat angle = atan2(dy, dx);',correct
'posx - 84',correct
'void draw() {    // make sure background is loaded    background(bg);    for (int i = 0; i < bunnies.length; i++) {        bunnies[i].drawBunny();        bunnies[i].collide();        bunnies[i].counting();    }    carrot.display();    // Angry.draw();    fill(0);    // write user instructions on screen    textSize(30);    textAlign(LEFT);    textSize(20);    text("Click to feed the rabbit. When it is hungry again, press n to generate a new carrot. \nYou have 6 carrots in store. \nCarrots used :" + counter, 10, 30);}',correct
'R1 = 198',correct
'textAlign(LEFT);',correct
'// head',correct
'PImage mouth;',TooManyFields
'// * based on code from Keith Peters.for (int i = id + 1; i < bunnies.length; i++) {    // x distance between bunnies    float dx = bunnies[i].posx - posx;    // y distance between bunnies    float dy = bunnies[i].posy - posy;    // square hitbox around  bunny    float distance = sqrt(dx * dx + dy * dy);    // Max distance between bunnies    float minDist = 50;    if (distance < minDist) {        // calculates the angle between dy and dx        float angle = atan2(dy, dx);        float targetX = posx + cos(angle) * minDist;        float targetY = posy + sin(angle) * minDist;        float ax = (targetX - bunnies[i].posx);        float ay = (targetY - bunnies[i].posy);        xdirection = xdirection * (-1);        // or -=ay but then it speeds up        ydirection = ydirection * (-1);        R = 51;        G = 219;        B = 60;    }}',correct
'// width of bunnyint rad = 70;',TooManyFields
'fill(R, G, B)',correct
'bunnies.length',correct
'display',correct
'showimage',correct
'{    // if the carrot is near the rabbit    xspeed = 1.2f;    yspeed = 0.8f;    R = 242;    G = 159;    B = 159;    R1 = 255;    G1 = 255;    B1 = 255;}',correct
'// loads image into the programcarrot = loadImage("carrot.png");',correct
'ydirection *= -1;',correct
'mouth1 = loadImage("chew.png")',correct
'// square hitbox around  bunnyfloat distance = sqrt(dx * dx + dy * dy);',correct
'// legs',correct
'void collide() {    // * based on code from Keith Peters.    for (int i = id + 1; i < bunnies.length; i++) {        // x distance between bunnies        float dx = bunnies[i].posx - posx;        // y distance between bunnies        float dy = bunnies[i].posy - posy;        // square hitbox around  bunny        float distance = sqrt(dx * dx + dy * dy);        // Max distance between bunnies        float minDist = 50;        if (distance < minDist) {            // calculates the angle between dy and dx            float angle = atan2(dy, dx);            float targetX = posx + cos(angle) * minDist;            float targetY = posy + sin(angle) * minDist;            float ax = (targetX - bunnies[i].posx);            float ay = (targetY - bunnies[i].posy);            xdirection = xdirection * (-1);            // or -=ay but then it speeds up            ydirection = ydirection * (-1);            R = 51;            G = 219;            B = 60;        }    }}',TooManyFields
'{    // calculates the angle between dy and dx    float angle = atan2(dy, dx);    float targetX = posx + cos(angle) * minDist;    float targetY = posy + sin(angle) * minDist;    float ax = (targetX - bunnies[i].posx);    float ay = (targetY - bunnies[i].posy);    xdirection = xdirection * (-1);    // or -=ay but then it speeds up    ydirection = ydirection * (-1);    R = 51;    G = 219;    B = 60;}',correct
'G = 35;',correct
'ellipse(posx - 8, posy - 75, 12, 17)',correct
'cos(angle)',correct
'posx - 28',correct
'i++',correct
'sin(angle)',correct
'posx - 23',correct
'posx - 26',correct
'{    for (int i = 0; i < bunnies.length; i++) {        bunnies[i].Collision();    }}',correct
'// loads image into the programmouth1 = loadImage("chew.png");',correct
'xdirection = xdirection1',correct
'loadImage("carrot.png")',correct
'for (int i = 0; i < bunnies.length; i++) {    bunnies[i] = new Bunny(random(0, width), random(0, height), random(-1, 1), random(-1, 1), carrot, i);}',correct
'posx + cos(angle) * minDist',correct
'keyPressed',correct
'{    xdirection *= -1;}',correct
'float ay = (targetY - bunnies[i].posy)',correct
'float ax = (targetX - bunnies[i].posx);',ShortVariable
'G = 219;',correct
'// draws an ear that shifts colour according to the mood of the bunnyellipse(posx + 23, posy - 115, 20, 55);',correct
'// mouth sadimage(mouth, posx - 3, posy - 55, 17, 10);',correct
'B = 159',correct
'image(nose, posx + 1, posy - 70, 50, 20)',correct
'fed += 1',correct
'// update position of bunnyposy = posy + (yspeed * ydirection);',correct
'G = 219',correct
'carrotX < posx + 50 && carrotX > posx - 50 && carrotY < posy - 20 && carrotY > posy - 70 && carrot.isVisable()',correct
'textAlign(LEFT)',correct
'ellipse(posx, posy - 75, 55, 55)',correct
'{    carrot.updatePosition(mouseX, mouseY);}',correct
'// for colourswich furint R1;',TooManyFields
'[10]',correct
'bunnies[i].drawBunny();',correct
'yspeed = 0.8f',correct
'yspeed = 2.2f',correct
'// for colourswich bodyint B;',TooManyFields
'posy = posy1;',correct
'atan2(dy, dx)',correct
'if (posy > height - rad || posy < rad) {    ydirection *= -1;}',correct
'bunnies[i].drawBunny()',correct
'bunnies[i].counting();',correct
'nose',correct
'void updatePosition(float x, float y) {    position = new PVector(x, y);}',correct
'{    // make sure background is loaded    background(bg);    for (int i = 0; i < bunnies.length; i++) {        bunnies[i].drawBunny();        bunnies[i].collide();        bunnies[i].counting();    }    carrot.display();    // Angry.draw();    fill(0);    // write user instructions on screen    textSize(30);    textAlign(LEFT);    textSize(20);    text("Click to feed the rabbit. When it is hungry again, press n to generate a new carrot. \nYou have 6 carrots in store. \nCarrots used :" + counter, 10, 30);}',correct
'mouth2 = loadImage("smile.png");',correct
'B1 = 192;',correct
'"smile.png"',correct
'width / 2',correct
'B = 138',correct
'// for colourswich furint B1;',TooManyFields
'posx - 50',correct
'{    position = new PVector(x, y);    // loads image into the program    carrot = loadImage("carrot.png");    showimage = true;}',correct
'// make it all a grey tint. Bunnies stop moving and background is white/grey ish// bunnies will be a darker tint of greyR = 144;',correct
'carrot',correct
'mouseDragged',correct
'// eyes// blackfill(0, 0, 0);',correct
'{    ladybugs[i].unselect();}',correct
'random(0, 255)',correct
'line(ladybugX + 15, ladybugY - 60, ladybugX + 10, ladybugY - 50)',correct
'{    isSelected = false;}',correct
'fill(0, 0, 0)',correct
'{    int xspeed = 1;    ladybugX = ladybugX + xspeed;    if (ladybugX >= width + 37) {        ladybugX = -75;    }}',correct
'ladybugX = -75',correct
'ladybugs[i] = new Ladybug(PApplet.parseInt(random(0, 501)), PApplet.parseInt(random(0, 501)))',correct
'{    ladybugs[i].scareBug();}',correct
'line(ladybugX - 40, ladybugY + 40, ladybugX + 40, ladybugY - 40)',correct
'for (int i = 0; i < ladybugs.length; i++) {    ladybugs[i].scareBug();}',correct
'fill(255, 0, 0);',correct
'{    if (isSelected) {        ladybugX = newX;        ladybugY = newY;    }}',correct
'if (isSelected) {    ladybugX = newX;    ladybugY = newY;}',correct
'{    for (int i = 0; i < ladybugs.length; i++) {        ladybugs[i].unselect();    }}',correct
'// head ladybugfill(0, 0, 0);',correct
'/* Armein Margriet Dul //<>// s2164736 Creature Project 2018, P4WCI*/// declare the ladybugsstatic final int LADYBUGS = 10;',correct
'{    ladybugs[i].move(mouseX, mouseY);}',correct
'boolean isSelected = false;',correct
'line(ladybugX + 15, ladybugY - 60, ladybugX + 10, ladybugY - 50);',correct
'float radius = 37.5f;',correct
'ladybugX = newX',correct
'[LADYBUGS]',correct
'ellipse(ladybugX + 10, ladybugY + 0, 8, 8);',correct
'mouseReleased',correct
'PImage',correct
'line(ladybugX - 60, ladybugY, ladybugX + 60, ladybugY);',correct
'isSelected = false;',correct
'xspeed = 1',correct
'{    ladybugX = initX;    ladybugY = initY;}',correct
'LADYBUGS = 10',correct
'// move the ladybug around in the field with a new x and y positionvoid move(int newX, int newY) {    if (isSelected) {        ladybugX = newX;        ladybugY = newY;    }}',correct
'line(ladybugX, ladybugY + 36, ladybugX, ladybugY - 36)',correct
'fill(random(0, 255), random(0, 255), random(0, 255));',correct
'for (int i = 0; i < ladybugs.length; i++) {    ladybugs[i].move(mouseX, mouseY);}',correct
'ladybugY - 18',correct
'ladybugX - 60',correct
'ellipse(ladybugX, ladybugY, 75, 75)',correct
'int initY',correct
'ladybugX - 40',correct
'mouseButton == LEFT',correct
'random(0, 501)',correct
'int initX',correct
'{    image(flowers, 0, 0);    // create the ladybugs    for (int i = 0; i < ladybugs.length; i++) {        ladybugs[i].display();        ladybugs[i].updated();    }}',correct
'strokeWeight(2);',correct
'ellipse(ladybugX - 10, ladybugY + 0, 8, 8)',correct
'ladybugX = ladybugX + xspeed;',correct
'ladybugY - 25',correct
'for (int i = 0; i < ladybugs.length; i++) {    ladybugs[i].unselect();}',correct
'37.5f',correct
'int newX',correct
'int newY',correct
'flowers = loadImage("flowers.png")',correct
'line(ladybugX - 15, ladybugY - 60, ladybugX - 10, ladybugY - 50)',correct
'ladybugX = -75;',correct
'Ladybug[]',correct
'new Ladybug[LADYBUGS]',correct
'ladybugX + 10',correct
'Ladybug[] ladybugs = new Ladybug[LADYBUGS];',correct
'// photo of my gardenPImage flowers;',correct
'/*when mouse is pressed on one of the ladybugs, only one of them is selected.  to make sure the ladybug doesnt "eat" others, there is a break in the program  reference: thanks to the help of Ansgar*/void mousePressed() {    for (int i = 0; i < ladybugs.length; i++) {        ladybugs[i].selected();        if (ladybugs[i].isSelected) {            break;        }    }}',correct
'ellipse(ladybugX, ladybugY, 75, 75);',correct
'ladybugX + 15',correct
'ladybugX + 17',correct
'{    fill(random(0, 255), random(0, 255), random(0, 255));}',correct
'{    isInsecure = !isInsecure;}',correct
'ladybugX + 18',correct
'ladybugY - 36',correct
'ellipse(ladybugX + 10, ladybugY + 0, 8, 8)',correct
'ladybugX = initX;',correct
'isSelected = true',correct
'{    ladybugs[i].display();    ladybugs[i].updated();}',correct
'ladybugX + xspeed',correct
'{    break;}',correct
'if (ladybugs[i].isSelected) {    break;}',correct
'ladybugY - 50',correct
'break;',correct
'ellipse(ladybugX - 17, ladybugY - 65, -8, -8);',correct
'{    for (int i = 0; i < ladybugs.length; i++) {        ladybugs[i].selected();        if (ladybugs[i].isSelected) {            break;        }    }}',correct
'// when ladybugs are out of the field, they will come backvoid updated() {    int xspeed = 1;    ladybugX = ladybugX + xspeed;    if (ladybugX >= width + 37) {        ladybugX = -75;    }}',correct
'ladybugY - 40',correct
'{    for (int i = 0; i < ladybugs.length; i++) {        ladybugs[i].scareBug();    }}',correct
'ladybugs[i].move(mouseX, mouseY)',correct
'{    ladybugX = -75;}',correct
'if (((mouseX - ladybugX) * (mouseX - ladybugX) + (mouseY - ladybugY) * (mouseY - ladybugY) <= radius * radius) && mouseButton == LEFT) {    isSelected = true;}',correct
'updated',correct
'// change x and y position of ladybug by moving mouse in any directionvoid mouseDragged() {    for (int i = 0; i < ladybugs.length; i++) {        ladybugs[i].move(mouseX, mouseY);    }}',correct
'// create the ladybugsfor (int i = 0; i < ladybugs.length; i++) {    ladybugs[i].display();    ladybugs[i].updated();}',correct
'ladybugs[i].isSelected',correct
'ladybugY - 60',correct
'int xspeed = 1',correct
'int ladybugX;',correct
'ladybugY + 0',correct
'Processing',correct
'Ladybug',correct
'line(ladybugX - 40, ladybugY - 40, ladybugX + 40, ladybugY + 40);',correct
'ellipse(ladybugX + 17, ladybugY - 64, -8, -8)',correct
'// initialize the ladybugs at a random position in the fieldfor (int i = 0; i < ladybugs.length; i++) {    ladybugs[i] = new Ladybug(PApplet.parseInt(random(0, 501)), PApplet.parseInt(random(0, 501)));}',correct
'// class of a ladybugclass Ladybug {    int ladybugX;    int ladybugY;    boolean isInsecure = false;    boolean isSelected = false;    float radius = 37.5f;    Ladybug(int initX, int initY) {        ladybugX = initX;        ladybugY = initY;    }    void display() {        // legs ladybug        fill(0, 0, 0);        strokeWeight(2);        line(ladybugX - 40, ladybugY + 40, ladybugX + 40, ladybugY - 40);        line(ladybugX - 60, ladybugY, ladybugX + 60, ladybugY);        line(ladybugX - 40, ladybugY - 40, ladybugX + 40, ladybugY + 40);        // head ladybug        fill(0, 0, 0);        strokeWeight(2);        ellipse(ladybugX, ladybugY - 25, 50, 50);        // body and bodycolour        strokeWeight(2);        if (isInsecure) {            fill(random(0, 255), random(0, 255), random(0, 255));        } else {            fill(255, 0, 0);        }        ellipse(ladybugX, ladybugY, 75, 75);        // body: on top of the ladybug        line(ladybugX, ladybugY + 36, ladybugX, ladybugY - 36);        // black        fill(0, 0, 0);        ellipse(ladybugX + 18, ladybugY + 18, 8, 8);        ellipse(ladybugX + 18, ladybugY - 18, 8, 8);        ellipse(ladybugX - 18, ladybugY - 18, 8, 8);        ellipse(ladybugX - 10, ladybugY + 0, 8, 8);        ellipse(ladybugX + 10, ladybugY + 0, 8, 8);        ellipse(ladybugX - 18, ladybugY + 18, 8, 8);        // feelers        strokeWeight(2);        line(ladybugX - 15, ladybugY - 60, ladybugX - 10, ladybugY - 50);        line(ladybugX + 15, ladybugY - 60, ladybugX + 10, ladybugY - 50);        // eyes        // black        fill(0, 0, 0);        ellipse(ladybugX + 17, ladybugY - 64, -8, -8);        ellipse(ladybugX - 17, ladybugY - 65, -8, -8);    }    // when ladybugs are out of the field, they will come back    void updated() {        int xspeed = 1;        ladybugX = ladybugX + xspeed;        if (ladybugX >= width + 37) {            ladybugX = -75;        }    }    // scare the ladybug, when you are inside the ladybug    void scareBug() {        if (((mouseX - ladybugX) * (mouseX - ladybugX) + (mouseY - ladybugY) * (mouseY - ladybugY) <= radius * radius) && mouseButton == LEFT) {            isInsecure = !isInsecure;        }    }    // move the ladybug around in the field with a new x and y position    void move(int newX, int newY) {        if (isSelected) {            ladybugX = newX;            ladybugY = newY;        }    }    /*only inside the ladybug, you can select it   reference: thanks to the help of Ansgar*/    void selected() {        if (((mouseX - ladybugX) * (mouseX - ladybugX) + (mouseY - ladybugY) * (mouseY - ladybugY) <= radius * radius) && mouseButton == LEFT) {            isSelected = true;        }    }    /*unselect the ladybug    reference: thanks to the help of Ansgar*/    void unselect() {        isSelected = false;    }}',correct
'ladybugX = initX',correct
'// scare the ladybug, when you are inside the ladybugvoid scareBug() {    if (((mouseX - ladybugX) * (mouseX - ladybugX) + (mouseY - ladybugY) * (mouseY - ladybugY) <= radius * radius) && mouseButton == LEFT) {        isInsecure = !isInsecure;    }}',correct
'ladybugs[i].scareBug();',correct
'ladybugY = initY;',correct
'ellipse(ladybugX - 18, ladybugY + 18, 8, 8)',correct
'void display() {    // legs ladybug    fill(0, 0, 0);    strokeWeight(2);    line(ladybugX - 40, ladybugY + 40, ladybugX + 40, ladybugY - 40);    line(ladybugX - 60, ladybugY, ladybugX + 60, ladybugY);    line(ladybugX - 40, ladybugY - 40, ladybugX + 40, ladybugY + 40);    // head ladybug    fill(0, 0, 0);    strokeWeight(2);    ellipse(ladybugX, ladybugY - 25, 50, 50);    // body and bodycolour    strokeWeight(2);    if (isInsecure) {        fill(random(0, 255), random(0, 255), random(0, 255));    } else {        fill(255, 0, 0);    }    ellipse(ladybugX, ladybugY, 75, 75);    // body: on top of the ladybug    line(ladybugX, ladybugY + 36, ladybugX, ladybugY - 36);    // black    fill(0, 0, 0);    ellipse(ladybugX + 18, ladybugY + 18, 8, 8);    ellipse(ladybugX + 18, ladybugY - 18, 8, 8);    ellipse(ladybugX - 18, ladybugY - 18, 8, 8);    ellipse(ladybugX - 10, ladybugY + 0, 8, 8);    ellipse(ladybugX + 10, ladybugY + 0, 8, 8);    ellipse(ladybugX - 18, ladybugY + 18, 8, 8);    // feelers    strokeWeight(2);    line(ladybugX - 15, ladybugY - 60, ladybugX - 10, ladybugY - 50);    line(ladybugX + 15, ladybugY - 60, ladybugX + 10, ladybugY - 50);    // eyes    // black    fill(0, 0, 0);    ellipse(ladybugX + 17, ladybugY - 64, -8, -8);    ellipse(ladybugX - 17, ladybugY - 65, -8, -8);}',correct
'false',correct
'int ladybugY;',correct
'if (isInsecure) {    fill(random(0, 255), random(0, 255), random(0, 255));} else {    fill(255, 0, 0);}',correct
'int i = 0',correct
'ladybugY - 65',correct
'ladybugY - 64',correct
'setup',correct
'for (int i = 0; i < ladybugs.length; i++) {    ladybugs[i].selected();    if (ladybugs[i].isSelected) {        break;    }}',correct
'{    for (int i = 0; i < ladybugs.length; i++) {        ladybugs[i].move(mouseX, mouseY);    }}',correct
'{    ladybugX = newX;    ladybugY = newY;}',correct
'scareBug',correct
'new Ladybug(PApplet.parseInt(random(0, 501)), PApplet.parseInt(random(0, 501)))',correct
'image(flowers, 0, 0);',correct
'i = 0',correct
'radius = 37.5f',correct
'ladybugY = initY',correct
'{    ladybugs[i] = new Ladybug(PApplet.parseInt(random(0, 501)), PApplet.parseInt(random(0, 501)));}',correct
'ladybugs[i].display();',correct
'line(ladybugX - 40, ladybugY - 40, ladybugX + 40, ladybugY + 40)',correct
'isSelected = true;',correct
'flowers = loadImage("flowers.png");',correct
'// when clicked inside the Ladybug AND left mousbutton, the Ladybug changes her colour)void mouseClicked() {    for (int i = 0; i < ladybugs.length; i++) {        ladybugs[i].scareBug();    }}',correct
'ellipse(ladybugX + 18, ladybugY + 18, 8, 8)',correct
'{    ladybugs[i].selected();    if (ladybugs[i].isSelected) {        break;    }}',correct
'ellipse(ladybugX - 17, ladybugY - 65, -8, -8)',correct
'ladybugX + 40',correct
'flowers',correct
'isInsecure = false',correct
'isInsecure = !isInsecure;',correct
'// body and bodycolourstrokeWeight(2);',correct
'Ladybug(int initX, int initY) {    ladybugX = initX;    ladybugY = initY;}',correct
'ellipse(ladybugX - 10, ladybugY + 0, 8, 8);',correct
'image(flowers, 0, 0)',correct
'{    if (((mouseX - ladybugX) * (mouseX - ladybugX) + (mouseY - ladybugY) * (mouseY - ladybugY) <= radius * radius) && mouseButton == LEFT) {        isInsecure = !isInsecure;    }}',correct
'ladybugY = newY',correct
'((mouseX - ladybugX) * (mouseX - ladybugX) + (mouseY - ladybugY) * (mouseY - ladybugY) <= radius * radius) && mouseButton == LEFT',correct
'"flowers.png"',correct
'{    flowers = loadImage("flowers.png");    // initialize the ladybugs at a random position in the field    for (int i = 0; i < ladybugs.length; i++) {        ladybugs[i] = new Ladybug(PApplet.parseInt(random(0, 501)), PApplet.parseInt(random(0, 501)));    }}',correct
'{    fill(255, 0, 0);}',correct
'ellipse(ladybugX + 18, ladybugY - 18, 8, 8)',correct
'// eyes',correct
'ladybugX = newX;',correct
'width + 37',correct
'line(ladybugX - 40, ladybugY + 40, ladybugX + 40, ladybugY - 40);',correct
'ladybugs[i].selected()',correct
'display',LongMethodRule
'line(ladybugX - 60, ladybugY, ladybugX + 60, ladybugY)',correct
'ladybugs[i].scareBug()',correct
'draw',correct
'/*only inside the ladybug, you can select it   reference: thanks to the help of Ansgar*/void selected() {    if (((mouseX - ladybugX) * (mouseX - ladybugX) + (mouseY - ladybugY) * (mouseY - ladybugY) <= radius * radius) && mouseButton == LEFT) {        isSelected = true;    }}',correct
'!isInsecure',correct
'ellipse(ladybugX, ladybugY - 25, 50, 50);',correct
'i < ladybugs.length',correct
'ladybugs[i].display()',correct
'// body: on top of the ladybugline(ladybugX, ladybugY + 36, ladybugX, ladybugY - 36);',correct
'PApplet.parseInt(random(0, 501))',correct
'// blackfill(0, 0, 0);',correct
'fill(255, 0, 0)',correct
'i++',correct
'ladybugs[i].selected();',correct
'void draw() {    image(flowers, 0, 0);    // create the ladybugs    for (int i = 0; i < ladybugs.length; i++) {        ladybugs[i].display();        ladybugs[i].updated();    }}',correct
'ellipse(ladybugX, ladybugY - 25, 50, 50)',correct
'ladybugs[i].updated();',correct
'ellipse(ladybugX - 18, ladybugY + 18, 8, 8);',correct
'boolean isInsecure = false;',correct
'ladybugY',correct
'ladybugX',correct
'ladybugY + 18',correct
'ladybugs[i] = new Ladybug(PApplet.parseInt(random(0, 501)), PApplet.parseInt(random(0, 501)));',correct
'void',correct
'ellipse(ladybugX - 18, ladybugY - 18, 8, 8)',correct
'void setup() {    flowers = loadImage("flowers.png");    // initialize the ladybugs at a random position in the field    for (int i = 0; i < ladybugs.length; i++) {        ladybugs[i] = new Ladybug(PApplet.parseInt(random(0, 501)), PApplet.parseInt(random(0, 501)));    }}',correct
'ladybugs[i].updated()',correct
'-8',correct
'{    isSelected = true;}',correct
'ladybugs[i].unselect()',correct
'{    if (((mouseX - ladybugX) * (mouseX - ladybugX) + (mouseY - ladybugY) * (mouseY - ladybugY) <= radius * radius) && mouseButton == LEFT) {        isSelected = true;    }}',correct
'ladybugs = new Ladybug[LADYBUGS]',correct
'if (((mouseX - ladybugX) * (mouseX - ladybugX) + (mouseY - ladybugY) * (mouseY - ladybugY) <= radius * radius) && mouseButton == LEFT) {    isInsecure = !isInsecure;}',correct
'strokeWeight(2)',correct
'mouseClicked',correct
'fill(random(0, 255), random(0, 255), random(0, 255))',correct
'true',correct
'ellipse(ladybugX + 18, ladybugY + 18, 8, 8);',correct
'// legs ladybugfill(0, 0, 0);',correct
'line(ladybugX - 15, ladybugY - 60, ladybugX - 10, ladybugY - 50);',correct
'{    // legs ladybug    fill(0, 0, 0);    strokeWeight(2);    line(ladybugX - 40, ladybugY + 40, ladybugX + 40, ladybugY - 40);    line(ladybugX - 60, ladybugY, ladybugX + 60, ladybugY);    line(ladybugX - 40, ladybugY - 40, ladybugX + 40, ladybugY + 40);    // head ladybug    fill(0, 0, 0);    strokeWeight(2);    ellipse(ladybugX, ladybugY - 25, 50, 50);    // body and bodycolour    strokeWeight(2);    if (isInsecure) {        fill(random(0, 255), random(0, 255), random(0, 255));    } else {        fill(255, 0, 0);    }    ellipse(ladybugX, ladybugY, 75, 75);    // body: on top of the ladybug    line(ladybugX, ladybugY + 36, ladybugX, ladybugY - 36);    // black    fill(0, 0, 0);    ellipse(ladybugX + 18, ladybugY + 18, 8, 8);    ellipse(ladybugX + 18, ladybugY - 18, 8, 8);    ellipse(ladybugX - 18, ladybugY - 18, 8, 8);    ellipse(ladybugX - 10, ladybugY + 0, 8, 8);    ellipse(ladybugX + 10, ladybugY + 0, 8, 8);    ellipse(ladybugX - 18, ladybugY + 18, 8, 8);    // feelers    strokeWeight(2);    line(ladybugX - 15, ladybugY - 60, ladybugX - 10, ladybugY - 50);    line(ladybugX + 15, ladybugY - 60, ladybugX + 10, ladybugY - 50);    // eyes    // black    fill(0, 0, 0);    ellipse(ladybugX + 17, ladybugY - 64, -8, -8);    ellipse(ladybugX - 17, ladybugY - 65, -8, -8);}',LongMethodRule
'ladybugX >= width + 37',correct
'ellipse(ladybugX - 18, ladybugY - 18, 8, 8);',correct
'ladybugX - 10',correct
'isInsecure = !isInsecure',correct
'ladybugX - 17',correct
'ladybugX - 15',correct
'-75',correct
'// feelersstrokeWeight(2);',correct
'ladybugX - 18',correct
'ladybugs.length',correct
'// when mouse is released, let the ladybugs do their own thingvoid mouseReleased() {    for (int i = 0; i < ladybugs.length; i++) {        ladybugs[i].unselect();    }}',correct
'int xspeed = 1;',correct
'ladybugY + 36',correct
'ladybugs[i].unselect();',correct
'ladybugX + 60',correct
'ladybugX = ladybugX + xspeed',correct
'move',correct
'ellipse(ladybugX + 18, ladybugY - 18, 8, 8);',correct
'ladybugs[i]',correct
'/* Armein Margriet Dul //<>// s2164736 Creature Project 2018, P4WCI*/',correct
'if (ladybugX >= width + 37) {    ladybugX = -75;}',correct
'ladybugs[i].move(mouseX, mouseY);',correct
'/*unselect the ladybug    reference: thanks to the help of Ansgar*/void unselect() {    isSelected = false;}',correct
'ladybugY + 40',correct
'isSelected = false',correct
'ellipse(ladybugX + 17, ladybugY - 64, -8, -8);',correct
'ladybugY = newY;',correct
'loadImage("flowers.png")',correct
'Water',correct
'{    hans.moveLeft();}',correct
'1.0f * PI',correct
'narwhalY - speed',correct
'hans = new Narwhal();',correct
'// making the jellyfish accelerate the higher your scorejellyfishX = jellyfishX + score / 5 + 1;',correct
'jellyfishX = jellyfishX + score / 5 + 1',correct
'waterX = waterX + 100',correct
'waterY = 600',correct
'random(0, 255)',correct
'jellyfishY = PApplet.parseInt(random(200, 500))',correct
'// headstroke(bodyColor);',correct
'score',correct
'Narwhal',correct
'if (shootLaser == false) {    laserX = narwhalX - 237;    laserY = narwhalY - 48;}',SimplifyBooleanExpressions
'arc(jellyfishX, jellyfishY, 50, 50, PI, 2 * PI);',correct
'narwhalX = 1150',correct
'laserY = narwhalY - 48',correct
'laserX - 5',correct
'stroke(100, 100, 255)',correct
'arc(narwhalX - 30, narwhalY, 150, 150, 1.0f * PI, 9);',correct
'jellyfishColorB = PApplet.parseInt(random(255));',correct
'narwhalY',correct
'narwhalX',correct
'moveUp',correct
'laserX = laserX - 5;',DrawingStateChangeRule
'{    waterY = 600;}',correct
'Water ocean;',correct
'void draw() {    // skyblue    background(135, 206, 235);    points.display();    hans.display();    ocean.display();    jello.display();    jello.interact();}',correct
'triangle(narwhalX + 200, narwhalY + 75, narwhalX + 235, narwhalY + 115, narwhalX + 235, narwhalY + 40)',correct
'score + 1',correct
'{    // skyblue    background(135, 206, 235);    points.display();    hans.display();    ocean.display();    jello.display();    jello.interact();}',correct
'jellyfishX - 25',correct
'PApplet.parseInt(random(0, 255))',correct
'fill(0, 0, 0)',correct
'int waterX = 50',correct
'narwhalX = -250;',correct
'dist(jellyfishX, jellyfishY, laserX, laserY)',correct
'int jellyfishColorB;',correct
'Score() {    textSize(32);    textX = 830;    textY = 50;    score = 0;}',correct
'int textX;',correct
'new Water()',correct
'jellyfishY',correct
'jellyfishX',correct
'if (key == s) {    hans.moveDown();}',correct
'Narwhal() {    narwhalX = width / 2;    narwhalY = height / 2;    // light grey    bodyColor = color(150, 150, 150);    laserX = narwhalX - 237;    laserY = narwhalY - 48;    speed = 20;}',correct
'textSize(32)',correct
'int jellyfishColorR;',correct
'shootLaser == true',correct
'// resetting the game and score when a jellyfish reaches the end of the screenif (jellyfishX > 950) {    score = 0;    jellyfishX = -100;    jellyfishY = PApplet.parseInt(random(200, 500));    jellyfishColorR = PApplet.parseInt(random(0, 255));    jellyfishColorG = PApplet.parseInt(random(255));    jellyfishColorB = PApplet.parseInt(random(255));    jellyfishColor = color(jellyfishColorR, jellyfishColorG, jellyfishColorB);}',correct
'fill(255, 0, 0);',correct
'int jellyfishY;',correct
'// Every Jellyfish will have a different colorjellyfishColorR = PApplet.parseInt(random(0, 255));',correct
'{    fill(255, 0, 0);    stroke(255, 0, 0);    rect(laserX, laserY, 30, 6);    laserX = laserX - 5;}',correct
'narwhalX - 237',correct
'stroke(bodyColor)',correct
'waterY = 600;',correct
'// Movementvoid moveUp() {    narwhalY = narwhalY - speed;}',correct
'jellyfishX + score / 5 + 1',correct
'hans',correct
'int textY;',correct
'rect(narwhalX - 237, narwhalY - 50, 150, 10);',correct
'tentaclesX = tentaclesX + 11',correct
'class Narwhal {    int bodyColor;    boolean shootLaser;    float speed;    float narwhalX;    float narwhalY;    Narwhal() {        narwhalX = width / 2;        narwhalY = height / 2;        // light grey        bodyColor = color(150, 150, 150);        laserX = narwhalX - 237;        laserY = narwhalY - 48;        speed = 20;    }    void display() {        // Horn        fill(255);        stroke(255);        rect(narwhalX - 237, narwhalY - 50, 150, 10);        // head        stroke(bodyColor);        fill(bodyColor);        arc(narwhalX - 30, narwhalY, 150, 150, 1.0f * PI, 9);        stroke(0, 0, 0);        fill(0, 0, 0);        ellipse(narwhalX - 60, narwhalY - 30, 15, 15);        // body        stroke(bodyColor);        fill(bodyColor);        triangle(narwhalX - 30, narwhalY - 75, narwhalX - 30, narwhalY + 75, narwhalX + 200, narwhalY + 75);        // Back Fins        triangle(narwhalX + 200, narwhalY + 75, narwhalX + 235, narwhalY + 115, narwhalX + 235, narwhalY + 40);        // Front Fins        triangle(narwhalX - 30, narwhalY + 75, narwhalX + 30, narwhalY + 75, narwhalX + 15, narwhalY + 130);        // Laser        if (shootLaser == true) {            fill(255, 0, 0);            stroke(255, 0, 0);            rect(laserX, laserY, 30, 6);            laserX = laserX - 5;        }        if (laserX <= -30) {            shootLaser = false;        }        if (shootLaser == false) {            laserX = narwhalX - 237;            laserY = narwhalY - 48;        }        // Returning from off screen        if (narwhalX < -250) {            narwhalX = 1150;        }        if (narwhalX > 1150) {            narwhalX = -250;        }    }    // Movement    void moveUp() {        narwhalY = narwhalY - speed;    }    void moveLeft() {        narwhalX = narwhalX - speed;    }    void moveDown() {        narwhalY = narwhalY + speed;    }    void moveRight() {        narwhalX = narwhalX + speed;    }    void shoot() {        shootLaser = true;    }}',correct
'{    fill(255);    text(score, textX, textY);}',correct
'// Waterfill(100, 100, 255);',correct
'textX',correct
'{    hans.moveRight();}',correct
'// light greybodyColor = color(150, 150, 150);',correct
'textY',correct
'a',correct
'rect(narwhalX - 237, narwhalY - 50, 150, 10)',correct
'd',correct
'color(jellyfishColorR, jellyfishColorG, jellyfishColorB)',correct
'{    jellyfishX = -100;    jellyfishY = PApplet.parseInt(random(200, 500));    jellyfishColorR = PApplet.parseInt(random(0, 255));    jellyfishColorG = PApplet.parseInt(random(255));    jellyfishColorB = PApplet.parseInt(random(255));    jellyfishColor = color(jellyfishColorR, jellyfishColorG, jellyfishColorB);    score = score + 1;}',correct
'jellyfishColorR = PApplet.parseInt(random(0, 255))',correct
'narwhalX = width / 2;',correct
'jello.interact()',correct
's',correct
'new Narwhal()',correct
'waterX = 50',correct
'w',correct
'random(255)',correct
'shootLaser',correct
'shootLaser = false;',correct
'jellyfishColorB = PApplet.parseInt(random(255))',correct
'narwhalY = narwhalY + speed',correct
'int waterY;',correct
'narwhalX + 30',correct
'textY = 50;',correct
'points.display()',correct
'jellyfishColor = color(jellyfishColorR, jellyfishColorG, jellyfishColorB);',correct
'if (narwhalX > 1150) {    narwhalX = -250;}',correct
'// defining the jellyfishstroke(jellyfishColor);',correct
'fill(bodyColor)',correct
'Narwhal hans;',correct
'hans = new Narwhal()',correct
'stroke(0, 0, 0)',correct
'narwhalY = height / 2;',correct
'int waterX;',correct
'{    // Water    fill(100, 100, 255);    stroke(100, 100, 255);    for (int waterX = 50; waterX < 900; waterX = waterX + 100) {        ellipse(waterX, waterY, 200, 200);    }}',correct
'triangle(narwhalX - 30, narwhalY + 75, narwhalX + 30, narwhalY + 75, narwhalX + 15, narwhalY + 130)',correct
'-100',correct
'waterX < 900',correct
'Score',correct
'score = 0',correct
'if (key == d) {    hans.moveRight();}',correct
'ocean',correct
'tentaclesX + 11',correct
'height / 2',correct
'bodyColor = color(150, 150, 150)',correct
'hans.moveLeft()',correct
'fill(bodyColor);',correct
'ellipse(narwhalX - 60, narwhalY - 30, 15, 15);',correct
'hans.moveRight();',correct
'waterX',correct
'narwhalY - 75',correct
'waterY',correct
'class Score {    int textX;    int textY;    Score() {        textSize(32);        textX = 830;        textY = 50;        score = 0;    }    void display() {        fill(255);        text(score, textX, textY);    }}',correct
'score = score + 1',correct
'int bodyColor;',correct
'narwhalX + 15',correct
'arc(narwhalX - 30, narwhalY, 150, 150, 1.0f * PI, 9)',correct
'hans.shoot();',correct
'fill(255)',correct
'speed',correct
'Processing',correct
'jellyfishX = -100',correct
'jellyfishY = PApplet.parseInt(random(200, 500));',correct
'{    narwhalY = narwhalY + speed;}',correct
'jello.display();',correct
'ellipse(narwhalX - 60, narwhalY - 30, 15, 15)',correct
'jellyfishColor',correct
'points.display();',correct
'boolean shootLaser;',correct
'triangle(narwhalX - 30, narwhalY - 75, narwhalX - 30, narwhalY + 75, narwhalX + 200, narwhalY + 75);',correct
'jellyfishColor = color(jellyfishColorR, jellyfishColorG, jellyfishColorB)',correct
'fill(jellyfishColor)',correct
'false',correct
'text(score, textX, textY);',correct
'{    // defining the jellyfish    stroke(jellyfishColor);    fill(jellyfishColor);    arc(jellyfishX, jellyfishY, 50, 50, PI, 2 * PI);    for (int tentaclesX = jellyfishX - 25; tentaclesX < jellyfishX + 25; tentaclesX = tentaclesX + 11) {        rect(tentaclesX, jellyfishY, 5, 50);    }}',correct
'points = new Score();',correct
'laserX = laserX - 5',correct
'Jellyfish',correct
'jello = new Jellyfish();',correct
'narwhalX + 200',correct
'points = new Score()',correct
'stroke(255)',correct
'shootLaser = true',correct
'PApplet.parseInt(random(255))',correct
'rect(laserX, laserY, 30, 6);',correct
'dist(jellyfishX, jellyfishY, laserX, laserY) < 40',correct
'int score;',correct
'narwhalX = narwhalX + speed',correct
'1.0f',correct
'PApplet.parseInt(random(200, 500))',correct
'{    if (key == w) {        hans.moveUp();    }    if (key == a) {        hans.moveLeft();    }    if (key == s) {        hans.moveDown();    }    if (key == d) {        hans.moveRight();    }}',correct
'jellyfishColorG = PApplet.parseInt(random(255));',correct
'{    textSize(32);    textX = 830;    textY = 50;    score = 0;}',correct
'fill(100, 100, 255)',correct
'text(score, textX, textY)',correct
'void moveDown() {    narwhalY = narwhalY + speed;}',correct
'hans.display();',correct
'-250',correct
'hans.display()',correct
'jello.display()',correct
'rect(tentaclesX, jellyfishY, 5, 50);',correct
'speed = 20',correct
'int tentaclesX;',correct
'Jellyfish() {    jellyfishX = -100;    jellyfishY = PApplet.parseInt(random(200, 500));    // Every Jellyfish will have a different color    jellyfishColorR = PApplet.parseInt(random(0, 255));    jellyfishColorG = PApplet.parseInt(random(255));    jellyfishColorB = PApplet.parseInt(random(255));    jellyfishColor = color(jellyfishColorR, jellyfishColorG, jellyfishColorB);}',correct
'narwhalX > 1150',correct
'narwhalY = narwhalY + speed;',correct
'if (key == a) {    hans.moveLeft();}',correct
'narwhalX = narwhalX - speed;',correct
'{    narwhalX = narwhalX + speed;}',correct
'textSize(32);',correct
'{    narwhalX = -250;}',correct
'narwhalX = narwhalX + speed;',correct
'laserX',correct
'laserY',correct
'laserX = narwhalX - 237',correct
'void moveLeft() {    narwhalX = narwhalX - speed;}',correct
'{    narwhalX = width / 2;    narwhalY = height / 2;    // light grey    bodyColor = color(150, 150, 150);    laserX = narwhalX - 237;    laserY = narwhalY - 48;    speed = 20;}',correct
'score / 5',correct
'hans.shoot()',correct
'// getting shot or stabbed with the hornif (dist(jellyfishX, jellyfishY, laserX, laserY) < 40) {    jellyfishX = -100;    jellyfishY = PApplet.parseInt(random(200, 500));    jellyfishColorR = PApplet.parseInt(random(0, 255));    jellyfishColorG = PApplet.parseInt(random(255));    jellyfishColorB = PApplet.parseInt(random(255));    jellyfishColor = color(jellyfishColorR, jellyfishColorG, jellyfishColorB);    score = score + 1;}',correct
'narwhalY = narwhalY - speed;',correct
'narwhalY - 30',correct
'hans.moveUp();',correct
'jellyfishColorR = PApplet.parseInt(random(0, 255));',correct
'float laserY;',correct
'ocean = new Water()',correct
'tentaclesX = jellyfishX - 25',correct
'narwhalX - speed',correct
'jellyfishColorB',correct
'hans.moveRight()',correct
'key == d',correct
'waterX + 100',correct
'Water() {    waterY = 600;}',correct
'jellyfishColorG',correct
'score = 0;',correct
'jello = new Jellyfish()',correct
'-30',correct
'class Water {    int waterX;    int waterY;    Water() {        waterY = 600;    }    void display() {        // Water        fill(100, 100, 255);        stroke(100, 100, 255);        for (int waterX = 50; waterX < 900; waterX = waterX + 100) {            ellipse(waterX, waterY, 200, 200);        }    }}',correct
'arc(jellyfishX, jellyfishY, 50, 50, PI, 2 * PI)',correct
'narwhalX = 1150;',correct
'{    hans.shoot();}',correct
'key == a',correct
'narwhalX + 235',correct
'{    ellipse(waterX, waterY, 200, 200);}',correct
'key == w',correct
'// bodystroke(bodyColor);',correct
'void interact() {    // making the jellyfish accelerate the higher your score    jellyfishX = jellyfishX + score / 5 + 1;    // getting shot or stabbed with the horn    if (dist(jellyfishX, jellyfishY, laserX, laserY) < 40) {        jellyfishX = -100;        jellyfishY = PApplet.parseInt(random(200, 500));        jellyfishColorR = PApplet.parseInt(random(0, 255));        jellyfishColorG = PApplet.parseInt(random(255));        jellyfishColorB = PApplet.parseInt(random(255));        jellyfishColor = color(jellyfishColorR, jellyfishColorG, jellyfishColorB);        score = score + 1;    }    // resetting the game and score when a jellyfish reaches the end of the screen    if (jellyfishX > 950) {        score = 0;        jellyfishX = -100;        jellyfishY = PApplet.parseInt(random(200, 500));        jellyfishColorR = PApplet.parseInt(random(0, 255));        jellyfishColorG = PApplet.parseInt(random(255));        jellyfishColorB = PApplet.parseInt(random(255));        jellyfishColor = color(jellyfishColorR, jellyfishColorG, jellyfishColorB);    }}',correct
'score = score + 1;',DrawingStateChangeRule
'narwhalY - 48',correct
'{    rect(tentaclesX, jellyfishY, 5, 50);}',correct
'{    // Horn    fill(255);    stroke(255);    rect(narwhalX - 237, narwhalY - 50, 150, 10);    // head    stroke(bodyColor);    fill(bodyColor);    arc(narwhalX - 30, narwhalY, 150, 150, 1.0f * PI, 9);    stroke(0, 0, 0);    fill(0, 0, 0);    ellipse(narwhalX - 60, narwhalY - 30, 15, 15);    // body    stroke(bodyColor);    fill(bodyColor);    triangle(narwhalX - 30, narwhalY - 75, narwhalX - 30, narwhalY + 75, narwhalX + 200, narwhalY + 75);    // Back Fins    triangle(narwhalX + 200, narwhalY + 75, narwhalX + 235, narwhalY + 115, narwhalX + 235, narwhalY + 40);    // Front Fins    triangle(narwhalX - 30, narwhalY + 75, narwhalX + 30, narwhalY + 75, narwhalX + 15, narwhalY + 130);    // Laser    if (shootLaser == true) {        fill(255, 0, 0);        stroke(255, 0, 0);        rect(laserX, laserY, 30, 6);        laserX = laserX - 5;    }    if (laserX <= -30) {        shootLaser = false;    }    if (shootLaser == false) {        laserX = narwhalX - 237;        laserY = narwhalY - 48;    }    // Returning from off screen    if (narwhalX < -250) {        narwhalX = 1150;    }    if (narwhalX > 1150) {        narwhalX = -250;    }}',LongMethodRule
'key == s',correct
'Score points;',correct
'Jellyfish jello;',correct
'narwhalY + speed',correct
'float laserX;',correct
'hans.moveUp()',correct
'// skybluebackground(135, 206, 235);',correct
'ocean.display();',correct
'stroke(jellyfishColor)',correct
'// Front Finstriangle(narwhalX - 30, narwhalY + 75, narwhalX + 30, narwhalY + 75, narwhalX + 15, narwhalY + 130);',correct
'jellyfishX + 25',correct
'display',correct
'float speed;',correct
'new Score()',correct
'draw',correct
'{    hans = new Narwhal();    jello = new Jellyfish();    ocean = new Water();    points = new Score();}',correct
'narwhalY + 115',correct
'{    score = 0;    jellyfishX = -100;    jellyfishY = PApplet.parseInt(random(200, 500));    jellyfishColorR = PApplet.parseInt(random(0, 255));    jellyfishColorG = PApplet.parseInt(random(255));    jellyfishColorB = PApplet.parseInt(random(255));    jellyfishColor = color(jellyfishColorR, jellyfishColorG, jellyfishColorB);}',correct
'random(200, 500)',correct
'stroke(100, 100, 255);',correct
'void mousePressed() {    hans.shoot();}',correct
'ocean.display()',correct
'textX = 830;',correct
'shootLaser = false',correct
'jellyfishColorR',correct
'jellyfishColorG = PApplet.parseInt(random(255))',correct
'rect(tentaclesX, jellyfishY, 5, 50)',correct
'void keyPressed() {    if (key == w) {        hans.moveUp();    }    if (key == a) {        hans.moveLeft();    }    if (key == s) {        hans.moveDown();    }    if (key == d) {        hans.moveRight();    }}',correct
'textX = 830',correct
'laserX <= -30',correct
'narwhalX = width / 2',correct
'narwhalY - 50',correct
'{    narwhalX = narwhalX - speed;}',correct
'narwhalY = narwhalY - speed',correct
'jellyfishX > 950',correct
'if (laserX <= -30) {    shootLaser = false;}',correct
'fill(255, 0, 0)',correct
'jellyfishX = -100;',correct
'shootLaser == false',correct
'narwhalX + speed',correct
'hans.moveDown()',correct
'int jellyfishColorG;',correct
'// Laserif (shootLaser == true) {    fill(255, 0, 0);    stroke(255, 0, 0);    rect(laserX, laserY, 30, 6);    laserX = laserX - 5;}',correct
'points',correct
'shootLaser = true;',correct
'fill(255);',correct
'triangle(narwhalX - 30, narwhalY - 75, narwhalX - 30, narwhalY + 75, narwhalX + 200, narwhalY + 75)',correct
'rect(laserX, laserY, 30, 6)',correct
'hans.moveDown();',correct
'{    hans.moveUp();}',correct
'// Returning from off screenif (narwhalX < -250) {    narwhalX = 1150;}',correct
'{    narwhalY = narwhalY - speed;}',correct
'color(150, 150, 150)',correct
'if (key == w) {    hans.moveUp();}',correct
'fill(jellyfishColor);',correct
'narwhalY + 40',correct
'float narwhalX;',correct
'new Jellyfish()',correct
'void shoot() {    shootLaser = true;}',correct
'void',correct
'narwhalY + 130',correct
'void setup() {    hans = new Narwhal();    jello = new Jellyfish();    ocean = new Water();    points = new Score();}',correct
'jellyfishX + score / 5',correct
'narwhalX - 60',correct
'background(135, 206, 235)',correct
'int jellyfishX;',correct
'{    hans.moveDown();}',correct
'{    jellyfishX = -100;    jellyfishY = PApplet.parseInt(random(200, 500));    // Every Jellyfish will have a different color    jellyfishColorR = PApplet.parseInt(random(0, 255));    jellyfishColorG = PApplet.parseInt(random(255));    jellyfishColorB = PApplet.parseInt(random(255));    jellyfishColor = color(jellyfishColorR, jellyfishColorG, jellyfishColorB);}',correct
'narwhalX = narwhalX - speed',correct
'{    shootLaser = false;}',correct
'true',correct
'stroke(255, 0, 0);',correct
'void display() {    // Horn    fill(255);    stroke(255);    rect(narwhalX - 237, narwhalY - 50, 150, 10);    // head    stroke(bodyColor);    fill(bodyColor);    arc(narwhalX - 30, narwhalY, 150, 150, 1.0f * PI, 9);    stroke(0, 0, 0);    fill(0, 0, 0);    ellipse(narwhalX - 60, narwhalY - 30, 15, 15);    // body    stroke(bodyColor);    fill(bodyColor);    triangle(narwhalX - 30, narwhalY - 75, narwhalX - 30, narwhalY + 75, narwhalX + 200, narwhalY + 75);    // Back Fins    triangle(narwhalX + 200, narwhalY + 75, narwhalX + 235, narwhalY + 115, narwhalX + 235, narwhalY + 40);    // Front Fins    triangle(narwhalX - 30, narwhalY + 75, narwhalX + 30, narwhalY + 75, narwhalX + 15, narwhalY + 130);    // Laser    if (shootLaser == true) {        fill(255, 0, 0);        stroke(255, 0, 0);        rect(laserX, laserY, 30, 6);        laserX = laserX - 5;    }    if (laserX <= -30) {        shootLaser = false;    }    if (shootLaser == false) {        laserX = narwhalX - 237;        laserY = narwhalY - 48;    }    // Returning from off screen    if (narwhalX < -250) {        narwhalX = 1150;    }    if (narwhalX > 1150) {        narwhalX = -250;    }}',correct
'bodyColor',correct
'narwhalX < -250',correct
'int jellyfishColor;',correct
'narwhalX - 30',correct
'stroke(255);',correct
'interact',correct
'ellipse(waterX, waterY, 200, 200);',correct
'int tentaclesX = jellyfishX - 25',correct
'{    narwhalX = 1150;}',correct
'fill(0, 0, 0);',correct
'ellipse(waterX, waterY, 200, 200)',correct
'laserY = narwhalY - 48;',DrawingStateChangeRule
'for (int waterX = 50; waterX < 900; waterX = waterX + 100) {    ellipse(waterX, waterY, 200, 200);}',correct
'{    laserX = narwhalX - 237;    laserY = narwhalY - 48;}',correct
'jello',correct
'tentaclesX',correct
'narwhalX = -250',correct
'void display() {    // defining the jellyfish    stroke(jellyfishColor);    fill(jellyfishColor);    arc(jellyfishX, jellyfishY, 50, 50, PI, 2 * PI);    for (int tentaclesX = jellyfishX - 25; tentaclesX < jellyfishX + 25; tentaclesX = tentaclesX + 11) {        rect(tentaclesX, jellyfishY, 5, 50);    }}',correct
'// Hornfill(255);',correct
'tentaclesX < jellyfishX + 25',correct
'textY = 50',correct
'{    // making the jellyfish accelerate the higher your score    jellyfishX = jellyfishX + score / 5 + 1;    // getting shot or stabbed with the horn    if (dist(jellyfishX, jellyfishY, laserX, laserY) < 40) {        jellyfishX = -100;        jellyfishY = PApplet.parseInt(random(200, 500));        jellyfishColorR = PApplet.parseInt(random(0, 255));        jellyfishColorG = PApplet.parseInt(random(255));        jellyfishColorB = PApplet.parseInt(random(255));        jellyfishColor = color(jellyfishColorR, jellyfishColorG, jellyfishColorB);        score = score + 1;    }    // resetting the game and score when a jellyfish reaches the end of the screen    if (jellyfishX > 950) {        score = 0;        jellyfishX = -100;        jellyfishY = PApplet.parseInt(random(200, 500));        jellyfishColorR = PApplet.parseInt(random(0, 255));        jellyfishColorG = PApplet.parseInt(random(255));        jellyfishColorB = PApplet.parseInt(random(255));        jellyfishColor = color(jellyfishColorR, jellyfishColorG, jellyfishColorB);    }}',correct
'stroke(0, 0, 0);',correct
'void display() {    fill(255);    text(score, textX, textY);}',correct
'ocean = new Water();',correct
'jello.interact();',correct
'stroke(255, 0, 0)',correct
'laserX = narwhalX - 237;',correct
'void moveRight() {    narwhalX = narwhalX + speed;}',correct
'speed = 20;',correct
'hans.moveLeft();',correct
'void display() {    // Water    fill(100, 100, 255);    stroke(100, 100, 255);    for (int waterX = 50; waterX < 900; waterX = waterX + 100) {        ellipse(waterX, waterY, 200, 200);    }}',correct
'{    shootLaser = true;}',correct
'width / 2',correct
'for (int tentaclesX = jellyfishX - 25; tentaclesX < jellyfishX + 25; tentaclesX = tentaclesX + 11) {    rect(tentaclesX, jellyfishY, 5, 50);}',correct
'2 * PI',correct
'class Jellyfish {    int jellyfishX;    int jellyfishY;    int jellyfishColor;    int jellyfishColorR;    int jellyfishColorG;    int jellyfishColorB;    int tentaclesX;    Jellyfish() {        jellyfishX = -100;        jellyfishY = PApplet.parseInt(random(200, 500));        // Every Jellyfish will have a different color        jellyfishColorR = PApplet.parseInt(random(0, 255));        jellyfishColorG = PApplet.parseInt(random(255));        jellyfishColorB = PApplet.parseInt(random(255));        jellyfishColor = color(jellyfishColorR, jellyfishColorG, jellyfishColorB);    }    void display() {        // defining the jellyfish        stroke(jellyfishColor);        fill(jellyfishColor);        arc(jellyfishX, jellyfishY, 50, 50, PI, 2 * PI);        for (int tentaclesX = jellyfishX - 25; tentaclesX < jellyfishX + 25; tentaclesX = tentaclesX + 11) {            rect(tentaclesX, jellyfishY, 5, 50);        }    }    void interact() {        // making the jellyfish accelerate the higher your score        jellyfishX = jellyfishX + score / 5 + 1;        // getting shot or stabbed with the horn        if (dist(jellyfishX, jellyfishY, laserX, laserY) < 40) {            jellyfishX = -100;            jellyfishY = PApplet.parseInt(random(200, 500));            jellyfishColorR = PApplet.parseInt(random(0, 255));            jellyfishColorG = PApplet.parseInt(random(255));            jellyfishColorB = PApplet.parseInt(random(255));            jellyfishColor = color(jellyfishColorR, jellyfishColorG, jellyfishColorB);            score = score + 1;        }        // resetting the game and score when a jellyfish reaches the end of the screen        if (jellyfishX > 950) {            score = 0;            jellyfishX = -100;            jellyfishY = PApplet.parseInt(random(200, 500));            jellyfishColorR = PApplet.parseInt(random(0, 255));            jellyfishColorG = PApplet.parseInt(random(255));            jellyfishColorB = PApplet.parseInt(random(255));            jellyfishColor = color(jellyfishColorR, jellyfishColorG, jellyfishColorB);        }    }}',correct
'// Back Finstriangle(narwhalX + 200, narwhalY + 75, narwhalX + 235, narwhalY + 115, narwhalX + 235, narwhalY + 40);',correct
'narwhalY + 75',correct
'narwhalY = height / 2',correct
'float narwhalY;',correct
'y2 = y1 + dist',correct
'float fenceBarWidth;',correct
'{    // draw the chikens beak    float dist = kipSize / 12;    float x1 = x - dist;    float y1 = y + kipSize / 16;    float y2 = y1 + dist;    float y3 = y1 + dist / 2;    fill(secondColor);    triangle(x1, y3, x, y1, x, y2);}',correct
'fenceBarWidth * 3',correct
'fenceBarWidth * 5',correct
'float dist = kipSize / 12',correct
'fenceBarWidth * 6',correct
'from = color(129, 234, 239)',correct
'rect(x, y, headSizeX, headSizeY, cornerRound);',correct
'float x_1 = x + kipSize / 11',correct
'float angle_;',correct
'rate = 0.001f',correct
'sky = lerpColor(from, to, r)',correct
'float y_3 = height / 5',correct
'Chicken.move();',correct
'x + kipSize / 2',correct
'-rate',correct
'width / 20',correct
'x_3 > width',correct
'println(r)',correct
'legLength = kipSize / 3',correct
'random(0, 256)',correct
'ellipseMode(CORNER)',correct
'x_3 = -1000;',correct
'void display() {    // draws the background, the fence and clouds    // changing background color    int from = color(129, 234, 239);    int to = color(0, 6, 45);    int sky = lerpColor(from, to, r);    r += rate;    println(r);    background(sky);    // looping background color change    if (r > 1 || r < 0) {        rate = -rate;    }    // draws ground    noStroke();    fill(groundColor);    rect(0, y, width, groundHeight);    // draws fence bar    fill(fenceColor);    float y_2 = height / 1.9f;    rect(0, y_2, width, fenceBarWidth);    // draws fenceposts    float y_ = groundHeight + height / 10;    for (float i = 0; i < 20; i++) {        float j = 2 * width / 20 * i;        rect(x_ + j - 100, y_, fenceWidth, fenceHeight);    }    if (x_ > fenceWidth * 2) {        x_ = 0;    }    // draws cloud    float y_3 = height / 5;    float cornerRound = width / 30;    float yAdd = height / 20;    fill(255, 120);    rect(x_2, y_3, fenceWidth * 5, fenceBarWidth * 6, cornerRound);    rect(x_3, y_3 - yAdd, fenceWidth * 8, fenceBarWidth * 5, cornerRound * 2);    rect(x_4, y_3 + yAdd * 3, fenceWidth * 9, fenceBarWidth * 3, cornerRound);    // loop clouds    if (x_2 > width) {        x_2 = -1000;    }    if (x_3 > width) {        x_3 = -1000;    }    if (x_4 > width) {        x_4 = -1000;    }}',TooManyFields
'fenceColor = color(119, 72, 9)',correct
'void displayBody() {    // draw the chickens body    fill(kipColor);    ellipseMode(CORNER);    float y_ = y + kipSize / 9;    arc(x, y_, kipSize, kipSize, 0, PI + QUARTER_PI, OPEN);}',correct
'y3 = y1 + dist / 2',correct
'x_ = x + kipSize / 2.8f',correct
'greenValue = PApplet.parseInt(random(0, 256))',correct
'int eyeColor = color(255);',correct
'translate(x_, y_)',correct
'x = width / 20',correct
'y1 + dist',correct
'width / 20 + width / 9',correct
'float y_ = y + kipSize / 10;',correct
'kipSize',correct
'if (x_3 > width) {    x_3 = -1000;}',correct
'x = initX',correct
'fill(eyeballColor)',correct
'new float[7]',correct
'fill(fenceColor)',correct
'float y_ = y + kipSize',correct
'fenceBarWidth = width / 50',correct
'float x1 = x - dist;',ShortVariable
'kipColor = color(redValue, greenValue, blueValue);',correct
'y = height / 1.6f;',correct
'fenceWidth = width / 20;',correct
'kipColor = color(redValue, greenValue, blueValue)',correct
'Chicken.displayHead();',correct
'speed * 2',correct
'speed * 3',correct
'float headSizeX = kipSize / 4;',correct
'rotate(radians(angle));',correct
'groundHeight + height / 10',correct
'speed * 2.5f * noise(t)',correct
'isOver = true;',correct
'speed = -speed',correct
't',correct
'float y2 = legLength',correct
'y + kipSize / 9',correct
'eyeColor = color(255)',correct
'x',correct
'y',correct
'float kipSize;',correct
'legWidth = kipSize / 40',correct
'float x_ = x + kipSize / 2.8f;',correct
'float x_;',correct
'float footLength = kipSize / 8;',correct
'// move the cloudsx_2 += speed * 2 * noise(t);',correct
'rect(0, y, width, groundHeight);',PixelHardcodeIgnoranceRule
'x + kipSize / 2.8f',correct
'x1 = x - dist',correct
'triangle(x_[3], y, x_[4], y_, x_[5], y);',correct
'-1000',correct
'[7]',correct
'float eyeSize = kipSize / 12',correct
'speed * 3 * noise(t)',correct
'kipSize / 35',correct
'// draw the chikens legspushMatrix();',correct
'boolean isOverKip(float newX, float newY) {    boolean isOver = false;    if (((newX <= x + kipSize) && newX >= x) && ((newY <= y + kipSize) && newY >= y)) {        isOver = true;    }    return isOver;}',correct
'rect(-kipSize / 15, y2, footLength, legWidth);',correct
'x_[i]',correct
'float eyeballSize = kipSize / 35;',correct
'Chicken.displayBeak();',correct
'x_[i - 1]',correct
'float x_1 = x + kipSize / 11;',correct
'rect(x_ + j - 100, y_, fenceWidth, fenceHeight)',correct
'kipSize = initSize',correct
'kipSize / 40',correct
'triangle(x_[1], y, x_[2], y_, x_[3], y);',correct
'2 * width',correct
'float x_ = x + kipSize / 2',correct
'eyeballColor = color(0)',correct
'Countryside = new scenery()',correct
'Chicken.displayLeg2();',correct
'float x;',TooManyFields
'float y_1 = y + kipSize / 11;',correct
'void mousePressed() {    if (Chicken.isOverKip(mouseX, mouseY)) {        Chicken.changeColor();    }}',correct
'float x1 = -kipSize / 50',correct
'Processing',correct
'{    Chicken = new kip(300, 200, 600);    Countryside = new scenery();}',correct
'cornerRound = 40',correct
'float groundHeight;',correct
'pushMatrix()',correct
'x_4 = width / 20 + width / (9 / 5);',correct
'// draws fencepostsfloat y_ = groundHeight + height / 10;',correct
'rect(x_4, y_3 + yAdd * 3, fenceWidth * 9, fenceBarWidth * 3, cornerRound);',correct
'float x1 = -kipSize / 50;',correct
'int from = color(129, 234, 239)',correct
'int redValue = PApplet.parseInt(random(0, 256))',correct
'x_ += speed',correct
'float y;',correct
'false',correct
'color(0, 6, 45)',correct
'Chicken.displayHead()',correct
'float[]',correct
'i < 20',correct
'fill(groundColor)',correct
'int fenceColor;',TooManyFields
'{    Chicken.changeColor();}',correct
'if ((angle > 20) || (angle_ > 20)) {    speed = -speed;}',correct
'cornerRound * 2',correct
'x_ = x;',correct
'{    Countryside.display();    Countryside.move();    Chicken.displayHead();    Chicken.displayEye();    Chicken.displayLeg2();    Chicken.displayBody();    Chicken.displayBeak();    Chicken.displayLeg1();    Chicken.move();}',correct
'int sky = lerpColor(from, to, r);',correct
'i = 1',correct
'i = 0',correct
'fenceBarWidth',correct
'y_3 + yAdd * 3',correct
'secondColor',correct
'rect(x_2, y_3, fenceWidth * 5, fenceBarWidth * 6, cornerRound);',correct
'y = initY',correct
'i - 1',correct
't = 0',correct
'rect(x_3, y_3 - yAdd, fenceWidth * 8, fenceBarWidth * 5, cornerRound * 2)',correct
'x_[3]',correct
'fill(kipColor);',correct
'x_4 = -1000;',correct
'int greenValue = PApplet.parseInt(random(0, 256))',correct
'float x_4;',TooManyFields
'float cornerRound = width / 30',correct
'{    x = initX;    y = initY;    kipSize = initSize;    kipColor = color(235);    secondColor = color(242, 162, 50);    angle = 0;    speed = 1;}',correct
'0.0001f',correct
'int eyeballColor = color(0);',correct
'color(119, 72, 9)',correct
'void displayHead() {    noStroke();    // draw the chikens head    rectMode(CORNER);    float headSizeX = kipSize / 4;    float headSizeY = kipSize / 1.5f;    float cornerRound = 40;    fill(kipColor);    rect(x, y, headSizeX, headSizeY, cornerRound);    // draw the weird thingy on the chickens head    fill(secondColor);    float[] x_ = new float[7];    float y_ = y - kipSize / 15;    for (int i = 1; i < x_.length; i++) {        x_[0] = x + headSizeX / 5;        x_[i] = x_[i - 1] + headSizeX / 9;    }    triangle(x_[1], y, x_[2], y_, x_[3], y);    triangle(x_[2], y, x_[3], y_, x_[4], y);    triangle(x_[3], y, x_[4], y_, x_[5], y);    triangle(x_[4], y, x_[5], y_, x_[6], y);}',correct
'rectMode(CORNER)',correct
'speed * 2.5f',correct
'kipSize / 2',correct
'kipSize / 3',correct
'y_ = y + kipSize',correct
'kipSize / 4',correct
'Countryside.display()',correct
'noStroke();',correct
'x_[4]',correct
'boolean isOver = false;',correct
'float fenceHeight;',correct
'float[] x_ = new float[7]',correct
'y - kipSize / 15',correct
'kipSize / 8',correct
'float x_3;',correct
'kipSize / 9',correct
'y_ = y - kipSize / 15',correct
'float legLength = kipSize / 3',correct
'float yAdd = height / 20;',correct
'x_[0] = x + headSizeX / 5;',correct
'float y2 = y1 + dist',correct
'float t;',ShortVariable
'ellipse(x_1, y_1, eyeballSize, eyeballSize);',correct
'x_[0]',correct
'float x1 = x - dist',correct
'if (((newX <= x + kipSize) && newX >= x) && ((newY <= y + kipSize) && newY >= y)) {    isOver = true;}',correct
'-kipSize / 50',correct
'// draw the chikens eyeellipseMode(CENTER);',correct
'if (Chicken.isOverKip(mouseX, mouseY)) {    Chicken.changeColor();}',correct
'float x_2;',correct
'angle',correct
'angle_ = -angle',correct
'float y2 = legLength;',ShortVariable
'{    boolean isOver = false;    if (((newX <= x + kipSize) && newX >= x) && ((newY <= y + kipSize) && newY >= y)) {        isOver = true;    }    return isOver;}',correct
'Chicken.displayLeg1();',correct
'Countryside.move()',correct
'void move() {    // change the angle of the chickens legs    angle += speed;    angle_ = -angle;    if ((angle > 20) || (angle_ > 20)) {        speed = -speed;    }}',correct
'x_[1]',correct
'-kipSize',correct
'float eyeSize = kipSize / 12;',correct
'color(242, 162, 50)',correct
'Chicken = new kip(300, 200, 600);',correct
'{    x_2 = -1000;}',correct
'headSizeX / 9',correct
'kip(float initX, float initY, float initSize) {    x = initX;    y = initY;    kipSize = initSize;    kipColor = color(235);    secondColor = color(242, 162, 50);    angle = 0;    speed = 1;}',correct
'fenceWidth',correct
'headSizeX / 5',correct
'x_[2]',correct
'fill(eyeColor);',correct
'kipSize / 1.5f',correct
'// draw the chikens beakfloat dist = kipSize / 12;',correct
'// change the angle of the chickens legsangle += speed;',correct
'x_ = 0;',correct
't += 0.0001f',correct
'fill(eyeballColor);',correct
'groundHeight = height - y;',correct
'float eyeballSize = kipSize / 35',correct
'Countryside.display();',correct
'// draws the background, the fence and clouds',correct
'{    rate = -rate;}',correct
'float angle;',correct
'ellipseMode(CENTER)',correct
'// looping background color changeif (r > 1 || r < 0) {    rate = -rate;}',correct
'new scenery()',correct
'color(18, 135, 30)',correct
'int greenValue = PApplet.parseInt(random(0, 256));',correct
'Countryside = new scenery();',correct
'PI + QUARTER_PI',correct
'void',correct
'{    // change the angle of the chickens legs    angle += speed;    angle_ = -angle;    if ((angle > 20) || (angle_ > 20)) {        speed = -speed;    }}',correct
'float r = 0.001f;',TooManyFields
'displayBeak',correct
'headSizeX = kipSize / 4',correct
'rate = -rate;',correct
'scenery() {    y = height / 1.6f;    x = width / 20;    x_ = x;    x_2 = width / 20;    x_3 = width / 20 + width / 9;    x_4 = width / 20 + width / (9 / 5);    groundHeight = height - y;    fenceHeight = height / 5;    fenceWidth = width / 20;    fenceBarWidth = width / 50;    groundColor = color(18, 135, 30);    fenceColor = color(119, 72, 9);    speed = 1;    t = 0;}',correct
'y_3 = height / 5',correct
'eyeballSize = kipSize / 35',correct
'float yAdd = height / 20',correct
'true',correct
'1.5f',correct
'fill(eyeColor)',correct
'y_ = y + kipSize / 10',correct
'y2 = legLength',correct
'fenceHeight',correct
'float rate = 0.001f;',correct
'-kipSize / 15',correct
'popMatrix()',correct
'isOver = true',correct
'((newX <= x + kipSize) && newX >= x) && ((newY <= y + kipSize) && newY >= y)',correct
'float cornerRound = width / 30;',correct
'scenery',correct
'float y1 = y + kipSize / 16',correct
'rotate(radians(angle_))',correct
'height / 10',correct
'y_2 = height / 1.9f',correct
'triangle(x_[1], y, x_[2], y_, x_[3], y)',correct
'x_ = new float[7]',correct
'1.6f',correct
'y1 = y + kipSize / 16',correct
'float j = 2 * width / 20 * i',correct
'background(sky)',correct
'void draw() {    Countryside.display();    Countryside.move();    Chicken.displayHead();    Chicken.displayEye();    Chicken.displayLeg2();    Chicken.displayBody();    Chicken.displayBeak();    Chicken.displayLeg1();    Chicken.move();}',correct
'void changeColor() {    int redValue = PApplet.parseInt(random(0, 256));    int blueValue = PApplet.parseInt(random(0, 256));    int greenValue = PApplet.parseInt(random(0, 256));    kipColor = color(redValue, greenValue, blueValue);}',correct
'// draw the chikens legsfill(secondColor);',correct
'displayLeg2',correct
'for (float i = 0; i < 20; i++) {    float j = 2 * width / 20 * i;    rect(x_ + j - 100, y_, fenceWidth, fenceHeight);}',correct
'x_4 > width',correct
'displayLeg1',correct
'x_3 += speed * 3 * noise(t)',correct
'float j = 2 * width / 20 * i;',ShortVariable
'background(sky);',correct
'height / 20',correct
'fenceColor',correct
'rate = -rate',correct
'angle_ = -angle;',correct
'x_4 = -1000',correct
'x = initX;',correct
'rect(x_4, y_3 + yAdd * 3, fenceWidth * 9, fenceBarWidth * 3, cornerRound)',correct
'j = 2 * width / 20 * i',correct
'rect(-kipSize / 15, y2, footLength, legWidth)',correct
'x_3 = width / 20 + width / 9;',correct
'y_1 = y + kipSize / 11',correct
'float y_ = groundHeight + height / 10',correct
'dist / 2',correct
'float newY',correct
'float newX',correct
'2.5f',correct
'class scenery {    float y;    float x;    float x_;    float x_2;    float x_3;    float x_4;    float groundHeight;    float fenceHeight;    float fenceWidth;    float fenceBarWidth;    int groundColor;    int fenceColor;    float speed;    float t;    float r = 0.001f;    float rate = 0.001f;    scenery() {        y = height / 1.6f;        x = width / 20;        x_ = x;        x_2 = width / 20;        x_3 = width / 20 + width / 9;        x_4 = width / 20 + width / (9 / 5);        groundHeight = height - y;        fenceHeight = height / 5;        fenceWidth = width / 20;        fenceBarWidth = width / 50;        groundColor = color(18, 135, 30);        fenceColor = color(119, 72, 9);        speed = 1;        t = 0;    }    void move() {        // move the fence        x_ += speed;        // move the clouds        x_2 += speed * 2 * noise(t);        x_3 += speed * 3 * noise(t);        x_4 += speed * 2.5f * noise(t);        t += 0.0001f;    }    void display() {        // draws the background, the fence and clouds        // changing background color        int from = color(129, 234, 239);        int to = color(0, 6, 45);        int sky = lerpColor(from, to, r);        r += rate;        println(r);        background(sky);        // looping background color change        if (r > 1 || r < 0) {            rate = -rate;        }        // draws ground        noStroke();        fill(groundColor);        rect(0, y, width, groundHeight);        // draws fence bar        fill(fenceColor);        float y_2 = height / 1.9f;        rect(0, y_2, width, fenceBarWidth);        // draws fenceposts        float y_ = groundHeight + height / 10;        for (float i = 0; i < 20; i++) {            float j = 2 * width / 20 * i;            rect(x_ + j - 100, y_, fenceWidth, fenceHeight);        }        if (x_ > fenceWidth * 2) {            x_ = 0;        }        // draws cloud        float y_3 = height / 5;        float cornerRound = width / 30;        float yAdd = height / 20;        fill(255, 120);        rect(x_2, y_3, fenceWidth * 5, fenceBarWidth * 6, cornerRound);        rect(x_3, y_3 - yAdd, fenceWidth * 8, fenceBarWidth * 5, cornerRound * 2);        rect(x_4, y_3 + yAdd * 3, fenceWidth * 9, fenceBarWidth * 3, cornerRound);        // loop clouds        if (x_2 > width) {            x_2 = -1000;        }        if (x_3 > width) {            x_3 = -1000;        }        if (x_4 > width) {            x_4 = -1000;        }    }}',correct
'fill(255, 120)',correct
'fill(secondColor);',correct
'// draw the chikens headrectMode(CORNER);',correct
'pushMatrix();',correct
'angle_',correct
'x_2',correct
'x_4',correct
'x_3',correct
'headSizeY = kipSize / 1.5f',correct
'// draw the chickens bodyfill(kipColor);',correct
'triangle(x_[2], y, x_[3], y_, x_[4], y);',correct
'x_3 = -1000',correct
'x_4 = width / 20 + width / (9 / 5)',correct
'y = height / 1.6f',correct
'// draw the weird thingy on the chickens headfill(secondColor);',correct
'float y_ = y + kipSize / 10',correct
'speed * 2 * noise(t)',correct
'// loop cloudsif (x_2 > width) {    x_2 = -1000;}',correct
'{    // draws the background, the fence and clouds    // changing background color    int from = color(129, 234, 239);    int to = color(0, 6, 45);    int sky = lerpColor(from, to, r);    r += rate;    println(r);    background(sky);    // looping background color change    if (r > 1 || r < 0) {        rate = -rate;    }    // draws ground    noStroke();    fill(groundColor);    rect(0, y, width, groundHeight);    // draws fence bar    fill(fenceColor);    float y_2 = height / 1.9f;    rect(0, y_2, width, fenceBarWidth);    // draws fenceposts    float y_ = groundHeight + height / 10;    for (float i = 0; i < 20; i++) {        float j = 2 * width / 20 * i;        rect(x_ + j - 100, y_, fenceWidth, fenceHeight);    }    if (x_ > fenceWidth * 2) {        x_ = 0;    }    // draws cloud    float y_3 = height / 5;    float cornerRound = width / 30;    float yAdd = height / 20;    fill(255, 120);    rect(x_2, y_3, fenceWidth * 5, fenceBarWidth * 6, cornerRound);    rect(x_3, y_3 - yAdd, fenceWidth * 8, fenceBarWidth * 5, cornerRound * 2);    rect(x_4, y_3 + yAdd * 3, fenceWidth * 9, fenceBarWidth * 3, cornerRound);    // loop clouds    if (x_2 > width) {        x_2 = -1000;    }    if (x_3 > width) {        x_3 = -1000;    }    if (x_4 > width) {        x_4 = -1000;    }}',LongMethodRule
'x_ + j - 100',correct
'Chicken',correct
'1.9f',correct
'void displayLeg1() {    // draw the chikens legs    pushMatrix();    float x_ = x + kipSize / 2.8f;    float y_ = y + kipSize;    translate(x_, y_);    rotate(radians(angle));    float x1 = -kipSize / 50;    float y1 = kipSize + kipSize / 2;    float legWidth = kipSize / 40;    float legLength = kipSize / 3;    float footLength = kipSize / 8;    float y2 = legLength;    rect(0, 0, legWidth, legLength);    rect(-kipSize / 15, y2, footLength, legWidth);    popMatrix();}',correct
'kipSize / 2.8f',correct
'fenceWidth = width / 20',correct
'groundColor = color(18, 135, 30)',correct
'int to = color(0, 6, 45);',correct
'{    // draw the chickens body    fill(kipColor);    ellipseMode(CORNER);    float y_ = y + kipSize / 9;    arc(x, y_, kipSize, kipSize, 0, PI + QUARTER_PI, OPEN);}',correct
'class kip {    float x;    float y;    float kipSize;    int kipColor;    int secondColor;    float angle;    float angle_;    float speed;    kip(float initX, float initY, float initSize) {        x = initX;        y = initY;        kipSize = initSize;        kipColor = color(235);        secondColor = color(242, 162, 50);        angle = 0;        speed = 1;    }    void move() {        // change the angle of the chickens legs        angle += speed;        angle_ = -angle;        if ((angle > 20) || (angle_ > 20)) {            speed = -speed;        }    }    void displayHead() {        noStroke();        // draw the chikens head        rectMode(CORNER);        float headSizeX = kipSize / 4;        float headSizeY = kipSize / 1.5f;        float cornerRound = 40;        fill(kipColor);        rect(x, y, headSizeX, headSizeY, cornerRound);        // draw the weird thingy on the chickens head        fill(secondColor);        float[] x_ = new float[7];        float y_ = y - kipSize / 15;        for (int i = 1; i < x_.length; i++) {            x_[0] = x + headSizeX / 5;            x_[i] = x_[i - 1] + headSizeX / 9;        }        triangle(x_[1], y, x_[2], y_, x_[3], y);        triangle(x_[2], y, x_[3], y_, x_[4], y);        triangle(x_[3], y, x_[4], y_, x_[5], y);        triangle(x_[4], y, x_[5], y_, x_[6], y);    }    void displayEye() {        // draw the chikens eye        ellipseMode(CENTER);        int eyeColor = color(255);        int eyeballColor = color(0);        float eyeSize = kipSize / 12;        float eyeballSize = kipSize / 35;        float x_ = x + kipSize / 10;        float y_ = y + kipSize / 10;        float x_1 = x + kipSize / 11;        float y_1 = y + kipSize / 11;        fill(eyeColor);        ellipse(x_, y_, eyeSize, eyeSize);        fill(eyeballColor);        ellipse(x_1, y_1, eyeballSize, eyeballSize);    }    void displayBody() {        // draw the chickens body        fill(kipColor);        ellipseMode(CORNER);        float y_ = y + kipSize / 9;        arc(x, y_, kipSize, kipSize, 0, PI + QUARTER_PI, OPEN);    }    void displayBeak() {        // draw the chikens beak        float dist = kipSize / 12;        float x1 = x - dist;        float y1 = y + kipSize / 16;        float y2 = y1 + dist;        float y3 = y1 + dist / 2;        fill(secondColor);        triangle(x1, y3, x, y1, x, y2);    }    void displayLeg1() {        // draw the chikens legs        pushMatrix();        float x_ = x + kipSize / 2.8f;        float y_ = y + kipSize;        translate(x_, y_);        rotate(radians(angle));        float x1 = -kipSize / 50;        float y1 = kipSize + kipSize / 2;        float legWidth = kipSize / 40;        float legLength = kipSize / 3;        float footLength = kipSize / 8;        float y2 = legLength;        rect(0, 0, legWidth, legLength);        rect(-kipSize / 15, y2, footLength, legWidth);        popMatrix();    }    void displayLeg2() {        // draw the chikens legs        fill(secondColor);        pushMatrix();        float x_ = x + kipSize / 2;        float y_ = y + kipSize;        translate(x_, y_);        rotate(radians(angle_));        float x1 = -kipSize / 50;        float y1 = kipSize + kipSize / 2;        float legWidth = kipSize / 40;        float legLength = kipSize / 3;        float footLength = kipSize / 8;        float y2 = legLength;        rect(0, 0, legWidth, legLength);        rect(-kipSize / 15, y2, footLength, legWidth);        popMatrix();    }    void changeColor() {        int redValue = PApplet.parseInt(random(0, 256));        int blueValue = PApplet.parseInt(random(0, 256));        int greenValue = PApplet.parseInt(random(0, 256));        kipColor = color(redValue, greenValue, blueValue);    }    boolean isOverKip(float newX, float newY) {        boolean isOver = false;        if (((newX <= x + kipSize) && newX >= x) && ((newY <= y + kipSize) && newY >= y)) {            isOver = true;        }        return isOver;    }}',correct
'// draws fence barfill(fenceColor);',correct
'lerpColor(from, to, r)',correct
'{    // draw the chikens eye    ellipseMode(CENTER);    int eyeColor = color(255);    int eyeballColor = color(0);    float eyeSize = kipSize / 12;    float eyeballSize = kipSize / 35;    float x_ = x + kipSize / 10;    float y_ = y + kipSize / 10;    float x_1 = x + kipSize / 11;    float y_1 = y + kipSize / 11;    fill(eyeColor);    ellipse(x_, y_, eyeSize, eyeSize);    fill(eyeballColor);    ellipse(x_1, y_1, eyeballSize, eyeballSize);}',correct
'x_ = 0',correct
'float initSize',correct
'Chicken.displayEye()',correct
'float y3 = y1 + dist / 2',correct
'int eyeballColor = color(0)',correct
'PApplet.parseInt(random(0, 256))',correct
'height / 1.6f',correct
'void displayLeg2() {    // draw the chikens legs    fill(secondColor);    pushMatrix();    float x_ = x + kipSize / 2;    float y_ = y + kipSize;    translate(x_, y_);    rotate(radians(angle_));    float x1 = -kipSize / 50;    float y1 = kipSize + kipSize / 2;    float legWidth = kipSize / 40;    float legLength = kipSize / 3;    float footLength = kipSize / 8;    float y2 = legLength;    rect(0, 0, legWidth, legLength);    rect(-kipSize / 15, y2, footLength, legWidth);    popMatrix();}',correct
'angle += speed',correct
'x_2 = width / 20;',correct
'ellipse(x_, y_, eyeSize, eyeSize);',correct
'float cornerRound = 40;',correct
'float y2 = y1 + dist;',correct
'{    // move the fence    x_ += speed;    // move the clouds    x_2 += speed * 2 * noise(t);    x_3 += speed * 3 * noise(t);    x_4 += speed * 2.5f * noise(t);    t += 0.0001f;}',correct
'float y1 = kipSize + kipSize / 2;',correct
'popMatrix();',correct
'float[] x_ = new float[7];',correct
'x_ = x + kipSize / 2',correct
'height - y',correct
'rect(0, 0, legWidth, legLength);',correct
'r > 1',correct
'rect(x_ + j - 100, y_, fenceWidth, fenceHeight);',correct
'float y_2 = height / 1.9f;',correct
'r += rate',correct
'new kip(300, 200, 600)',correct
'2.8f',correct
'float headSizeX = kipSize / 4',correct
'noStroke()',correct
'color(235)',correct
'y_3 - yAdd',correct
'int sky = lerpColor(from, to, r)',correct
'int groundColor;',TooManyFields
'groundColor = color(18, 135, 30);',correct
'fill(255, 120);',correct
'{    noStroke();    // draw the chikens head    rectMode(CORNER);    float headSizeX = kipSize / 4;    float headSizeY = kipSize / 1.5f;    float cornerRound = 40;    fill(kipColor);    rect(x, y, headSizeX, headSizeY, cornerRound);    // draw the weird thingy on the chickens head    fill(secondColor);    float[] x_ = new float[7];    float y_ = y - kipSize / 15;    for (int i = 1; i < x_.length; i++) {        x_[0] = x + headSizeX / 5;        x_[i] = x_[i - 1] + headSizeX / 9;    }    triangle(x_[1], y, x_[2], y_, x_[3], y);    triangle(x_[2], y, x_[3], y_, x_[4], y);    triangle(x_[3], y, x_[4], y_, x_[5], y);    triangle(x_[4], y, x_[5], y_, x_[6], y);}',correct
'-angle',correct
'x_[i] = x_[i - 1] + headSizeX / 9',correct
'x_ = x',correct
'isOver = false',correct
'// move the fencex_ += speed;',correct
'{    // draw the chikens legs    pushMatrix();    float x_ = x + kipSize / 2.8f;    float y_ = y + kipSize;    translate(x_, y_);    rotate(radians(angle));    float x1 = -kipSize / 50;    float y1 = kipSize + kipSize / 2;    float legWidth = kipSize / 40;    float legLength = kipSize / 3;    float footLength = kipSize / 8;    float y2 = legLength;    rect(0, 0, legWidth, legLength);    rect(-kipSize / 15, y2, footLength, legWidth);    popMatrix();}',correct
'float y_ = y + kipSize / 9',correct
'rect(x, y, headSizeX, headSizeY, cornerRound)',correct
'Chicken.changeColor();',correct
'if (x_4 > width) {    x_4 = -1000;}',correct
'int to = color(0, 6, 45)',correct
'float y_ = y + kipSize;',correct
'secondColor = color(242, 162, 50)',correct
'speed = -speed;',correct
'rect(0, 0, legWidth, legLength)',correct
'color(redValue, greenValue, blueValue)',correct
'Chicken.displayLeg2()',correct
'y + kipSize',correct
'{    isOver = true;}',correct
'x_ = x + kipSize / 10',correct
'height / 5',correct
'Countryside',correct
'kipSize = initSize;',correct
'float y3 = y1 + dist / 2;',correct
'int eyeColor = color(255)',correct
'y + kipSize / 16',correct
'y + kipSize / 10',correct
'ellipse(x_, y_, eyeSize, eyeSize)',correct
'y + kipSize / 11',correct
'x_1 = x + kipSize / 11',correct
'x_4 += speed * 2.5f * noise(t);',correct
'height / 1.9f',correct
'{    x_[0] = x + headSizeX / 5;    x_[i] = x_[i - 1] + headSizeX / 9;}',correct
'r < 0',correct
'float i = 0',correct
'int blueValue = PApplet.parseInt(random(0, 256))',correct
'speed',correct
'float y_ = y - kipSize / 15',correct
'groundHeight = height - y',correct
'kip Chicken;',correct
'redValue = PApplet.parseInt(random(0, 256))',correct
'kip',correct
'rect(x_2, y_3, fenceWidth * 5, fenceBarWidth * 6, cornerRound)',correct
'float footLength = kipSize / 8',correct
'{    int redValue = PApplet.parseInt(random(0, 256));    int blueValue = PApplet.parseInt(random(0, 256));    int greenValue = PApplet.parseInt(random(0, 256));    kipColor = color(redValue, greenValue, blueValue);}',correct
'kipColor = color(235);',correct
'triangle(x_[4], y, x_[5], y_, x_[6], y)',correct
'arc(x, y_, kipSize, kipSize, 0, PI + QUARTER_PI, OPEN);',correct
'x_[5]',correct
'float y_ = y - kipSize / 15;',correct
'// draws groundnoStroke();',correct
'y1 + dist / 2',correct
'secondColor = color(242, 162, 50);',correct
'(angle > 20) || (angle_ > 20)',correct
'void move() {    // move the fence    x_ += speed;    // move the clouds    x_2 += speed * 2 * noise(t);    x_3 += speed * 3 * noise(t);    x_4 += speed * 2.5f * noise(t);    t += 0.0001f;}',TooManyFields
'rect(0, y_2, width, fenceBarWidth)',correct
'triangle(x_[2], y, x_[3], y_, x_[4], y)',correct
'x_',correct
'Countryside.move();',correct
'void displayBeak() {    // draw the chikens beak    float dist = kipSize / 12;    float x1 = x - dist;    float y1 = y + kipSize / 16;    float y2 = y1 + dist;    float y3 = y1 + dist / 2;    fill(secondColor);    triangle(x1, y3, x, y1, x, y2);}',correct
'triangle(x1, y3, x, y1, x, y2);',correct
'Chicken.displayLeg1()',correct
'int i = 1',correct
'x_ + j',correct
'boolean isOver = false',correct
'void displayEye() {    // draw the chikens eye    ellipseMode(CENTER);    int eyeColor = color(255);    int eyeballColor = color(0);    float eyeSize = kipSize / 12;    float eyeballSize = kipSize / 35;    float x_ = x + kipSize / 10;    float y_ = y + kipSize / 10;    float x_1 = x + kipSize / 11;    float y_1 = y + kipSize / 11;    fill(eyeColor);    ellipse(x_, y_, eyeSize, eyeSize);    fill(eyeballColor);    ellipse(x_1, y_1, eyeballSize, eyeballSize);}',correct
'x_[i - 1] + headSizeX / 9',correct
'x_[6]',correct
'int blueValue = PApplet.parseInt(random(0, 256));',correct
'Chicken = new kip(300, 200, 600)',correct
'float headSizeY = kipSize / 1.5f;',correct
'y = initY;',correct
'triangle(x_[4], y, x_[5], y_, x_[6], y);',correct
'color(255)',correct
'float x_ = x + kipSize / 10',correct
'x1 = -kipSize / 50',correct
'ellipse(x_1, y_1, eyeballSize, eyeballSize)',correct
'Chicken.displayEye();',correct
'float legWidth = kipSize / 40',correct
'x_[0] = x + headSizeX / 5',correct
'eyeSize = kipSize / 12',correct
'kipSize / 10',correct
'fenceBarWidth = width / 50;',correct
'kipSize / 11',correct
'return isOver;',correct
'kipSize / 12',correct
'r += rate;',correct
'yAdd * 3',correct
'fenceHeight = height / 5;',correct
'fenceHeight = height / 5',correct
'fenceWidth * 8',correct
'fenceWidth * 5',correct
'fill(groundColor);',correct
'fenceWidth * 2',correct
'kipColor = color(235)',correct
'x + kipSize / 11',correct
'x + kipSize / 10',correct
'float x_ = x + kipSize / 2;',correct
't = 0;',correct
'fenceWidth * 9',correct
'groundHeight',correct
'float y_ = y + kipSize / 9;',correct
'rect(0, y, width, groundHeight)',correct
'int secondColor;',correct
'rect(x_3, y_3 - yAdd, fenceWidth * 8, fenceBarWidth * 5, cornerRound * 2);',correct
'speed = 1;',correct
'Chicken.displayBeak()',correct
'println(r);',correct
'kipColor',correct
'noise(t)',correct
'kipSize + kipSize / 2',correct
'x_2 = -1000;',correct
'float legLength = kipSize / 3;',correct
'{    y = height / 1.6f;    x = width / 20;    x_ = x;    x_2 = width / 20;    x_3 = width / 20 + width / 9;    x_4 = width / 20 + width / (9 / 5);    groundHeight = height - y;    fenceHeight = height / 5;    fenceWidth = width / 20;    fenceBarWidth = width / 50;    groundColor = color(18, 135, 30);    fenceColor = color(119, 72, 9);    speed = 1;    t = 0;}',correct
't += 0.0001f;',correct
'float y1 = y + kipSize / 16;',correct
'void setup() {    Chicken = new kip(300, 200, 600);    Countryside = new scenery();}',correct
'2 * width / 20 * i',correct
'color(0)',correct
'width / 20 + width / (9 / 5)',correct
'{    if (Chicken.isOverKip(mouseX, mouseY)) {        Chicken.changeColor();    }}',correct
'Chicken.displayBody();',correct
'x_[i] = x_[i - 1] + headSizeX / 9;',correct
'fill(kipColor)',correct
'kipSize / 15',correct
'display',LongMethodRule
'kipSize / 16',correct
'float speed;',correct
'-speed',correct
'y1 = kipSize + kipSize / 2',correct
'dist = kipSize / 12',correct
'{    x_3 = -1000;}',correct
'{    x_4 = -1000;}',correct
'x - dist',correct
'displayEye',correct
'x_2 = -1000',correct
'Chicken.displayBody()',correct
'ellipseMode(CORNER);',correct
'color(129, 234, 239)',correct
'x_ > fenceWidth * 2',correct
'i < x_.length',correct
'cornerRound = width / 30',correct
'angle = 0',correct
'x_2 > width',correct
'float x_ = x + kipSize / 10;',correct
'{    speed = -speed;}',correct
'triangle(x1, y3, x, y1, x, y2)',correct
'for (int i = 1; i < x_.length; i++) {    x_[0] = x + headSizeX / 5;    x_[i] = x_[i - 1] + headSizeX / 9;}',correct
'float initX',correct
'float initY',correct
'width / 50',correct
'i++',correct
'x_3 += speed * 3 * noise(t);',correct
'Chicken.isOverKip(mouseX, mouseY)',correct
'int kipColor;',correct
'to = color(0, 6, 45)',correct
'width / (9 / 5)',correct
'blueValue = PApplet.parseInt(random(0, 256))',correct
'float y1 = kipSize + kipSize / 2',correct
'x_4 += speed * 2.5f * noise(t)',correct
'radians(angle)',correct
'x = width / 20;',correct
'displayBody',correct
'float legWidth = kipSize / 40;',correct
'arc(x, y_, kipSize, kipSize, 0, PI + QUARTER_PI, OPEN)',correct
'translate(x_, y_);',correct
'y_ = y + kipSize / 9',correct
'Chicken.move()',correct
'x_2 += speed * 2 * noise(t)',correct
'fill(secondColor)',correct
'speed = 1',correct
'footLength = kipSize / 8',correct
'x_2 = width / 20',correct
'{    // draw the chikens legs    fill(secondColor);    pushMatrix();    float x_ = x + kipSize / 2;    float y_ = y + kipSize;    translate(x_, y_);    rotate(radians(angle_));    float x1 = -kipSize / 50;    float y1 = kipSize + kipSize / 2;    float legWidth = kipSize / 40;    float legLength = kipSize / 3;    float footLength = kipSize / 8;    float y2 = legLength;    rect(0, 0, legWidth, legLength);    rect(-kipSize / 15, y2, footLength, legWidth);    popMatrix();}',correct
'fenceColor = color(119, 72, 9);',correct
'{    float j = 2 * width / 20 * i;    rect(x_ + j - 100, y_, fenceWidth, fenceHeight);}',correct
'if (x_ > fenceWidth * 2) {    x_ = 0;}',correct
'{    x_ = 0;}',correct
'radians(angle_)',correct
'r = 0.001f',correct
'rect(0, y_2, width, fenceBarWidth);',correct
'int redValue = PApplet.parseInt(random(0, 256));',correct
'Chicken.changeColor()',correct
'yAdd = height / 20',correct
'width / 30',correct
'float fenceWidth;',correct
'0.001f',correct
'rotate(radians(angle_));',correct
'angle = 0;',correct
'groundColor',correct
'rotate(radians(angle))',correct
'x_.length',correct
'move',correct
'x + headSizeX / 5',correct
'// draws the background, the fence and clouds// changing background colorint from = color(129, 234, 239);',correct
'float x_ = x + kipSize / 2.8f',correct
'// draws cloudfloat y_3 = height / 5;',correct
'triangle(x_[3], y, x_[4], y_, x_[5], y)',correct
'displayHead',correct
'y_ = groundHeight + height / 10',correct
'float y_2 = height / 1.9f',correct
'float cornerRound = 40',correct
'scenery Countryside;',correct
'2 * width / 20',correct
'float y_1 = y + kipSize / 11',correct
'r > 1 || r < 0',correct
'x_3 = width / 20 + width / 9',correct
'width / 9',correct
'float headSizeY = kipSize / 1.5f',correct
'mousinY',correct
'mousinX',correct
'ellipse(mousuX - 15, mousuY + 5, 20, 20)',correct
'{    mousinX = initX;    mousinY = initY;}',correct
'a2.drawmousin()',correct
'mousuY - 35',correct
'new mousi1()',correct
'ellipse(mousuX + 20, mousuY + 30, 50, 20);',correct
'mousuX + 10',correct
'ellipse(mousuX, mousuY - 25, 10, 10)',correct
'mousuX + 15',correct
'ellipse(mousinX, mousinY + 30, 30, 30);',correct
'ellipse(i * 100, height / 4, 50, 50)',correct
'ellipse(mousinX, mousinY, 60, 50);',correct
'a2 = new mousin(100, 100)',correct
'line(mousi1X - 15, mousi1Y + 15, mousi1X, mousi1Y - 5)',correct
'ellipse(mousuX - 20, mousuY + 70, 20, 50)',correct
'{}',correct
'if (show_kid) {    a1.drawmousin();}',correct
'// headfill(50, 255, 50);',correct
'mousi1Y - 20',correct
'stroke(0);',correct
'mousi1X + 15',correct
'stroke(0)',correct
'void mouseClicked() {    if (dist(mouseX, mouseY, 300, 200) < 10) {        show_kid = true;    }    if (dist(mouseX, mouseY, 300, 200) < 20) {        show_kid2 = true;    }    c2.mousuClicked(mouseX, mouseY);}',correct
'{    // clout    stroke(255);    fill(255);    ellipse(i * 100, height / 4, 50, 50);    ellipse(i * 100 + 25, height / 4, 35, 35);    ellipse(i * 100 - 25, height / 4, 35, 35);}',correct
'mousinX + 20',correct
'ellipse(mousinX + 10, mousinY - 10, 10, 10);',correct
'background(140, 140, 250);',correct
'mousi1X + 10',correct
'show_kid2 = true',correct
'{    for (int i = 0; i < 5; i = i + 1) {        // clout        stroke(255);        fill(255);        ellipse(i * 100, height / 4, 50, 50);        ellipse(i * 100 + 25, height / 4, 35, 35);        ellipse(i * 100 - 25, height / 4, 35, 35);    }}',correct
'{    background(140, 140, 250);    show_kid = false;    show_kid2 = false;}',correct
'int mousi1X = 300;',correct
'mousi1Y + 5',correct
'line(mousuX - 15, mousuY + 15, mousuX, mousuY - 5)',correct
'fill(50, 255, 50)',correct
'drawmousi1',LongMethodRule
'ellipse(mousuX, mousuY, 20, 10);',correct
';',EmptyStatementNotInLoop
'mousi1Y - 10',correct
'// cloutstroke(255);',correct
'int mousuX = 100;',correct
'fill(255, 0, 0);',correct
'mousinX + 15',correct
'mousinX + 10',correct
'stroke(255, 100, 100)',correct
'ellipse(mousuX, mousuY - 25, 10, 10);',correct
'ellipse(mousuX - 15, mousuY + 5, 20, 20);',correct
'stroke(bodyColor)',correct
'mousi1X + 20',correct
'fill(0);',correct
'ellipse(mousuX, mousuY, 50, 40)',correct
'ellipse(mousi1X + 20, mousi1Y + 30, 50, 20);',correct
'if (show_kid2) {    a2.drawmousin();}',correct
'mousinX = initX',correct
'line(mousinX + 15, mousinY + 15, mousinX, mousinY - 5)',correct
'ellipse(mousi1X - 20, mousi1Y - 20, 20, 20);',correct
'triangle(mousuX + 5, mousuY - 25, mousuX + 15, mousuY - 35, mousuX + 15, mousuY - 15);',correct
'fill(0, 0, 255);',correct
'ellipse(mousuX - 20, mousuY + 70, 20, 50);',correct
'ellipse(mousuX, mousuY + 50, 70, 70)',correct
'mousuX = 100',correct
'ellipse(mousinX + 10, mousinY - 10, 10, 10)',correct
'mousu() {}',correct
'triangle(mousuX + 5, mousuY - 25, mousuX + 15, mousuY - 35, mousuX + 15, mousuY - 15)',correct
'show_kid = true;',correct
'ellipse(mousuX + 20, mousuY + 30, 50, 20)',correct
'int initY',correct
'class mousi1 {    int mousi1X = 300;    int mousi1Y = 200;    int bodyColor;    mousi1() {    }    void drawmousi1() {        // body        stroke(bodyColor);        fill(bodyColor);        ellipse(mousi1X, mousi1Y + 50, 70, 70);        ellipse(mousi1X - 20, mousi1Y + 70, 20, 50);        ellipse(mousi1X + 20, mousi1Y + 70, 20, 50);        ellipse(mousi1X - 20, mousi1Y + 30, 50, 20);        ellipse(mousi1X + 20, mousi1Y + 30, 50, 20);        fill(255);        ellipse(mousi1X, mousi1Y + 50, 55, 55);        fill(0, 0, 255);        // <>//        // head        fill(bodyColor);        ellipse(mousi1X, mousi1Y, 60, 50);        ellipse(mousi1X + 20, mousi1Y - 20, 20, 20);        ellipse(mousi1X - 20, mousi1Y - 20, 20, 20);        fill(255);        ellipse(mousi1X, mousi1Y, 50, 40);        fill(255, 0, 0);        ellipse(mousi1X + 15, mousi1Y + 5, 20, 20);        ellipse(mousi1X - 15, mousi1Y + 5, 20, 20);        stroke(0);        line(mousi1X - 15, mousi1Y + 15, mousi1X, mousi1Y - 5);        line(mousi1X + 15, mousi1Y + 15, mousi1X, mousi1Y - 5);        fill(0);        ellipse(mousi1X - 10, mousi1Y - 10, 10, 10);        ellipse(mousi1X + 10, mousi1Y - 10, 10, 10);        fill(255, 100, 100);        ellipse(mousi1X, mousi1Y, 20, 10);    }}',correct
'i * 100 + 25',correct
'mousuY = 200',correct
'ellipse(mousi1X - 20, mousi1Y + 30, 50, 20)',correct
'mousinY = initY;',correct
'int initX',correct
'ellipse(mousinX - 20, mousinY + 30, 25, 15);',correct
'ellipse(mousuX - 10, mousuY - 10, 10, 10);',correct
'triangle(mousuX - 5, mousuY - 25, mousuX - 15, mousuY - 35, mousuX - 15, mousuY - 15);',correct
'ellipse(mousi1X + 10, mousi1Y - 10, 10, 10)',correct
'drawmousu',LongMethodRule
'void draw() {    background(140, 140, 250);    c.drawclout();    b1.drawmousi1();    c2.drawmousu();    if (show_kid) {        a1.drawmousin();    }    if (show_kid2) {        a2.drawmousin();    }}',correct
'ellipse(mousuX - 20, mousuY + 30, 50, 20)',correct
'{    mousuX = X;    mousuY = Y;}',correct
'ellipse(mousuX, mousuY, 60, 50)',correct
'class clout {    clout() {    }    void drawclout() {        for (int i = 0; i < 5; i = i + 1) {            // clout            stroke(255);            fill(255);            ellipse(i * 100, height / 4, 50, 50);            ellipse(i * 100 + 25, height / 4, 35, 35);            ellipse(i * 100 - 25, height / 4, 35, 35);        }    }}',correct
'mousu',correct
'mousinX - 15',correct
'ellipse(i * 100 + 25, height / 4, 35, 35);',correct
'void drawmousi1() {    // body    stroke(bodyColor);    fill(bodyColor);    ellipse(mousi1X, mousi1Y + 50, 70, 70);    ellipse(mousi1X - 20, mousi1Y + 70, 20, 50);    ellipse(mousi1X + 20, mousi1Y + 70, 20, 50);    ellipse(mousi1X - 20, mousi1Y + 30, 50, 20);    ellipse(mousi1X + 20, mousi1Y + 30, 50, 20);    fill(255);    ellipse(mousi1X, mousi1Y + 50, 55, 55);    fill(0, 0, 255);    // <>//    // head    fill(bodyColor);    ellipse(mousi1X, mousi1Y, 60, 50);    ellipse(mousi1X + 20, mousi1Y - 20, 20, 20);    ellipse(mousi1X - 20, mousi1Y - 20, 20, 20);    fill(255);    ellipse(mousi1X, mousi1Y, 50, 40);    fill(255, 0, 0);    ellipse(mousi1X + 15, mousi1Y + 5, 20, 20);    ellipse(mousi1X - 15, mousi1Y + 5, 20, 20);    stroke(0);    line(mousi1X - 15, mousi1Y + 15, mousi1X, mousi1Y - 5);    line(mousi1X + 15, mousi1Y + 15, mousi1X, mousi1Y - 5);    fill(0);    ellipse(mousi1X - 10, mousi1Y - 10, 10, 10);    ellipse(mousi1X + 10, mousi1Y - 10, 10, 10);    fill(255, 100, 100);    ellipse(mousi1X, mousi1Y, 20, 10);}',correct
'ellipse(mousuX - 20, mousuY - 20, 20, 20)',correct
'mousuX = X;',correct
'ellipse(mousuX + 20, mousuY + 70, 20, 50)',correct
'ellipse(mousinX + 20, mousinY - 20, 20, 20);',correct
'ellipse(mousinX - 20, mousinY - 20, 20, 20);',correct
'line(mousinX - 15, mousinY + 15, mousinX, mousinY - 5);',correct
'i + 1',correct
'show_kid2 = false;',correct
'ellipse(mousi1X - 10, mousi1Y - 10, 10, 10)',correct
'mousinX - 20',correct
'ellipse(mousinX, mousinY, 20, 10);',correct
'mousuY + 50',correct
'ellipse(i * 100 - 25, height / 4, 35, 35)',correct
'ellipse(mousi1X, mousi1Y + 50, 55, 55)',correct
'ellipse(mousinX + 20, mousinY - 20, 20, 20)',correct
'mousinY = initY',correct
'fill(bodyColor)',correct
'mousu c2 = new mousu();',ShortVariable
'show_kid2',correct
'ellipse(mousi1X + 20, mousi1Y - 20, 20, 20)',correct
'ellipse(mousinX + 15, mousinY + 50, 15, 25)',correct
'ellipse(mousinX - 15, mousinY + 50, 15, 25);',correct
'mousi1Y = 200',correct
'ellipse(mousi1X, mousi1Y, 60, 50);',correct
'fill(0)',correct
'ellipse(mousinX, mousinY, 50, 40);',correct
'mousi1Y - 5',correct
'mousin',correct
'height / 4',correct
'new mousin(100, 100)',correct
'fill(bodyColor);',correct
'ellipse(mousuX, mousuY, 60, 50);',correct
'stroke(50, 255, 50)',correct
'ellipse(mousi1X + 20, mousi1Y + 30, 50, 20)',correct
'mousinX - 10',correct
'ellipse(mousi1X + 20, mousi1Y - 20, 20, 20);',correct
'ellipse(mousi1X + 20, mousi1Y + 70, 20, 50);',correct
'c2.mousuClicked(mouseX, mouseY);',correct
'ellipse(mousinX - 20, mousinY - 20, 20, 20)',correct
'ellipse(i * 100, height / 4, 50, 50);',correct
'new mousu()',correct
'clout() {}',StatelessClassRule
'boolean show_kid2;',correct
'ellipse(mousi1X - 20, mousi1Y + 70, 20, 50);',correct
'class mousin {    int mousinX;    int mousinY;    mousin(int initX, int initY) {        mousinX = initX;        mousinY = initY;    }    void drawmousin() {        // body        fill(50, 255, 50);        stroke(50, 255, 50);        ellipse(mousinX, mousinY + 30, 50, 50);        ellipse(mousinX - 15, mousinY + 50, 15, 25);        ellipse(mousinX + 15, mousinY + 50, 15, 25);        ellipse(mousinX - 20, mousinY + 30, 25, 15);        ellipse(mousinX + 20, mousinY + 30, 25, 15);        fill(255);        ellipse(mousinX, mousinY + 30, 30, 30);        // head        fill(50, 255, 50);        ellipse(mousinX, mousinY, 60, 50);        ellipse(mousinX + 20, mousinY - 20, 20, 20);        ellipse(mousinX - 20, mousinY - 20, 20, 20);        fill(255);        ellipse(mousinX, mousinY, 50, 40);        fill(255, 0, 0);        ellipse(mousinX + 15, mousinY + 5, 20, 20);        ellipse(mousinX - 15, mousinY + 5, 20, 20);        stroke(0);        line(mousinX - 15, mousinY + 15, mousinX, mousinY - 5);        line(mousinX + 15, mousinY + 15, mousinX, mousinY - 5);        fill(0);        ellipse(mousinX - 10, mousinY - 10, 10, 10);        ellipse(mousinX + 10, mousinY - 10, 10, 10);        fill(255, 100, 100);        ellipse(mousinX, mousinY, 20, 10);    }}',correct
'mousuY - 15',correct
'int bodyColor;',correct
'ellipse(mousinX + 20, mousinY + 30, 25, 15)',correct
'dist(mouseX, mouseY, 300, 200)',correct
'boolean show_kid;',correct
'new mousin(200, 200)',correct
'ellipse(mousi1X, mousi1Y + 50, 55, 55);',correct
'mousinY + 5',correct
'fill(255)',correct
'line(mousi1X + 15, mousi1Y + 15, mousi1X, mousi1Y - 5);',correct
'i < 5',correct
'ellipse(mousi1X - 20, mousi1Y + 70, 20, 50)',correct
'Processing',correct
'b1.drawmousi1()',correct
'show_kid = true',correct
'c.drawclout()',correct
'a1 = new mousin(200, 200)',correct
'if (dist(mouseX, mouseY, 300, 200) < 20) {    show_kid2 = true;}',correct
'c2 = new mousu()',correct
'mousuY - 10',correct
'void mousuClicked(int X, int Y) {    mousuX = X;    mousuY = Y;}',correct
'mousinY + 15',correct
'mousuY + 70',correct
'line(mousi1X + 15, mousi1Y + 15, mousi1X, mousi1Y - 5)',correct
'{    a1.drawmousin();}',correct
'{    // body    stroke(bodyColor);    fill(bodyColor);    ellipse(mousi1X, mousi1Y + 50, 70, 70);    ellipse(mousi1X - 20, mousi1Y + 70, 20, 50);    ellipse(mousi1X + 20, mousi1Y + 70, 20, 50);    ellipse(mousi1X - 20, mousi1Y + 30, 50, 20);    ellipse(mousi1X + 20, mousi1Y + 30, 50, 20);    fill(255);    ellipse(mousi1X, mousi1Y + 50, 55, 55);    fill(0, 0, 255);    // <>//    // head    fill(bodyColor);    ellipse(mousi1X, mousi1Y, 60, 50);    ellipse(mousi1X + 20, mousi1Y - 20, 20, 20);    ellipse(mousi1X - 20, mousi1Y - 20, 20, 20);    fill(255);    ellipse(mousi1X, mousi1Y, 50, 40);    fill(255, 0, 0);    ellipse(mousi1X + 15, mousi1Y + 5, 20, 20);    ellipse(mousi1X - 15, mousi1Y + 5, 20, 20);    stroke(0);    line(mousi1X - 15, mousi1Y + 15, mousi1X, mousi1Y - 5);    line(mousi1X + 15, mousi1Y + 15, mousi1X, mousi1Y - 5);    fill(0);    ellipse(mousi1X - 10, mousi1Y - 10, 10, 10);    ellipse(mousi1X + 10, mousi1Y - 10, 10, 10);    fill(255, 100, 100);    ellipse(mousi1X, mousi1Y, 20, 10);}',LongMethodRule
'ellipse(mousuX - 10, mousuY - 10, 10, 10)',correct
'{    ;    // body    stroke(255, 100, 100);    fill(255, 100, 100);    ellipse(mousuX, mousuY + 50, 70, 70);    ellipse(mousuX - 20, mousuY + 70, 20, 50);    ellipse(mousuX + 20, mousuY + 70, 20, 50);    ellipse(mousuX - 20, mousuY + 30, 50, 20);    ellipse(mousuX + 20, mousuY + 30, 50, 20);    fill(255);    ellipse(mousuX, mousuY + 50, 55, 55);    // head    fill(255, 100, 100);    ellipse(mousuX, mousuY, 60, 50);    ellipse(mousuX + 20, mousuY - 20, 20, 20);    ellipse(mousuX - 20, mousuY - 20, 20, 20);    fill(255);    ellipse(mousuX, mousuY, 50, 40);    fill(255, 0, 0);    ellipse(mousuX + 15, mousuY + 5, 20, 20);    ellipse(mousuX - 15, mousuY + 5, 20, 20);    stroke(0);    line(mousuX - 15, mousuY + 15, mousuX, mousuY - 5);    line(mousuX + 15, mousuY + 15, mousuX, mousuY - 5);    fill(0);    ellipse(mousuX - 10, mousuY - 10, 10, 10);    ellipse(mousuX + 10, mousuY - 10, 10, 10);    fill(255, 100, 100);    ellipse(mousuX, mousuY, 20, 10);    fill(255, 0, 0);    ellipse(mousuX, mousuY - 25, 10, 10);    triangle(mousuX + 5, mousuY - 25, mousuX + 15, mousuY - 35, mousuX + 15, mousuY - 15);    triangle(mousuX - 5, mousuY - 25, mousuX - 15, mousuY - 35, mousuX - 15, mousuY - 15);}',LongMethodRule
'mousinY + 30',correct
'line(mousuX + 15, mousuY + 15, mousuX, mousuY - 5);',correct
'mousuY - 25',correct
'b1 = new mousi1()',correct
'false',correct
'ellipse(mousuX + 10, mousuY - 10, 10, 10)',correct
'ellipse(mousinX + 15, mousinY + 50, 15, 25);',correct
'int i = 0',correct
'{    // body    fill(50, 255, 50);    stroke(50, 255, 50);    ellipse(mousinX, mousinY + 30, 50, 50);    ellipse(mousinX - 15, mousinY + 50, 15, 25);    ellipse(mousinX + 15, mousinY + 50, 15, 25);    ellipse(mousinX - 20, mousinY + 30, 25, 15);    ellipse(mousinX + 20, mousinY + 30, 25, 15);    fill(255);    ellipse(mousinX, mousinY + 30, 30, 30);    // head    fill(50, 255, 50);    ellipse(mousinX, mousinY, 60, 50);    ellipse(mousinX + 20, mousinY - 20, 20, 20);    ellipse(mousinX - 20, mousinY - 20, 20, 20);    fill(255);    ellipse(mousinX, mousinY, 50, 40);    fill(255, 0, 0);    ellipse(mousinX + 15, mousinY + 5, 20, 20);    ellipse(mousinX - 15, mousinY + 5, 20, 20);    stroke(0);    line(mousinX - 15, mousinY + 15, mousinX, mousinY - 5);    line(mousinX + 15, mousinY + 15, mousinX, mousinY - 5);    fill(0);    ellipse(mousinX - 10, mousinY - 10, 10, 10);    ellipse(mousinX + 10, mousinY - 10, 10, 10);    fill(255, 100, 100);    ellipse(mousinX, mousinY, 20, 10);}',LongMethodRule
'mousuX + 5',correct
'stroke(255)',correct
'mousuY - 20',correct
'// bodystroke(255, 100, 100);',correct
'mousi1',correct
'c = new clout()',correct
'mousuY + 15',correct
'{    show_kid = true;}',correct
'i = 0',correct
'line(mousinX + 15, mousinY + 15, mousinX, mousinY - 5);',correct
'c2.mousuClicked(mouseX, mouseY)',correct
'mousi1X = 300',correct
'ellipse(mousi1X, mousi1Y, 60, 50)',correct
'background(140, 140, 250)',correct
'mousi1X - 20',correct
'mousuX = X',correct
'a2.drawmousin();',correct
'ellipse(mousuX + 10, mousuY - 10, 10, 10);',correct
'mousin a1 = new mousin(200, 200);',ShortVariable
'ellipse(mousi1X + 20, mousi1Y + 70, 20, 50)',correct
'ellipse(i * 100 - 25, height / 4, 35, 35);',correct
'ellipse(mousi1X, mousi1Y, 50, 40);',correct
'line(mousinX - 15, mousinY + 15, mousinX, mousinY - 5)',correct
'i * 100 - 25',correct
'ellipse(mousi1X, mousi1Y, 20, 10);',correct
'ellipse(mousi1X, mousi1Y, 50, 40)',correct
'mousinY + 50',correct
'ellipse(mousuX, mousuY + 50, 55, 55)',correct
'mousuX - 20',correct
'ellipse(mousuX - 20, mousuY + 30, 50, 20);',correct
'void drawmousu() {    ;    // body    stroke(255, 100, 100);    fill(255, 100, 100);    ellipse(mousuX, mousuY + 50, 70, 70);    ellipse(mousuX - 20, mousuY + 70, 20, 50);    ellipse(mousuX + 20, mousuY + 70, 20, 50);    ellipse(mousuX - 20, mousuY + 30, 50, 20);    ellipse(mousuX + 20, mousuY + 30, 50, 20);    fill(255);    ellipse(mousuX, mousuY + 50, 55, 55);    // head    fill(255, 100, 100);    ellipse(mousuX, mousuY, 60, 50);    ellipse(mousuX + 20, mousuY - 20, 20, 20);    ellipse(mousuX - 20, mousuY - 20, 20, 20);    fill(255);    ellipse(mousuX, mousuY, 50, 40);    fill(255, 0, 0);    ellipse(mousuX + 15, mousuY + 5, 20, 20);    ellipse(mousuX - 15, mousuY + 5, 20, 20);    stroke(0);    line(mousuX - 15, mousuY + 15, mousuX, mousuY - 5);    line(mousuX + 15, mousuY + 15, mousuX, mousuY - 5);    fill(0);    ellipse(mousuX - 10, mousuY - 10, 10, 10);    ellipse(mousuX + 10, mousuY - 10, 10, 10);    fill(255, 100, 100);    ellipse(mousuX, mousuY, 20, 10);    fill(255, 0, 0);    ellipse(mousuX, mousuY - 25, 10, 10);    triangle(mousuX + 5, mousuY - 25, mousuX + 15, mousuY - 35, mousuX + 15, mousuY - 15);    triangle(mousuX - 5, mousuY - 25, mousuX - 15, mousuY - 35, mousuX - 15, mousuY - 15);}',correct
'class mousu {    int mousuX = 100;    int mousuY = 200;    mousu() {    }    void drawmousu() {        ;        // body        stroke(255, 100, 100);        fill(255, 100, 100);        ellipse(mousuX, mousuY + 50, 70, 70);        ellipse(mousuX - 20, mousuY + 70, 20, 50);        ellipse(mousuX + 20, mousuY + 70, 20, 50);        ellipse(mousuX - 20, mousuY + 30, 50, 20);        ellipse(mousuX + 20, mousuY + 30, 50, 20);        fill(255);        ellipse(mousuX, mousuY + 50, 55, 55);        // head        fill(255, 100, 100);        ellipse(mousuX, mousuY, 60, 50);        ellipse(mousuX + 20, mousuY - 20, 20, 20);        ellipse(mousuX - 20, mousuY - 20, 20, 20);        fill(255);        ellipse(mousuX, mousuY, 50, 40);        fill(255, 0, 0);        ellipse(mousuX + 15, mousuY + 5, 20, 20);        ellipse(mousuX - 15, mousuY + 5, 20, 20);        stroke(0);        line(mousuX - 15, mousuY + 15, mousuX, mousuY - 5);        line(mousuX + 15, mousuY + 15, mousuX, mousuY - 5);        fill(0);        ellipse(mousuX - 10, mousuY - 10, 10, 10);        ellipse(mousuX + 10, mousuY - 10, 10, 10);        fill(255, 100, 100);        ellipse(mousuX, mousuY, 20, 10);        fill(255, 0, 0);        ellipse(mousuX, mousuY - 25, 10, 10);        triangle(mousuX + 5, mousuY - 25, mousuX + 15, mousuY - 35, mousuX + 15, mousuY - 15);        triangle(mousuX - 5, mousuY - 25, mousuX - 15, mousuY - 35, mousuX - 15, mousuY - 15);    }    void mousuClicked(int X, int Y) {        mousuX = X;        mousuY = Y;    }}',correct
'ellipse(mousuX + 20, mousuY - 20, 20, 20);',correct
'ellipse(i * 100 + 25, height / 4, 35, 35)',correct
'{    a2.drawmousin();}',correct
'ellipse(mousuX + 20, mousuY + 70, 20, 50);',correct
'ellipse(mousinX, mousinY, 20, 10)',correct
'ellipse(mousinX - 15, mousinY + 50, 15, 25)',correct
'ellipse(mousuX + 15, mousuY + 5, 20, 20);',correct
'mousuY + 5',correct
'mousinY - 5',correct
'ellipse(mousi1X - 20, mousi1Y - 20, 20, 20)',correct
'int mousinX;',correct
'mousuX - 10',correct
'ellipse(mousinX, mousinY + 30, 50, 50);',correct
'c2.drawmousu();',correct
'mousuX - 15',correct
'show_kid',correct
'// bodystroke(bodyColor);',correct
'mousi1() {}',UncommentedEmptyConstructor
'// bodyfill(50, 255, 50);',correct
'mousuY + 30',correct
'new clout()',correct
'ellipse(mousinX - 20, mousinY + 30, 25, 15)',correct
'show_kid2 = false',correct
'show_kid2 = true;',correct
'mousi1 b1 = new mousi1();',correct
'mousinY - 10',correct
'clout c = new clout();',ShortVariable
'show_kid = false',correct
'show_kid = false;',correct
'line(mousuX - 15, mousuY + 15, mousuX, mousuY - 5);',correct
'ellipse(mousi1X + 15, mousi1Y + 5, 20, 20)',correct
'i = i + 1',correct
'int mousinY;',correct
'{    show_kid2 = true;}',correct
'c2.drawmousu()',correct
'mousuX - 5',correct
'ellipse(mousi1X - 15, mousi1Y + 5, 20, 20)',correct
'ellipse(mousinX - 10, mousinY - 10, 10, 10)',correct
'ellipse(mousuX + 20, mousuY - 20, 20, 20)',correct
'drawclout',correct
'mousi1Y + 15',correct
'ellipse(mousinX, mousinY, 50, 40)',correct
'a1.drawmousin();',correct
'ellipse(mousi1X - 10, mousi1Y - 10, 10, 10);',correct
'fill(0, 0, 255)',correct
'mousi1Y + 50',correct
'fill(255, 0, 0)',correct
'// <>//// headfill(bodyColor);',correct
'mousinY - 20',correct
'mousin(int initX, int initY) {    mousinX = initX;    mousinY = initY;}',correct
'// headfill(255, 100, 100);',correct
'{    if (dist(mouseX, mouseY, 300, 200) < 10) {        show_kid = true;    }    if (dist(mouseX, mouseY, 300, 200) < 20) {        show_kid2 = true;    }    c2.mousuClicked(mouseX, mouseY);}',correct
'fill(255, 100, 100);',correct
'ellipse(mousi1X, mousi1Y, 20, 10)',correct
'ellipse(mousi1X, mousi1Y + 50, 70, 70)',correct
'fill(255);',correct
'dist(mouseX, mouseY, 300, 200) < 10',correct
'c.drawclout();',correct
'int Y',correct
'ellipse(mousuX, mousuY + 50, 55, 55);',correct
'ellipse(mousinX, mousinY + 30, 30, 30)',correct
'ellipse(mousi1X, mousi1Y + 50, 70, 70);',correct
'int X',correct
'ellipse(mousinX, mousinY, 60, 50)',correct
'mousin a2 = new mousin(100, 100);',ShortVariable
'ellipse(mousuX, mousuY + 50, 70, 70);',correct
'line(mousuX + 15, mousuY + 15, mousuX, mousuY - 5)',correct
'void',correct
'void drawclout() {    for (int i = 0; i < 5; i = i + 1) {        // clout        stroke(255);        fill(255);        ellipse(i * 100, height / 4, 50, 50);        ellipse(i * 100 + 25, height / 4, 35, 35);        ellipse(i * 100 - 25, height / 4, 35, 35);    }}',StatelessClassRule
'ellipse(mousuX + 15, mousuY + 5, 20, 20)',correct
'ellipse(mousi1X - 15, mousi1Y + 5, 20, 20);',correct
'int mousuY = 200;',correct
'// <>//',correct
'b1.drawmousi1();',correct
'dist(mouseX, mouseY, 300, 200) < 20',correct
'ellipse(mousinX, mousinY + 30, 50, 50)',correct
'true',correct
'mousuY = Y;',correct
'mousuY = Y',correct
'{    background(140, 140, 250);    c.drawclout();    b1.drawmousi1();    c2.drawmousu();    if (show_kid) {        a1.drawmousin();    }    if (show_kid2) {        a2.drawmousin();    }}',correct
'mousi1Y + 30',correct
'mousi1Y + 70',correct
'triangle(mousuX - 5, mousuY - 25, mousuX - 15, mousuY - 35, mousuX - 15, mousuY - 15)',correct
'bodyColor',correct
'mousuY - 5',correct
'void drawmousin() {    // body    fill(50, 255, 50);    stroke(50, 255, 50);    ellipse(mousinX, mousinY + 30, 50, 50);    ellipse(mousinX - 15, mousinY + 50, 15, 25);    ellipse(mousinX + 15, mousinY + 50, 15, 25);    ellipse(mousinX - 20, mousinY + 30, 25, 15);    ellipse(mousinX + 20, mousinY + 30, 25, 15);    fill(255);    ellipse(mousinX, mousinY + 30, 30, 30);    // head    fill(50, 255, 50);    ellipse(mousinX, mousinY, 60, 50);    ellipse(mousinX + 20, mousinY - 20, 20, 20);    ellipse(mousinX - 20, mousinY - 20, 20, 20);    fill(255);    ellipse(mousinX, mousinY, 50, 40);    fill(255, 0, 0);    ellipse(mousinX + 15, mousinY + 5, 20, 20);    ellipse(mousinX - 15, mousinY + 5, 20, 20);    stroke(0);    line(mousinX - 15, mousinY + 15, mousinX, mousinY - 5);    line(mousinX + 15, mousinY + 15, mousinX, mousinY - 5);    fill(0);    ellipse(mousinX - 10, mousinY - 10, 10, 10);    ellipse(mousinX + 10, mousinY - 10, 10, 10);    fill(255, 100, 100);    ellipse(mousinX, mousinY, 20, 10);}',correct
'ellipse(mousi1X + 15, mousi1Y + 5, 20, 20);',correct
'ellipse(mousinX - 10, mousinY - 10, 10, 10);',correct
'ellipse(mousinX - 15, mousinY + 5, 20, 20);',correct
'if (dist(mouseX, mouseY, 300, 200) < 10) {    show_kid = true;}',correct
'a1.drawmousin()',correct
'stroke(50, 255, 50);',correct
'ellipse(mousinX + 20, mousinY + 30, 25, 15);',correct
'void setup() {    background(140, 140, 250);    show_kid = false;    show_kid2 = false;}',correct
'int mousi1Y = 200;',correct
'ellipse(mousi1X + 10, mousi1Y - 10, 10, 10);',correct
'ellipse(mousuX, mousuY, 20, 10)',correct
'line(mousi1X - 15, mousi1Y + 15, mousi1X, mousi1Y - 5);',correct
'ellipse(mousinX + 15, mousinY + 5, 20, 20)',correct
'ellipse(mousuX, mousuY, 50, 40);',correct
'clout',StatelessClassRule
'mousinX = initX;',correct
'mousi1X - 10',correct
'fill(255, 100, 100)',correct
'ellipse(mousinX + 15, mousinY + 5, 20, 20);',correct
'ellipse(mousuX - 20, mousuY - 20, 20, 20);',correct
'i * 100',correct
'mousi1X - 15',correct
'ellipse(mousinX - 15, mousinY + 5, 20, 20)',correct
'mousuX + 20',correct
'ellipse(mousi1X - 20, mousi1Y + 30, 50, 20);',correct
'drawmousin',LongMethodRule
'random(width)',correct
'{    pinkbearA[i] = new Pinkbear(random(width), random(height));}',correct
'arc(monsterx + 43, monstery - 72, 20, 20, 100, 300)',correct
'line(monsterx - 6, monstery - 47, monsterx + 6, monstery - 47);',correct
'leftArm = new Arm(monsterx - 45, monstery, 1);',correct
'monstery + 90',correct
'textSize(40);',correct
'// ears// pinkfill(0xffEA78F2);',correct
'class Arm {    float monsterx;    float monstery;    float angularSpeed;    float angle;    Arm(float initX, float initY, float initAngularSpeed) {        monsterx = initX;        monstery = initY;        angularSpeed = initAngularSpeed;    }    void display() {        fill(0xffEA78F2);        pushMatrix();        translate(monsterx, monstery);        if (mousePressed) {            rotate(radians(angle));        }        ellipse(0, 0, 100, 35);        popMatrix();        angle = (angle + angularSpeed) % 50;    }    void updateMonsterPosition(float initX, float initY) {        monsterx = initX;        monstery = initY;    }}',correct
'translate(monsterx, monstery);',correct
'monsterx + 6',correct
'random(-2, 2)',correct
'// arms',correct
'monsterx < 0',correct
'translate(monsterx, monstery)',correct
'{    speedY = -3;}',correct
'pushMatrix();',correct
'// mouth',correct
'monstery - 100',correct
'monstery - 47',correct
'{    speedY = 1;}',correct
'fill(0xffEA78F2);',correct
'random(1)',correct
'speedY = 1;',correct
'Arm',correct
'{    background(0);    fill(255);    textSize(40);    text("Keep the mouse pressed to say hello to Pinkbear!", 30, 35);    for (int i = 0; i < pinkbearA.length; i++) {        pinkbearA[i].display();        pinkbearA[i].updatePosition();    }}',correct
'leftArm.updateMonsterPosition(monsterx - 45, monstery)',correct
'// By Robbert-Jan BerkenbosPinkbear[] pinkbearA = new Pinkbear[14];',correct
'void setup() {    for (int i = 0; i < pinkbearA.length; i++) {        pinkbearA[i] = new Pinkbear(random(width), random(height));    }}',correct
'{    for (int i = 0; i < pinkbearA.length; i++) {        pinkbearA[i] = new Pinkbear(random(width), random(height));    }}',correct
'// blackfill(0);',correct
'text("Keep the mouse pressed to say hello to Pinkbear!", 30, 35)',correct
'ellipse(0, 0, 100, 35);',correct
'if (mousePressed) {    rotate(radians(angle));}',correct
'pinkbearA.length',correct
'rect(monsterx, monstery, 100, 130);',correct
'rectMode(CENTER)',correct
'stroke(1);',correct
'pinkbearA[i].display();',correct
'rightArm = new Arm(monsterx + 45, monstery, -1)',correct
'random(height)',correct
'triangle(monsterx + 50, monstery - 64, monsterx - 50, monstery - 64, monsterx, monstery - 100)',correct
'ellipse(monsterx, monstery + 60, 100, 90);',correct
'rotate(radians(angle));',correct
'popMatrix();',correct
'strokeWeight(2);',correct
'pinkbearA[i].display()',correct
'rightArm = new Arm(monsterx + 45, monstery, -1);',correct
'[14]',correct
'// head// pinkfill(0xffEA78F2);',correct
'speedX = 1',correct
'rectMode(CENTER);',correct
'monsterx + 30',correct
'monsterx + speedX',correct
'noStroke()',correct
'// eye// whitefill(255);',correct
'void display() {    fill(0xffEA78F2);    pushMatrix();    translate(monsterx, monstery);    if (mousePressed) {        rotate(radians(angle));    }    ellipse(0, 0, 100, 35);    popMatrix();    angle = (angle + angularSpeed) % 50;}',correct
'// By Robbert-Jan Berkenbos',correct
'monstery = monstery + speedY;',correct
'monstery + speedY',correct
'monsterx + 45',correct
'monsterx + 43',correct
'speedY = -3;',correct
'monstery = initY',correct
'// body// pinkfill(0xffEA78F2);',correct
'ellipse(monsterx - 30, monstery + 90, 40, 40);',correct
'Pinkbear(float initX, float initY) {    monsterx = initX;    monstery = initY;    leftArm = new Arm(monsterx - 45, monstery, 1);    rightArm = new Arm(monsterx + 45, monstery, -1);}',correct
'monsterx = initX;',correct
'pinkbearA[i].updatePosition()',correct
'// feet// dark pinkfill(0xffE868F0);',correct
'fill(0)',correct
'monstery + 60',correct
'if (monstery < 0) {    speedY = 1;}',correct
'ellipse(monsterx, monstery - 80, 30, 40);',correct
'leftArm.display()',correct
'monsterx + 50',correct
'rightArm.updateMonsterPosition(monsterx + 45, monstery)',correct
'new Arm(monsterx - 45, monstery, 1)',correct
'i < pinkbearA.length',correct
'angularSpeed = initAngularSpeed;',correct
'rightArm',correct
'{    monsterx = initX;    monstery = initY;}',correct
'fill(255)',correct
'Processing',correct
'for (int i = 0; i < pinkbearA.length; i++) {    pinkbearA[i] = new Pinkbear(random(width), random(height));}',correct
'ellipse(monsterx, monstery - 80, 12, 12)',correct
'angle = (angle + angularSpeed) % 50',correct
'pushMatrix()',correct
'leftArm.updateMonsterPosition(monsterx - 45, monstery);',correct
'Pinkbear',correct
'float speedY = random(1);',correct
'rightArm.updateMonsterPosition(monsterx + 45, monstery);',correct
'rightArm.display()',correct
'new Pinkbear(random(width), random(height))',correct
'monsterx = monsterx + speedX',correct
'{    pinkbearA[i].display();    pinkbearA[i].updatePosition();}',correct
'float initAngularSpeed',correct
'int i = 0',correct
'{    fill(0xffEA78F2);    pushMatrix();    translate(monsterx, monstery);    if (mousePressed) {        rotate(radians(angle));    }    ellipse(0, 0, 100, 35);    popMatrix();    angle = (angle + angularSpeed) % 50;}',correct
'leftArm = new Arm(monsterx - 45, monstery, 1)',correct
'speedY = random(1)',correct
'rightArm.display();',correct
'i = 0',correct
'ellipse(monsterx + 30, monstery + 90, 40, 40);',correct
'void display() {    noStroke();    // body    // pink    fill(0xffEA78F2);    rectMode(CENTER);    rect(monsterx, monstery, 100, 130);    // head    // pink    fill(0xffEA78F2);    triangle(monsterx + 50, monstery - 64, monsterx - 50, monstery - 64, monsterx, monstery - 100);    // ass    // pink    fill(0xffEA78F2);    ellipse(monsterx, monstery + 60, 100, 90);    // ears    // pink    fill(0xffEA78F2);    arc(monsterx - 43, monstery - 72, 20, 20, 100, 300);    arc(monsterx + 43, monstery - 72, 20, 20, 100, 300);    // arms    // pink    leftArm.display();    rightArm.display();    // mouth    // dark pink    fill(0xffE868F0);    ellipse(monsterx, monstery - 47, 17, 15);    // feet    // dark pink    fill(0xffE868F0);    ellipse(monsterx - 30, monstery + 90, 40, 40);    ellipse(monsterx + 30, monstery + 90, 40, 40);    // eye    // white    fill(255);    ellipse(monsterx, monstery - 80, 30, 40);    // black    fill(0);    ellipse(monsterx, monstery - 80, 12, 12);    stroke(1);    strokeWeight(2);    line(monsterx - 6, monstery - 47, monsterx + 6, monstery - 47);}',correct
'monsterx > width',correct
'if (monsterx > width) {    speedX = -1;}',correct
'rect(monsterx, monstery, 100, 130)',correct
'text("Keep the mouse pressed to say hello to Pinkbear!", 30, 35);',correct
'speedX = 1;',correct
'background(0)',correct
'float monstery;',correct
'arc(monsterx + 43, monstery - 72, 20, 20, 100, 300);',correct
'new Pinkbear[14]',correct
'monsterx += random(-2, 2)',correct
'ellipse(monsterx, monstery - 80, 30, 40)',correct
'monstery += random(-1, 1)',correct
'fill(0xffEA78F2)',correct
'monstery',correct
'monsterx',correct
'(angle + angularSpeed) % 50',correct
'speedX = -1;',correct
'pinkbearA[i].updatePosition();',correct
'void draw() {    background(0);    fill(255);    textSize(40);    text("Keep the mouse pressed to say hello to Pinkbear!", 30, 35);    for (int i = 0; i < pinkbearA.length; i++) {        pinkbearA[i].display();        pinkbearA[i].updatePosition();    }}',correct
'{    noStroke();    // body    // pink    fill(0xffEA78F2);    rectMode(CENTER);    rect(monsterx, monstery, 100, 130);    // head    // pink    fill(0xffEA78F2);    triangle(monsterx + 50, monstery - 64, monsterx - 50, monstery - 64, monsterx, monstery - 100);    // ass    // pink    fill(0xffEA78F2);    ellipse(monsterx, monstery + 60, 100, 90);    // ears    // pink    fill(0xffEA78F2);    arc(monsterx - 43, monstery - 72, 20, 20, 100, 300);    arc(monsterx + 43, monstery - 72, 20, 20, 100, 300);    // arms    // pink    leftArm.display();    rightArm.display();    // mouth    // dark pink    fill(0xffE868F0);    ellipse(monsterx, monstery - 47, 17, 15);    // feet    // dark pink    fill(0xffE868F0);    ellipse(monsterx - 30, monstery + 90, 40, 40);    ellipse(monsterx + 30, monstery + 90, 40, 40);    // eye    // white    fill(255);    ellipse(monsterx, monstery - 80, 30, 40);    // black    fill(0);    ellipse(monsterx, monstery - 80, 12, 12);    stroke(1);    strokeWeight(2);    line(monsterx - 6, monstery - 47, monsterx + 6, monstery - 47);}',correct
'noStroke();',correct
'float monsterx;',correct
'monsterx - 30',correct
'class Pinkbear {    float monsterx;    float monstery;    float speedX = random(1);    float speedY = random(1);    Arm leftArm;    Arm rightArm;    Pinkbear(float initX, float initY) {        monsterx = initX;        monstery = initY;        leftArm = new Arm(monsterx - 45, monstery, 1);        rightArm = new Arm(monsterx + 45, monstery, -1);    }    void display() {        noStroke();        // body        // pink        fill(0xffEA78F2);        rectMode(CENTER);        rect(monsterx, monstery, 100, 130);        // head        // pink        fill(0xffEA78F2);        triangle(monsterx + 50, monstery - 64, monsterx - 50, monstery - 64, monsterx, monstery - 100);        // ass        // pink        fill(0xffEA78F2);        ellipse(monsterx, monstery + 60, 100, 90);        // ears        // pink        fill(0xffEA78F2);        arc(monsterx - 43, monstery - 72, 20, 20, 100, 300);        arc(monsterx + 43, monstery - 72, 20, 20, 100, 300);        // arms        // pink        leftArm.display();        rightArm.display();        // mouth        // dark pink        fill(0xffE868F0);        ellipse(monsterx, monstery - 47, 17, 15);        // feet        // dark pink        fill(0xffE868F0);        ellipse(monsterx - 30, monstery + 90, 40, 40);        ellipse(monsterx + 30, monstery + 90, 40, 40);        // eye        // white        fill(255);        ellipse(monsterx, monstery - 80, 30, 40);        // black        fill(0);        ellipse(monsterx, monstery - 80, 12, 12);        stroke(1);        strokeWeight(2);        line(monsterx - 6, monstery - 47, monsterx + 6, monstery - 47);    }    void updatePosition() {        leftArm.updateMonsterPosition(monsterx - 45, monstery);        rightArm.updateMonsterPosition(monsterx + 45, monstery);        monsterx += random(-2, 2);        monstery += random(-1, 1);        monsterx = monsterx + speedX;        if (monsterx > width) {            speedX = -1;        }        if (monsterx < 0) {            speedX = 1;        }        monstery = monstery + speedY;        if (monstery > height) {            speedY = -3;        }        if (monstery < 0) {            speedY = 1;        }    }}',correct
'Arm leftArm;',correct
'ellipse(monsterx, monstery - 47, 17, 15);',correct
'new Arm(monsterx + 45, monstery, -1)',correct
'void updatePosition() {    leftArm.updateMonsterPosition(monsterx - 45, monstery);    rightArm.updateMonsterPosition(monsterx + 45, monstery);    monsterx += random(-2, 2);    monstery += random(-1, 1);    monsterx = monsterx + speedX;    if (monsterx > width) {        speedX = -1;    }    if (monsterx < 0) {        speedX = 1;    }    monstery = monstery + speedY;    if (monstery > height) {        speedY = -3;    }    if (monstery < 0) {        speedY = 1;    }}',correct
'float angularSpeed;',correct
'line(monsterx - 6, monstery - 47, monsterx + 6, monstery - 47)',correct
'monsterx - 45',correct
'angle',correct
'// ass',correct
'pinkbearA[i]',correct
'void updateMonsterPosition(float initX, float initY) {    monsterx = initX;    monstery = initY;}',correct
'monsterx - 43',correct
'// head',correct
'{    monsterx = initX;    monstery = initY;    leftArm = new Arm(monsterx - 45, monstery, 1);    rightArm = new Arm(monsterx + 45, monstery, -1);}',correct
'triangle(monsterx + 50, monstery - 64, monsterx - 50, monstery - 64, monsterx, monstery - 100);',correct
'if (monstery > height) {    speedY = -3;}',correct
'display',correct
'background(0);',correct
'// arms// pinkleftArm.display();',correct
'monstery = monstery + speedY',correct
'pinkbearA[i] = new Pinkbear(random(width), random(height))',correct
'ellipse(monsterx, monstery - 80, 12, 12);',correct
'fill(0xffE868F0)',correct
'angularSpeed',correct
'// feet',correct
'monsterx += random(-2, 2);',correct
'monsterx - 50',correct
'Arm(float initX, float initY, float initAngularSpeed) {    monsterx = initX;    monstery = initY;    angularSpeed = initAngularSpeed;}',correct
'random(-1, 1)',correct
'monsterx = monsterx + speedX;',correct
'float initX',correct
'float initY',correct
'i++',correct
'{    leftArm.updateMonsterPosition(monsterx - 45, monstery);    rightArm.updateMonsterPosition(monsterx + 45, monstery);    monsterx += random(-2, 2);    monstery += random(-1, 1);    monsterx = monsterx + speedX;    if (monsterx > width) {        speedX = -1;    }    if (monsterx < 0) {        speedX = 1;    }    monstery = monstery + speedY;    if (monstery > height) {        speedY = -3;    }    if (monstery < 0) {        speedY = 1;    }}',correct
'monstery - 72',correct
'ellipse(monsterx, monstery - 47, 17, 15)',correct
'fill(255);',correct
'float angle;',correct
'angularSpeed = initAngularSpeed',correct
'// ass// pinkfill(0xffEA78F2);',correct
'float speedX = random(1);',correct
'radians(angle)',correct
'arc(monsterx - 43, monstery - 72, 20, 20, 100, 300);',correct
'leftArm',correct
'speedX = -1',correct
'{    monsterx = initX;    monstery = initY;    angularSpeed = initAngularSpeed;}',correct
'monstery = initY;',correct
'"Keep the mouse pressed to say hello to Pinkbear!"',correct
'arc(monsterx - 43, monstery - 72, 20, 20, 100, 300)',correct
'if (monsterx < 0) {    speedX = 1;}',correct
'{    speedX = -1;}',correct
'void',correct
'-1',correct
'ellipse(monsterx + 30, monstery + 90, 40, 40)',correct
'-2',correct
'-3',correct
'monstery - 80',correct
'monstery += random(-1, 1);',correct
'{    rotate(radians(angle));}',correct
'// eye',correct
'monstery < 0',correct
'speedY = -3',correct
'strokeWeight(2)',correct
'textSize(40)',correct
'ellipse(monsterx - 30, monstery + 90, 40, 40)',correct
'ellipse(0, 0, 100, 35)',correct
'ellipse(monsterx, monstery + 60, 100, 90)',correct
'stroke(1)',correct
'for (int i = 0; i < pinkbearA.length; i++) {    pinkbearA[i].display();    pinkbearA[i].updatePosition();}',correct
'popMatrix()',correct
'// body',correct
'speedY = 1',correct
'Pinkbear[]',correct
'rotate(radians(angle))',correct
'pinkbearA = new Pinkbear[14]',correct
'monsterx = initX',correct
'// mouth// dark pinkfill(0xffE868F0);',correct
'monsterx - 6',correct
'Arm rightArm;',correct
'// ears',correct
'monstery - 64',correct
'{    speedX = 1;}',correct
'speedX = random(1)',correct
'pinkbearA[i] = new Pinkbear(random(width), random(height));',correct
'angle = (angle + angularSpeed) % 50;',correct
'monstery > height',correct
'// eyerect(batX - 38, batY - 6, 1, 4);',correct
'batY + 64',correct
'batY + 63',correct
'rect(batX - 38, batY - 6, 1, 4)',correct
'batY + 60',correct
'bat = new Bat(width, height / 2);',correct
'batX - 5',correct
'batX - 4',correct
'branch',correct
'color(50, 50, 50)',correct
'// tooth lefttriangle(bathangingX - 4, bathangingY + 26, bathangingX - 3, bathangingY + 24, bathangingX - 1, bathangingY + 26);',correct
'batwingdown1(batY);',correct
'batY + 6',correct
'batY + 5',correct
'bat',correct
'batY + 3',correct
'fill(color(50, 50, 50))',correct
'{    stroke(bodyColor);    fill(bodyColor);    // wing part 1    triangle(batX - 20, batY, batX - 30, batY - 38, batX - 5, batY - 60);    // wing part 2    triangle(batX - 20, batY, batX + 20, batY - 65, batX - 5, batY - 60);    // wing part 3    triangle(batX - 20, batY, batX + 20, batY - 63, batX, batY - 10);    // wing part 4    triangle(batX, batY - 10, batX + 21, batY - 66, batX + 50, batY - 70);    // wing part 5    triangle(batX + 15, batY - 30, batX + 51, batY - 69, batX + 65, batY - 55);    fill(91, 31, 40);    stroke(91, 30, 40);    // body    rect(batX, batY, 50, 20, 7);    // head    rect(batX - 33, batY, 20, 18, 7);    // ear    triangle(batX - 39, batY - 8, batX - 38, batY - 16, batX - 30, batY - 8);    // nose    rect(batX - 44, batY - 1, 10, 8, 7);    // feet    rect(batX + 30, batY + 6, 14, 6, 7);    stroke(255);    // teeth filling    fill(255);    // teeth    triangle(batX - 45, batY + 3, batX - 47, batY + 3, batX - 46, batY + 5);    // eye    rect(batX - 38, batY - 6, 1, 4);    // wing line 1    line(batX - 22, batY - 38, batX + 12, batY - 22);    // wing line 2    line(batX, batY - 55, batX + 26, batY - 32);    // wing line 3    line(batX + 21, batY - 64, batX + 45, batY - 42);}',correct
'line(batX - 22, batY - 38, batX + 12, batY - 22)',correct
'batX = xInit',correct
'batY + 69',correct
'// branchrect(branchX, branchY, 400, 10, 7);',correct
'batY + 66',correct
'batY + 65',correct
'stroke(0);',correct
'batY - 10',correct
'stroke(0)',correct
'theta = 0',correct
'batwingdown1(batY)',correct
'// wing part 5triangle(batX + 15, batY - 30, batX + 51, batY - 69, batX + 65, batY - 55);',correct
'float bathangingX;',correct
'// wing colourfill(color(50, 50, 50));',correct
'batY + 70',correct
'triangle(bathangingX + 8, bathangingY + 39, bathangingX + 5, bathangingY + 48, bathangingX + 2, bathangingY + 39)',correct
'rect(bathangingX, bathangingY + 29, 16, 20)',correct
'// tooth lefttriangle(bathangingX + 4, bathangingY + 26, bathangingX + 3, bathangingY + 24, bathangingX + 1, bathangingY + 26);',correct
'// wing part 2triangle(batX - 20, batY, batX + 20, batY + 65, batX - 5, batY + 60);',correct
'// left footrect(bathangingX - 7, bathangingY - 28, 6, 14, 7);',correct
'branch.run()',correct
'Branch(float xInit, float yInit) {    branchX = xInit;    branchY = yInit;}',correct
'triangle(batX + 15, batY - 30, batX + 51, batY - 69, batX + 65, batY - 55)',correct
'wingCounter++',correct
'// branch colourfill(0xff812D0C);',correct
'hang = new Bathanging(50, height / 2)',correct
'// bat hanging from branch// brown body colourfill(91, 31, 40);',correct
'batY - 16',correct
'branch = new Branch(0, height / 2 - 40)',correct
'batX > 50',correct
'float batStart;',correct
'sin(theta)',correct
'// feetrect(batX + 30, batY + 6, 14, 6, 7);',correct
'branchX = xInit',correct
'batY - 22',correct
'batX = batX - 4',correct
'rect(bathangingX - 7, bathangingY - 28, 6, 14, 7)',correct
'hang',correct
'{    batwingup1(batY);}',correct
'batY0 + 7',correct
'new Branch(0, height / 2 - 40)',correct
'// bat hanging from branch',correct
'stroke(bodyColor)',correct
'void setup() {    rectMode(CENTER);    ellipseMode(CENTER);    bat = new Bat(width, height / 2);    branch = new Branch(0, height / 2 - 40);}',correct
'batY0 = yInit;',correct
'line(batX + 21, batY - 64, batX + 45, batY - 42)',correct
'bathangingX = xInit',correct
'color(50)',correct
'triangle(batX - 39, batY - 8, batX - 38, batY - 16, batX - 30, batY - 8)',correct
'// teethtriangle(batX - 45, batY + 3, batX - 47, batY + 3, batX - 46, batY + 5);',correct
'batY0',correct
'batY - 32',correct
'bat.run()',correct
'rectMode(CENTER)',correct
'batY - 30',correct
'new Bathanging(50, height / 2)',correct
'float theta = 0;',correct
'{    batX = xInit;    batY0 = yInit;    // blackish    bodyColor = color(50);    batStart = -100;}',correct
'line(bathangingX + 5, bathangingY + 36, bathangingX + 2, bathangingY + 36)',correct
'// wing line 3line(batX + 21, batY - 64, batX + 45, batY - 42);',correct
'bathangingY = yInit',correct
'wingCounter++;',correct
'branchY = yInit',correct
'batwingup1(batY);',correct
'// wing line 2line(batX, batY - 55, batX + 26, batY - 32);',correct
'float batX;',correct
'line(batX + 21, batY + 64, batX + 45, batY + 42)',correct
'class Bathanging {    float bathangingX;    float bathangingY;    Bathanging(float xInit, float yInit) {        bathangingX = xInit;        bathangingY = yInit;    }    void run() {        // bat hanging from branch        // brown body colour        fill(91, 31, 40);        noStroke();        // head        rect(bathangingX, bathangingY + 29, 16, 20);        // left foot        rect(bathangingX - 7, bathangingY - 28, 6, 14, 7);        // right foot        rect(bathangingX + 7, bathangingY - 28, 6, 14, 7);        // left ear        triangle(bathangingX - 8, bathangingY + 39, bathangingX - 5, bathangingY + 48, bathangingX - 2, bathangingY + 39);        // right ear        triangle(bathangingX + 8, bathangingY + 39, bathangingX + 5, bathangingY + 48, bathangingX + 2, bathangingY + 39);        stroke(0);        // nose        rect(bathangingX, bathangingY + 30, 8, 6);        // wing colour        fill(color(50, 50, 50));        noStroke();        // body        rect(bathangingX, bathangingY, 26, 50);        fill(255);        // everything that is supposed to be white is below here        stroke(255);        // tooth left        triangle(bathangingX - 4, bathangingY + 26, bathangingX - 3, bathangingY + 24, bathangingX - 1, bathangingY + 26);        // tooth left        triangle(bathangingX + 4, bathangingY + 26, bathangingX + 3, bathangingY + 24, bathangingX + 1, bathangingY + 26);        // wing line        line(bathangingX - 13, bathangingY - 25, bathangingX + 13, bathangingY + 25);        // wing small line        line(bathangingX + 13, bathangingY - 25, bathangingX - 4, bathangingY - 10);        // left eye        line(bathangingX - 5, bathangingY + 36, bathangingX - 2, bathangingY + 36);        // right eye        line(bathangingX + 5, bathangingY + 36, bathangingX + 2, bathangingY + 36);    }}',correct
'bathangingX + 13',correct
'hang.run()',correct
'bat.run();',correct
'rect(bathangingX, bathangingY, 26, 50)',correct
'rectMode(CENTER);',correct
'batY - 38',correct
'// wing line 1line(batX - 22, batY - 38, batX + 12, batY - 22);',correct
'map(sin(theta), -1, 0.2f, batY0 - 7, batY0 + 7)',correct
'triangle(batX - 45, batY + 3, batX - 47, batY + 3, batX - 46, batY + 5)',correct
'noStroke()',correct
'height / 2 - 40',correct
'batX - 33',correct
'run',correct
'stroke(91, 30, 40);',correct
'batX - 38',correct
'batX - 39',correct
'float batY0;',correct
'triangle(batX - 20, batY, batX + 20, batY - 63, batX, batY - 10)',correct
'batX - 30',correct
'wingCounter < 40',correct
'// Program draws flying bat',correct
'line(bathangingX - 13, bathangingY - 25, bathangingX + 13, bathangingY + 25)',correct
'batY + 22',correct
'fill(bodyColor)',correct
'batY + 30',correct
'{    hang = new Bathanging(50, height / 2);    float batY = map(sin(theta), -1, 0.2f, batY0 - 7, batY0 + 7);    theta += 0.15f;    if (wingCounter <= 20) {        batwingup1(batY);    } else {        batwingdown1(batY);    }    if (wingCounter < 40) {        wingCounter++;    } else {        wingCounter = 0;    }    // when reaching branch it hangs and the flying bat disappears    if (batX > 50) {        batX = batX - 4;    } else {        hang.run();        batX = batStart;    }}',correct
'batX - 45',correct
'batX - 44',correct
'Bathanging',correct
'batX = batX - 4;',correct
'batX - 47',correct
'batX - 46',correct
'wingCounter = 0;',correct
'void batwingdown1(float batY) {    stroke(bodyColor);    fill(bodyColor);    // wing part 1    triangle(batX - 20, batY, batX - 30, batY + 38, batX - 5, batY + 60);    // wing part 2    triangle(batX - 20, batY, batX + 20, batY + 65, batX - 5, batY + 60);    // wing part 3    triangle(batX - 20, batY, batX + 20, batY + 63, batX, batY + 10);    // wing part 4    triangle(batX, batY + 10, batX + 21, batY + 66, batX + 50, batY + 70);    // wing part 5    triangle(batX + 15, batY + 30, batX + 51, batY + 69, batX + 65, batY + 55);    fill(91, 31, 40);    stroke(91, 30, 40);    // body    rect(batX, batY, 50, 20, 7);    // head    rect(batX - 33, batY, 20, 18, 7);    // ear    triangle(batX - 39, batY - 8, batX - 38, batY - 16, batX - 30, batY - 8);    // nose    rect(batX - 44, batY - 1, 10, 8, 7);    // feet    rect(batX + 30, batY + 6, 14, 6, 7);    stroke(255);    // teeth filling    fill(255);    // teeth    triangle(batX - 45, batY + 3, batX - 47, batY + 3, batX - 46, batY + 5);    // eye    rect(batX - 38, batY - 6, 1, 4);    // wing line 1    line(batX - 22, batY + 38, batX + 12, batY + 22);    // wing line 2    line(batX, batY + 55, batX + 26, batY + 32);    // wing line 3    line(batX + 21, batY + 64, batX + 45, batY + 42);}',correct
'-100',correct
'height / 2',correct
'bathangingX - 13',correct
'fill(bodyColor);',correct
'batY + 38',correct
'batY + 32',correct
'0.15f',correct
'batX = batStart;',correct
'batY + 42',correct
'branchY',correct
'branchX',correct
'int bodyColor;',correct
'triangle(batX - 20, batY, batX - 30, batY - 38, batX - 5, batY - 60)',correct
'// Program draws flying bat// By Thomas de Rooij 2129310Bat bat;',correct
'fill(255)',correct
'{    wingCounter = 0;}',correct
'batX',correct
'theta += 0.15f',correct
'Processing',correct
'Branch branch;',correct
'Bathanging(float xInit, float yInit) {    bathangingX = xInit;    bathangingY = yInit;}',correct
'Branch',correct
'// wing part 3triangle(batX - 20, batY, batX + 20, batY - 63, batX, batY - 10);',correct
'// headrect(bathangingX, bathangingY + 29, 16, 20);',correct
'bathangingX - 2',correct
'bathangingX - 3',correct
'bathangingX - 4',correct
'bathangingX - 5',correct
'bathangingX - 1',correct
'0.2f',correct
'bathangingX - 7',correct
'bathangingX - 8',correct
'false',correct
'batX - 22',correct
'Bat(float xInit, float yInit) {    batX = xInit;    batY0 = yInit;    // blackish    bodyColor = color(50);    batStart = -100;}',correct
'new Bat(width, height / 2)',correct
'branch = new Branch(0, height / 2 - 40);',correct
'rect(bathangingX, bathangingY + 30, 8, 6)',correct
'// eartriangle(batX - 39, batY - 8, batX - 38, batY - 16, batX - 30, batY - 8);',correct
'ellipseMode(CENTER);',correct
'batY = map(sin(theta), -1, 0.2f, batY0 - 7, batY0 + 7)',correct
'batX - 20',correct
'stroke(255)',correct
'bathangingY + 24',correct
'bathangingY + 25',correct
'bathangingY + 26',correct
'stroke(bodyColor);',correct
'batY + 55',correct
'bathangingY + 29',correct
'isHanging = false',correct
'{    rectMode(CENTER);    ellipseMode(CENTER);    bat = new Bat(width, height / 2);    branch = new Branch(0, height / 2 - 40);}',correct
'triangle(bathangingX + 4, bathangingY + 26, bathangingX + 3, bathangingY + 24, bathangingX + 1, bathangingY + 26)',correct
'boolean isHanging = false;',correct
'// wing line 3line(batX + 21, batY + 64, batX + 45, batY + 42);',correct
'line(bathangingX - 5, bathangingY + 36, bathangingX - 2, bathangingY + 36)',correct
'background(0)',correct
'bathangingY + 30',correct
'line(batX, batY - 55, batX + 26, batY - 32)',correct
'batX + 50',correct
'batX + 51',correct
'triangle(batX + 15, batY + 30, batX + 51, batY + 69, batX + 65, batY + 55)',correct
'bathangingY + 36',correct
'class Branch {    float branchX;    float branchY;    Branch(float xInit, float yInit) {        branchX = xInit;        branchY = yInit;    }    void run() {        noStroke();        // branch colour        fill(0xff812D0C);        // branch        rect(branchX, branchY, 400, 10, 7);    }}',correct
'bathangingY + 39',correct
'float xInit',correct
'batX = xInit;',correct
'theta += 0.15f;',correct
'// left eyeline(bathangingX - 5, bathangingY + 36, bathangingX - 2, bathangingY + 36);',correct
'bodyColor = color(50)',correct
'// everything that is supposed to be white is below herestroke(255);',correct
'rect(bathangingX + 7, bathangingY - 28, 6, 14, 7)',correct
'batX + 65',correct
'{    batX = batX - 4;}',correct
'{    batwingdown1(batY);}',correct
'noStroke();',correct
'bathangingY + 48',correct
'triangle(batX - 20, batY, batX + 20, batY + 65, batX - 5, batY + 60)',correct
'line(bathangingX + 13, bathangingY - 25, bathangingX - 4, bathangingY - 10)',correct
'// teeth fillingfill(255);',correct
'// wing line 1line(batX - 22, batY + 38, batX + 12, batY + 22);',correct
'rect(batX, batY, 50, 20, 7)',correct
'branch.run();',correct
'// headrect(batX - 33, batY, 20, 18, 7);',correct
'// draw bat with wing upvoid batwingup1(float batY) {    stroke(bodyColor);    fill(bodyColor);    // wing part 1    triangle(batX - 20, batY, batX - 30, batY - 38, batX - 5, batY - 60);    // wing part 2    triangle(batX - 20, batY, batX + 20, batY - 65, batX - 5, batY - 60);    // wing part 3    triangle(batX - 20, batY, batX + 20, batY - 63, batX, batY - 10);    // wing part 4    triangle(batX, batY - 10, batX + 21, batY - 66, batX + 50, batY - 70);    // wing part 5    triangle(batX + 15, batY - 30, batX + 51, batY - 69, batX + 65, batY - 55);    fill(91, 31, 40);    stroke(91, 30, 40);    // body    rect(batX, batY, 50, 20, 7);    // head    rect(batX - 33, batY, 20, 18, 7);    // ear    triangle(batX - 39, batY - 8, batX - 38, batY - 16, batX - 30, batY - 8);    // nose    rect(batX - 44, batY - 1, 10, 8, 7);    // feet    rect(batX + 30, batY + 6, 14, 6, 7);    stroke(255);    // teeth filling    fill(255);    // teeth    triangle(batX - 45, batY + 3, batX - 47, batY + 3, batX - 46, batY + 5);    // eye    rect(batX - 38, batY - 6, 1, 4);    // wing line 1    line(batX - 22, batY - 38, batX + 12, batY - 22);    // wing line 2    line(batX, batY - 55, batX + 26, batY - 32);    // wing line 3    line(batX + 21, batY - 64, batX + 45, batY - 42);}',correct
'// wing part 4triangle(batX, batY + 10, batX + 21, batY + 66, batX + 50, batY + 70);',correct
'{    wingCounter++;}',correct
'// wing line 2line(batX, batY + 55, batX + 26, batY + 32);',correct
'class Bat {    Bathanging hang;    float wingCounter = 0;    int bodyColor;    float theta = 0;    float batX;    float batY0;    float batStart;    boolean isHanging = false;    Bat(float xInit, float yInit) {        batX = xInit;        batY0 = yInit;        // blackish        bodyColor = color(50);        batStart = -100;    }    void run() {        hang = new Bathanging(50, height / 2);        float batY = map(sin(theta), -1, 0.2f, batY0 - 7, batY0 + 7);        theta += 0.15f;        if (wingCounter <= 20) {            batwingup1(batY);        } else {            batwingdown1(batY);        }        if (wingCounter < 40) {            wingCounter++;        } else {            wingCounter = 0;        }        // when reaching branch it hangs and the flying bat disappears        if (batX > 50) {            batX = batX - 4;        } else {            hang.run();            batX = batStart;        }    }    // draw bat with wing up    void batwingup1(float batY) {        stroke(bodyColor);        fill(bodyColor);        // wing part 1        triangle(batX - 20, batY, batX - 30, batY - 38, batX - 5, batY - 60);        // wing part 2        triangle(batX - 20, batY, batX + 20, batY - 65, batX - 5, batY - 60);        // wing part 3        triangle(batX - 20, batY, batX + 20, batY - 63, batX, batY - 10);        // wing part 4        triangle(batX, batY - 10, batX + 21, batY - 66, batX + 50, batY - 70);        // wing part 5        triangle(batX + 15, batY - 30, batX + 51, batY - 69, batX + 65, batY - 55);        fill(91, 31, 40);        stroke(91, 30, 40);        // body        rect(batX, batY, 50, 20, 7);        // head        rect(batX - 33, batY, 20, 18, 7);        // ear        triangle(batX - 39, batY - 8, batX - 38, batY - 16, batX - 30, batY - 8);        // nose        rect(batX - 44, batY - 1, 10, 8, 7);        // feet        rect(batX + 30, batY + 6, 14, 6, 7);        stroke(255);        // teeth filling        fill(255);        // teeth        triangle(batX - 45, batY + 3, batX - 47, batY + 3, batX - 46, batY + 5);        // eye        rect(batX - 38, batY - 6, 1, 4);        // wing line 1        line(batX - 22, batY - 38, batX + 12, batY - 22);        // wing line 2        line(batX, batY - 55, batX + 26, batY - 32);        // wing line 3        line(batX + 21, batY - 64, batX + 45, batY - 42);    }    void batwingdown1(float batY) {        stroke(bodyColor);        fill(bodyColor);        // wing part 1        triangle(batX - 20, batY, batX - 30, batY + 38, batX - 5, batY + 60);        // wing part 2        triangle(batX - 20, batY, batX + 20, batY + 65, batX - 5, batY + 60);        // wing part 3        triangle(batX - 20, batY, batX + 20, batY + 63, batX, batY + 10);        // wing part 4        triangle(batX, batY + 10, batX + 21, batY + 66, batX + 50, batY + 70);        // wing part 5        triangle(batX + 15, batY + 30, batX + 51, batY + 69, batX + 65, batY + 55);        fill(91, 31, 40);        stroke(91, 30, 40);        // body        rect(batX, batY, 50, 20, 7);        // head        rect(batX - 33, batY, 20, 18, 7);        // ear        triangle(batX - 39, batY - 8, batX - 38, batY - 16, batX - 30, batY - 8);        // nose        rect(batX - 44, batY - 1, 10, 8, 7);        // feet        rect(batX + 30, batY + 6, 14, 6, 7);        stroke(255);        // teeth filling        fill(255);        // teeth        triangle(batX - 45, batY + 3, batX - 47, batY + 3, batX - 46, batY + 5);        // eye        rect(batX - 38, batY - 6, 1, 4);        // wing line 1        line(batX - 22, batY + 38, batX + 12, batY + 22);        // wing line 2        line(batX, batY + 55, batX + 26, batY + 32);        // wing line 3        line(batX + 21, batY + 64, batX + 45, batY + 42);    }}',correct
'// bodyrect(bathangingX, bathangingY, 26, 50);',correct
'batX + 30',correct
'bathangingX + 4',correct
'bathangingX + 5',correct
'bathangingX + 7',correct
'{    stroke(bodyColor);    fill(bodyColor);    // wing part 1    triangle(batX - 20, batY, batX - 30, batY + 38, batX - 5, batY + 60);    // wing part 2    triangle(batX - 20, batY, batX + 20, batY + 65, batX - 5, batY + 60);    // wing part 3    triangle(batX - 20, batY, batX + 20, batY + 63, batX, batY + 10);    // wing part 4    triangle(batX, batY + 10, batX + 21, batY + 66, batX + 50, batY + 70);    // wing part 5    triangle(batX + 15, batY + 30, batX + 51, batY + 69, batX + 65, batY + 55);    fill(91, 31, 40);    stroke(91, 30, 40);    // body    rect(batX, batY, 50, 20, 7);    // head    rect(batX - 33, batY, 20, 18, 7);    // ear    triangle(batX - 39, batY - 8, batX - 38, batY - 16, batX - 30, batY - 8);    // nose    rect(batX - 44, batY - 1, 10, 8, 7);    // feet    rect(batX + 30, batY + 6, 14, 6, 7);    stroke(255);    // teeth filling    fill(255);    // teeth    triangle(batX - 45, batY + 3, batX - 47, batY + 3, batX - 46, batY + 5);    // eye    rect(batX - 38, batY - 6, 1, 4);    // wing line 1    line(batX - 22, batY + 38, batX + 12, batY + 22);    // wing line 2    line(batX, batY + 55, batX + 26, batY + 32);    // wing line 3    line(batX + 21, batY + 64, batX + 45, batY + 42);}',correct
'// wing part 3triangle(batX - 20, batY, batX + 20, batY + 63, batX, batY + 10);',correct
'rect(branchX, branchY, 400, 10, 7)',correct
'bathangingX + 1',correct
'bathangingX + 2',correct
'batStart = -100;',correct
'bathangingX + 3',correct
'batStart',correct
'bathangingX + 8',correct
'batX = batStart',correct
'background(0);',correct
'batX + 45',correct
'void run() {    hang = new Bathanging(50, height / 2);    float batY = map(sin(theta), -1, 0.2f, batY0 - 7, batY0 + 7);    theta += 0.15f;    if (wingCounter <= 20) {        batwingup1(batY);    } else {        batwingdown1(batY);    }    if (wingCounter < 40) {        wingCounter++;    } else {        wingCounter = 0;    }    // when reaching branch it hangs and the flying bat disappears    if (batX > 50) {        batX = batX - 4;    } else {        hang.run();        batX = batStart;    }}',correct
'fill(91, 31, 40);',correct
'// left eartriangle(bathangingX - 8, bathangingY + 39, bathangingX - 5, bathangingY + 48, bathangingX - 2, bathangingY + 39);',correct
'// bodyrect(batX, batY, 50, 20, 7);',correct
'// wing part 1triangle(batX - 20, batY, batX - 30, batY - 38, batX - 5, batY - 60);',correct
'batStart = -100',correct
'branchX = xInit;',correct
'// right eartriangle(bathangingX + 8, bathangingY + 39, bathangingX + 5, bathangingY + 48, bathangingX + 2, bathangingY + 39);',correct
'// wing small lineline(bathangingX + 13, bathangingY - 25, bathangingX - 4, bathangingY - 10);',correct
'batY + 10',correct
'float batY = map(sin(theta), -1, 0.2f, batY0 - 7, batY0 + 7)',correct
'batY - 42',correct
'fill(0xff812D0C)',correct
'bat = new Bat(width, height / 2)',correct
'// wing part 4triangle(batX, batY - 10, batX + 21, batY - 66, batX + 50, batY - 70);',correct
'batX + 12',correct
'batX + 15',correct
'triangle(bathangingX - 4, bathangingY + 26, bathangingX - 3, bathangingY + 24, bathangingX - 1, bathangingY + 26)',correct
'triangle(batX, batY + 10, batX + 21, batY + 66, batX + 50, batY + 70)',correct
'fill(255);',correct
'batY - 6',correct
'ellipseMode(CENTER)',correct
'rect(batX - 44, batY - 1, 10, 8, 7)',correct
'{    branchX = xInit;    branchY = yInit;}',correct
'bathangingY - 10',correct
'batY - 1',correct
'bathangingY',correct
'bathangingX',correct
'// blackishbodyColor = color(50);',correct
'batY - 8',correct
'bathangingY = yInit;',correct
'batY - 55',correct
'void',correct
'-1',correct
'triangle(bathangingX - 8, bathangingY + 39, bathangingX - 5, bathangingY + 48, bathangingX - 2, bathangingY + 39)',correct
'wingCounter = 0',correct
'// when reaching branch it hangs and the flying bat disappearsif (batX > 50) {    batX = batX - 4;} else {    hang.run();    batX = batStart;}',correct
'// wing part 1triangle(batX - 20, batY, batX - 30, batY + 38, batX - 5, batY + 60);',correct
'batX + 20',correct
'batX + 21',correct
'triangle(batX - 20, batY, batX + 20, batY - 65, batX - 5, batY - 60)',correct
'{    hang.run();    batX = batStart;}',correct
'void run() {    noStroke();    // branch colour    fill(0xff812D0C);    // branch    rect(branchX, branchY, 400, 10, 7);}',correct
'hang.run();',correct
'batX + 26',correct
'batwingdown1',correct
'rect(batX + 30, batY + 6, 14, 6, 7)',correct
'// right eyeline(bathangingX + 5, bathangingY + 36, bathangingX + 2, bathangingY + 36);',correct
'batwingup1(batY)',correct
'void run() {    // bat hanging from branch    // brown body colour    fill(91, 31, 40);    noStroke();    // head    rect(bathangingX, bathangingY + 29, 16, 20);    // left foot    rect(bathangingX - 7, bathangingY - 28, 6, 14, 7);    // right foot    rect(bathangingX + 7, bathangingY - 28, 6, 14, 7);    // left ear    triangle(bathangingX - 8, bathangingY + 39, bathangingX - 5, bathangingY + 48, bathangingX - 2, bathangingY + 39);    // right ear    triangle(bathangingX + 8, bathangingY + 39, bathangingX + 5, bathangingY + 48, bathangingX + 2, bathangingY + 39);    stroke(0);    // nose    rect(bathangingX, bathangingY + 30, 8, 6);    // wing colour    fill(color(50, 50, 50));    noStroke();    // body    rect(bathangingX, bathangingY, 26, 50);    fill(255);    // everything that is supposed to be white is below here    stroke(255);    // tooth left    triangle(bathangingX - 4, bathangingY + 26, bathangingX - 3, bathangingY + 24, bathangingX - 1, bathangingY + 26);    // tooth left    triangle(bathangingX + 4, bathangingY + 26, bathangingX + 3, bathangingY + 24, bathangingX + 1, bathangingY + 26);    // wing line    line(bathangingX - 13, bathangingY - 25, bathangingX + 13, bathangingY + 25);    // wing small line    line(bathangingX + 13, bathangingY - 25, bathangingX - 4, bathangingY - 10);    // left eye    line(bathangingX - 5, bathangingY + 36, bathangingX - 2, bathangingY + 36);    // right eye    line(bathangingX + 5, bathangingY + 36, bathangingX + 2, bathangingY + 36);}',correct
'if (wingCounter <= 20) {    batwingup1(batY);} else {    batwingdown1(batY);}',correct
'float yInit',correct
'bathangingY - 25',correct
'bathangingY - 28',correct
'// wing part 5triangle(batX + 15, batY + 30, batX + 51, batY + 69, batX + 65, batY + 55);',correct
'triangle(batX - 20, batY, batX + 20, batY + 63, batX, batY + 10)',correct
'if (wingCounter < 40) {    wingCounter++;} else {    wingCounter = 0;}',correct
'batY - 65',correct
'batY - 66',correct
'batY - 63',correct
'// noserect(bathangingX, bathangingY + 30, 8, 6);',correct
'bodyColor',correct
'batY - 64',correct
'float batY = map(sin(theta), -1, 0.2f, batY0 - 7, batY0 + 7);',correct
'{    // bat hanging from branch    // brown body colour    fill(91, 31, 40);    noStroke();    // head    rect(bathangingX, bathangingY + 29, 16, 20);    // left foot    rect(bathangingX - 7, bathangingY - 28, 6, 14, 7);    // right foot    rect(bathangingX + 7, bathangingY - 28, 6, 14, 7);    // left ear    triangle(bathangingX - 8, bathangingY + 39, bathangingX - 5, bathangingY + 48, bathangingX - 2, bathangingY + 39);    // right ear    triangle(bathangingX + 8, bathangingY + 39, bathangingX + 5, bathangingY + 48, bathangingX + 2, bathangingY + 39);    stroke(0);    // nose    rect(bathangingX, bathangingY + 30, 8, 6);    // wing colour    fill(color(50, 50, 50));    noStroke();    // body    rect(bathangingX, bathangingY, 26, 50);    fill(255);    // everything that is supposed to be white is below here    stroke(255);    // tooth left    triangle(bathangingX - 4, bathangingY + 26, bathangingX - 3, bathangingY + 24, bathangingX - 1, bathangingY + 26);    // tooth left    triangle(bathangingX + 4, bathangingY + 26, bathangingX + 3, bathangingY + 24, bathangingX + 1, bathangingY + 26);    // wing line    line(bathangingX - 13, bathangingY - 25, bathangingX + 13, bathangingY + 25);    // wing small line    line(bathangingX + 13, bathangingY - 25, bathangingX - 4, bathangingY - 10);    // left eye    line(bathangingX - 5, bathangingY + 36, bathangingX - 2, bathangingY + 36);    // right eye    line(bathangingX + 5, bathangingY + 36, bathangingX + 2, bathangingY + 36);}',correct
'float bathangingY;',correct
'{    bathangingX = xInit;    bathangingY = yInit;}',correct
'batY - 60',correct
'hang = new Bathanging(50, height / 2);',correct
'branchY = yInit;',correct
'stroke(255);',correct
'float batY',correct
'float branchY;',correct
'{    background(0);    branch.run();    bat.run();}',correct
'{    noStroke();    // branch colour    fill(0xff812D0C);    // branch    rect(branchX, branchY, 400, 10, 7);}',correct
'line(batX, batY + 55, batX + 26, batY + 32)',correct
'batwingup1',correct
'Bathanging hang;',correct
'// right footrect(bathangingX + 7, bathangingY - 28, 6, 14, 7);',correct
'line(batX - 22, batY + 38, batX + 12, batY + 22)',correct
'// wing part 2triangle(batX - 20, batY, batX + 20, batY - 65, batX - 5, batY - 60);',correct
'wingCounter <= 20',correct
'batY0 - 7',correct
'batY - 69',correct
'rect(batX - 33, batY, 20, 18, 7)',correct
'triangle(batX - 20, batY, batX - 30, batY + 38, batX - 5, batY + 60)',correct
'bathangingX = xInit;',correct
'stroke(91, 30, 40)',correct
'batY - 70',correct
'// wing lineline(bathangingX - 13, bathangingY - 25, bathangingX + 13, bathangingY + 25);',correct
'float branchX;',correct
'batY0 = yInit',correct
'void draw() {    background(0);    branch.run();    bat.run();}',correct
'Bat',correct
'triangle(batX, batY - 10, batX + 21, batY - 66, batX + 50, batY - 70)',correct
'float wingCounter = 0;',correct
'// noserect(batX - 44, batY - 1, 10, 8, 7);',correct
'fill(91, 31, 40)',correct
'chomusukeX - 85',correct
'line(chomusukeX - 25, chomusukeY + 180, chomusukeX - 18, chomusukeY + 130)',correct
'// https://steamcommunity.com/workshop/filedetails/?id=702060467 by MrKenziv',correct
'bezier(chomusukeX + 30, chomusukeY + 70, chomusukeX + 30, chomusukeY + 140, chomusukeX + 40, chomusukeY + 120, chomusukeX + 10, chomusukeY + 180)',correct
'quad(chomusukeX - 130, chomusukeY + 180, chomusukeX + 11, chomusukeY + 180, chomusukeX + 31, chomusukeY + 70, chomusukeX - 45, chomusukeY + 65)',correct
'chomusukeY = mouseY',correct
'int chomusukeX;',correct
'float backgroundHueChange = 0.5f;',correct
'colorMode(HSB, 100, 100, 100)',correct
'// eyesellipse(chomusukeX + 45, chomusukeY - 5, 30, 43);',correct
'bezier(chomusukeX - 45, chomusukeY + 65, chomusukeX - 50, chomusukeY + 65, chomusukeX - 60, chomusukeY + 75, chomusukeX - 75, chomusukeY + 95);',correct
'chomusukeY + 65',correct
'line(chomusukeX - 25, chomusukeY + 180, chomusukeX - 18, chomusukeY + 130);',correct
'int chomusukeY;',correct
'chomusukeY + 68',correct
'{}',EmptyIfStmt
'if (mouseButton == LEFT) {    chomusukeX = mouseX;    chomusukeY = mouseY;    stroke(bodyColor);    fill(255, 0, 0);    ellipse(chomusukeX + 45, chomusukeY - 5, 30, 43);    ellipse(chomusukeX - 45, chomusukeY - 5, 30, 43);    stroke(bodyColor);    fill(0, 0, 0);    quad(chomusukeX - 20, chomusukeY - 20, chomusukeX - 15, chomusukeY - 30, chomusukeX - 45, chomusukeY - 50, chomusukeX - 45, chomusukeY - 40);    quad(chomusukeX + 20, chomusukeY - 20, chomusukeX + 15, chomusukeY - 30, chomusukeX + 45, chomusukeY - 50, chomusukeX + 45, chomusukeY - 40);} else if (mouseButton == RIGHT) {    PImage img;    img = loadImage("meguminpic.jpg");    image(img, 0, 0);    // https://steamcommunity.com/workshop/filedetails/?id=702060467 by MrKenziv    stroke(bodyColor);    fill(76, 53, 32);    // body    noStroke();    quad(chomusukeX - 130, chomusukeY + 180, chomusukeX + 11, chomusukeY + 180, chomusukeX + 31, chomusukeY + 70, chomusukeX - 45, chomusukeY + 65);    triangle(chomusukeX - 130, chomusukeY + 180, chomusukeX - 76, chomusukeY + 96, chomusukeX - 40, chomusukeY + 60);    stroke(0);    ellipse(chomusukeX, chomusukeY, 180, 150);    triangle(chomusukeX + 40, chomusukeY - 66, chomusukeX + 90, chomusukeY - 75, chomusukeX + 85, chomusukeY - 25);    triangle(chomusukeX - 40, chomusukeY - 66, chomusukeX - 90, chomusukeY - 75, chomusukeX - 85, chomusukeY - 25);    bezier(chomusukeX + 30, chomusukeY + 70, chomusukeX + 30, chomusukeY + 140, chomusukeX + 40, chomusukeY + 120, chomusukeX + 10, chomusukeY + 180);    bezier(chomusukeX - 45, chomusukeY + 65, chomusukeX - 50, chomusukeY + 65, chomusukeX - 60, chomusukeY + 75, chomusukeX - 75, chomusukeY + 95);    bezier(chomusukeX - 75, chomusukeY + 95, chomusukeX - 130, chomusukeY + 110, chomusukeX - 133, chomusukeY + 160, chomusukeX - 130, chomusukeY + 180);    bezier(chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX + 10, chomusukeY + 180);    bezier(chomusukeX - 122, chomusukeY + 130, chomusukeX - 150, chomusukeY + 40, chomusukeX - 230, chomusukeY + 60, chomusukeX - 130, chomusukeY + 150);    line(chomusukeX - 65, chomusukeY + 180, chomusukeX - 60, chomusukeY + 170);    line(chomusukeX - 45, chomusukeY + 180, chomusukeX - 60, chomusukeY + 140);    line(chomusukeX - 25, chomusukeY + 180, chomusukeX - 18, chomusukeY + 130);    bezier(chomusukeX - 25, chomusukeY + 170, chomusukeX - 10, chomusukeY + 165, chomusukeX + 5, chomusukeY + 155, chomusukeX + 10, chomusukeY + 145);    line(chomusukeX - 10, chomusukeY + 180, chomusukeX - 10, chomusukeY + 165);    stroke(bodyColor);    fill(61, 60, 59);    // wings    triangle(chomusukeX - 90, chomusukeY + 35, chomusukeX - 110, chomusukeY + 70, chomusukeX - 70, chomusukeY + 58);    triangle(chomusukeX - 85, chomusukeY + 40, chomusukeX - 90, chomusukeY + 80, chomusukeX - 60, chomusukeY + 68);    triangle(chomusukeX - 75, chomusukeY + 55, chomusukeX - 75, chomusukeY + 85, chomusukeX - 55, chomusukeY + 70);    triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 65, chomusukeY + 100, chomusukeX + 30, chomusukeY + 80);    triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 32, chomusukeY + 100, chomusukeX + 30, chomusukeY + 75);    stroke(bodyColor);    fill(209, 189, 117);    // eyes    ellipse(chomusukeX + 45, chomusukeY - 5, 30, 43);    ellipse(chomusukeX - 45, chomusukeY - 5, 30, 43);    stroke(bodyColor);    fill(191, 132, 122);    // mouth    triangle(chomusukeX + 0, chomusukeY + 30, chomusukeX + 10, chomusukeY + 48, chomusukeX - 10, chomusukeY + 48);    stroke(bodyColor);    fill(206, 8, 44);    // cross    quad(chomusukeX - 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 65, chomusukeX - 5, chomusukeY - 65);    quad(chomusukeX - 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 53, chomusukeX - 13, chomusukeY - 53);} else {}',correct
'chomusukeY + 60',correct
'{    PImage img;    img = loadImage("meguminpic.jpg");    image(img, 0, 0);    // https://steamcommunity.com/workshop/filedetails/?id=702060467 by MrKenziv    stroke(bodyColor);    fill(76, 53, 32);    // body    noStroke();    quad(chomusukeX - 130, chomusukeY + 180, chomusukeX + 11, chomusukeY + 180, chomusukeX + 31, chomusukeY + 70, chomusukeX - 45, chomusukeY + 65);    triangle(chomusukeX - 130, chomusukeY + 180, chomusukeX - 76, chomusukeY + 96, chomusukeX - 40, chomusukeY + 60);    stroke(0);    ellipse(chomusukeX, chomusukeY, 180, 150);    triangle(chomusukeX + 40, chomusukeY - 66, chomusukeX + 90, chomusukeY - 75, chomusukeX + 85, chomusukeY - 25);    triangle(chomusukeX - 40, chomusukeY - 66, chomusukeX - 90, chomusukeY - 75, chomusukeX - 85, chomusukeY - 25);    bezier(chomusukeX + 30, chomusukeY + 70, chomusukeX + 30, chomusukeY + 140, chomusukeX + 40, chomusukeY + 120, chomusukeX + 10, chomusukeY + 180);    bezier(chomusukeX - 45, chomusukeY + 65, chomusukeX - 50, chomusukeY + 65, chomusukeX - 60, chomusukeY + 75, chomusukeX - 75, chomusukeY + 95);    bezier(chomusukeX - 75, chomusukeY + 95, chomusukeX - 130, chomusukeY + 110, chomusukeX - 133, chomusukeY + 160, chomusukeX - 130, chomusukeY + 180);    bezier(chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX + 10, chomusukeY + 180);    bezier(chomusukeX - 122, chomusukeY + 130, chomusukeX - 150, chomusukeY + 40, chomusukeX - 230, chomusukeY + 60, chomusukeX - 130, chomusukeY + 150);    line(chomusukeX - 65, chomusukeY + 180, chomusukeX - 60, chomusukeY + 170);    line(chomusukeX - 45, chomusukeY + 180, chomusukeX - 60, chomusukeY + 140);    line(chomusukeX - 25, chomusukeY + 180, chomusukeX - 18, chomusukeY + 130);    bezier(chomusukeX - 25, chomusukeY + 170, chomusukeX - 10, chomusukeY + 165, chomusukeX + 5, chomusukeY + 155, chomusukeX + 10, chomusukeY + 145);    line(chomusukeX - 10, chomusukeY + 180, chomusukeX - 10, chomusukeY + 165);    stroke(bodyColor);    fill(61, 60, 59);    // wings    triangle(chomusukeX - 90, chomusukeY + 35, chomusukeX - 110, chomusukeY + 70, chomusukeX - 70, chomusukeY + 58);    triangle(chomusukeX - 85, chomusukeY + 40, chomusukeX - 90, chomusukeY + 80, chomusukeX - 60, chomusukeY + 68);    triangle(chomusukeX - 75, chomusukeY + 55, chomusukeX - 75, chomusukeY + 85, chomusukeX - 55, chomusukeY + 70);    triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 65, chomusukeY + 100, chomusukeX + 30, chomusukeY + 80);    triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 32, chomusukeY + 100, chomusukeX + 30, chomusukeY + 75);    stroke(bodyColor);    fill(209, 189, 117);    // eyes    ellipse(chomusukeX + 45, chomusukeY - 5, 30, 43);    ellipse(chomusukeX - 45, chomusukeY - 5, 30, 43);    stroke(bodyColor);    fill(191, 132, 122);    // mouth    triangle(chomusukeX + 0, chomusukeY + 30, chomusukeX + 10, chomusukeY + 48, chomusukeX - 10, chomusukeY + 48);    stroke(bodyColor);    fill(206, 8, 44);    // cross    quad(chomusukeX - 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 65, chomusukeX - 5, chomusukeY - 65);    quad(chomusukeX - 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 53, chomusukeX - 13, chomusukeY - 53);}',DecentralizedEventHandlingRule
'stroke(0);',correct
'chomusukeX - 75',correct
'fill(209, 189, 117)',correct
'stroke(0)',correct
'PImage img;',correct
'chomusukeX - 70',correct
'fill(0, 0, 0)',correct
'chomusukeX - 76',correct
'chomusukeY + 75',correct
'Chomusuke',correct
'chomusukeX - 150',correct
'chomusukeY + 70',correct
'triangle(chomusukeX + 40, chomusukeY - 66, chomusukeX + 90, chomusukeY - 75, chomusukeX + 85, chomusukeY - 25);',correct
'bezier(chomusukeX - 25, chomusukeY + 170, chomusukeX - 10, chomusukeY + 165, chomusukeX + 5, chomusukeY + 155, chomusukeX + 10, chomusukeY + 145)',correct
'fill(255, 0, 0);',correct
'chomusukeY - 5',correct
'stroke(bodyColor)',correct
'quad(chomusukeX - 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 65, chomusukeX - 5, chomusukeY - 65)',correct
'triangle(chomusukeX - 130, chomusukeY + 180, chomusukeX - 76, chomusukeY + 96, chomusukeX - 40, chomusukeY + 60);',correct
'line(chomusukeX - 45, chomusukeY + 180, chomusukeX - 60, chomusukeY + 140)',correct
'PImage',correct
'triangle(chomusukeX - 40, chomusukeY - 66, chomusukeX - 90, chomusukeY - 75, chomusukeX - 85, chomusukeY - 25);',correct
'chomusukeY + 48',correct
'fill(209, 189, 117);',correct
'class Chomusuke {    int chomusukeX;    int chomusukeY;    int bodyColor;    float backgroundHueOffset = 0;    float backgroundHueChange = 0.5f;    Chomusuke() {        chomusukeX = width / 2;        chomusukeY = height / 2;    }    void display() {        colorMode(HSB, 100, 100, 100);        for (int i = 0; i <= 100; i++) {            background((i + backgroundHueOffset) % 100, 100, 100);        }        colorMode(RGB, 255, 255, 255);        if (backgroundHueOffset >= 0 && backgroundHueOffset <= 100) {            backgroundHueOffset += backgroundHueChange;        } else if (backgroundHueOffset > 100) {            backgroundHueOffset = 0;        } else {            backgroundHueOffset = 100;        }        // background inspired by ansgar and student assisstens        stroke(bodyColor);        fill(76, 53, 32);        // body        noStroke();        quad(chomusukeX - 130, chomusukeY + 180, chomusukeX + 11, chomusukeY + 180, chomusukeX + 31, chomusukeY + 70, chomusukeX - 45, chomusukeY + 65);        triangle(chomusukeX - 130, chomusukeY + 180, chomusukeX - 76, chomusukeY + 96, chomusukeX - 40, chomusukeY + 60);        stroke(0);        ellipse(chomusukeX, chomusukeY, 180, 150);        triangle(chomusukeX + 40, chomusukeY - 66, chomusukeX + 90, chomusukeY - 75, chomusukeX + 85, chomusukeY - 25);        triangle(chomusukeX - 40, chomusukeY - 66, chomusukeX - 90, chomusukeY - 75, chomusukeX - 85, chomusukeY - 25);        bezier(chomusukeX + 30, chomusukeY + 70, chomusukeX + 30, chomusukeY + 140, chomusukeX + 40, chomusukeY + 120, chomusukeX + 10, chomusukeY + 180);        bezier(chomusukeX - 45, chomusukeY + 65, chomusukeX - 50, chomusukeY + 65, chomusukeX - 60, chomusukeY + 75, chomusukeX - 75, chomusukeY + 95);        bezier(chomusukeX - 75, chomusukeY + 95, chomusukeX - 130, chomusukeY + 110, chomusukeX - 133, chomusukeY + 160, chomusukeX - 130, chomusukeY + 180);        bezier(chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX + 10, chomusukeY + 180);        bezier(chomusukeX - 122, chomusukeY + 130, chomusukeX - 150, chomusukeY + 40, chomusukeX - 230, chomusukeY + 60, chomusukeX - 130, chomusukeY + 150);        line(chomusukeX - 65, chomusukeY + 180, chomusukeX - 60, chomusukeY + 170);        line(chomusukeX - 45, chomusukeY + 180, chomusukeX - 60, chomusukeY + 140);        line(chomusukeX - 25, chomusukeY + 180, chomusukeX - 18, chomusukeY + 130);        bezier(chomusukeX - 25, chomusukeY + 170, chomusukeX - 10, chomusukeY + 165, chomusukeX + 5, chomusukeY + 155, chomusukeX + 10, chomusukeY + 145);        line(chomusukeX - 10, chomusukeY + 180, chomusukeX - 10, chomusukeY + 165);        stroke(bodyColor);        fill(61, 60, 59);        // wings        triangle(chomusukeX - 90, chomusukeY + 35, chomusukeX - 110, chomusukeY + 70, chomusukeX - 70, chomusukeY + 58);        triangle(chomusukeX - 85, chomusukeY + 40, chomusukeX - 90, chomusukeY + 80, chomusukeX - 60, chomusukeY + 68);        triangle(chomusukeX - 75, chomusukeY + 55, chomusukeX - 75, chomusukeY + 85, chomusukeX - 55, chomusukeY + 70);        triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 65, chomusukeY + 100, chomusukeX + 30, chomusukeY + 80);        triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 32, chomusukeY + 100, chomusukeX + 30, chomusukeY + 75);        stroke(bodyColor);        fill(209, 189, 117);        // eyes        ellipse(chomusukeX + 45, chomusukeY - 5, 30, 43);        ellipse(chomusukeX - 45, chomusukeY - 5, 30, 43);        stroke(bodyColor);        fill(191, 132, 122);        // mouth        triangle(chomusukeX + 0, chomusukeY + 30, chomusukeX + 10, chomusukeY + 48, chomusukeX - 10, chomusukeY + 48);        stroke(bodyColor);        fill(206, 8, 44);        // cross        quad(chomusukeX - 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 65, chomusukeX - 5, chomusukeY - 65);        quad(chomusukeX - 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 53, chomusukeX - 13, chomusukeY - 53);    }    void pressMouse() {        if (mouseButton == LEFT) {            chomusukeX = mouseX;            chomusukeY = mouseY;            stroke(bodyColor);            fill(255, 0, 0);            ellipse(chomusukeX + 45, chomusukeY - 5, 30, 43);            ellipse(chomusukeX - 45, chomusukeY - 5, 30, 43);            stroke(bodyColor);            fill(0, 0, 0);            quad(chomusukeX - 20, chomusukeY - 20, chomusukeX - 15, chomusukeY - 30, chomusukeX - 45, chomusukeY - 50, chomusukeX - 45, chomusukeY - 40);            quad(chomusukeX + 20, chomusukeY - 20, chomusukeX + 15, chomusukeY - 30, chomusukeX + 45, chomusukeY - 50, chomusukeX + 45, chomusukeY - 40);        } else if (mouseButton == RIGHT) {            PImage img;            img = loadImage("meguminpic.jpg");            image(img, 0, 0);            // https://steamcommunity.com/workshop/filedetails/?id=702060467 by MrKenziv            stroke(bodyColor);            fill(76, 53, 32);            // body            noStroke();            quad(chomusukeX - 130, chomusukeY + 180, chomusukeX + 11, chomusukeY + 180, chomusukeX + 31, chomusukeY + 70, chomusukeX - 45, chomusukeY + 65);            triangle(chomusukeX - 130, chomusukeY + 180, chomusukeX - 76, chomusukeY + 96, chomusukeX - 40, chomusukeY + 60);            stroke(0);            ellipse(chomusukeX, chomusukeY, 180, 150);            triangle(chomusukeX + 40, chomusukeY - 66, chomusukeX + 90, chomusukeY - 75, chomusukeX + 85, chomusukeY - 25);            triangle(chomusukeX - 40, chomusukeY - 66, chomusukeX - 90, chomusukeY - 75, chomusukeX - 85, chomusukeY - 25);            bezier(chomusukeX + 30, chomusukeY + 70, chomusukeX + 30, chomusukeY + 140, chomusukeX + 40, chomusukeY + 120, chomusukeX + 10, chomusukeY + 180);            bezier(chomusukeX - 45, chomusukeY + 65, chomusukeX - 50, chomusukeY + 65, chomusukeX - 60, chomusukeY + 75, chomusukeX - 75, chomusukeY + 95);            bezier(chomusukeX - 75, chomusukeY + 95, chomusukeX - 130, chomusukeY + 110, chomusukeX - 133, chomusukeY + 160, chomusukeX - 130, chomusukeY + 180);            bezier(chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX + 10, chomusukeY + 180);            bezier(chomusukeX - 122, chomusukeY + 130, chomusukeX - 150, chomusukeY + 40, chomusukeX - 230, chomusukeY + 60, chomusukeX - 130, chomusukeY + 150);            line(chomusukeX - 65, chomusukeY + 180, chomusukeX - 60, chomusukeY + 170);            line(chomusukeX - 45, chomusukeY + 180, chomusukeX - 60, chomusukeY + 140);            line(chomusukeX - 25, chomusukeY + 180, chomusukeX - 18, chomusukeY + 130);            bezier(chomusukeX - 25, chomusukeY + 170, chomusukeX - 10, chomusukeY + 165, chomusukeX + 5, chomusukeY + 155, chomusukeX + 10, chomusukeY + 145);            line(chomusukeX - 10, chomusukeY + 180, chomusukeX - 10, chomusukeY + 165);            stroke(bodyColor);            fill(61, 60, 59);            // wings            triangle(chomusukeX - 90, chomusukeY + 35, chomusukeX - 110, chomusukeY + 70, chomusukeX - 70, chomusukeY + 58);            triangle(chomusukeX - 85, chomusukeY + 40, chomusukeX - 90, chomusukeY + 80, chomusukeX - 60, chomusukeY + 68);            triangle(chomusukeX - 75, chomusukeY + 55, chomusukeX - 75, chomusukeY + 85, chomusukeX - 55, chomusukeY + 70);            triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 65, chomusukeY + 100, chomusukeX + 30, chomusukeY + 80);            triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 32, chomusukeY + 100, chomusukeX + 30, chomusukeY + 75);            stroke(bodyColor);            fill(209, 189, 117);            // eyes            ellipse(chomusukeX + 45, chomusukeY - 5, 30, 43);            ellipse(chomusukeX - 45, chomusukeY - 5, 30, 43);            stroke(bodyColor);            fill(191, 132, 122);            // mouth            triangle(chomusukeX + 0, chomusukeY + 30, chomusukeX + 10, chomusukeY + 48, chomusukeX - 10, chomusukeY + 48);            stroke(bodyColor);            fill(206, 8, 44);            // cross            quad(chomusukeX - 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 65, chomusukeX - 5, chomusukeY - 65);            quad(chomusukeX - 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 53, chomusukeX - 13, chomusukeY - 53);        } else {        }    // mouseButton inspired by Liz Rutledge https://www.openprocessing.org/sketch/33428#    }}',correct
'chomusukeY + 40',correct
'fill(61, 60, 59);',correct
'rectMode(CENTER)',correct
'mouseButton == RIGHT',correct
'fill(76, 53, 32);',correct
'chomusukeX - 90',correct
'backgroundHueOffset = 100;',correct
'mouseButton == LEFT',correct
'chomusukeY + 55',correct
'// background inspired by ansgar and student assisstensstroke(bodyColor);',correct
'chomusukeY + 58',correct
'quad(chomusukeX - 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 53, chomusukeX - 13, chomusukeY - 53)',correct
'rectMode(CENTER);',correct
'noStroke()',correct
'{    chomusukeX = mouseX;    chomusukeY = mouseY;    stroke(bodyColor);    fill(255, 0, 0);    ellipse(chomusukeX + 45, chomusukeY - 5, 30, 43);    ellipse(chomusukeX - 45, chomusukeY - 5, 30, 43);    stroke(bodyColor);    fill(0, 0, 0);    quad(chomusukeX - 20, chomusukeY - 20, chomusukeX - 15, chomusukeY - 30, chomusukeX - 45, chomusukeY - 50, chomusukeX - 45, chomusukeY - 40);    quad(chomusukeX + 20, chomusukeY - 20, chomusukeX + 15, chomusukeY - 30, chomusukeX + 45, chomusukeY - 50, chomusukeX + 45, chomusukeY - 40);}',correct
'chomusukeY + 170',correct
'colorMode(RGB, 255, 255, 255)',correct
'chomusukeX + 20',correct
'fill(206, 8, 44)',correct
'chomusukeY + 180',correct
'quad(chomusukeX - 130, chomusukeY + 180, chomusukeX + 11, chomusukeY + 180, chomusukeX + 31, chomusukeY + 70, chomusukeX - 45, chomusukeY + 65);',correct
'chomusukeX - 122',correct
'triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 32, chomusukeY + 100, chomusukeX + 30, chomusukeY + 75);',correct
'Chomusuke h1;',ShortVariable
'{    colorMode(HSB, 100, 100, 100);    for (int i = 0; i <= 100; i++) {        background((i + backgroundHueOffset) % 100, 100, 100);    }    colorMode(RGB, 255, 255, 255);    if (backgroundHueOffset >= 0 && backgroundHueOffset <= 100) {        backgroundHueOffset += backgroundHueChange;    } else if (backgroundHueOffset > 100) {        backgroundHueOffset = 0;    } else {        backgroundHueOffset = 100;    }    // background inspired by ansgar and student assisstens    stroke(bodyColor);    fill(76, 53, 32);    // body    noStroke();    quad(chomusukeX - 130, chomusukeY + 180, chomusukeX + 11, chomusukeY + 180, chomusukeX + 31, chomusukeY + 70, chomusukeX - 45, chomusukeY + 65);    triangle(chomusukeX - 130, chomusukeY + 180, chomusukeX - 76, chomusukeY + 96, chomusukeX - 40, chomusukeY + 60);    stroke(0);    ellipse(chomusukeX, chomusukeY, 180, 150);    triangle(chomusukeX + 40, chomusukeY - 66, chomusukeX + 90, chomusukeY - 75, chomusukeX + 85, chomusukeY - 25);    triangle(chomusukeX - 40, chomusukeY - 66, chomusukeX - 90, chomusukeY - 75, chomusukeX - 85, chomusukeY - 25);    bezier(chomusukeX + 30, chomusukeY + 70, chomusukeX + 30, chomusukeY + 140, chomusukeX + 40, chomusukeY + 120, chomusukeX + 10, chomusukeY + 180);    bezier(chomusukeX - 45, chomusukeY + 65, chomusukeX - 50, chomusukeY + 65, chomusukeX - 60, chomusukeY + 75, chomusukeX - 75, chomusukeY + 95);    bezier(chomusukeX - 75, chomusukeY + 95, chomusukeX - 130, chomusukeY + 110, chomusukeX - 133, chomusukeY + 160, chomusukeX - 130, chomusukeY + 180);    bezier(chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX + 10, chomusukeY + 180);    bezier(chomusukeX - 122, chomusukeY + 130, chomusukeX - 150, chomusukeY + 40, chomusukeX - 230, chomusukeY + 60, chomusukeX - 130, chomusukeY + 150);    line(chomusukeX - 65, chomusukeY + 180, chomusukeX - 60, chomusukeY + 170);    line(chomusukeX - 45, chomusukeY + 180, chomusukeX - 60, chomusukeY + 140);    line(chomusukeX - 25, chomusukeY + 180, chomusukeX - 18, chomusukeY + 130);    bezier(chomusukeX - 25, chomusukeY + 170, chomusukeX - 10, chomusukeY + 165, chomusukeX + 5, chomusukeY + 155, chomusukeX + 10, chomusukeY + 145);    line(chomusukeX - 10, chomusukeY + 180, chomusukeX - 10, chomusukeY + 165);    stroke(bodyColor);    fill(61, 60, 59);    // wings    triangle(chomusukeX - 90, chomusukeY + 35, chomusukeX - 110, chomusukeY + 70, chomusukeX - 70, chomusukeY + 58);    triangle(chomusukeX - 85, chomusukeY + 40, chomusukeX - 90, chomusukeY + 80, chomusukeX - 60, chomusukeY + 68);    triangle(chomusukeX - 75, chomusukeY + 55, chomusukeX - 75, chomusukeY + 85, chomusukeX - 55, chomusukeY + 70);    triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 65, chomusukeY + 100, chomusukeX + 30, chomusukeY + 80);    triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 32, chomusukeY + 100, chomusukeX + 30, chomusukeY + 75);    stroke(bodyColor);    fill(209, 189, 117);    // eyes    ellipse(chomusukeX + 45, chomusukeY - 5, 30, 43);    ellipse(chomusukeX - 45, chomusukeY - 5, 30, 43);    stroke(bodyColor);    fill(191, 132, 122);    // mouth    triangle(chomusukeX + 0, chomusukeY + 30, chomusukeX + 10, chomusukeY + 48, chomusukeX - 10, chomusukeY + 48);    stroke(bodyColor);    fill(206, 8, 44);    // cross    quad(chomusukeX - 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 65, chomusukeX - 5, chomusukeY - 65);    quad(chomusukeX - 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 53, chomusukeX - 13, chomusukeY - 53);}',LongMethodRule
'chomusukeX + 15',correct
'fill(191, 132, 122)',correct
'chomusukeX + 13',correct
'h1.pressMouse();',correct
'chomusukeX + 10',correct
'fill(76, 53, 32)',correct
'chomusukeX + 11',correct
'pressMouse',LongMethodRule
'triangle(chomusukeX - 75, chomusukeY + 55, chomusukeX - 75, chomusukeY + 85, chomusukeX - 55, chomusukeY + 70);',correct
'ellipse(chomusukeX + 45, chomusukeY - 5, 30, 43)',correct
'chomusukeX - 110',correct
'chomusukeX - 230',correct
'height / 2',correct
'chomusukeY + 35',correct
'Chomusuke() {    chomusukeX = width / 2;    chomusukeY = height / 2;}',correct
'chomusukeY + 30',correct
'{    if (mouseButton == LEFT) {        chomusukeX = mouseX;        chomusukeY = mouseY;        stroke(bodyColor);        fill(255, 0, 0);        ellipse(chomusukeX + 45, chomusukeY - 5, 30, 43);        ellipse(chomusukeX - 45, chomusukeY - 5, 30, 43);        stroke(bodyColor);        fill(0, 0, 0);        quad(chomusukeX - 20, chomusukeY - 20, chomusukeX - 15, chomusukeY - 30, chomusukeX - 45, chomusukeY - 50, chomusukeX - 45, chomusukeY - 40);        quad(chomusukeX + 20, chomusukeY - 20, chomusukeX + 15, chomusukeY - 30, chomusukeX + 45, chomusukeY - 50, chomusukeX + 45, chomusukeY - 40);    } else if (mouseButton == RIGHT) {        PImage img;        img = loadImage("meguminpic.jpg");        image(img, 0, 0);        // https://steamcommunity.com/workshop/filedetails/?id=702060467 by MrKenziv        stroke(bodyColor);        fill(76, 53, 32);        // body        noStroke();        quad(chomusukeX - 130, chomusukeY + 180, chomusukeX + 11, chomusukeY + 180, chomusukeX + 31, chomusukeY + 70, chomusukeX - 45, chomusukeY + 65);        triangle(chomusukeX - 130, chomusukeY + 180, chomusukeX - 76, chomusukeY + 96, chomusukeX - 40, chomusukeY + 60);        stroke(0);        ellipse(chomusukeX, chomusukeY, 180, 150);        triangle(chomusukeX + 40, chomusukeY - 66, chomusukeX + 90, chomusukeY - 75, chomusukeX + 85, chomusukeY - 25);        triangle(chomusukeX - 40, chomusukeY - 66, chomusukeX - 90, chomusukeY - 75, chomusukeX - 85, chomusukeY - 25);        bezier(chomusukeX + 30, chomusukeY + 70, chomusukeX + 30, chomusukeY + 140, chomusukeX + 40, chomusukeY + 120, chomusukeX + 10, chomusukeY + 180);        bezier(chomusukeX - 45, chomusukeY + 65, chomusukeX - 50, chomusukeY + 65, chomusukeX - 60, chomusukeY + 75, chomusukeX - 75, chomusukeY + 95);        bezier(chomusukeX - 75, chomusukeY + 95, chomusukeX - 130, chomusukeY + 110, chomusukeX - 133, chomusukeY + 160, chomusukeX - 130, chomusukeY + 180);        bezier(chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX + 10, chomusukeY + 180);        bezier(chomusukeX - 122, chomusukeY + 130, chomusukeX - 150, chomusukeY + 40, chomusukeX - 230, chomusukeY + 60, chomusukeX - 130, chomusukeY + 150);        line(chomusukeX - 65, chomusukeY + 180, chomusukeX - 60, chomusukeY + 170);        line(chomusukeX - 45, chomusukeY + 180, chomusukeX - 60, chomusukeY + 140);        line(chomusukeX - 25, chomusukeY + 180, chomusukeX - 18, chomusukeY + 130);        bezier(chomusukeX - 25, chomusukeY + 170, chomusukeX - 10, chomusukeY + 165, chomusukeX + 5, chomusukeY + 155, chomusukeX + 10, chomusukeY + 145);        line(chomusukeX - 10, chomusukeY + 180, chomusukeX - 10, chomusukeY + 165);        stroke(bodyColor);        fill(61, 60, 59);        // wings        triangle(chomusukeX - 90, chomusukeY + 35, chomusukeX - 110, chomusukeY + 70, chomusukeX - 70, chomusukeY + 58);        triangle(chomusukeX - 85, chomusukeY + 40, chomusukeX - 90, chomusukeY + 80, chomusukeX - 60, chomusukeY + 68);        triangle(chomusukeX - 75, chomusukeY + 55, chomusukeX - 75, chomusukeY + 85, chomusukeX - 55, chomusukeY + 70);        triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 65, chomusukeY + 100, chomusukeX + 30, chomusukeY + 80);        triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 32, chomusukeY + 100, chomusukeX + 30, chomusukeY + 75);        stroke(bodyColor);        fill(209, 189, 117);        // eyes        ellipse(chomusukeX + 45, chomusukeY - 5, 30, 43);        ellipse(chomusukeX - 45, chomusukeY - 5, 30, 43);        stroke(bodyColor);        fill(191, 132, 122);        // mouth        triangle(chomusukeX + 0, chomusukeY + 30, chomusukeX + 10, chomusukeY + 48, chomusukeX - 10, chomusukeY + 48);        stroke(bodyColor);        fill(206, 8, 44);        // cross        quad(chomusukeX - 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 65, chomusukeX - 5, chomusukeY - 65);        quad(chomusukeX - 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 53, chomusukeX - 13, chomusukeY - 53);    } else {    }// mouseButton inspired by Liz Rutledge https://www.openprocessing.org/sketch/33428#}',LongMethodRule
'chomusukeY = mouseY;',DecentralizedEventHandlingRule
'chomusukeX + 40',correct
'bezier(chomusukeX - 75, chomusukeY + 95, chomusukeX - 130, chomusukeY + 110, chomusukeX - 133, chomusukeY + 160, chomusukeX - 130, chomusukeY + 180)',correct
'line(chomusukeX - 65, chomusukeY + 180, chomusukeX - 60, chomusukeY + 170)',correct
'int bodyColor;',correct
'quad(chomusukeX - 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 53, chomusukeX - 13, chomusukeY - 53);',correct
'h1',correct
'chomusukeX + 45',correct
'bezier(chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX + 10, chomusukeY + 180)',correct
'triangle(chomusukeX - 85, chomusukeY + 40, chomusukeX - 90, chomusukeY + 80, chomusukeX - 60, chomusukeY + 68)',correct
'Processing',correct
'new Chomusuke()',correct
'ellipse(chomusukeX - 45, chomusukeY - 5, 30, 43)',correct
'backgroundHueOffset += backgroundHueChange',correct
'triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 65, chomusukeY + 100, chomusukeX + 30, chomusukeY + 80);',correct
'void pressMouse() {    if (mouseButton == LEFT) {        chomusukeX = mouseX;        chomusukeY = mouseY;        stroke(bodyColor);        fill(255, 0, 0);        ellipse(chomusukeX + 45, chomusukeY - 5, 30, 43);        ellipse(chomusukeX - 45, chomusukeY - 5, 30, 43);        stroke(bodyColor);        fill(0, 0, 0);        quad(chomusukeX - 20, chomusukeY - 20, chomusukeX - 15, chomusukeY - 30, chomusukeX - 45, chomusukeY - 50, chomusukeX - 45, chomusukeY - 40);        quad(chomusukeX + 20, chomusukeY - 20, chomusukeX + 15, chomusukeY - 30, chomusukeX + 45, chomusukeY - 50, chomusukeX + 45, chomusukeY - 40);    } else if (mouseButton == RIGHT) {        PImage img;        img = loadImage("meguminpic.jpg");        image(img, 0, 0);        // https://steamcommunity.com/workshop/filedetails/?id=702060467 by MrKenziv        stroke(bodyColor);        fill(76, 53, 32);        // body        noStroke();        quad(chomusukeX - 130, chomusukeY + 180, chomusukeX + 11, chomusukeY + 180, chomusukeX + 31, chomusukeY + 70, chomusukeX - 45, chomusukeY + 65);        triangle(chomusukeX - 130, chomusukeY + 180, chomusukeX - 76, chomusukeY + 96, chomusukeX - 40, chomusukeY + 60);        stroke(0);        ellipse(chomusukeX, chomusukeY, 180, 150);        triangle(chomusukeX + 40, chomusukeY - 66, chomusukeX + 90, chomusukeY - 75, chomusukeX + 85, chomusukeY - 25);        triangle(chomusukeX - 40, chomusukeY - 66, chomusukeX - 90, chomusukeY - 75, chomusukeX - 85, chomusukeY - 25);        bezier(chomusukeX + 30, chomusukeY + 70, chomusukeX + 30, chomusukeY + 140, chomusukeX + 40, chomusukeY + 120, chomusukeX + 10, chomusukeY + 180);        bezier(chomusukeX - 45, chomusukeY + 65, chomusukeX - 50, chomusukeY + 65, chomusukeX - 60, chomusukeY + 75, chomusukeX - 75, chomusukeY + 95);        bezier(chomusukeX - 75, chomusukeY + 95, chomusukeX - 130, chomusukeY + 110, chomusukeX - 133, chomusukeY + 160, chomusukeX - 130, chomusukeY + 180);        bezier(chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX + 10, chomusukeY + 180);        bezier(chomusukeX - 122, chomusukeY + 130, chomusukeX - 150, chomusukeY + 40, chomusukeX - 230, chomusukeY + 60, chomusukeX - 130, chomusukeY + 150);        line(chomusukeX - 65, chomusukeY + 180, chomusukeX - 60, chomusukeY + 170);        line(chomusukeX - 45, chomusukeY + 180, chomusukeX - 60, chomusukeY + 140);        line(chomusukeX - 25, chomusukeY + 180, chomusukeX - 18, chomusukeY + 130);        bezier(chomusukeX - 25, chomusukeY + 170, chomusukeX - 10, chomusukeY + 165, chomusukeX + 5, chomusukeY + 155, chomusukeX + 10, chomusukeY + 145);        line(chomusukeX - 10, chomusukeY + 180, chomusukeX - 10, chomusukeY + 165);        stroke(bodyColor);        fill(61, 60, 59);        // wings        triangle(chomusukeX - 90, chomusukeY + 35, chomusukeX - 110, chomusukeY + 70, chomusukeX - 70, chomusukeY + 58);        triangle(chomusukeX - 85, chomusukeY + 40, chomusukeX - 90, chomusukeY + 80, chomusukeX - 60, chomusukeY + 68);        triangle(chomusukeX - 75, chomusukeY + 55, chomusukeX - 75, chomusukeY + 85, chomusukeX - 55, chomusukeY + 70);        triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 65, chomusukeY + 100, chomusukeX + 30, chomusukeY + 80);        triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 32, chomusukeY + 100, chomusukeX + 30, chomusukeY + 75);        stroke(bodyColor);        fill(209, 189, 117);        // eyes        ellipse(chomusukeX + 45, chomusukeY - 5, 30, 43);        ellipse(chomusukeX - 45, chomusukeY - 5, 30, 43);        stroke(bodyColor);        fill(191, 132, 122);        // mouth        triangle(chomusukeX + 0, chomusukeY + 30, chomusukeX + 10, chomusukeY + 48, chomusukeX - 10, chomusukeY + 48);        stroke(bodyColor);        fill(206, 8, 44);        // cross        quad(chomusukeX - 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 65, chomusukeX - 5, chomusukeY - 65);        quad(chomusukeX - 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 53, chomusukeX - 13, chomusukeY - 53);    } else {    }// mouseButton inspired by Liz Rutledge https://www.openprocessing.org/sketch/33428#}',correct
'float backgroundHueOffset = 0;',correct
'// https://steamcommunity.com/workshop/filedetails/?id=702060467 by MrKenzivstroke(bodyColor);',correct
'chomusukeX = mouseX;',DecentralizedEventHandlingRule
'ellipse(chomusukeX, chomusukeY, 180, 150);',correct
'bezier(chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX + 10, chomusukeY + 180);',correct
'chomusukeX + 32',correct
'chomusukeX + 30',correct
'img = loadImage("meguminpic.jpg")',correct
'chomusukeX + 31',correct
'chomusukeX - 130',correct
'bezier(chomusukeX - 25, chomusukeY + 170, chomusukeX - 10, chomusukeY + 165, chomusukeX + 5, chomusukeY + 155, chomusukeX + 10, chomusukeY + 145);',correct
'ellipseMode(CENTER);',correct
'int i = 0',correct
'chomusukeX - 5',correct
'PImage img',correct
'// bodynoStroke();',correct
'triangle(chomusukeX - 85, chomusukeY + 40, chomusukeX - 90, chomusukeY + 80, chomusukeX - 60, chomusukeY + 68);',correct
'stroke(bodyColor);',correct
'background((i + backgroundHueOffset) % 100, 100, 100)',correct
'triangle(chomusukeX + 0, chomusukeY + 30, chomusukeX + 10, chomusukeY + 48, chomusukeX - 10, chomusukeY + 48)',correct
'chomusukeX - 133',correct
'{    background((i + backgroundHueOffset) % 100, 100, 100);}',correct
'i = 0',correct
'backgroundHueOffset >= 0 && backgroundHueOffset <= 100',correct
'chomusukeY',correct
'chomusukeX',correct
'chomusukeY + 130',correct
'line(chomusukeX - 10, chomusukeY + 180, chomusukeX - 10, chomusukeY + 165);',correct
'{    backgroundHueOffset = 100;}',correct
'quad(chomusukeX - 20, chomusukeY - 20, chomusukeX - 15, chomusukeY - 30, chomusukeX - 45, chomusukeY - 50, chomusukeX - 45, chomusukeY - 40)',correct
'triangle(chomusukeX - 75, chomusukeY + 55, chomusukeX - 75, chomusukeY + 85, chomusukeX - 55, chomusukeY + 70)',correct
'chomusukeX + 65',correct
'background((i + backgroundHueOffset) % 100, 100, 100);',correct
'bezier(chomusukeX - 45, chomusukeY + 65, chomusukeX - 50, chomusukeY + 65, chomusukeX - 60, chomusukeY + 75, chomusukeX - 75, chomusukeY + 95)',correct
'chomusukeX + 50',correct
'void display() {    colorMode(HSB, 100, 100, 100);    for (int i = 0; i <= 100; i++) {        background((i + backgroundHueOffset) % 100, 100, 100);    }    colorMode(RGB, 255, 255, 255);    if (backgroundHueOffset >= 0 && backgroundHueOffset <= 100) {        backgroundHueOffset += backgroundHueChange;    } else if (backgroundHueOffset > 100) {        backgroundHueOffset = 0;    } else {        backgroundHueOffset = 100;    }    // background inspired by ansgar and student assisstens    stroke(bodyColor);    fill(76, 53, 32);    // body    noStroke();    quad(chomusukeX - 130, chomusukeY + 180, chomusukeX + 11, chomusukeY + 180, chomusukeX + 31, chomusukeY + 70, chomusukeX - 45, chomusukeY + 65);    triangle(chomusukeX - 130, chomusukeY + 180, chomusukeX - 76, chomusukeY + 96, chomusukeX - 40, chomusukeY + 60);    stroke(0);    ellipse(chomusukeX, chomusukeY, 180, 150);    triangle(chomusukeX + 40, chomusukeY - 66, chomusukeX + 90, chomusukeY - 75, chomusukeX + 85, chomusukeY - 25);    triangle(chomusukeX - 40, chomusukeY - 66, chomusukeX - 90, chomusukeY - 75, chomusukeX - 85, chomusukeY - 25);    bezier(chomusukeX + 30, chomusukeY + 70, chomusukeX + 30, chomusukeY + 140, chomusukeX + 40, chomusukeY + 120, chomusukeX + 10, chomusukeY + 180);    bezier(chomusukeX - 45, chomusukeY + 65, chomusukeX - 50, chomusukeY + 65, chomusukeX - 60, chomusukeY + 75, chomusukeX - 75, chomusukeY + 95);    bezier(chomusukeX - 75, chomusukeY + 95, chomusukeX - 130, chomusukeY + 110, chomusukeX - 133, chomusukeY + 160, chomusukeX - 130, chomusukeY + 180);    bezier(chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX + 10, chomusukeY + 180);    bezier(chomusukeX - 122, chomusukeY + 130, chomusukeX - 150, chomusukeY + 40, chomusukeX - 230, chomusukeY + 60, chomusukeX - 130, chomusukeY + 150);    line(chomusukeX - 65, chomusukeY + 180, chomusukeX - 60, chomusukeY + 170);    line(chomusukeX - 45, chomusukeY + 180, chomusukeX - 60, chomusukeY + 140);    line(chomusukeX - 25, chomusukeY + 180, chomusukeX - 18, chomusukeY + 130);    bezier(chomusukeX - 25, chomusukeY + 170, chomusukeX - 10, chomusukeY + 165, chomusukeX + 5, chomusukeY + 155, chomusukeX + 10, chomusukeY + 145);    line(chomusukeX - 10, chomusukeY + 180, chomusukeX - 10, chomusukeY + 165);    stroke(bodyColor);    fill(61, 60, 59);    // wings    triangle(chomusukeX - 90, chomusukeY + 35, chomusukeX - 110, chomusukeY + 70, chomusukeX - 70, chomusukeY + 58);    triangle(chomusukeX - 85, chomusukeY + 40, chomusukeX - 90, chomusukeY + 80, chomusukeX - 60, chomusukeY + 68);    triangle(chomusukeX - 75, chomusukeY + 55, chomusukeX - 75, chomusukeY + 85, chomusukeX - 55, chomusukeY + 70);    triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 65, chomusukeY + 100, chomusukeX + 30, chomusukeY + 80);    triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 32, chomusukeY + 100, chomusukeX + 30, chomusukeY + 75);    stroke(bodyColor);    fill(209, 189, 117);    // eyes    ellipse(chomusukeX + 45, chomusukeY - 5, 30, 43);    ellipse(chomusukeX - 45, chomusukeY - 5, 30, 43);    stroke(bodyColor);    fill(191, 132, 122);    // mouth    triangle(chomusukeX + 0, chomusukeY + 30, chomusukeX + 10, chomusukeY + 48, chomusukeX - 10, chomusukeY + 48);    stroke(bodyColor);    fill(206, 8, 44);    // cross    quad(chomusukeX - 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 65, chomusukeX - 5, chomusukeY - 65);    quad(chomusukeX - 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 53, chomusukeX - 13, chomusukeY - 53);}',correct
'chomusukeY + 140',correct
'chomusukeY + 145',correct
'bezier(chomusukeX - 122, chomusukeY + 130, chomusukeX - 150, chomusukeY + 40, chomusukeX - 230, chomusukeY + 60, chomusukeX - 130, chomusukeY + 150);',correct
'triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 65, chomusukeY + 100, chomusukeX + 30, chomusukeY + 80)',correct
'void setup() {    rectMode(CENTER);    ellipseMode(CENTER);    h1 = new Chomusuke();}',correct
'if (backgroundHueOffset > 100) {    backgroundHueOffset = 0;} else {    backgroundHueOffset = 100;}',correct
'image(img, 0, 0);',correct
'chomusukeX - 20',correct
'chomusukeY + 150',correct
'triangle(chomusukeX - 40, chomusukeY - 66, chomusukeX - 90, chomusukeY - 75, chomusukeX - 85, chomusukeY - 25)',correct
'chomusukeY + 155',correct
'{    chomusukeX = width / 2;    chomusukeY = height / 2;}',correct
'h1.pressMouse()',correct
'chomusukeX - 25',correct
'h1.display();',correct
'chomusukeX + 85',correct
'// mouseButton inspired by Liz Rutledge https://www.openprocessing.org/sketch/33428#',correct
'fill(206, 8, 44);',correct
'bezier(chomusukeX - 122, chomusukeY + 130, chomusukeX - 150, chomusukeY + 40, chomusukeX - 230, chomusukeY + 60, chomusukeX - 130, chomusukeY + 150)',correct
'chomusukeY - 66',correct
'chomusukeX = mouseX',correct
'quad(chomusukeX + 20, chomusukeY - 20, chomusukeX + 15, chomusukeY - 30, chomusukeX + 45, chomusukeY - 50, chomusukeX + 45, chomusukeY - 40)',correct
'img = loadImage("meguminpic.jpg");',correct
'"meguminpic.jpg"',correct
'ellipse(chomusukeX + 45, chomusukeY - 5, 30, 43);',correct
'0.5f',correct
'chomusukeY - 65',correct
'chomusukeY + 160',correct
'display',LongMethodRule
'chomusukeY + 165',correct
'(i + backgroundHueOffset) % 100',correct
'chomusukeX - 15',correct
'chomusukeX - 13',correct
'quad(chomusukeX + 20, chomusukeY - 20, chomusukeX + 15, chomusukeY - 30, chomusukeX + 45, chomusukeY - 50, chomusukeX + 45, chomusukeY - 40);',correct
'chomusukeX - 10',correct
'chomusukeX + 5',correct
'backgroundHueOffset > 100',correct
'chomusukeX - 18',correct
'backgroundHueOffset = 0;',correct
'chomusukeY - 75',correct
'loadImage("meguminpic.jpg")',correct
'chomusukeX + 0',correct
'// crossquad(chomusukeX - 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 65, chomusukeX - 5, chomusukeY - 65);',correct
'line(chomusukeX - 65, chomusukeY + 180, chomusukeX - 60, chomusukeY + 170);',correct
'triangle(chomusukeX - 90, chomusukeY + 35, chomusukeX - 110, chomusukeY + 70, chomusukeX - 70, chomusukeY + 58)',correct
'chomusukeX - 40',correct
'fill(255, 0, 0)',correct
'i++',correct
'line(chomusukeX - 45, chomusukeY + 180, chomusukeX - 60, chomusukeY + 140);',correct
'{    backgroundHueOffset = 0;}',correct
'chomusukeX - 45',correct
'if (mouseButton == RIGHT) {    PImage img;    img = loadImage("meguminpic.jpg");    image(img, 0, 0);    // https://steamcommunity.com/workshop/filedetails/?id=702060467 by MrKenziv    stroke(bodyColor);    fill(76, 53, 32);    // body    noStroke();    quad(chomusukeX - 130, chomusukeY + 180, chomusukeX + 11, chomusukeY + 180, chomusukeX + 31, chomusukeY + 70, chomusukeX - 45, chomusukeY + 65);    triangle(chomusukeX - 130, chomusukeY + 180, chomusukeX - 76, chomusukeY + 96, chomusukeX - 40, chomusukeY + 60);    stroke(0);    ellipse(chomusukeX, chomusukeY, 180, 150);    triangle(chomusukeX + 40, chomusukeY - 66, chomusukeX + 90, chomusukeY - 75, chomusukeX + 85, chomusukeY - 25);    triangle(chomusukeX - 40, chomusukeY - 66, chomusukeX - 90, chomusukeY - 75, chomusukeX - 85, chomusukeY - 25);    bezier(chomusukeX + 30, chomusukeY + 70, chomusukeX + 30, chomusukeY + 140, chomusukeX + 40, chomusukeY + 120, chomusukeX + 10, chomusukeY + 180);    bezier(chomusukeX - 45, chomusukeY + 65, chomusukeX - 50, chomusukeY + 65, chomusukeX - 60, chomusukeY + 75, chomusukeX - 75, chomusukeY + 95);    bezier(chomusukeX - 75, chomusukeY + 95, chomusukeX - 130, chomusukeY + 110, chomusukeX - 133, chomusukeY + 160, chomusukeX - 130, chomusukeY + 180);    bezier(chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX - 130, chomusukeY + 180, chomusukeX + 10, chomusukeY + 180);    bezier(chomusukeX - 122, chomusukeY + 130, chomusukeX - 150, chomusukeY + 40, chomusukeX - 230, chomusukeY + 60, chomusukeX - 130, chomusukeY + 150);    line(chomusukeX - 65, chomusukeY + 180, chomusukeX - 60, chomusukeY + 170);    line(chomusukeX - 45, chomusukeY + 180, chomusukeX - 60, chomusukeY + 140);    line(chomusukeX - 25, chomusukeY + 180, chomusukeX - 18, chomusukeY + 130);    bezier(chomusukeX - 25, chomusukeY + 170, chomusukeX - 10, chomusukeY + 165, chomusukeX + 5, chomusukeY + 155, chomusukeX + 10, chomusukeY + 145);    line(chomusukeX - 10, chomusukeY + 180, chomusukeX - 10, chomusukeY + 165);    stroke(bodyColor);    fill(61, 60, 59);    // wings    triangle(chomusukeX - 90, chomusukeY + 35, chomusukeX - 110, chomusukeY + 70, chomusukeX - 70, chomusukeY + 58);    triangle(chomusukeX - 85, chomusukeY + 40, chomusukeX - 90, chomusukeY + 80, chomusukeX - 60, chomusukeY + 68);    triangle(chomusukeX - 75, chomusukeY + 55, chomusukeX - 75, chomusukeY + 85, chomusukeX - 55, chomusukeY + 70);    triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 65, chomusukeY + 100, chomusukeX + 30, chomusukeY + 80);    triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 32, chomusukeY + 100, chomusukeX + 30, chomusukeY + 75);    stroke(bodyColor);    fill(209, 189, 117);    // eyes    ellipse(chomusukeX + 45, chomusukeY - 5, 30, 43);    ellipse(chomusukeX - 45, chomusukeY - 5, 30, 43);    stroke(bodyColor);    fill(191, 132, 122);    // mouth    triangle(chomusukeX + 0, chomusukeY + 30, chomusukeX + 10, chomusukeY + 48, chomusukeX - 10, chomusukeY + 48);    stroke(bodyColor);    fill(206, 8, 44);    // cross    quad(chomusukeX - 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 30, chomusukeX + 5, chomusukeY - 65, chomusukeX - 5, chomusukeY - 65);    quad(chomusukeX - 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 43, chomusukeX + 13, chomusukeY - 53, chomusukeX - 13, chomusukeY - 53);} else {}',DecentralizedEventHandlingRule
'ellipseMode(CENTER)',correct
'if (backgroundHueOffset >= 0 && backgroundHueOffset <= 100) {    backgroundHueOffset += backgroundHueChange;} else if (backgroundHueOffset > 100) {    backgroundHueOffset = 0;} else {    backgroundHueOffset = 100;}',correct
'colorMode(RGB, 255, 255, 255);',correct
'i <= 100',correct
'chomusukeY - 43',correct
'backgroundHueChange = 0.5f',correct
'chomusukeY - 40',correct
'chomusukeY = height / 2;',correct
'triangle(chomusukeX + 50, chomusukeY + 68, chomusukeX + 32, chomusukeY + 100, chomusukeX + 30, chomusukeY + 75)',correct
'void',LongMethodRule
'fill(191, 132, 122);',correct
'chomusukeX + 90',correct
'chomusukeY + 100',correct
'backgroundHueOffset <= 100',correct
'ellipse(chomusukeX, chomusukeY, 180, 150)',correct
'quad(chomusukeX - 20, chomusukeY - 20, chomusukeX - 15, chomusukeY - 30, chomusukeX - 45, chomusukeY - 50, chomusukeX - 45, chomusukeY - 40);',correct
'bezier(chomusukeX + 30, chomusukeY + 70, chomusukeX + 30, chomusukeY + 140, chomusukeX + 40, chomusukeY + 120, chomusukeX + 10, chomusukeY + 180);',correct
'{    rectMode(CENTER);    ellipseMode(CENTER);    h1 = new Chomusuke();}',correct
'chomusukeX = width / 2;',correct
'chomusukeY = height / 2',correct
'chomusukeY - 50',correct
'h1.display()',correct
'backgroundHueOffset >= 0',correct
'chomusukeY - 53',correct
'colorMode(HSB, 100, 100, 100);',correct
'chomusukeX = width / 2',correct
'img',correct
'bodyColor',correct
'fill(61, 60, 59)',correct
'chomusukeX - 60',correct
'chomusukeY + 110',correct
'fill(0, 0, 0);',correct
'for (int i = 0; i <= 100; i++) {    background((i + backgroundHueOffset) % 100, 100, 100);}',correct
'ellipse(chomusukeX - 45, chomusukeY - 5, 30, 43);',correct
'chomusukeX - 65',correct
'chomusukeY - 25',correct
'line(chomusukeX - 10, chomusukeY + 180, chomusukeX - 10, chomusukeY + 165)',correct
'triangle(chomusukeX - 130, chomusukeY + 180, chomusukeX - 76, chomusukeY + 96, chomusukeX - 40, chomusukeY + 60)',correct
'void draw() {    h1.display();    h1.pressMouse();}',correct
'chomusukeY + 80',correct
'backgroundHueOffset = 0',correct
'chomusukeY - 20',correct
'chomusukeY + 85',correct
'// wingstriangle(chomusukeX - 90, chomusukeY + 35, chomusukeX - 110, chomusukeY + 70, chomusukeX - 70, chomusukeY + 58);',correct
'chomusukeX - 50',correct
'backgroundHueOffset = 100',correct
'chomusukeY + 120',correct
'image(img, 0, 0)',correct
'bezier(chomusukeX - 75, chomusukeY + 95, chomusukeX - 130, chomusukeY + 110, chomusukeX - 133, chomusukeY + 160, chomusukeX - 130, chomusukeY + 180);',correct
'chomusukeX - 55',correct
'width / 2',correct
'h1 = new Chomusuke();',correct
'{    backgroundHueOffset += backgroundHueChange;}',correct
'{    h1.display();    h1.pressMouse();}',correct
'backgroundHueOffset += backgroundHueChange;',correct
'triangle(chomusukeX + 40, chomusukeY - 66, chomusukeX + 90, chomusukeY - 75, chomusukeX + 85, chomusukeY - 25)',correct
'// mouthtriangle(chomusukeX + 0, chomusukeY + 30, chomusukeX + 10, chomusukeY + 48, chomusukeX - 10, chomusukeY + 48);',correct
'chomusukeY + 95',correct
'h1 = new Chomusuke()',correct
'chomusukeY + 96',correct
'chomusukeY - 30',correct
'koala = new Koala()',correct
'koalaX',correct
'koalaY',correct
'koalaY - 72',correct
'new Koala()',correct
'{    koala.bodyColorA = color(209);    koala.mouthColorA = color(209);    leaf.leafColor = 0xff628B50;    leaf.leafXspeed = random(1, 3);    leaf.leafYspeed = random(1, 3);}',correct
'ellipse(koalaX + 55, koalaY - 83, 70, 50);',correct
'koala.bodyColorA = koala.bodyColorB;',correct
'{    koala.cheekColor = koala.cheekColor + 5;    if (koala.cheekColor > 209) {        koala.cheekColor = color(255, 214, 227);    }}',correct
'leafX + 30',correct
'leaf.display()',correct
'new Leaves()',correct
'Koala() {    // Koalas location    koalaX = width / 2;    koalaY = height / 2;    // Koalas colours    bodyColorA = color(209);    bodyColorB = color(162, 183, 216);    mouthColorA = bodyColorA;    mouthColorB = 0xffF2C4E5;    cheekColor = color(255, 214, 227);}',correct
'{    leafXspeed = leafXspeed * -1;}',correct
'ellipse(leafX + 10, leafY + 10, 3, 40)',correct
'stroke(0);',correct
'new Leaves[10]',correct
'stroke(0)',correct
'stroke(cheekColor);',correct
'// Koalas locationkoalaX = width / 2;',correct
'leafYspeed = leafYspeed * -1;',correct
'koalaY - 83',correct
'{    background(0xffFFF4B7);    koala.display();    leaf.display();    for (int i = 0; i < leaves.length; i++) {        leaves[i].display();    }}',correct
'ellipse(koalaX + 55, koalaY - 83, 70, 50)',correct
'koalaX + 50',correct
'koalaX + 55',correct
'leaf.moveIt(mouseX, mouseY);',correct
'koala.bodyColorB',correct
'leafYspeed = random(1, 5)',correct
'koala.bodyColorA',correct
'{    leafY = yMouse;}',correct
'{    // Koalas location    koalaX = width / 2;    koalaY = height / 2;    // Koalas colours    bodyColorA = color(209);    bodyColorB = color(162, 183, 216);    mouthColorA = bodyColorA;    mouthColorB = 0xffF2C4E5;    cheekColor = color(255, 214, 227);}',correct
'leaf.leafXspeed = random(1, 3)',correct
'koalaY - 58',correct
'koala.cheekColor = koala.cheekColor + 5',correct
'leaf.moveIt(mouseX, mouseY)',correct
'leaf.leafColor = 0xff628B50',correct
'ellipse(koalaX + 55, koalaY - 111, 80, 60)',correct
'random(1, 4)',correct
'spacingY = 7',correct
'mouthColorB',correct
'koala.cheekColor',correct
'{    koalaX = xMouse;}',correct
'for (float leafx = leafX; leafx < leafX + 30; leafx += spacingX) {    stroke(0);    ellipse(leafx, leafy, 20, 5);}',correct
'fill(cheekColor)',correct
'koala.moveMe(mouseX, mouseY);',correct
'mouthColorA',correct
'ellipse(koalaX + 35, koalaY - 94, 17, 15);',correct
'koala.display();',correct
'leafY + leafYspeed',correct
'(leafX > width) || (leafY < 0)',correct
'koalaY = height / 2;',correct
'if ((yMouse > 83) && (yMouse < height)) {    koalaY = yMouse;}',correct
'ellipse(koalaX, koalaY - 58, 30, 42);',correct
'mouseButton == LEFT',correct
'random(1, 3)',correct
'mouthColorB = 0xffF2C4E5;',correct
'leaves[i].display();',correct
'leaf.leafYspeed = 0',correct
'koala.mouthColorA = koala.bodyColorB;',correct
'bodyColorB = color(162, 183, 216);',correct
'noStroke()',correct
'{    koala.bodyColorA = koala.bodyColorB;    koala.mouthColorA = koala.bodyColorB;    leaf.leafColor = color(0);    leaf.leafXspeed = 0;    leaf.leafYspeed = 0;}',correct
'koalaX = width / 2',correct
'koala.cheekColor = color(255, 214, 227);',correct
'leafy = leafY',correct
'{    if (mouseButton == LEFT) {        koala.moveMe(mouseX, mouseY);    } else {        leaf.moveIt(mouseX, mouseY);        koala.mouthColorA = koala.mouthColorB;    }}',correct
'(leafY > height) || (leafY < 0)',correct
'ellipse(koalaX + 50, koalaY - 72, 35, 25)',correct
'koala.mouthColorA = koala.mouthColorB;',correct
'(yMouse > 83) && (yMouse < height)',correct
'leafY',correct
'leafX',correct
'koala.mouthColorA = koala.bodyColorA;',correct
'koala.mouthColorA = koala.bodyColorA',correct
'koala.mouthColorA = koala.bodyColorB',correct
'float leafXspeed = random(1, 4);',correct
'leafy <= leafY + 25',correct
'Leaves leaf = new Leaves();',correct
'fill(0)',correct
'int koalaY;',correct
'bodyColorA',correct
'height / 2',correct
'bodyColorB',correct
'int cheekColor;',correct
'leaf.leafColor = color(0);',correct
'leaf.leafColor = color(0)',correct
'color(255, 214, 227)',correct
'ellipse(koalaX - 55, koalaY - 83, 70, 50)',correct
'koalaY = height / 2',correct
'leafy += spacingY',correct
'ellipse(koalaX + 35, koalaY - 94, 17, 15)',correct
'float leafY;',correct
'cheekColor = color(255, 214, 227)',correct
'koalaY - 94',correct
'if ((leafY > height) || (leafY < 0)) {    leafYspeed = leafYspeed * -1;}',correct
'Processing',correct
'float leafy = leafY',correct
'fill(leafColor);',correct
'bodyColorA = color(209)',correct
'background(0xffFFF4B7)',correct
'koala.mouthColorA = koala.mouthColorB',correct
'koala.cheekColor = color(255, 214, 227)',correct
'void mouseClicked() {    koala.bodyColorA = koala.bodyColorB;    koala.mouthColorA = koala.bodyColorB;    leaf.leafColor = color(0);    leaf.leafXspeed = 0;    leaf.leafYspeed = 0;}',correct
'leafx < leafX + 30',correct
'{    noStroke();    fill(leafColor);    for (float leafy = leafY; leafy <= leafY + 25; leafy += spacingY) {        for (float leafx = leafX; leafx < leafX + 30; leafx += spacingX) {            stroke(0);            ellipse(leafx, leafy, 20, 5);        }    }    ellipse(leafX + 10, leafY + 10, 3, 40);    leafX = leafX + leafXspeed;    leafY = leafY + leafYspeed;    if ((leafX > width) || (leafY < 0)) {        leafXspeed = leafXspeed * -1;    }    if ((leafY > height) || (leafY < 0)) {        leafYspeed = leafYspeed * -1;    }}',correct
'float leafX;',correct
'leafX = leafX + leafXspeed',correct
'cheekColor',correct
'koalaX + 35',correct
'for (float leafy = leafY; leafy <= leafY + 25; leafy += spacingY) {    for (float leafx = leafX; leafx < leafX + 30; leafx += spacingX) {        stroke(0);        ellipse(leafx, leafy, 20, 5);    }}',correct
'fill(leafColor)',correct
'spacingX = 20',correct
'ellipse(koalaX, koalaY - 58, 30, 42)',correct
'void mouseReleased() {    koala.mouthColorA = koala.bodyColorA;}',correct
'int i = 0',correct
'ellipse(koalaX - 35, koalaY - 94, 17, 15)',correct
'int spacingY = 7;',correct
'ellipse(koalaX, koalaY - 40, 42, 30)',correct
'void draw() {    background(0xffFFF4B7);    koala.display();    leaf.display();    for (int i = 0; i < leaves.length; i++) {        leaves[i].display();    }}',correct
'if (mouseButton == LEFT) {    koala.moveMe(mouseX, mouseY);} else {    leaf.moveIt(mouseX, mouseY);    koala.mouthColorA = koala.mouthColorB;}',correct
'class Leaves {    float leafX;    float leafY;    float leafXspeed = random(1, 4);    float leafYspeed = random(1, 5);    int spacingY = 7;    int spacingX = 20;    int leafColor;    Leaves() {        // nothing yet        leafColor = 0xff628B50;    }    void display() {        noStroke();        fill(leafColor);        for (float leafy = leafY; leafy <= leafY + 25; leafy += spacingY) {            for (float leafx = leafX; leafx < leafX + 30; leafx += spacingX) {                stroke(0);                ellipse(leafx, leafy, 20, 5);            }        }        ellipse(leafX + 10, leafY + 10, 3, 40);        leafX = leafX + leafXspeed;        leafY = leafY + leafYspeed;        if ((leafX > width) || (leafY < 0)) {            leafXspeed = leafXspeed * -1;        }        if ((leafY > height) || (leafY < 0)) {            leafYspeed = leafYspeed * -1;        }    }    void moveIt(int xMouse, int yMouse) {        if ((xMouse > 75) && (xMouse < width - 75)) {            leafX = xMouse;        }        if ((yMouse > 83) && (yMouse < height)) {            leafY = yMouse;        }    }}',correct
'mouthColorB = 0xffF2C4E5',correct
'ellipse(leafx, leafy, 20, 5);',correct
'Leaves[]',correct
'// Ari Lee/*This is a programme of a face of koala which chages its cheekcolor when mouse moved, chages location as dragged by left button of mouse, chages body color when  its clicked. Body color changes back when key pressed. It opens its mouth when the  leaf dragged. 11 leaves are bouncing freely. One leaf chages colour and stops when mouse clicked. The colour changes back and move freely again when key pressed.  It can be dragged with right button of mouse. */Koala koala = new Koala();',correct
'i = 0',correct
'int leafColor;',correct
'int mouthColorB;',correct
'mouthColorA = bodyColorA',correct
'leafX = leafX + leafXspeed;',correct
'koala.moveMe(mouseX, mouseY)',correct
'leaves.length',correct
'if ((xMouse > 75) && (xMouse < width - 75)) {    leafX = xMouse;}',correct
'ellipse(koalaX - 50, koalaY - 72, 35, 25)',correct
'leaf.leafXspeed',correct
'{    leafYspeed = leafYspeed * -1;}',correct
'koala.display()',correct
'int bodyColorB;',correct
'int spacingX = 20;',correct
'leaves[i].display()',correct
'leaf.leafXspeed = random(1, 3);',correct
'mouthColorA = bodyColorA;',correct
'// mouthfill(mouthColorA);',correct
'int mouthColorA;',correct
'leaf.leafYspeed = random(1, 3)',correct
'ellipse(koalaX, koalaY - 40, 42, 30);',correct
'leafY + 25',correct
'for (int i = 0; i < leaves.length; i++) {    leaves[i] = new Leaves();}',correct
'leafYspeed = leafYspeed * -1',correct
'{    koala.mouthColorA = koala.bodyColorA;}',correct
'koala.bodyColorA = koala.bodyColorB',correct
'Leaves[] leaves = new Leaves[10];',correct
'leafY = yMouse;',correct
'koala.mouthColorA = color(209)',correct
'int bodyColorA;',correct
'void setup() {    for (int i = 0; i < leaves.length; i++) {        leaves[i] = new Leaves();    }}',correct
'{    koala.cheekColor = color(255, 214, 227);}',correct
'noStroke();',correct
'{    if ((xMouse > 75) && (xMouse < width - 75)) {        leafX = xMouse;    }    if ((yMouse > 83) && (yMouse < height)) {        leafY = yMouse;    }}',correct
'{    koalaY = yMouse;}',correct
'koala.mouthColorA = color(209);',correct
'void keyPressed() {    koala.bodyColorA = color(209);    koala.mouthColorA = color(209);    leaf.leafColor = 0xff628B50;    leaf.leafXspeed = random(1, 3);    leaf.leafYspeed = random(1, 3);}',correct
'leafColor',correct
'// cheeksfill(cheekColor);',correct
'// nosefill(0);',correct
'void mouseMoved() {    koala.cheekColor = koala.cheekColor + 5;    if (koala.cheekColor > 209) {        koala.cheekColor = color(255, 214, 227);    }}',correct
'leaf.leafXspeed = 0;',correct
'int koalaX;',correct
'leaves[i] = new Leaves();',correct
'koalaY = yMouse;',correct
'color(0)',correct
'i < leaves.length',correct
'if ((yMouse > 83) && (yMouse < height)) {    leafY = yMouse;}',correct
'void mouseDragged() {    if (mouseButton == LEFT) {        koala.moveMe(mouseX, mouseY);    } else {        leaf.moveIt(mouseX, mouseY);        koala.mouthColorA = koala.mouthColorB;    }}',correct
'color(162, 183, 216)',correct
'leaf.leafColor = 0xff628B50;',correct
'{    // nothing yet    leafColor = 0xff628B50;}',correct
'display',correct
'leafX = xMouse;',correct
'koala.bodyColorA = color(209);',correct
'ellipse(koalaX - 55, koalaY - 83, 70, 50);',correct
'ellipse(koalaX + 55, koalaY - 111, 80, 60);',correct
'ellipse(koalaX - 55, koalaY - 111, 80, 60)',correct
'void display() {    fill(bodyColorA);    noStroke();    // earsII    ellipse(koalaX - 55, koalaY - 111, 80, 60);    ellipse(koalaX + 55, koalaY - 111, 80, 60);    ellipse(koalaX - 55, koalaY - 83, 70, 50);    ellipse(koalaX + 55, koalaY - 83, 70, 50);    // face    ellipse(koalaX, koalaY - 83, 150, 120);    // mouth    fill(mouthColorA);    noStroke();    ellipse(koalaX, koalaY - 40, 42, 30);    // nose    fill(0);    stroke(0);    ellipse(koalaX, koalaY - 58, 30, 42);    // eyes    fill(0);    stroke(0);    ellipse(koalaX - 35, koalaY - 94, 17, 15);    ellipse(koalaX + 35, koalaY - 94, 17, 15);    // cheeks    fill(cheekColor);    stroke(cheekColor);    ellipse(koalaX - 50, koalaY - 72, 35, 25);    ellipse(koalaX + 50, koalaY - 72, 35, 25);}',correct
'ellipse(koalaX, koalaY - 83, 150, 120)',correct
'{    koala.moveMe(mouseX, mouseY);}',correct
'leafY = leafY + leafYspeed;',correct
'leafXspeed = random(1, 4)',correct
'{    leaves[i] = new Leaves();}',correct
'koala.cheekColor > 209',correct
'{    leaf.moveIt(mouseX, mouseY);    koala.mouthColorA = koala.mouthColorB;}',correct
'leaves[i] = new Leaves()',correct
'(xMouse > 75) && (xMouse < width - 75)',correct
'leaf.leafYspeed = random(1, 3);',correct
'// eyesfill(0);',correct
'void moveIt(int xMouse, int yMouse) {    if ((xMouse > 75) && (xMouse < width - 75)) {        leafX = xMouse;    }    if ((yMouse > 83) && (yMouse < height)) {        leafY = yMouse;    }}',correct
'leaves[i]',correct
'leafX + leafXspeed',correct
'leaf.leafXspeed = 0',correct
'koalaY = yMouse',correct
'i++',correct
'float leafYspeed = random(1, 5);',correct
'leafColor = 0xff628B50',correct
'fill(bodyColorA)',correct
'float leafx = leafX',correct
'{    leafX = xMouse;}',correct
'leafY = yMouse',correct
'fill(bodyColorA);',correct
'leafYspeed * -1',correct
'ellipse(koalaX - 50, koalaY - 72, 35, 25);',correct
'ellipse(leafX + 10, leafY + 10, 3, 40);',correct
'koala.mouthColorB',correct
'// earsIIellipse(koalaX - 55, koalaY - 111, 80, 60);',correct
'koala.mouthColorA',correct
'koala.bodyColorA = color(209)',correct
'fill(mouthColorA)',correct
'ellipse(leafx, leafy, 20, 5)',correct
'void',correct
'-1',correct
'koalaY - 40',correct
'stroke(cheekColor)',correct
'{    for (int i = 0; i < leaves.length; i++) {        leaves[i] = new Leaves();    }}',correct
'random(1, 5)',correct
'for (int i = 0; i < leaves.length; i++) {    leaves[i].display();}',correct
'void display() {    noStroke();    fill(leafColor);    for (float leafy = leafY; leafy <= leafY + 25; leafy += spacingY) {        for (float leafx = leafX; leafx < leafX + 30; leafx += spacingX) {            stroke(0);            ellipse(leafx, leafy, 20, 5);        }    }    ellipse(leafX + 10, leafY + 10, 3, 40);    leafX = leafX + leafXspeed;    leafY = leafY + leafYspeed;    if ((leafX > width) || (leafY < 0)) {        leafXspeed = leafXspeed * -1;    }    if ((leafY > height) || (leafY < 0)) {        leafYspeed = leafYspeed * -1;    }}',correct
'if ((xMouse > 75) && (xMouse < width - 75)) {    koalaX = xMouse;}',correct
'koalaX = xMouse;',correct
'leafXspeed = leafXspeed * -1',correct
'{    fill(bodyColorA);    noStroke();    // earsII    ellipse(koalaX - 55, koalaY - 111, 80, 60);    ellipse(koalaX + 55, koalaY - 111, 80, 60);    ellipse(koalaX - 55, koalaY - 83, 70, 50);    ellipse(koalaX + 55, koalaY - 83, 70, 50);    // face    ellipse(koalaX, koalaY - 83, 150, 120);    // mouth    fill(mouthColorA);    noStroke();    ellipse(koalaX, koalaY - 40, 42, 30);    // nose    fill(0);    stroke(0);    ellipse(koalaX, koalaY - 58, 30, 42);    // eyes    fill(0);    stroke(0);    ellipse(koalaX - 35, koalaY - 94, 17, 15);    ellipse(koalaX + 35, koalaY - 94, 17, 15);    // cheeks    fill(cheekColor);    stroke(cheekColor);    ellipse(koalaX - 50, koalaY - 72, 35, 25);    ellipse(koalaX + 50, koalaY - 72, 35, 25);}',correct
'{    leaves[i].display();}',correct
'koalaX - 35',correct
'// Ari Lee',correct
'cheekColor = color(255, 214, 227);',correct
'koalaY - 111',correct
'if ((leafX > width) || (leafY < 0)) {    leafXspeed = leafXspeed * -1;}',correct
'leaf.leafYspeed = 0;',correct
'if (koala.cheekColor > 209) {    koala.cheekColor = color(255, 214, 227);}',correct
'ellipse(koalaX - 35, koalaY - 94, 17, 15);',correct
'int yMouse',correct
'ellipse(koalaX + 50, koalaY - 72, 35, 25);',correct
'{    if ((xMouse > 75) && (xMouse < width - 75)) {        koalaX = xMouse;    }    if ((yMouse > 83) && (yMouse < height)) {        koalaY = yMouse;    }}',correct
'leafx += spacingX',correct
'Koala',correct
'leafY + 10',correct
'leafx = leafX',correct
'[10]',correct
'color(209)',correct
'class Koala {    int koalaX;    int koalaY;    int cheekColor;    int bodyColorA;    int bodyColorB;    int mouthColorA;    int mouthColorB;    Koala() {        // Koalas location        koalaX = width / 2;        koalaY = height / 2;        // Koalas colours        bodyColorA = color(209);        bodyColorB = color(162, 183, 216);        mouthColorA = bodyColorA;        mouthColorB = 0xffF2C4E5;        cheekColor = color(255, 214, 227);    }    void display() {        fill(bodyColorA);        noStroke();        // earsII        ellipse(koalaX - 55, koalaY - 111, 80, 60);        ellipse(koalaX + 55, koalaY - 111, 80, 60);        ellipse(koalaX - 55, koalaY - 83, 70, 50);        ellipse(koalaX + 55, koalaY - 83, 70, 50);        // face        ellipse(koalaX, koalaY - 83, 150, 120);        // mouth        fill(mouthColorA);        noStroke();        ellipse(koalaX, koalaY - 40, 42, 30);        // nose        fill(0);        stroke(0);        ellipse(koalaX, koalaY - 58, 30, 42);        // eyes        fill(0);        stroke(0);        ellipse(koalaX - 35, koalaY - 94, 17, 15);        ellipse(koalaX + 35, koalaY - 94, 17, 15);        // cheeks        fill(cheekColor);        stroke(cheekColor);        ellipse(koalaX - 50, koalaY - 72, 35, 25);        ellipse(koalaX + 50, koalaY - 72, 35, 25);    }    void moveMe(int xMouse, int yMouse) {        if ((xMouse > 75) && (xMouse < width - 75)) {            koalaX = xMouse;        }        if ((yMouse > 83) && (yMouse < height)) {            koalaY = yMouse;        }    }}',correct
'bodyColorB = color(162, 183, 216)',correct
'leaves = new Leaves[10]',correct
'koala.cheekColor + 5',correct
'leafX + 10',correct
'Leaves',correct
'leafX = xMouse',correct
'int xMouse',correct
'{    stroke(0);    ellipse(leafx, leafy, 20, 5);}',correct
'koalaX = xMouse',correct
'leaf.leafColor',correct
'leafY = leafY + leafYspeed',correct
'leafXspeed = leafXspeed * -1;',correct
'koala.cheekColor = koala.cheekColor + 5;',correct
'{    for (float leafx = leafX; leafx < leafX + 30; leafx += spacingX) {        stroke(0);        ellipse(leafx, leafy, 20, 5);    }}',correct
'void moveMe(int xMouse, int yMouse) {    if ((xMouse > 75) && (xMouse < width - 75)) {        koalaX = xMouse;    }    if ((yMouse > 83) && (yMouse < height)) {        koalaY = yMouse;    }}',correct
'Leaves() {    // nothing yet    leafColor = 0xff628B50;}',correct
'// Koalas coloursbodyColorA = color(209);',correct
'width / 2',correct
'koalaX - 50',correct
'leaf = new Leaves()',correct
'leaf.leafYspeed',correct
'// faceellipse(koalaX, koalaY - 83, 150, 120);',correct
'koalaX - 55',correct
'background(0xffFFF4B7);',correct
'leaf.display();',correct
'leafXspeed * -1',correct
'dx += random(-15, 15)',correct
'triangle(x, y - 88, x + 25, y - 45, x - 25, y - 45);',correct
'x = centreX;',correct
'boolean ifOver = false;',correct
'// All red lighter colored areasfill(color(255, 154, 163));',correct
'y + 88',correct
'dx > 0',correct
'dy += random(-100, 100);',correct
'new Gem(random(100, 900), random(100, 700))',correct
'dy = -0.7f * dy;',correct
'x > 945',correct
'triangle(x, y - 88, x - 25, y - 45, x - 54, y - 30);',correct
'ifOver = true',correct
'{    isGreen = 0;}',correct
'color(69, 96, 85)',correct
'fill(color(255, 212, 216))',correct
'// All green darkest colored areasfill(color(91, 127, 112));',correct
'dy < 0',correct
'float mx',ShortVariable
'y - 30',correct
'ifOver = true;',correct
'int isGreen;',correct
'triangle(x, y + 88, x + 25, y + 45, x + 54, y + 30);',correct
'random(100, 900)',correct
'boolean ifOver = false',correct
'triangle(x, y - 88, x - 25, y - 45, x - 54, y - 30)',correct
'dist(x, y, mx, my) < 60',correct
'float my',correct
'if (y > 712 && dy > 0) {    dy = -0.7f * dy;}',correct
'// All green lighter colored areasfill(color(153, 255, 211));',correct
'c = 0',correct
'// All green lightest colored areasfill(color(212, 255, 236));',correct
'void superSpeed() {    dx += random(-100, 100);    dy += random(-100, 100);}',correct
'quad(x - 54, y - 30, x - 54, y + 30, x - 25, y + 45, x - 25, y - 45);',correct
'dx += random(-100, 100)',correct
'// give the gem super speed if the mouse was pressed on a RED gemvoid mousePressed() {    for (int c = 0; c < gemsCreated; c++) {        if (gems[c].mouseOver(mouseX, mouseY)) {            gems[c].superSpeed();        }    }}',correct
'x > 945 && dx > 0',correct
'void move() {    // moves the gem, but slowes down due to the mulitplier    x += dx * 0.8f;    y += dy * 0.8f;    // if the x speed or the y speed gets too close to 0, the speed will be randomized    if ((dx > -1.8f && dx < 1.8f) || (dy > -1.8f && dy < 1.8f)) {        dx += random(-15, 15);        dy += random(-15, 15);    }    // if the x speed or the y speed gets too close to 0 the colour will change to red    if ((dy > -2 && dy < 2) || (dy > -2 && dy < 2)) {        isGreen = 1;    } else {        isGreen = 0;    }    // if the gem gets too close to the wall, bounce back    if (x < 55 && dx < 0) {        dx = -0.7f * dx;    }    if (y < 90 && dy < 0) {        dy = -0.7f * dy;    }    if (x > 945 && dx > 0) {        dx = -0.7f * dx;    }    if (y > 712 && dy > 0) {        dy = -0.7f * dy;    }}',correct
'void display() {    if (isGreen == 0) {        // All green lightest colored areas        fill(color(212, 255, 236));        stroke(1);        triangle(x, y - 88, x - 25, y - 45, x - 54, y - 30);        // All green lighter colored areas        fill(color(153, 255, 211));        stroke(1);        quad(x - 54, y - 30, x - 54, y + 30, x - 25, y + 45, x - 25, y - 45);        triangle(x, y - 88, x + 25, y - 45, x - 25, y - 45);        // All green medium colored areas        fill(color(17, 255, 152));        stroke(1);        quad(x - 25, y - 45, x - 25, y + 45, x + 25, y + 45, x + 25, y - 45);        triangle(x, y - 88, x + 25, y - 45, x + 54, y - 30);        triangle(x, y + 88, x - 25, y + 45, x - 54, y + 30);        // All green darker colored areas        fill(color(80, 181, 137));        stroke(1);        quad(x + 54, y - 30, x + 54, y + 30, x + 25, y + 45, x + 25, y - 45);        triangle(x, y + 88, x + 25, y + 45, x - 25, y + 45);        // All green darkest colored areas        fill(color(91, 127, 112));        stroke(1);        triangle(x, y + 88, x + 25, y + 45, x + 54, y + 30);    } else {        // All red lightest colored areas        fill(color(255, 212, 216));        stroke(1);        triangle(x, y - 88, x - 25, y - 45, x - 54, y - 30);        // All red lighter colored areas        fill(color(255, 154, 163));        stroke(1);        quad(x - 54, y - 30, x - 54, y + 30, x - 25, y + 45, x - 25, y - 45);        triangle(x, y - 88, x + 25, y - 45, x - 25, y - 45);        // All red medium colored areas        fill(color(255, 17, 37));        stroke(1);        quad(x - 25, y - 45, x - 25, y + 45, x + 25, y + 45, x + 25, y - 45);        triangle(x, y - 88, x + 25, y - 45, x + 54, y - 30);        triangle(x, y + 88, x - 25, y + 45, x - 54, y + 30);        // All red darker colored areas        fill(color(181, 80, 89));        stroke(1);        quad(x + 54, y - 30, x + 54, y + 30, x + 25, y + 45, x + 25, y - 45);        triangle(x, y + 88, x + 25, y + 45, x - 25, y + 45);        // All red darkest colored areas        fill(color(119, 73, 77));        stroke(1);        triangle(x, y + 88, x + 25, y + 45, x + 54, y + 30);    }}',correct
'int gemsCreated = 20;',correct
'stroke(1);',correct
'{    ifOver = true;}',correct
'dy += random(-100, 100)',correct
'float dx;',correct
'// generate 20 new gems at the startvoid setup() {    for (int c = 0; c < gemsCreated; c++) {        gems[c] = new Gem(random(100, 900), random(100, 700));    }}',correct
'dist(x, y, mx, my)',correct
'static final int maxgems = 20;',VariableNamingConventions
'y = centreY;',correct
'x',correct
'y',correct
'dx * 0.8f',correct
'{    // moves the gem, but slowes down due to the mulitplier    x += dx * 0.8f;    y += dy * 0.8f;    // if the x speed or the y speed gets too close to 0, the speed will be randomized    if ((dx > -1.8f && dx < 1.8f) || (dy > -1.8f && dy < 1.8f)) {        dx += random(-15, 15);        dy += random(-15, 15);    }    // if the x speed or the y speed gets too close to 0 the colour will change to red    if ((dy > -2 && dy < 2) || (dy > -2 && dy < 2)) {        isGreen = 1;    } else {        isGreen = 0;    }    // if the gem gets too close to the wall, bounce back    if (x < 55 && dx < 0) {        dx = -0.7f * dx;    }    if (y < 90 && dy < 0) {        dy = -0.7f * dy;    }    if (x > 945 && dx > 0) {        dx = -0.7f * dx;    }    if (y > 712 && dy > 0) {        dy = -0.7f * dy;    }}',correct
'if (dist(x, y, mx, my) < 60) {    ifOver = true;}',correct
'fill(color(212, 255, 236))',correct
'{    for (int c = 0; c < gemsCreated; c++) {        if (gems[c].mouseOver(mouseX, mouseY)) {            gems[c].superSpeed();        }    }}',correct
'maxgems = 20',correct
'x - 54',correct
'if (y < 90 && dy < 0) {    dy = -0.7f * dy;}',correct
'fill(color(119, 73, 77))',correct
'float dy;',correct
'y > 712 && dy > 0',correct
'dx < 0',correct
'{    dx += random(-100, 100);    dy += random(-100, 100);}',correct
'dx',correct
'dy',correct
'y < 90',correct
'{    gems[c].display();}',correct
'(dy > -2 && dy < 2) || (dy > -2 && dy < 2)',correct
'{    gems[c].move();}',correct
'gems[c].superSpeed();',correct
'quad(x - 25, y - 45, x - 25, y + 45, x + 25, y + 45, x + 25, y - 45)',correct
'triangle(x, y + 88, x + 25, y + 45, x - 25, y + 45)',correct
'for (int c = 0; c < gemsCreated; c++) {    gems[c].display();}',correct
'background(color(69, 96, 85));',correct
'color(212, 255, 236)',correct
'// All green darker colored areasfill(color(80, 181, 137));',correct
'random(-100, 100)',correct
'y += dy * 0.8f;',correct
'-100',correct
'fill(color(255, 17, 37))',correct
'dx = -0.7f * dx',correct
'for (int c = 0; c < gemsCreated; c++) {    gems[c] = new Gem(random(100, 900), random(100, 700));}',correct
'quad(x - 54, y - 30, x - 54, y + 30, x - 25, y + 45, x - 25, y - 45)',correct
'{    background(color(69, 96, 85));    for (int c = 0; c < gemsCreated; c++) {        gems[c].move();    }    for (int c = 0; c < gemsCreated; c++) {        gems[c].display();    }}',correct
'gems = new Gem[maxgems]',correct
'isGreen == 0',correct
'class Gem {    float x;    float y;    float dx;    float dy;    int isGreen;    Gem(float centreX, float centreY) {        x = centreX;        y = centreY;        // dx and dy are the speeds and are randomized at the beggining        dx = random(-15, 15);        dy = random(-15, 15);        // this variable is the toggle for the colour of the gem        isGreen = 0;    }    void display() {        if (isGreen == 0) {            // All green lightest colored areas            fill(color(212, 255, 236));            stroke(1);            triangle(x, y - 88, x - 25, y - 45, x - 54, y - 30);            // All green lighter colored areas            fill(color(153, 255, 211));            stroke(1);            quad(x - 54, y - 30, x - 54, y + 30, x - 25, y + 45, x - 25, y - 45);            triangle(x, y - 88, x + 25, y - 45, x - 25, y - 45);            // All green medium colored areas            fill(color(17, 255, 152));            stroke(1);            quad(x - 25, y - 45, x - 25, y + 45, x + 25, y + 45, x + 25, y - 45);            triangle(x, y - 88, x + 25, y - 45, x + 54, y - 30);            triangle(x, y + 88, x - 25, y + 45, x - 54, y + 30);            // All green darker colored areas            fill(color(80, 181, 137));            stroke(1);            quad(x + 54, y - 30, x + 54, y + 30, x + 25, y + 45, x + 25, y - 45);            triangle(x, y + 88, x + 25, y + 45, x - 25, y + 45);            // All green darkest colored areas            fill(color(91, 127, 112));            stroke(1);            triangle(x, y + 88, x + 25, y + 45, x + 54, y + 30);        } else {            // All red lightest colored areas            fill(color(255, 212, 216));            stroke(1);            triangle(x, y - 88, x - 25, y - 45, x - 54, y - 30);            // All red lighter colored areas            fill(color(255, 154, 163));            stroke(1);            quad(x - 54, y - 30, x - 54, y + 30, x - 25, y + 45, x - 25, y - 45);            triangle(x, y - 88, x + 25, y - 45, x - 25, y - 45);            // All red medium colored areas            fill(color(255, 17, 37));            stroke(1);            quad(x - 25, y - 45, x - 25, y + 45, x + 25, y + 45, x + 25, y - 45);            triangle(x, y - 88, x + 25, y - 45, x + 54, y - 30);            triangle(x, y + 88, x - 25, y + 45, x - 54, y + 30);            // All red darker colored areas            fill(color(181, 80, 89));            stroke(1);            quad(x + 54, y - 30, x + 54, y + 30, x + 25, y + 45, x + 25, y - 45);            triangle(x, y + 88, x + 25, y + 45, x - 25, y + 45);            // All red darkest colored areas            fill(color(119, 73, 77));            stroke(1);            triangle(x, y + 88, x + 25, y + 45, x + 54, y + 30);        }    }    void move() {        // moves the gem, but slowes down due to the mulitplier        x += dx * 0.8f;        y += dy * 0.8f;        // if the x speed or the y speed gets too close to 0, the speed will be randomized        if ((dx > -1.8f && dx < 1.8f) || (dy > -1.8f && dy < 1.8f)) {            dx += random(-15, 15);            dy += random(-15, 15);        }        // if the x speed or the y speed gets too close to 0 the colour will change to red        if ((dy > -2 && dy < 2) || (dy > -2 && dy < 2)) {            isGreen = 1;        } else {            isGreen = 0;        }        // if the gem gets too close to the wall, bounce back        if (x < 55 && dx < 0) {            dx = -0.7f * dx;        }        if (y < 90 && dy < 0) {            dy = -0.7f * dy;        }        if (x > 945 && dx > 0) {            dx = -0.7f * dx;        }        if (y > 712 && dy > 0) {            dy = -0.7f * dy;        }    }    // if the mouse cursor is over a RED gem, return true    boolean mouseOver(float mx, float my) {        boolean ifOver = false;        if (isGreen == 1) {            if (dist(x, y, mx, my) < 60) {                ifOver = true;            }        }        return ifOver;    }    void superSpeed() {        dx += random(-100, 100);        dy += random(-100, 100);    }}',correct
'y - 45',correct
'isGreen == 1',correct
'Gem[]',correct
'float x;',correct
'fill(color(153, 255, 211))',correct
'Processing',correct
'y < 90 && dy < 0',correct
'quad(x + 54, y - 30, x + 54, y + 30, x + 25, y + 45, x + 25, y - 45);',correct
'triangle(x, y + 88, x - 25, y + 45, x - 54, y + 30);',correct
'color(255, 212, 216)',correct
'dy = random(-15, 15)',correct
'false',correct
'float centreY',correct
'float y;',correct
'// All red medium colored areasfill(color(255, 17, 37));',correct
'if (isGreen == 1) {    if (dist(x, y, mx, my) < 60) {        ifOver = true;    }}',correct
'float centreX',correct
'gems[c].move();',correct
'gems[c].mouseOver(mouseX, mouseY)',correct
'gems[c].move()',correct
'random(100, 700)',correct
'{    // All red lightest colored areas    fill(color(255, 212, 216));    stroke(1);    triangle(x, y - 88, x - 25, y - 45, x - 54, y - 30);    // All red lighter colored areas    fill(color(255, 154, 163));    stroke(1);    quad(x - 54, y - 30, x - 54, y + 30, x - 25, y + 45, x - 25, y - 45);    triangle(x, y - 88, x + 25, y - 45, x - 25, y - 45);    // All red medium colored areas    fill(color(255, 17, 37));    stroke(1);    quad(x - 25, y - 45, x - 25, y + 45, x + 25, y + 45, x + 25, y - 45);    triangle(x, y - 88, x + 25, y - 45, x + 54, y - 30);    triangle(x, y + 88, x - 25, y + 45, x - 54, y + 30);    // All red darker colored areas    fill(color(181, 80, 89));    stroke(1);    quad(x + 54, y - 30, x + 54, y + 30, x + 25, y + 45, x + 25, y - 45);    triangle(x, y + 88, x + 25, y + 45, x - 25, y + 45);    // All red darkest colored areas    fill(color(119, 73, 77));    stroke(1);    triangle(x, y + 88, x + 25, y + 45, x + 54, y + 30);}',correct
'void draw() {    background(color(69, 96, 85));    for (int c = 0; c < gemsCreated; c++) {        gems[c].move();    }    for (int c = 0; c < gemsCreated; c++) {        gems[c].display();    }}',correct
'fill(color(17, 255, 152))',correct
'// if the mouse cursor is over a RED gem, return trueboolean mouseOver(float mx, float my) {    boolean ifOver = false;    if (isGreen == 1) {        if (dist(x, y, mx, my) < 60) {            ifOver = true;        }    }    return ifOver;}',correct
'setup',correct
'-0.7f * dy',correct
'-0.7f * dx',correct
'color(255, 17, 37)',correct
'c++',correct
'isGreen = 1;',correct
'triangle(x, y + 88, x + 25, y + 45, x + 54, y + 30)',correct
'triangle(x, y - 88, x + 25, y - 45, x - 25, y - 45)',correct
'x += dx * 0.8f',correct
'x < 55',correct
'{    x = centreX;    y = centreY;    // dx and dy are the speeds and are randomized at the beggining    dx = random(-15, 15);    dy = random(-15, 15);    // this variable is the toggle for the colour of the gem    isGreen = 0;}',correct
'new Gem[maxgems]',correct
'-15',correct
'return ifOver;',correct
'{    dx += random(-15, 15);    dy += random(-15, 15);}',correct
'color(255, 154, 163)',correct
'dx += random(-100, 100);',correct
'quad(x + 54, y - 30, x + 54, y + 30, x + 25, y + 45, x + 25, y - 45)',correct
'int c = 0',correct
'Gem(float centreX, float centreY) {    x = centreX;    y = centreY;    // dx and dy are the speeds and are randomized at the beggining    dx = random(-15, 15);    dy = random(-15, 15);    // this variable is the toggle for the colour of the gem    isGreen = 0;}',correct
'x - 25',correct
'isGreen = 0;',correct
'x = centreX',correct
'Gem',correct
'c < gemsCreated',correct
'// if the x speed or the y speed gets too close to 0, the speed will be randomizedif ((dx > -1.8f && dx < 1.8f) || (dy > -1.8f && dy < 1.8f)) {    dx += random(-15, 15);    dy += random(-15, 15);}',correct
'isGreen',correct
'Gem[] gems = new Gem[maxgems];',correct
'gems[c].superSpeed()',correct
'// All green medium colored areasfill(color(17, 255, 152));',correct
'isGreen = 0',correct
'// All red lightest colored areasfill(color(255, 212, 216));',correct
'fill(color(80, 181, 137))',correct
'isGreen = 1',correct
'[maxgems]',correct
'gems[c]',correct
'dy += random(-15, 15)',correct
'{    // All green lightest colored areas    fill(color(212, 255, 236));    stroke(1);    triangle(x, y - 88, x - 25, y - 45, x - 54, y - 30);    // All green lighter colored areas    fill(color(153, 255, 211));    stroke(1);    quad(x - 54, y - 30, x - 54, y + 30, x - 25, y + 45, x - 25, y - 45);    triangle(x, y - 88, x + 25, y - 45, x - 25, y - 45);    // All green medium colored areas    fill(color(17, 255, 152));    stroke(1);    quad(x - 25, y - 45, x - 25, y + 45, x + 25, y + 45, x + 25, y - 45);    triangle(x, y - 88, x + 25, y - 45, x + 54, y - 30);    triangle(x, y + 88, x - 25, y + 45, x - 54, y + 30);    // All green darker colored areas    fill(color(80, 181, 137));    stroke(1);    quad(x + 54, y - 30, x + 54, y + 30, x + 25, y + 45, x + 25, y - 45);    triangle(x, y + 88, x + 25, y + 45, x - 25, y + 45);    // All green darkest colored areas    fill(color(91, 127, 112));    stroke(1);    triangle(x, y + 88, x + 25, y + 45, x + 54, y + 30);}',correct
'gems[c] = new Gem(random(100, 900), random(100, 700))',correct
'gems[c].display()',correct
'y - 88',correct
'// if the gem gets too close to the wall, bounce backif (x < 55 && dx < 0) {    dx = -0.7f * dx;}',correct
'{    for (int c = 0; c < gemsCreated; c++) {        gems[c] = new Gem(random(100, 900), random(100, 700));    }}',correct
'// this variable is the toggle for the colour of the gemisGreen = 0;',correct
'color(119, 73, 77)',correct
'dy = random(-15, 15);',correct
'dy += random(-15, 15);',correct
'color(80, 181, 137)',correct
'fill(color(255, 154, 163))',correct
'dx = random(-15, 15)',correct
'fill(color(91, 127, 112))',correct
'display',LongMethodRule
'if (gems[c].mouseOver(mouseX, mouseY)) {    gems[c].superSpeed();}',correct
'// if the x speed or the y speed gets too close to 0 the colour will change to redif ((dy > -2 && dy < 2) || (dy > -2 && dy < 2)) {    isGreen = 1;} else {    isGreen = 0;}',correct
'{    gems[c] = new Gem(random(100, 900), random(100, 700));}',correct
'// All red darker colored areasfill(color(181, 80, 89));',correct
'y = centreY',correct
'gemsCreated = 20',correct
'background(color(69, 96, 85))',correct
'{    if (dist(x, y, mx, my) < 60) {        ifOver = true;    }}',correct
'color(17, 255, 152)',correct
'for (int c = 0; c < gemsCreated; c++) {    gems[c].move();}',correct
'{    isGreen = 1;}',correct
'gems[c] = new Gem(random(100, 900), random(100, 700));',correct
'dx = -0.7f * dx;',correct
'if (x > 945 && dx > 0) {    dx = -0.7f * dx;}',correct
'y + 45',correct
'mousePressed',correct
'x < 55 && dx < 0',correct
'triangle(x, y - 88, x + 25, y - 45, x + 54, y - 30)',correct
'0.7f',correct
'triangle(x, y + 88, x + 25, y + 45, x - 25, y + 45);',correct
'x + 25',correct
'triangle(x, y + 88, x - 25, y + 45, x - 54, y + 30)',correct
'triangle(x, y - 88, x + 25, y - 45, x + 54, y - 30);',correct
'dy > 0',correct
'void',correct
'y > 712',correct
'-0.7f',correct
'(dx > -1.8f && dx < 1.8f) || (dy > -1.8f && dy < 1.8f)',correct
'dx += random(-15, 15);',correct
'color(153, 255, 211)',correct
'ifOver = false',correct
'dy * 0.8f',correct
'true',correct
'0.8f',correct
'dy = -0.7f * dy',correct
'for (int c = 0; c < gemsCreated; c++) {    if (gems[c].mouseOver(mouseX, mouseY)) {        gems[c].superSpeed();    }}',correct
'stroke(1)',correct
'x + 54',correct
'quad(x - 25, y - 45, x - 25, y + 45, x + 25, y + 45, x + 25, y - 45);',correct
'{    dx = -0.7f * dx;}',correct
'{    dy = -0.7f * dy;}',correct
'// moves the gem, but slowes down due to the mulitplierx += dx * 0.8f;',correct
'{    if (gems[c].mouseOver(mouseX, mouseY)) {        gems[c].superSpeed();    }}',correct
'random(-15, 15)',correct
'y += dy * 0.8f',correct
'// dx and dy are the speeds and are randomized at the begginingdx = random(-15, 15);',correct
'color(181, 80, 89)',correct
'{    boolean ifOver = false;    if (isGreen == 1) {        if (dist(x, y, mx, my) < 60) {            ifOver = true;        }    }    return ifOver;}',correct
'fill(color(181, 80, 89))',correct
'move',correct
'y + 30',correct
'mouseOver',ShortVariable
'// All red darkest colored areasfill(color(119, 73, 77));',correct
'{    gems[c].superSpeed();}',correct
'boolean',ShortVariable
'gems[c].display();',correct
'{    if (isGreen == 0) {        // All green lightest colored areas        fill(color(212, 255, 236));        stroke(1);        triangle(x, y - 88, x - 25, y - 45, x - 54, y - 30);        // All green lighter colored areas        fill(color(153, 255, 211));        stroke(1);        quad(x - 54, y - 30, x - 54, y + 30, x - 25, y + 45, x - 25, y - 45);        triangle(x, y - 88, x + 25, y - 45, x - 25, y - 45);        // All green medium colored areas        fill(color(17, 255, 152));        stroke(1);        quad(x - 25, y - 45, x - 25, y + 45, x + 25, y + 45, x + 25, y - 45);        triangle(x, y - 88, x + 25, y - 45, x + 54, y - 30);        triangle(x, y + 88, x - 25, y + 45, x - 54, y + 30);        // All green darker colored areas        fill(color(80, 181, 137));        stroke(1);        quad(x + 54, y - 30, x + 54, y + 30, x + 25, y + 45, x + 25, y - 45);        triangle(x, y + 88, x + 25, y + 45, x - 25, y + 45);        // All green darkest colored areas        fill(color(91, 127, 112));        stroke(1);        triangle(x, y + 88, x + 25, y + 45, x + 54, y + 30);    } else {        // All red lightest colored areas        fill(color(255, 212, 216));        stroke(1);        triangle(x, y - 88, x - 25, y - 45, x - 54, y - 30);        // All red lighter colored areas        fill(color(255, 154, 163));        stroke(1);        quad(x - 54, y - 30, x - 54, y + 30, x - 25, y + 45, x - 25, y - 45);        triangle(x, y - 88, x + 25, y - 45, x - 25, y - 45);        // All red medium colored areas        fill(color(255, 17, 37));        stroke(1);        quad(x - 25, y - 45, x - 25, y + 45, x + 25, y + 45, x + 25, y - 45);        triangle(x, y - 88, x + 25, y - 45, x + 54, y - 30);        triangle(x, y + 88, x - 25, y + 45, x - 54, y + 30);        // All red darker colored areas        fill(color(181, 80, 89));        stroke(1);        quad(x + 54, y - 30, x + 54, y + 30, x + 25, y + 45, x + 25, y - 45);        triangle(x, y + 88, x + 25, y + 45, x - 25, y + 45);        // All red darkest colored areas        fill(color(119, 73, 77));        stroke(1);        triangle(x, y + 88, x + 25, y + 45, x + 54, y + 30);    }}',LongMethodRule
'color(91, 127, 112)',correct
'r2',correct
'r3',correct
'mod',correct
'y = yTemp;',correct
'y = y + (1 * yDirection)',correct
'y = y + (1 * yDirection);',correct
'fill(r3);',correct
'int y = 0',correct
'unit = tempUnit;',correct
'background(0)',correct
'woY = woYTemp;',correct
'new Woman(x * unit, y * unit, unit / 2, unit / 2, random(0.05f, 0.8f), unit)',correct
'2.5f',correct
'int r2;',ShortVariable
'yDirection *= -1;',correct
'mods[index++] = new Woman(x * unit, y * unit, unit / 2, unit / 2, random(0.05f, 0.8f), unit);',correct
'for (Woman mod : mods) {    mod.update();    mod.display();}',correct
'x + (speed * xDirection)',correct
'r1 = color(random(255), random(255), random(255))',correct
'mod.update();',correct
'rect(woX + x + 1, woY + y, 1, 5, 0, 0, 0.5f, 0.5f)',correct
'speed = speedTemp;',correct
'for (int y = 0; y < highCount; y++) {    for (int x = 0; x < wideCount; x++) {        mods[index++] = new Woman(x * unit, y * unit, unit / 2, unit / 2, random(0.05f, 0.8f), unit);    }}',correct
'yDirection = 1',correct
'woY + y - 10',correct
'woX + x - 1.5f',correct
'int yDirection = 1;',correct
'noStroke();',correct
'{    noStroke();    int wideCount = width / unit;    int highCount = height / unit;    count = wideCount * highCount;    mods = new Woman[count];    int index = 0;    for (int y = 0; y < highCount; y++) {        for (int x = 0; x < wideCount; x++) {            mods[index++] = new Woman(x * unit, y * unit, unit / 2, unit / 2, random(0.05f, 0.8f), unit);        }    }}',correct
'x = x + (speed * xDirection);',correct
'if (keyPressed) {    r1 = color(random(255), random(255), random(255));    r2 = color(random(255), random(255), random(255));    r3 = color(random(255), random(255), random(255));}',DecentralizedEventHandlingRule
'{    r1 = color(random(255), random(255), random(255));    r2 = color(random(255), random(255), random(255));    r3 = color(random(255), random(255), random(255));}',correct
'woX + x + 1',correct
'{    xDirection *= -1;    x = x + (1 * xDirection);    y = y + (1 * yDirection);}',correct
'int r3;',correct
'highCount = height / unit',correct
'woX + x - 5',correct
'color(random(255), random(255), random(255))',correct
'int highCount = height / unit;',correct
'mods[index++] = new Woman(x * unit, y * unit, unit / 2, unit / 2, random(0.05f, 0.8f), unit)',correct
'{    woX = woXTemp;    woY = woYTemp;    x = xTemp;    y = yTemp;    speed = speedTemp;    unit = tempUnit;    r1 = color(random(255), random(255), random(255));    r2 = color(random(255), random(255), random(255));    r3 = color(random(255), random(255), random(255));}',correct
'class Woman {    int woX;    int woY;    float x, y;    int unit;    int xDirection = 1;    int yDirection = 1;    float speed;    int r1;    int r2;    int r3;    Woman(int woXTemp, int woYTemp, int xTemp, int yTemp, float speedTemp, int tempUnit) {        woX = woXTemp;        woY = woYTemp;        x = xTemp;        y = yTemp;        speed = speedTemp;        unit = tempUnit;        r1 = color(random(255), random(255), random(255));        r2 = color(random(255), random(255), random(255));        r3 = color(random(255), random(255), random(255));    }    void update() {        x = x + (speed * xDirection);        if (x >= unit || x <= 0) {            xDirection *= -1;            x = x + (1 * xDirection);            y = y + (1 * yDirection);        }        if (y >= unit || y <= 0) {            yDirection *= -1;            y = y + (1 * yDirection);        }        if (keyPressed) {            r1 = color(random(255), random(255), random(255));            r2 = color(random(255), random(255), random(255));            r3 = color(random(255), random(255), random(255));        }    }    // Custom method for drawing the object    void display() {        fill(r1);        ellipseMode(RADIUS);        ellipse(woX + x, woY + y - 10, 2.5f, 2.5f);        fill(r2);        rect(woX + x - 1.5f, woY + y, 1, 5, 0, 0, 0.5f, 0.5f);        fill(r3);        rect(woX + x + 1, woY + y, 1, 5, 0, 0, 0.5f, 0.5f);        fill(r3);        triangle(woX + x - 5, woY + y, woX + x, woY + y - 7.5f, woX + x + 5, woY + y);    }}',correct
'mod.display()',correct
'[count]',correct
'x = xTemp',correct
'triangle(woX + x - 5, woY + y, woX + x, woY + y - 7.5f, woX + x + 5, woY + y);',correct
'fill(r3)',correct
'{    mods[index++] = new Woman(x * unit, y * unit, unit / 2, unit / 2, random(0.05f, 0.8f), unit);}',correct
'0.5f',correct
'unit = 20',correct
'x <= 0',correct
'y = 0',correct
'int woY;',correct
'mods = new Woman[count]',correct
'mods = new Woman[count];',correct
'rect(woX + x - 1.5f, woY + y, 1, 5, 0, 0, 0.5f, 0.5f);',correct
'y = yTemp',correct
'speed = speedTemp',correct
'index++',correct
'r2 = color(random(255), random(255), random(255));',correct
'display',correct
'float speed;',correct
'mod.update()',correct
'background(0);',correct
'xDirection *= -1',correct
'new Woman[count]',correct
'int index = 0',correct
'Woman[] mods;',correct
'woX = woXTemp',correct
'triangle(woX + x - 5, woY + y, woX + x, woY + y - 7.5f, woX + x + 5, woY + y)',correct
'int wideCount = width / unit;',correct
'fill(r2)',correct
'woX + x',correct
'x',correct
'int xTemp',correct
'y',correct
'int woX;',correct
'index = 0',correct
'y + (1 * yDirection)',correct
'random(255)',correct
'void update() {    x = x + (speed * xDirection);    if (x >= unit || x <= 0) {        xDirection *= -1;        x = x + (1 * xDirection);        y = y + (1 * yDirection);    }    if (y >= unit || y <= 0) {        yDirection *= -1;        y = y + (1 * yDirection);    }    if (keyPressed) {        r1 = color(random(255), random(255), random(255));        r2 = color(random(255), random(255), random(255));        r3 = color(random(255), random(255), random(255));    }}',correct
'woX = woXTemp;',correct
'r2 = color(random(255), random(255), random(255))',correct
'rect(woX + x - 1.5f, woY + y, 1, 5, 0, 0, 0.5f, 0.5f)',correct
'int index = 0;',correct
'noStroke()',correct
'woY',correct
'woX',correct
'fill(r1);',correct
'mods',correct
'void draw() {    background(0);    for (Woman mod : mods) {        mod.update();        mod.display();    }}',correct
'int unit = 20;',correct
'unit / 2',correct
'x = x + (1 * xDirection)',correct
'x >= unit',correct
'Woman[]',correct
'ellipse(woX + x, woY + y - 10, 2.5f, 2.5f);',correct
'ellipse(woX + x, woY + y - 10, 2.5f, 2.5f)',correct
'fill(r1)',correct
'y < highCount',correct
'y++',correct
'y * unit',correct
'height / unit',correct
'count = wideCount * highCount;',correct
'x * unit',correct
'Woman',correct
'int xDirection = 1;',correct
'rect(woX + x + 1, woY + y, 1, 5, 0, 0, 0.5f, 0.5f);',correct
'mods[index++]',correct
'int x = 0',correct
'x = x + (speed * xDirection)',correct
'int unit;',correct
'void',correct
'woY = woYTemp',correct
'-1',correct
'count',correct
'int tempUnit',correct
'x >= unit || x <= 0',correct
'int woXTemp',correct
'unit',correct
'xDirection = 1',correct
'unit = tempUnit',correct
'xDirection *= -1;',correct
'int highCount = height / unit',correct
'random(0.05f, 0.8f)',correct
'if (y >= unit || y <= 0) {    yDirection *= -1;    y = y + (1 * yDirection);}',correct
'// Custom method for drawing the objectvoid display() {    fill(r1);    ellipseMode(RADIUS);    ellipse(woX + x, woY + y - 10, 2.5f, 2.5f);    fill(r2);    rect(woX + x - 1.5f, woY + y, 1, 5, 0, 0, 0.5f, 0.5f);    fill(r3);    rect(woX + x + 1, woY + y, 1, 5, 0, 0, 0.5f, 0.5f);    fill(r3);    triangle(woX + x - 5, woY + y, woX + x, woY + y - 7.5f, woX + x + 5, woY + y);}',correct
'1.5f',correct
'for (int x = 0; x < wideCount; x++) {    mods[index++] = new Woman(x * unit, y * unit, unit / 2, unit / 2, random(0.05f, 0.8f), unit);}',correct
'0.8f',correct
'float x, y;',correct
'wideCount * highCount',correct
'{    for (int x = 0; x < wideCount; x++) {        mods[index++] = new Woman(x * unit, y * unit, unit / 2, unit / 2, random(0.05f, 0.8f), unit);    }}',correct
'woY + y',correct
'y <= 0',correct
'void setup() {    noStroke();    int wideCount = width / unit;    int highCount = height / unit;    count = wideCount * highCount;    mods = new Woman[count];    int index = 0;    for (int y = 0; y < highCount; y++) {        for (int x = 0; x < wideCount; x++) {            mods[index++] = new Woman(x * unit, y * unit, unit / 2, unit / 2, random(0.05f, 0.8f), unit);        }    }}',correct
'fill(r2);',correct
'int count;',correct
'int wideCount = width / unit',correct
'x = xTemp;',correct
'if (x >= unit || x <= 0) {    xDirection *= -1;    x = x + (1 * xDirection);    y = y + (1 * yDirection);}',correct
'ellipseMode(RADIUS)',correct
'int woYTemp',correct
'r3 = color(random(255), random(255), random(255))',correct
'woX + x + 5',correct
'Woman(int woXTemp, int woYTemp, int xTemp, int yTemp, float speedTemp, int tempUnit) {    woX = woXTemp;    woY = woYTemp;    x = xTemp;    y = yTemp;    speed = speedTemp;    unit = tempUnit;    r1 = color(random(255), random(255), random(255));    r2 = color(random(255), random(255), random(255));    r3 = color(random(255), random(255), random(255));}',correct
'Woman mod',correct
'speed',correct
'x < wideCount',correct
'y >= unit',correct
'x = 0',correct
'Processing',correct
'{    mod.update();    mod.display();}',correct
'x + (1 * xDirection)',correct
'r1 = color(random(255), random(255), random(255));',correct
'woY + y - 7.5f',correct
'wideCount = width / unit',correct
'x++',correct
'count = wideCount * highCount',correct
'{    x = x + (speed * xDirection);    if (x >= unit || x <= 0) {        xDirection *= -1;        x = x + (1 * xDirection);        y = y + (1 * yDirection);    }    if (y >= unit || y <= 0) {        yDirection *= -1;        y = y + (1 * yDirection);    }    if (keyPressed) {        r1 = color(random(255), random(255), random(255));        r2 = color(random(255), random(255), random(255));        r3 = color(random(255), random(255), random(255));    }}',correct
'{    background(0);    for (Woman mod : mods) {        mod.update();        mod.display();    }}',correct
'x = x + (1 * xDirection);',correct
'{    yDirection *= -1;    y = y + (1 * yDirection);}',correct
'r3 = color(random(255), random(255), random(255));',correct
'int yTemp',correct
'width / unit',correct
'7.5f',correct
'float speedTemp',correct
'y >= unit || y <= 0',correct
'yDirection *= -1',correct
'0.05f',correct
'{    fill(r1);    ellipseMode(RADIUS);    ellipse(woX + x, woY + y - 10, 2.5f, 2.5f);    fill(r2);    rect(woX + x - 1.5f, woY + y, 1, 5, 0, 0, 0.5f, 0.5f);    fill(r3);    rect(woX + x + 1, woY + y, 1, 5, 0, 0, 0.5f, 0.5f);    fill(r3);    triangle(woX + x - 5, woY + y, woX + x, woY + y - 7.5f, woX + x + 5, woY + y);}',correct
'ellipseMode(RADIUS);',correct
'mod.display();',correct
'int r1;',ShortVariable
'r1',correct
'ident',correct
'legOffsetX1 = 0;',correct
'PApplet.parseInt(distanceY) == 0',correct
'positionEye1 = creatureX + eyeOffset1',correct
'land = new SoundFile(this, "stomb.wav")',correct
'shadowHeight = 20',correct
'int positionEye1, positionEye2, eyeOffset1, eyeOffset2, eyeOffsetY;',correct
'creature[ident].hold();',correct
'void display(int x, int y) {    int creatureX = x, creatureY = y;    fill(255);    stroke(0);    strokeWeight(2);    if (center) {        ellipse(positionEye1, creatureY - eyeOffsetY, 12, 17);        ellipse(positionEye2, creatureY - eyeOffsetY, 12, 17);    } else {        ellipse(positionEye1, creatureY - eyeOffsetY, 9, 14);        ellipse(positionEye2, creatureY - eyeOffsetY, 10, 15);    }}',correct
'// bellybelly.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY), jumpDown);',correct
'nxtCreatureX = PApplet.parseInt(random(20, width - 20))',correct
'shadowOffsetY = 100;',correct
'legs',correct
'{    int creatureX = x, creatureY = y;    center = true;    positionEye1 = creatureX - eyeOffset2 - 4;    positionEye2 = creatureX + eyeOffset2 + 4;}',correct
'eyeOffsetY = 52',correct
'// normal dynamic shadowshadowWidth += PApplet.parseInt(jumpHeight * 0.5f);',correct
'{    if (nxtCreatureX < creatureX) {        eyes.turnLeft(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));    } else {        eyes.turnRight(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));    }}',correct
'stroke(0);',correct
'stroke(0)',correct
'{    play = false;    return true;}',correct
'eyes.turnLeft(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY))',correct
'creature[i].clicked()',correct
'{    // head    fill(bodyColor);    strokeWeight(3);    stroke(0);    ellipse(creatureX, creatureY - headOffsetY, 30, 30);    // eyes    eyes.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));    // shadow    shadow.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY), jumpHeight);    // legs    legs.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));    // belly    belly.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY), jumpDown);}',correct
'creatureX = x',correct
'shadowHeight = 20 - PApplet.parseInt((shadowOffsetY - 75) * 0.3f);',correct
'if (creature[ident].clicked()) {    creature[ident].reset();}',correct
'int headOffsetY, jumpSteps, nxtCreatureX, nxtCreatureY;',correct
'click',correct
'// calculate the increase per frameincreaseX = distanceX / (amountJumps * (jumpSteps * 2));',correct
'belly = new creatureBelly();',correct
'jumpHeight * 0.3f',correct
'void reset() {    hold = false;}',correct
'PApplet.parseInt(random(20, width - 20))',correct
'dist(mouseX, mouseY, creatureX, creatureY - headOffsetY) <= 30',correct
'shadowWidth = 70 - PApplet.parseInt((shadowOffsetY - 75) * 0.5f)',correct
'eyes = new creatureEyes()',correct
'fill(255, 140, 0);',correct
'shadowWidth = 0',correct
'creatureEyes eyes;',correct
'creature[i].chooseSpot();',correct
'{    for (int i = 0; i < creature.length; ++i) {        creature[i].hover();        if (creature[i].clicked()) {            ident = i;            break;        }    }    if (creature[ident].clicked()) {        creature[ident].hold();    }}',correct
'void hold() {    hold = true;    shadowWidth = 70;    shadowHeight = 20;    shadowOffsetY = 100;    shadowWidth = 70 - PApplet.parseInt((shadowOffsetY - 75) * 0.5f);    shadowHeight = 20 - PApplet.parseInt((shadowOffsetY - 75) * 0.3f);}',correct
'[4]',correct
'abs(distanceX) / 100',correct
'creatureY = y;',correct
'{    eyes.turnLeft(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));}',correct
'creatureX',correct
'{    int creatureX = x, creatureY = y;    fill(255);    stroke(0);    strokeWeight(2);    if (center) {        ellipse(positionEye1, creatureY - eyeOffsetY, 12, 17);        ellipse(positionEye2, creatureY - eyeOffsetY, 12, 17);    } else {        ellipse(positionEye1, creatureY - eyeOffsetY, 9, 14);        ellipse(positionEye2, creatureY - eyeOffsetY, 10, 15);    }}',correct
'creatureY',correct
'eyes',correct
'jumpDown == false',correct
'sin(jumpSin)',correct
'color(255, 140, 0)',correct
'creature[i].turn();',correct
'{    creature[ident].hold();}',correct
'bellyOffsetY == -10',correct
'rotate(radians(-flounce * 2))',correct
'flounce += 10',correct
'void display() {    // head    fill(bodyColor);    strokeWeight(3);    stroke(0);    ellipse(creatureX, creatureY - headOffsetY, 30, 30);    // eyes    eyes.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));    // shadow    shadow.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY), jumpHeight);    // legs    legs.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));    // belly    belly.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY), jumpDown);}',correct
'new creatureLegs()',correct
'shadowHeight = 20 - PApplet.parseInt((shadowOffsetY - 75) * 0.3f)',correct
'void turn() {    if (nxtCreatureX < creatureX) {        eyes.turnLeft(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));    } else {        eyes.turnRight(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));    }}',correct
'SoundFile',correct
'jumpSin += PI / jumpSteps',correct
'{    // normal dynamic shadow    shadowWidth += PApplet.parseInt(jumpHeight * 0.5f);    shadowHeight += PApplet.parseInt(jumpHeight * 0.3f);    shadowOffsetY -= jumpHeight;    if (shadowWidth <= 0) {        shadowWidth = 0;    }    if (shadowHeight <= 0) {        shadowHeight = 0;    }}',SimplifyBooleanExpressions
'new creatureBelly()',correct
'distanceY = (creatureY - jumpHeight) - nxtCreatureY;',correct
'void draw() {    background(255, 155, 0);    for (int i = 0; i < creature.length; ++i) {        if (creature[i].clicked() == false) {            creature[i].chooseSpot();            creature[i].turn();            creature[i].autojump();        }        creature[i].display();        if (creature[i].playSound()) {            land.play();        }    }}',correct
'mouseY - 20',correct
'creatureY = mouseY - 20;',correct
'void center(int x, int y) {    int creatureX = x, creatureY = y;    center = true;    positionEye1 = creatureX - eyeOffset2 - 4;    positionEye2 = creatureX + eyeOffset2 + 4;}',correct
'boolean jumpDown = wriggle;',correct
'shadowWidth <= 0',correct
'boolean hold = false;',AvoidFieldNameMatchingMethodName
'if (bellyOffsetY == 3) {    bellyOffsetY = -10;    bellyHeight = 65;}',correct
'distanceX = 0',correct
'isThere == true',SimplifyBooleanExpressions
'PApplet.parseInt(abs(distanceY) / 100)',correct
'{    center = false;}',correct
'rect(creatureX - legOffestX2, creatureY + legOffsetY, 7, 70, 5);',correct
'int bellyHeight, bellyOffsetY;',correct
'// eyeseyes.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));',correct
'eyes.center(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY))',correct
'hold',correct
'if (creature[ident].clicked()) {    creature[ident].hold();}',correct
'boolean clicked() {    return click;}',correct
'eyes.turnRight(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY))',correct
'creature[i].playSound()',correct
'if (jumpHeight > 0) {    jumpDown = true;} else {    jumpDown = false;}',correct
'-flounce * 2',correct
'ident = i;',correct
'legs.reset()',correct
'{    flounce2 = true;}',correct
'creatureX - eyeOffset2 - 4',correct
'jumpHeight = 0',correct
'fill(bodyColor)',correct
'bellyHeight = 65',correct
'sin(jumpSin) * -5',correct
'creatureY = y',correct
'{    amountJumps = PApplet.parseInt(abs(distanceY) / 100) + 1;}',correct
'// shadowshadow.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY), jumpHeight);',correct
'positionEye2 = creatureX - eyeOffset2',correct
'{    play = true;    return false;}',correct
'creatureEyes',correct
'flounce = 0;',correct
'height - 20',correct
'{    creature[ident].reset();}',correct
'(creatureY - jumpHeight) - nxtCreatureY',correct
'nxtCreatureY = PApplet.parseInt(random(20, height - 20));',correct
'eyes.center(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));',correct
'void mousePressed() {    for (int i = 0; i < creature.length; ++i) {        creature[i].hover();        if (creature[i].clicked()) {            ident = i;            break;        }    }    if (creature[ident].clicked()) {        creature[ident].hold();    }}',correct
'bellyOffsetY = -10;',correct
'jumpDown == true',correct
'bellyHeight = 70',correct
'creatureShadow shadow;',correct
'70 - PApplet.parseInt((shadowOffsetY - 75) * 0.5f)',correct
'legOffsetY',correct
'flounce = 0',correct
'0 - legOffestX2',correct
'shadow.reset()',correct
'bellyOffsetY = -10',correct
'play = true',correct
'if (creature[i].clicked() == false) {    creature[i].chooseSpot();    creature[i].turn();    creature[i].autojump();}',SimplifyBooleanExpressions
'boolean jumpDown, click, play;',correct
'(creatureX - jumpHeight) - nxtCreatureX',correct
'abs(increaseX)',correct
'eyes.turnLeft(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));',correct
'{    ident = i;    break;}',correct
'class creatureLegs {    int legOffsetY, legOffsetX1, legOffestX2, flounce;    boolean hold = false, flounce2 = false;    creatureLegs() {        legOffsetY = 5;        legOffsetX1 = 0;        legOffestX2 = 7;        flounce = 0;    }    void display(int x, int y) {        int creatureX = x, creatureY = y;        stroke(0);        strokeWeight(3);        fill(255, 140, 0);        // leg movment        if (hold) {            if (flounce == 0) {                flounce2 = true;            } else if (flounce == 20) {                flounce2 = false;            }            if (flounce2) {                flounce += 10;            } else {                flounce -= 10;            }            pushMatrix();            translate(creatureX, creatureY);            rotate(radians(flounce));            rect(0 - legOffestX2, 0 + legOffsetY, 7, 70, 5);            rotate(radians(-flounce * 2));            rect(0, 0 + legOffsetY, 7, 70, 5);            popMatrix();        } else {            flounce = 0;            // static legs            rect(creatureX, creatureY + legOffsetY, 7, 70, 5);            rect(creatureX - legOffestX2, creatureY + legOffsetY, 7, 70, 5);        }    }    void hold() {        hold = true;    }    void reset() {        hold = false;    }}',correct
'Processing',correct
'if (center) {    ellipse(positionEye1, creatureY - eyeOffsetY, 12, 17);    ellipse(positionEye2, creatureY - eyeOffsetY, 12, 17);} else {    ellipse(positionEye1, creatureY - eyeOffsetY, 9, 14);    ellipse(positionEye2, creatureY - eyeOffsetY, 10, 15);}',correct
'center = true',correct
'land.play()',correct
'{    hold = false;    shadowWidth = 70;    shadowHeight = 20;    shadowOffsetY = 75;}',correct
'dist(mouseX, mouseY, creatureX, creatureY - headOffsetY)',correct
'int shadowWidth, shadowHeight;',correct
'pushMatrix()',correct
'positionEye2 = creatureX + eyeOffset2 + 4',correct
'distanceY = 0;',correct
'belly.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY), jumpDown)',correct
'{    land.play();}',correct
'0 + legOffsetY',correct
'jumpHeight > 0',correct
'PApplet.parseInt(creatureX)',correct
'void reset() {    hold = false;    shadowWidth = 70;    shadowHeight = 20;    shadowOffsetY = 75;}',correct
'ellipse(positionEye2, creatureY - eyeOffsetY, 12, 17)',correct
'{    ellipse(positionEye1, creatureY - eyeOffsetY, 9, 14);    ellipse(positionEye2, creatureY - eyeOffsetY, 10, 15);}',correct
'(shadowOffsetY - 75) * 0.5f',correct
'width - 20',correct
'false',correct
'new SoundFile(this, "stomb.wav")',correct
'jumpDown = wriggle',correct
'jumpDown = false',correct
'creatureLegs',correct
'abs(increaseY)',correct
'shadowHeight',correct
'float jumpHeight = jumpH;',correct
'creatureY += jumpHeight',correct
'PApplet.parseInt(creatureY)',correct
'positionEye1 = creatureX - eyeOffset2 - 4',correct
'legOffsetY = 5;',correct
'fill(0, 0, 0, 95)',correct
'distanceY = abs(distanceY - abs(increaseY));',correct
'click = false;',correct
'creature[i]',correct
'distanceX = abs(distanceX - abs(increaseX))',correct
'creature.length',correct
'{    int creatureX = x, creatureY = y;    positionEye1 = creatureX + eyeOffset1;    positionEye2 = creatureX + eyeOffset2;}',correct
'bellyHeight = 65;',correct
'creatureY -= increaseY;',correct
'rect(creatureX - legOffestX2, creatureY + legOffsetY, 7, 70, 5)',correct
'hold = false;',correct
'eyes.reset();',correct
'{    if (dist(mouseX, mouseY, creatureX, creatureY) <= 70 || dist(mouseX, mouseY, creatureX, creatureY - headOffsetY) <= 30) {        click = true;    } else {        click = false;    }}',correct
'{    // check if arrived    boolean isThere = false;    if (PApplet.parseInt(distanceX) == 0 && PApplet.parseInt(distanceY) == 0) {        isThere = true;    }    // if arrived choose a new location    if (isThere == true) {        nxtCreatureX = PApplet.parseInt(random(20, width - 20));        nxtCreatureY = PApplet.parseInt(random(20, height - 20));        // calculate the distances        distanceX = (creatureX - jumpHeight) - nxtCreatureX;        distanceY = (creatureY - jumpHeight) - nxtCreatureY;        // decide for the amount of jumps to do        if (PApplet.parseInt(abs(distanceX) / 100) + 1 > PApplet.parseInt(abs(distanceY) / 100) + 1) {            amountJumps = PApplet.parseInt(abs(distanceX) / 100) + 1;        } else {            amountJumps = PApplet.parseInt(abs(distanceY) / 100) + 1;        }        // calculate the increase per frame        increaseX = distanceX / (amountJumps * (jumpSteps * 2));        increaseY = distanceY / (amountJumps * (jumpSteps * 2));        isThere = false;    } else {        // if not there add increase to the creatures position        creatureX -= increaseX;        creatureY -= increaseY;        distanceX = abs(distanceX - abs(increaseX));        distanceY = abs(distanceY - abs(increaseY));    }}',correct
'i = 0',correct
'bellyOffsetY',correct
'0.3f',correct
'amountJumps = PApplet.parseInt(abs(distanceX) / 100) + 1;',correct
'nxtCreatureX < creatureX',correct
'{    ellipse(positionEye1, creatureY - eyeOffsetY, 12, 17);    ellipse(positionEye2, creatureY - eyeOffsetY, 12, 17);}',correct
'legOffsetX1',correct
'increaseY = distanceY / (amountJumps * (jumpSteps * 2));',correct
'legOffsetX1 = 0',correct
'return click;',correct
'// static legsrect(creatureX, creatureY + legOffsetY, 7, 70, 5);',correct
'shadowOffsetY = 100',correct
'rotate(radians(-flounce * 2));',correct
'creatureX - eyeOffset1',correct
'creatureShadow() {    shadowWidth = 70;    shadowHeight = 20;    shadowOffsetY = 75;}',correct
'legs.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY))',correct
'PApplet.parseInt(jumpHeight * 0.3f)',correct
'hold = true;',correct
'creatureX - eyeOffset2',correct
'i < creature.length',correct
'jumpDown',correct
'distanceX = 0;',correct
'eyeOffset1 = 10',correct
'click = false',correct
'(shadowOffsetY - 75) * 0.3f',correct
'isThere = true',correct
'creature[ident].reset();',correct
'abs(distanceX)',correct
'rect(0 - legOffestX2, 0 + legOffsetY, 7, 70, 5);',correct
'shadowHeight += PApplet.parseInt(jumpHeight * 0.3f);',correct
'strokeWeight(1)',correct
'float jumpHeight, jumpSin = 0, increaseX, increaseY, distanceX, distanceY, creatureX, creatureY;',correct
'creatureX = mouseX;',correct
'creatureY = mouseY - 20',correct
'bellyHeight',correct
'jumpDown = false;',correct
'flounce2 = false;',correct
'boolean hold = false, flounce2 = false;',correct
'void autojump() {    jumpSin += PI / jumpSteps;    jumpHeight = sin(jumpSin) * -5;    creatureY += jumpHeight;    if (jumpHeight > 0) {        jumpDown = true;    } else {        jumpDown = false;    }}',correct
'{    click = false;}',correct
'0.5f',correct
'positionEye1 = creatureX - eyeOffset1;',correct
'ellipse(creatureX, creatureY - headOffsetY, 30, 30);',correct
'rect(0 - legOffestX2, 0 + legOffsetY, 7, 70, 5)',correct
'{    hold = false;}',correct
'jumpDown == false && play',correct
'// headfill(bodyColor);',correct
'void reset() {    center = false;}',correct
'shadowWidth = 70 - PApplet.parseInt((shadowOffsetY - 75) * 0.5f);',correct
'background(255, 155, 0)',correct
'creatureY - headOffsetY',correct
'hold = false',correct
'flounce -= 10',correct
'void turnLeft(int x, int y) {    int creatureX = x, creatureY = y;    positionEye1 = creatureX - eyeOffset1;    positionEye2 = creatureX - eyeOffset2;}',correct
'int y',correct
'creature[i].clicked() == false',correct
'{    if (creature[ident].clicked()) {        creature[ident].hold();    }}',correct
'{    isThere = true;}',correct
'int x',correct
'flounce -= 10;',correct
'// decide for the amount of jumps to doif (PApplet.parseInt(abs(distanceX) / 100) + 1 > PApplet.parseInt(abs(distanceY) / 100) + 1) {    amountJumps = PApplet.parseInt(abs(distanceX) / 100) + 1;} else {    amountJumps = PApplet.parseInt(abs(distanceY) / 100) + 1;}',correct
'void turnRight(int x, int y) {    int creatureX = x, creatureY = y;    positionEye1 = creatureX + eyeOffset1;    positionEye2 = creatureX + eyeOffset2;}',correct
'if (dist(mouseX, mouseY, creatureX, creatureY) <= 70 || dist(mouseX, mouseY, creatureX, creatureY - headOffsetY) <= 30) {    click = true;} else {    click = false;}',correct
'new creatureEyes()',correct
'legs.hold();',correct
'center = false;',correct
'creature[i].autojump()',correct
'new creatureShadow()',correct
'ellipseMode(CENTER)',correct
'click = true',correct
'bellyHeight = 70;',correct
'distanceX - abs(increaseX)',correct
'ellipse(positionEye1, creatureY - eyeOffsetY, 12, 17);',correct
'creature[ident].clicked()',correct
'strokeWeight(3)',correct
'PApplet.parseInt(jumpHeight * 0.5f)',correct
'{    click = true;}',correct
'amountJumps = 0',correct
'void',correct
'creatureX + eyeOffset2 + 4',correct
'creatureClass(float x, float y) {    eyes = new creatureEyes();    legs = new creatureLegs();    belly = new creatureBelly();    shadow = new creatureShadow();    creatureX = x;    creatureY = y;    headOffsetY = 45;    jumpHeight = 0;    jumpSteps = 15;    jumpDown = false;    play = true;    bodyColor = color(255, 140, 0);    ellipseMode(CENTER);}',correct
'creatureBelly',correct
'-5',correct
'random(20, height - 20)',correct
'mouseY + 20',correct
'increaseX = distanceX / (amountJumps * (jumpSteps * 2))',correct
'stroke(0, 0, 0, 95);',correct
'jumpHeight = sin(jumpSin) * -5;',correct
'strokeWeight(2)',correct
'true',correct
'creature[ident]',correct
'{    int creatureX = x, creatureY = y;    boolean jumpDown = wriggle;    if (jumpDown == false) {        if (bellyOffsetY == -10) {            bellyHeight = 70;        }        bellyOffsetY = 3;    } else {        if (bellyOffsetY == 3) {            bellyOffsetY = -10;            bellyHeight = 65;        }    }    ellipse(creatureX, creatureY + bellyOffsetY, 70, bellyHeight);}',correct
'creatureX = x;',correct
'popMatrix()',correct
'eyes.reset()',correct
'creature[i].display();',correct
'amountJumps = PApplet.parseInt(abs(distanceY) / 100) + 1;',correct
'{    bellyOffsetY = 0;    bellyHeight = 70;}',correct
'{    hold = true;}',correct
'shadowOffsetY = 75;',correct
'shadow.reset();',correct
'{    shadowWidth = 70;    shadowHeight = 20;    shadowOffsetY = 75;}',correct
'shadow = new creatureShadow()',correct
'creatureX = mouseX',correct
'land',correct
'boolean center = false;',AvoidFieldNameMatchingMethodName
'void setup() {    frameRate(30);    land = new SoundFile(this, "stomb.wav");    for (int i = 0; i < creature.length; ++i) {        creature[i] = new creatureClass(random(20, width - 20), random(20, height - 20));    }}',correct
'shadow.hold();',correct
'{    return false;}',correct
'creatureEyes() {    eyeOffset1 = 10;    eyeOffset2 = 2;    eyeOffsetY = 52;}',correct
'float x',correct
'float y',correct
'float jumpHeight = jumpH',correct
'PApplet.parseInt(distanceX) == 0',correct
'shadow.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY), jumpHeight)',correct
'// calculate the distancesdistanceX = (creatureX - jumpHeight) - nxtCreatureX;',correct
'legOffestX2 = 7;',correct
'center = true;',correct
'shadowHeight = 0;',correct
'jumpHeight * 0.5f',correct
'void hold() {    creatureX = mouseX;    creatureY = mouseY - 20;    shadow.hold();    jumpDown = true;    eyes.center(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));    legs.hold();}',correct
'jumpSteps = 15;',correct
'center = false',correct
'creatureLegs() {    legOffsetY = 5;    legOffsetX1 = 0;    legOffestX2 = 7;    flounce = 0;}',correct
'legOffestX2',correct
'shadowWidth += PApplet.parseInt(jumpHeight * 0.5f)',correct
'ellipse(creatureX, creatureY + shadowOffsetY, shadowWidth, shadowHeight);',correct
'if (nxtCreatureX < creatureX) {    eyes.turnLeft(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));} else {    eyes.turnRight(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));}',correct
'// if arrived choose a new locationif (isThere == true) {    nxtCreatureX = PApplet.parseInt(random(20, width - 20));    nxtCreatureY = PApplet.parseInt(random(20, height - 20));    // calculate the distances    distanceX = (creatureX - jumpHeight) - nxtCreatureX;    distanceY = (creatureY - jumpHeight) - nxtCreatureY;    // decide for the amount of jumps to do    if (PApplet.parseInt(abs(distanceX) / 100) + 1 > PApplet.parseInt(abs(distanceY) / 100) + 1) {        amountJumps = PApplet.parseInt(abs(distanceX) / 100) + 1;    } else {        amountJumps = PApplet.parseInt(abs(distanceY) / 100) + 1;    }    // calculate the increase per frame    increaseX = distanceX / (amountJumps * (jumpSteps * 2));    increaseY = distanceY / (amountJumps * (jumpSteps * 2));    isThere = false;} else {    // if not there add increase to the creatures position    creatureX -= increaseX;    creatureY -= increaseY;    distanceX = abs(distanceX - abs(increaseX));    distanceY = abs(distanceY - abs(increaseY));}',correct
'creature[ident].reset()',correct
'belly = new creatureBelly()',correct
'hold == false',correct
'legOffestX2 = 7',correct
'class creatureEyes {    int positionEye1, positionEye2, eyeOffset1, eyeOffset2, eyeOffsetY;    boolean center = false;    creatureEyes() {        eyeOffset1 = 10;        eyeOffset2 = 2;        eyeOffsetY = 52;    }    void display(int x, int y) {        int creatureX = x, creatureY = y;        fill(255);        stroke(0);        strokeWeight(2);        if (center) {            ellipse(positionEye1, creatureY - eyeOffsetY, 12, 17);            ellipse(positionEye2, creatureY - eyeOffsetY, 12, 17);        } else {            ellipse(positionEye1, creatureY - eyeOffsetY, 9, 14);            ellipse(positionEye2, creatureY - eyeOffsetY, 10, 15);        }    }    void turnLeft(int x, int y) {        int creatureX = x, creatureY = y;        positionEye1 = creatureX - eyeOffset1;        positionEye2 = creatureX - eyeOffset2;    }    void turnRight(int x, int y) {        int creatureX = x, creatureY = y;        positionEye1 = creatureX + eyeOffset1;        positionEye2 = creatureX + eyeOffset2;    }    void center(int x, int y) {        int creatureX = x, creatureY = y;        center = true;        positionEye1 = creatureX - eyeOffset2 - 4;        positionEye2 = creatureX + eyeOffset2 + 4;    }    void reset() {        center = false;    }}',correct
'float jumpH',correct
'flounce == 20',correct
'int legOffsetY, legOffsetX1, legOffestX2, flounce;',correct
'jumpHeight = 0;',correct
'// legslegs.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));',correct
'jumpDown = true;',correct
'shadowHeight = 0',correct
'creature[ident].hold()',correct
'positionEye2 = creatureX + eyeOffset2 + 4;',correct
'ident = i',correct
'fill(255, 140, 0)',correct
'dist(mouseX, mouseY, creatureX, creatureY)',correct
'void reset() {    click = false;    jumpDown = false;    distanceX = 0;    distanceY = 0;    jumpSin = 0;    jumpHeight = 0;    shadow.reset();    eyes.reset();    legs.reset();    creatureX = mouseX;    creatureY = mouseY + 20;}',correct
'void chooseSpot() {    // check if arrived    boolean isThere = false;    if (PApplet.parseInt(distanceX) == 0 && PApplet.parseInt(distanceY) == 0) {        isThere = true;    }    // if arrived choose a new location    if (isThere == true) {        nxtCreatureX = PApplet.parseInt(random(20, width - 20));        nxtCreatureY = PApplet.parseInt(random(20, height - 20));        // calculate the distances        distanceX = (creatureX - jumpHeight) - nxtCreatureX;        distanceY = (creatureY - jumpHeight) - nxtCreatureY;        // decide for the amount of jumps to do        if (PApplet.parseInt(abs(distanceX) / 100) + 1 > PApplet.parseInt(abs(distanceY) / 100) + 1) {            amountJumps = PApplet.parseInt(abs(distanceX) / 100) + 1;        } else {            amountJumps = PApplet.parseInt(abs(distanceY) / 100) + 1;        }        // calculate the increase per frame        increaseX = distanceX / (amountJumps * (jumpSteps * 2));        increaseY = distanceY / (amountJumps * (jumpSteps * 2));        isThere = false;    } else {        // if not there add increase to the creatures position        creatureX -= increaseX;        creatureY -= increaseY;        distanceX = abs(distanceX - abs(increaseX));        distanceY = abs(distanceY - abs(increaseY));    }}',correct
'bellyOffsetY == 3',correct
'jumpHeight = sin(jumpSin) * -5',correct
'positionEye1 = creatureX - eyeOffset2 - 4;',correct
'shadowHeight = 20;',correct
'eyeOffset2 = 2',correct
'"stomb.wav"',correct
'shadowWidth = 70',correct
'pushMatrix();',correct
'jumpSin = 0;',correct
'strokeWeight(1);',correct
'creature[i].hover();',correct
'creatureShadow',correct
'creature[i].chooseSpot()',correct
'{    if (bellyOffsetY == -10) {        bellyHeight = 70;    }    bellyOffsetY = 3;}',correct
'PApplet.parseInt((shadowOffsetY - 75) * 0.3f)',correct
'frameRate(30);',correct
'headOffsetY = 45;',correct
'eyeOffset2 = 2;',correct
'{    int creatureX = x, creatureY = y;    stroke(0);    strokeWeight(3);    fill(255, 140, 0);    // leg movment    if (hold) {        if (flounce == 0) {            flounce2 = true;        } else if (flounce == 20) {            flounce2 = false;        }        if (flounce2) {            flounce += 10;        } else {            flounce -= 10;        }        pushMatrix();        translate(creatureX, creatureY);        rotate(radians(flounce));        rect(0 - legOffestX2, 0 + legOffsetY, 7, 70, 5);        rotate(radians(-flounce * 2));        rect(0, 0 + legOffsetY, 7, 70, 5);        popMatrix();    } else {        flounce = 0;        // static legs        rect(creatureX, creatureY + legOffsetY, 7, 70, 5);        rect(creatureX - legOffestX2, creatureY + legOffsetY, 7, 70, 5);    }}',LongMethodRule
'new creatureClass[4]',correct
'belly',correct
'shadowOffsetY',correct
'boolean wriggle',correct
'creature = new creatureClass[4]',correct
'nxtCreatureY = PApplet.parseInt(random(20, height - 20))',correct
'20 - PApplet.parseInt((shadowOffsetY - 75) * 0.3f)',correct
'land.play();',correct
'translate(creatureX, creatureY)',correct
'shadow.hold()',correct
'{    flounce2 = false;}',correct
'return false;',correct
'PApplet.parseInt(distanceY)',correct
'bellyOffsetY = 3',correct
'shadow = new creatureShadow();',correct
'class creatureBelly {    int bellyHeight, bellyOffsetY;    creatureBelly() {        bellyOffsetY = 0;        bellyHeight = 70;    }    void display(int x, int y, boolean wriggle) {        int creatureX = x, creatureY = y;        boolean jumpDown = wriggle;        if (jumpDown == false) {            if (bellyOffsetY == -10) {                bellyHeight = 70;            }            bellyOffsetY = 3;        } else {            if (bellyOffsetY == 3) {                bellyOffsetY = -10;                bellyHeight = 65;            }        }        ellipse(creatureX, creatureY + bellyOffsetY, 70, bellyHeight);    }}',correct
'{    nxtCreatureX = PApplet.parseInt(random(20, width - 20));    nxtCreatureY = PApplet.parseInt(random(20, height - 20));    // calculate the distances    distanceX = (creatureX - jumpHeight) - nxtCreatureX;    distanceY = (creatureY - jumpHeight) - nxtCreatureY;    // decide for the amount of jumps to do    if (PApplet.parseInt(abs(distanceX) / 100) + 1 > PApplet.parseInt(abs(distanceY) / 100) + 1) {        amountJumps = PApplet.parseInt(abs(distanceX) / 100) + 1;    } else {        amountJumps = PApplet.parseInt(abs(distanceY) / 100) + 1;    }    // calculate the increase per frame    increaseX = distanceX / (amountJumps * (jumpSteps * 2));    increaseY = distanceY / (amountJumps * (jumpSteps * 2));    isThere = false;}',SimplifyBooleanExpressions
'distanceX / (amountJumps * (jumpSteps * 2))',correct
'shadowHeight <= 0',correct
'positionEye2 = creatureX - eyeOffset2;',correct
'if (jumpDown == false && play) {    play = false;    return true;} else if (jumpDown == true) {    play = true;    return false;} else {    return false;}',SimplifyBooleanExpressions
'{    eyeOffset1 = 10;    eyeOffset2 = 2;    eyeOffsetY = 52;}',correct
'eyes = new creatureEyes();',correct
'bellyOffsetY = 0',correct
'{    if (flounce == 0) {        flounce2 = true;    } else if (flounce == 20) {        flounce2 = false;    }    if (flounce2) {        flounce += 10;    } else {        flounce -= 10;    }    pushMatrix();    translate(creatureX, creatureY);    rotate(radians(flounce));    rect(0 - legOffestX2, 0 + legOffsetY, 7, 70, 5);    rotate(radians(-flounce * 2));    rect(0, 0 + legOffsetY, 7, 70, 5);    popMatrix();}',correct
'positionEye2 = creatureX + eyeOffset2;',correct
'popMatrix();',correct
'strokeWeight(2);',correct
'jumpSin = 0',correct
'eyeOffset1 = 10;',correct
'void display(int x, int y, float jumpH) {    int creatureX = x, creatureY = y;    float jumpHeight = jumpH;    if (hold == false) {        // normal dynamic shadow        shadowWidth += PApplet.parseInt(jumpHeight * 0.5f);        shadowHeight += PApplet.parseInt(jumpHeight * 0.3f);        shadowOffsetY -= jumpHeight;        if (shadowWidth <= 0) {            shadowWidth = 0;        }        if (shadowHeight <= 0) {            shadowHeight = 0;        }    }    fill(0, 0, 0, 95);    stroke(0, 0, 0, 95);    strokeWeight(1);    ellipse(creatureX, creatureY + shadowOffsetY, shadowWidth, shadowHeight);}',correct
'increaseY',correct
'increaseX',correct
'PApplet.parseInt(distanceX)',correct
'bodyColor = color(255, 140, 0)',correct
'creatureY += jumpHeight;',correct
'creature[i] = new creatureClass(random(20, width - 20), random(20, height - 20))',correct
'void display(int x, int y) {    int creatureX = x, creatureY = y;    stroke(0);    strokeWeight(3);    fill(255, 140, 0);    // leg movment    if (hold) {        if (flounce == 0) {            flounce2 = true;        } else if (flounce == 20) {            flounce2 = false;        }        if (flounce2) {            flounce += 10;        } else {            flounce -= 10;        }        pushMatrix();        translate(creatureX, creatureY);        rotate(radians(flounce));        rect(0 - legOffestX2, 0 + legOffsetY, 7, 70, 5);        rotate(radians(-flounce * 2));        rect(0, 0 + legOffsetY, 7, 70, 5);        popMatrix();    } else {        flounce = 0;        // static legs        rect(creatureX, creatureY + legOffsetY, 7, 70, 5);        rect(creatureX - legOffestX2, creatureY + legOffsetY, 7, 70, 5);    }}',correct
'hold = true',correct
'fill(0, 0, 0, 95);',correct
'bodyColor = color(255, 140, 0);',correct
'if (flounce == 20) {    flounce2 = false;}',correct
'creature[i] = new creatureClass(random(20, width - 20), random(20, height - 20));',correct
'legs = new creatureLegs();',correct
'creatureY = mouseY + 20',correct
'ellipse(creatureX, creatureY - headOffsetY, 30, 30)',correct
'click = true;',correct
'PApplet.parseInt(abs(distanceY) / 100) + 1',correct
'land = new SoundFile(this, "stomb.wav");',correct
'headOffsetY',correct
'{    flounce = 0;    // static legs    rect(creatureX, creatureY + legOffsetY, 7, 70, 5);    rect(creatureX - legOffestX2, creatureY + legOffsetY, 7, 70, 5);}',correct
'eyeOffset2',correct
'{    shadowHeight = 0;}',correct
'isThere = false',correct
'eyeOffset1',correct
'{    int creatureX = x, creatureY = y;    positionEye1 = creatureX - eyeOffset1;    positionEye2 = creatureX - eyeOffset2;}',correct
'creatureY = mouseY + 20;',correct
'frameRate(30)',correct
'abs(distanceY)',correct
'eyeOffsetY',correct
'int ident;',correct
'this',correct
'boolean isThere = false',correct
'break;',correct
'strokeWeight(3);',correct
'distanceY = abs(distanceY - abs(increaseY))',correct
'void mouseDragged() {    if (creature[ident].clicked()) {        creature[ident].hold();    }}',correct
'PApplet.parseInt((shadowOffsetY - 75) * 0.5f)',correct
'creature[i].turn()',correct
'if (shadowWidth <= 0) {    shadowWidth = 0;}',correct
'{    shadowWidth = 0;}',correct
'PApplet.parseInt(distanceX) == 0 && PApplet.parseInt(distanceY) == 0',correct
'nxtCreatureX = PApplet.parseInt(random(20, width - 20));',correct
'if (creature[i].playSound()) {    land.play();}',correct
'boolean playSound() {    if (jumpDown == false && play) {        play = false;        return true;    } else if (jumpDown == true) {        play = true;        return false;    } else {        return false;    }}',correct
'nxtCreatureY',correct
'creatureBelly belly;',correct
'eyes.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY))',correct
'positionEye2 = creatureX + eyeOffset2',correct
'int bodyColor;',correct
'abs(distanceY) / 100',correct
'creatureX + eyeOffset1',correct
'distanceY - abs(increaseY)',correct
'fill(255)',correct
'creatureX + eyeOffset2',correct
'shadowHeight += PApplet.parseInt(jumpHeight * 0.3f)',correct
'if (flounce2) {    flounce += 10;} else {    flounce -= 10;}',correct
'shadowWidth',correct
'nxtCreatureX',correct
'shadowWidth = 70;',correct
'PApplet.parseInt(random(20, height - 20))',correct
'shadowOffsetY -= jumpHeight;',correct
'{    if (bellyOffsetY == 3) {        bellyOffsetY = -10;        bellyHeight = 65;    }}',correct
'jumpSteps = 15',correct
'amountJumps = PApplet.parseInt(abs(distanceY) / 100) + 1',correct
'positionEye1',correct
'isThere = true;',correct
'flounce += 10;',correct
'positionEye2',correct
'{    eyes.turnRight(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));}',correct
'int i = 0',correct
'ellipseMode(CENTER);',correct
'{    flounce -= 10;}',correct
'shadowWidth = 0;',correct
'{    bellyOffsetY = -10;    bellyHeight = 65;}',correct
'{    if (creature[ident].clicked()) {        creature[ident].reset();    }}',correct
'flounce',correct
'play',correct
'bellyOffsetY = 0;',correct
'increaseY = distanceY / (amountJumps * (jumpSteps * 2))',correct
'shadow',correct
'boolean jumpDown = wriggle',correct
'{    amountJumps = PApplet.parseInt(abs(distanceX) / 100) + 1;}',correct
'++i',correct
'distanceX = abs(distanceX - abs(increaseX));',correct
'creatureY - eyeOffsetY',correct
'-10',correct
'play = false;',correct
'jumpHeight',correct
'{    legOffsetY = 5;    legOffsetX1 = 0;    legOffestX2 = 7;    flounce = 0;}',correct
'new creatureClass(random(20, width - 20), random(20, height - 20))',correct
'radians(-flounce * 2)',correct
'headOffsetY = 45',correct
'if (PApplet.parseInt(distanceX) == 0 && PApplet.parseInt(distanceY) == 0) {    isThere = true;}',correct
'isThere = false;',correct
'chooseSpot',correct
'if (hold == false) {    // normal dynamic shadow    shadowWidth += PApplet.parseInt(jumpHeight * 0.5f);    shadowHeight += PApplet.parseInt(jumpHeight * 0.3f);    shadowOffsetY -= jumpHeight;    if (shadowWidth <= 0) {        shadowWidth = 0;    }    if (shadowHeight <= 0) {        shadowHeight = 0;    }}',correct
'float shadowOffsetY;',correct
'translate(creatureX, creatureY);',correct
'flounce2 = false',correct
'{    creatureX = mouseX;    creatureY = mouseY - 20;    shadow.hold();    jumpDown = true;    eyes.center(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));    legs.hold();}',correct
'// check if arrivedboolean isThere = false;',correct
'return true;',correct
'distanceY / (amountJumps * (jumpSteps * 2))',correct
'{    // if not there add increase to the creatures position    creatureX -= increaseX;    creatureY -= increaseY;    distanceX = abs(distanceX - abs(increaseX));    distanceY = abs(distanceY - abs(increaseY));}',SimplifyBooleanExpressions
'-flounce',correct
'{    jumpDown = false;}',correct
'void mouseReleased() {    if (creature[ident].clicked()) {        creature[ident].reset();    }}',correct
'creatureX - legOffestX2',correct
'ellipse(positionEye2, creatureY - eyeOffsetY, 10, 15);',correct
'{    creature[i].hover();    if (creature[i].clicked()) {        ident = i;        break;    }}',correct
'class creatureClass {    int amountJumps = 0;    int headOffsetY, jumpSteps, nxtCreatureX, nxtCreatureY;    int bodyColor;    boolean jumpDown, click, play;    float jumpHeight, jumpSin = 0, increaseX, increaseY, distanceX, distanceY, creatureX, creatureY;    creatureEyes eyes;    creatureLegs legs;    creatureBelly belly;    creatureShadow shadow;    creatureClass(float x, float y) {        eyes = new creatureEyes();        legs = new creatureLegs();        belly = new creatureBelly();        shadow = new creatureShadow();        creatureX = x;        creatureY = y;        headOffsetY = 45;        jumpHeight = 0;        jumpSteps = 15;        jumpDown = false;        play = true;        bodyColor = color(255, 140, 0);        ellipseMode(CENTER);    }    void display() {        // head        fill(bodyColor);        strokeWeight(3);        stroke(0);        ellipse(creatureX, creatureY - headOffsetY, 30, 30);        // eyes        eyes.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));        // shadow        shadow.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY), jumpHeight);        // legs        legs.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));        // belly        belly.display(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY), jumpDown);    }    void chooseSpot() {        // check if arrived        boolean isThere = false;        if (PApplet.parseInt(distanceX) == 0 && PApplet.parseInt(distanceY) == 0) {            isThere = true;        }        // if arrived choose a new location        if (isThere == true) {            nxtCreatureX = PApplet.parseInt(random(20, width - 20));            nxtCreatureY = PApplet.parseInt(random(20, height - 20));            // calculate the distances            distanceX = (creatureX - jumpHeight) - nxtCreatureX;            distanceY = (creatureY - jumpHeight) - nxtCreatureY;            // decide for the amount of jumps to do            if (PApplet.parseInt(abs(distanceX) / 100) + 1 > PApplet.parseInt(abs(distanceY) / 100) + 1) {                amountJumps = PApplet.parseInt(abs(distanceX) / 100) + 1;            } else {                amountJumps = PApplet.parseInt(abs(distanceY) / 100) + 1;            }            // calculate the increase per frame            increaseX = distanceX / (amountJumps * (jumpSteps * 2));            increaseY = distanceY / (amountJumps * (jumpSteps * 2));            isThere = false;        } else {            // if not there add increase to the creatures position            creatureX -= increaseX;            creatureY -= increaseY;            distanceX = abs(distanceX - abs(increaseX));            distanceY = abs(distanceY - abs(increaseY));        }    }    void turn() {        if (nxtCreatureX < creatureX) {            eyes.turnLeft(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));        } else {            eyes.turnRight(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));        }    }    void autojump() {        jumpSin += PI / jumpSteps;        jumpHeight = sin(jumpSin) * -5;        creatureY += jumpHeight;        if (jumpHeight > 0) {            jumpDown = true;        } else {            jumpDown = false;        }    }    boolean playSound() {        if (jumpDown == false && play) {            play = false;            return true;        } else if (jumpDown == true) {            play = true;            return false;        } else {            return false;        }    }    void hover() {        if (dist(mouseX, mouseY, creatureX, creatureY) <= 70 || dist(mouseX, mouseY, creatureX, creatureY - headOffsetY) <= 30) {            click = true;        } else {            click = false;        }    }    boolean clicked() {        return click;    }    void hold() {        creatureX = mouseX;        creatureY = mouseY - 20;        shadow.hold();        jumpDown = true;        eyes.center(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));        legs.hold();    }    void reset() {        click = false;        jumpDown = false;        distanceX = 0;        distanceY = 0;        jumpSin = 0;        jumpHeight = 0;        shadow.reset();        eyes.reset();        legs.reset();        creatureX = mouseX;        creatureY = mouseY + 20;    }}',correct
'int amountJumps = 0;',correct
'play = true;',correct
'PApplet.parseInt(abs(distanceX) / 100)',correct
'creatureY -= increaseY',correct
'{    click = false;    jumpDown = false;    distanceX = 0;    distanceY = 0;    jumpSin = 0;    jumpHeight = 0;    shadow.reset();    eyes.reset();    legs.reset();    creatureX = mouseX;    creatureY = mouseY + 20;}',correct
'if (creature[i].clicked()) {    ident = i;    break;}',correct
'play = false',correct
'{    flounce += 10;}',correct
'creatureY + legOffsetY',correct
'creatureY + shadowOffsetY',correct
'radians(flounce)',correct
'positionEye1 = creatureX + eyeOffset1;',correct
'for (int i = 0; i < creature.length; ++i) {    if (creature[i].clicked() == false) {        creature[i].chooseSpot();        creature[i].turn();        creature[i].autojump();    }    creature[i].display();    if (creature[i].playSound()) {        land.play();    }}',correct
'rect(creatureX, creatureY + legOffsetY, 7, 70, 5)',correct
'display',correct
'abs(distanceX - abs(increaseX))',correct
'stroke(0, 0, 0, 95)',correct
'PI / jumpSteps',correct
'jumpDown = true',correct
'dist(mouseX, mouseY, creatureX, creatureY) <= 70',correct
'// leg movmentif (hold) {    if (flounce == 0) {        flounce2 = true;    } else if (flounce == 20) {        flounce2 = false;    }    if (flounce2) {        flounce += 10;    } else {        flounce -= 10;    }    pushMatrix();    translate(creatureX, creatureY);    rotate(radians(flounce));    rect(0 - legOffestX2, 0 + legOffsetY, 7, 70, 5);    rotate(radians(-flounce * 2));    rect(0, 0 + legOffsetY, 7, 70, 5);    popMatrix();} else {    flounce = 0;    // static legs    rect(creatureX, creatureY + legOffsetY, 7, 70, 5);    rect(creatureX - legOffestX2, creatureY + legOffsetY, 7, 70, 5);}',correct
'ellipse(positionEye1, creatureY - eyeOffsetY, 9, 14);',correct
'random(20, width - 20)',correct
'// if not there add increase to the creatures positioncreatureX -= increaseX;',correct
'legs = new creatureLegs()',correct
'creatureX -= increaseX',correct
'ellipse(positionEye2, creatureY - eyeOffsetY, 12, 17);',correct
'{    creature[i].chooseSpot();    creature[i].turn();    creature[i].autojump();}',correct
'if (jumpDown == true) {    play = true;    return false;} else {    return false;}',SimplifyBooleanExpressions
'{    jumpDown = true;}',correct
'PApplet.parseInt(abs(distanceX) / 100) + 1',correct
'{    background(255, 155, 0);    for (int i = 0; i < creature.length; ++i) {        if (creature[i].clicked() == false) {            creature[i].chooseSpot();            creature[i].turn();            creature[i].autojump();        }        creature[i].display();        if (creature[i].playSound()) {            land.play();        }    }}',correct
'legOffsetY = 5',correct
'fill(255);',correct
'if (bellyOffsetY == -10) {    bellyHeight = 70;}',correct
'legs.reset();',correct
'jumpHeight = jumpH',correct
'{    eyes = new creatureEyes();    legs = new creatureLegs();    belly = new creatureBelly();    shadow = new creatureShadow();    creatureX = x;    creatureY = y;    headOffsetY = 45;    jumpHeight = 0;    jumpSteps = 15;    jumpDown = false;    play = true;    bodyColor = color(255, 140, 0);    ellipseMode(CENTER);}',correct
'ellipse(creatureX, creatureY + bellyOffsetY, 70, bellyHeight)',correct
'creatureLegs legs;',correct
'ellipse(positionEye1, creatureY - eyeOffsetY, 9, 14)',correct
'eyeOffsetY = 52;',correct
'flounce2 = true',correct
'ellipse(positionEye1, creatureY - eyeOffsetY, 12, 17)',correct
'creatureClass[]',correct
'legs.hold()',correct
'bellyOffsetY = 3;',correct
'class creatureShadow {    float shadowOffsetY;    int shadowWidth, shadowHeight;    boolean hold = false;    creatureShadow() {        shadowWidth = 70;        shadowHeight = 20;        shadowOffsetY = 75;    }    void display(int x, int y, float jumpH) {        int creatureX = x, creatureY = y;        float jumpHeight = jumpH;        if (hold == false) {            // normal dynamic shadow            shadowWidth += PApplet.parseInt(jumpHeight * 0.5f);            shadowHeight += PApplet.parseInt(jumpHeight * 0.3f);            shadowOffsetY -= jumpHeight;            if (shadowWidth <= 0) {                shadowWidth = 0;            }            if (shadowHeight <= 0) {                shadowHeight = 0;            }        }        fill(0, 0, 0, 95);        stroke(0, 0, 0, 95);        strokeWeight(1);        ellipse(creatureX, creatureY + shadowOffsetY, shadowWidth, shadowHeight);    }    void hold() {        hold = true;        shadowWidth = 70;        shadowHeight = 20;        shadowOffsetY = 100;        shadowWidth = 70 - PApplet.parseInt((shadowOffsetY - 75) * 0.5f);        shadowHeight = 20 - PApplet.parseInt((shadowOffsetY - 75) * 0.3f);    }    void reset() {        hold = false;        shadowWidth = 70;        shadowHeight = 20;        shadowOffsetY = 75;    }}',correct
'for (int i = 0; i < creature.length; ++i) {    creature[i] = new creatureClass(random(20, width - 20), random(20, height - 20));}',correct
'{    if (creature[i].clicked() == false) {        creature[i].chooseSpot();        creature[i].turn();        creature[i].autojump();    }    creature[i].display();    if (creature[i].playSound()) {        land.play();    }}',correct
'int creatureX = x, creatureY = y;',correct
'{    jumpSin += PI / jumpSteps;    jumpHeight = sin(jumpSin) * -5;    creatureY += jumpHeight;    if (jumpHeight > 0) {        jumpDown = true;    } else {        jumpDown = false;    }}',correct
'ellipse(creatureX, creatureY + shadowOffsetY, shadowWidth, shadowHeight)',correct
'positionEye1 = creatureX - eyeOffset1',correct
'if (jumpDown == false) {    if (bellyOffsetY == -10) {        bellyHeight = 70;    }    bellyOffsetY = 3;} else {    if (bellyOffsetY == 3) {        bellyOffsetY = -10;        bellyHeight = 65;    }}',SimplifyBooleanExpressions
'jumpSteps',correct
'{    return click;}',correct
'flounce2 = true;',correct
'abs(distanceY - abs(increaseY))',correct
'{    if (jumpDown == false && play) {        play = false;        return true;    } else if (jumpDown == true) {        play = true;        return false;    } else {        return false;    }}',correct
'background(255, 155, 0);',correct
'creatureClass[] creature = new creatureClass[4];',correct
'int creatureX = x, creatureY = y',correct
'bodyColor',correct
'rotate(radians(flounce));',correct
'distanceY = (creatureY - jumpHeight) - nxtCreatureY',correct
'flounce == 0',correct
'{    int creatureX = x, creatureY = y;    float jumpHeight = jumpH;    if (hold == false) {        // normal dynamic shadow        shadowWidth += PApplet.parseInt(jumpHeight * 0.5f);        shadowHeight += PApplet.parseInt(jumpHeight * 0.3f);        shadowOffsetY -= jumpHeight;        if (shadowWidth <= 0) {            shadowWidth = 0;        }        if (shadowHeight <= 0) {            shadowHeight = 0;        }    }    fill(0, 0, 0, 95);    stroke(0, 0, 0, 95);    strokeWeight(1);    ellipse(creatureX, creatureY + shadowOffsetY, shadowWidth, shadowHeight);}',correct
'SoundFile land;',correct
'if (flounce == 0) {    flounce2 = true;} else if (flounce == 20) {    flounce2 = false;}',correct
'void hold() {    hold = true;}',correct
'eyes.turnRight(PApplet.parseInt(creatureX), PApplet.parseInt(creatureY));',correct
'dist(mouseX, mouseY, creatureX, creatureY) <= 70 || dist(mouseX, mouseY, creatureX, creatureY - headOffsetY) <= 30',correct
'{    hold = true;    shadowWidth = 70;    shadowHeight = 20;    shadowOffsetY = 100;    shadowWidth = 70 - PApplet.parseInt((shadowOffsetY - 75) * 0.5f);    shadowHeight = 20 - PApplet.parseInt((shadowOffsetY - 75) * 0.3f);}',correct
'void display(int x, int y, boolean wriggle) {    int creatureX = x, creatureY = y;    boolean jumpDown = wriggle;    if (jumpDown == false) {        if (bellyOffsetY == -10) {            bellyHeight = 70;        }        bellyOffsetY = 3;    } else {        if (bellyOffsetY == 3) {            bellyOffsetY = -10;            bellyHeight = 65;        }    }    ellipse(creatureX, creatureY + bellyOffsetY, 70, bellyHeight);}',correct
'creatureBelly() {    bellyOffsetY = 0;    bellyHeight = 70;}',correct
'rotate(radians(flounce))',correct
'distanceX = (creatureX - jumpHeight) - nxtCreatureX',correct
'{    creature[i] = new creatureClass(random(20, width - 20), random(20, height - 20));}',correct
'{    bellyHeight = 70;}',correct
'{    frameRate(30);    land = new SoundFile(this, "stomb.wav");    for (int i = 0; i < creature.length; ++i) {        creature[i] = new creatureClass(random(20, width - 20), random(20, height - 20));    }}',correct
'creature[i].hover()',correct
'creatureY + bellyOffsetY',correct
'distanceY = 0',correct
'shadowOffsetY = 75',correct
'amountJumps = PApplet.parseInt(abs(distanceX) / 100) + 1',correct
'creature[i].display()',correct
'shadowOffsetY -= jumpHeight',correct
'if (shadowHeight <= 0) {    shadowHeight = 0;}',correct
'jumpSin += PI / jumpSteps;',correct
'ellipse(positionEye2, creatureY - eyeOffsetY, 10, 15)',correct
'ellipse(creatureX, creatureY + bellyOffsetY, 70, bellyHeight);',correct
'void hover() {    if (dist(mouseX, mouseY, creatureX, creatureY) <= 70 || dist(mouseX, mouseY, creatureX, creatureY - headOffsetY) <= 30) {        click = true;    } else {        click = false;    }}',correct
'rect(0, 0 + legOffsetY, 7, 70, 5)',correct
'creatureClass',correct
'distanceY',correct
'rect(0, 0 + legOffsetY, 7, 70, 5);',correct
'distanceX',correct
'PApplet.parseInt(abs(distanceX) / 100) + 1 > PApplet.parseInt(abs(distanceY) / 100) + 1',correct
'for (int i = 0; i < creature.length; ++i) {    creature[i].hover();    if (creature[i].clicked()) {        ident = i;        break;    }}',correct
'creature[i].autojump();',correct
'ypos - 19',correct
'curveVertex(xpos + 112, ypos - 6)',correct
'xpos = xpos + (xspeed * xdirection)',correct
'body = new Body[numBodies]',correct
'ypos + 82',correct
'curveVertex(xpos - 9, ypos - 10);',correct
'ypos + 80',correct
'ypos - 27',correct
'ypos = ypos + (yspeed * ydirection)',correct
'{    // groups Ollies to mouse    xpos = mouseX;    ypos = mouseY;}',DecentralizedEventHandlingRule
'curveVertex(xpos - 2, ypos + 56);',correct
'curveVertex(xpos + 9, ypos - 10)',correct
'ypos - 24',correct
'curveVertex(xpos + 11, ypos - 8)',correct
'xpos + 6',correct
'xpos + 7',correct
'xpos + 8',correct
'xspeed = 6',correct
'xpos + 3',correct
'xpos + 4',correct
'ypos - 30',correct
'curveVertex(xpos + 14, ypos - 2)',correct
'body[i].move()',correct
'ypos - 38',correct
'ypos - 39',correct
'ypos - 36',correct
'if (mousePressed && (mouseButton == LEFT)) {    // groups Ollies to mouse    xpos = mouseX;    ypos = mouseY;}',correct
'curveVertex(xpos + 7, ypos + 70)',correct
'body[i] = new Body()',correct
'float xdirection = random(-3, 3);',correct
'{    // fancy background color changer    background(Color, 255, 255);    if (Color >= 255)        Color = 0;    else {        Color = Color + 1;    }    for (int i = 0; i < body.length; i++) {        // gives 20 Ollies        body[i].run();        body[i].move();        body[i].mouse();    }}',correct
'ellipse(xpos + 20, ypos + 20, 13, 20);',correct
'ypos + 60',correct
'ypos + 62',correct
'ypos + 63',correct
'numBodies = 20',correct
'curveVertex(xpos + 100, ypos - 56);',correct
'xpos + 9',correct
'if (ypos > height - 20 || ypos < 20) {    ydirection *= -1;}',correct
'ypos + 68',correct
'curveVertex(xpos - 2, ypos + 55);',correct
'ypos + 64',correct
'fill(d, e, f);',correct
'8.5f',correct
'ypos + 66',correct
'curveVertex(xpos - 2, ypos + 80)',correct
'curveVertex(xpos + 15, ypos);',correct
'a',correct
'b',correct
'c',correct
'd',correct
'if (Color >= 255)    Color = 0;else {    Color = Color + 1;}',correct
'e',correct
'f',correct
'xpos - 14.5f',correct
'ypos + 72',correct
'ypos + 74',correct
'ypos - 10',correct
'// builds the characterstrokeWeight(1);',correct
'ypos + 70',correct
'curveVertex(xpos + 14.5f, ypos + 9);',correct
'float ypos;',correct
'ypos - 16',correct
'ypos - 18',correct
'float ydirection = random(-3, 3);',correct
'ypos - 12',correct
'ypos + 76',correct
'curveVertex(xpos + 11, ypos + 45)',correct
'ypos + 78',correct
'ypos - 14',correct
'xpos + 15',correct
'xpos + 14',correct
'// fancy background color changerbackground(Color, 255, 255);',correct
'xpos + 13',correct
'ellipse(xpos + 39, ypos - 19, 3, 3);',correct
'xpos + 12',correct
'curveVertex(xpos + 120, ypos - 39);',correct
'curveVertex(xpos - 13, ypos + 25);',correct
'xpos + 11',correct
'curveVertex(xpos + 9, ypos - 10);',correct
'curveVertex(xpos + 7, ypos - 12);',correct
'curveVertex(xpos - 38, ypos - 27)',correct
'colorMode(HSB)',correct
'curveVertex(xpos - 118, ypos - 30)',correct
'curveVertex(xpos - 118, ypos - 42)',correct
'ypos + 40',correct
'void setup() {    colorMode(HSB);    // Array Setup    body = new Body[numBodies];    for (int i = 0; i < body.length; i++) {        body[i] = new Body();    }}',correct
'{    // builds the character    strokeWeight(1);    // feet    fill(a, b, c);    ellipse(xpos - 30, ypos + 63, 45, 25);    ellipse(xpos + 30, ypos + 63, 45, 25);    // ears    beginShape();    curveVertex(xpos - 100, ypos);    curveVertex(xpos - 106, ypos - 3);    curveVertex(xpos - 112, ypos - 6);    curveVertex(xpos - 112, ypos - 18);    curveVertex(xpos - 114, ypos - 24);    curveVertex(xpos - 118, ypos - 30);    curveVertex(xpos - 119, ypos - 36);    curveVertex(xpos - 120, ypos - 39);    curveVertex(xpos - 118, ypos - 42);    curveVertex(xpos - 116, ypos - 49);    curveVertex(xpos - 112, ypos - 52);    curveVertex(xpos - 106, ypos - 54);    curveVertex(xpos - 100, ypos - 56);    curveVertex(xpos - 88, ypos - 58);    curveVertex(xpos - 82, ypos - 56);    curveVertex(xpos - 76, ypos - 54);    curveVertex(xpos - 58, ypos - 46);    curveVertex(xpos - 52, ypos - 38);    curveVertex(xpos - 46, ypos - 30);    curveVertex(xpos - 38, ypos - 27);    curveVertex(xpos - 37, ypos - 27);    endShape();    beginShape();    curveVertex(xpos + 100, ypos);    curveVertex(xpos + 106, ypos - 3);    curveVertex(xpos + 112, ypos - 6);    curveVertex(xpos + 112, ypos - 18);    curveVertex(xpos + 114, ypos - 24);    curveVertex(xpos + 118, ypos - 30);    curveVertex(xpos + 119, ypos - 36);    curveVertex(xpos + 120, ypos - 39);    curveVertex(xpos + 118, ypos - 42);    curveVertex(xpos + 116, ypos - 49);    curveVertex(xpos + 112, ypos - 52);    curveVertex(xpos + 106, ypos - 54);    curveVertex(xpos + 100, ypos - 56);    curveVertex(xpos + 88, ypos - 58);    curveVertex(xpos + 82, ypos - 56);    curveVertex(xpos + 76, ypos - 54);    curveVertex(xpos + 58, ypos - 46);    curveVertex(xpos + 52, ypos - 38);    curveVertex(xpos + 46, ypos - 30);    curveVertex(xpos + 38, ypos - 27);    curveVertex(xpos + 37, ypos - 27);    endShape();    // body    ellipse(xpos, ypos, 200, 130);    fill(d, e, f);    ellipse(xpos - 37, ypos - 18, 20, 20);    ellipse(xpos + 37, ypos - 18, 20, 20);    fill(255, 0, 0);    ellipse(xpos - 39, ypos - 19, 3, 3);    ellipse(xpos + 39, ypos - 19, 3, 3);    // teeth    fill(d, e, f);    ellipse(xpos - 20, ypos + 20, 13, 20);    ellipse(xpos + 20, ypos + 20, 13, 20);    // nose    fill(a, b, c);    beginShape();    curveVertex(xpos, ypos - 19);    curveVertex(xpos - 3, ypos - 16);    curveVertex(xpos - 6, ypos - 14);    curveVertex(xpos - 7, ypos - 12);    curveVertex(xpos - 9, ypos - 10);    curveVertex(xpos - 11, ypos - 8);    curveVertex(xpos - 12, ypos - 6);    curveVertex(xpos - 13, ypos - 4);    curveVertex(xpos - 14, ypos - 2);    curveVertex(xpos - 15, ypos);    curveVertex(xpos - 15, ypos + 5);    curveVertex(xpos - 14.5f, ypos + 10);    curveVertex(xpos - 14, ypos + 15);    curveVertex(xpos - 13.5f, ypos + 20);    curveVertex(xpos - 13, ypos + 25);    curveVertex(xpos - 12, ypos + 30);    curveVertex(xpos - 10, ypos + 35);    curveVertex(xpos - 9, ypos + 40);    curveVertex(xpos - 8, ypos + 45);    curveVertex(xpos - 6, ypos + 50);    curveVertex(xpos - 2, ypos + 55);    curveVertex(xpos - 2, ypos + 56);    curveVertex(xpos - 3, ypos + 58);    curveVertex(xpos - 4, ypos + 60);    curveVertex(xpos - 5, ypos + 62);    curveVertex(xpos - 5.5f, ypos + 64);    curveVertex(xpos - 6, ypos + 66);    curveVertex(xpos - 6.5f, ypos + 68);    curveVertex(xpos - 6.5f, ypos + 70);    curveVertex(xpos - 6, ypos + 72);    curveVertex(xpos - 5, ypos + 74);    curveVertex(xpos - 4.5f, ypos + 76);    curveVertex(xpos - 3.5f, ypos + 78);    curveVertex(xpos - 2, ypos + 80);    curveVertex(xpos, ypos + 82);    curveVertex(xpos + 2.5f, ypos + 80);    curveVertex(xpos + 4, ypos + 78);    curveVertex(xpos + 6, ypos + 74);    curveVertex(xpos + 7, ypos + 70);    curveVertex(xpos + 8, ypos + 66);    curveVertex(xpos + 8.5f, ypos + 62);    curveVertex(xpos + 9, ypos + 58);    curveVertex(xpos + 9.5f, ypos + 54);    curveVertex(xpos + 11, ypos + 45);    curveVertex(xpos + 12, ypos + 36);    curveVertex(xpos + 13, ypos + 27);    curveVertex(xpos + 14, ypos + 18);    curveVertex(xpos + 14.5f, ypos + 9);    curveVertex(xpos + 15, ypos);    curveVertex(xpos + 14, ypos - 2);    curveVertex(xpos + 13, ypos - 4);    curveVertex(xpos + 12, ypos - 6);    curveVertex(xpos + 11, ypos - 8);    curveVertex(xpos + 9, ypos - 10);    curveVertex(xpos + 7, ypos - 12);    curveVertex(xpos + 6, ypos - 14);    curveVertex(xpos + 3, ypos - 16);    curveVertex(xpos, ypos - 19);    endShape();}',LongMethodRule
'int b;',ShortVariable
'curveVertex(xpos + 58, ypos - 46);',correct
'curveVertex(xpos + 14.5f, ypos + 9)',correct
'body[i] = new Body();',correct
'curveVertex(xpos - 13, ypos - 4)',correct
'ypos + 45',correct
'{    // gives 20 Ollies    body[i].run();    body[i].move();    body[i].mouse();}',correct
'curveVertex(xpos + 6, ypos + 74);',correct
'Color',correct
'curveVertex(xpos + 13, ypos + 27);',correct
'curveVertex(xpos + 7, ypos - 12)',correct
'curveVertex(xpos - 100, ypos)',correct
'curveVertex(xpos - 6, ypos + 66);',correct
'ypos + 50',correct
'curveVertex(xpos - 3.5f, ypos + 78)',correct
'height - 22',correct
'curveVertex(xpos - 6.5f, ypos + 70);',correct
'height - 20',correct
'14.5f',correct
'ypos + 58',correct
'curveVertex(xpos + 13, ypos + 27)',correct
'b = 125',correct
'9.5f',correct
'ypos + 54',correct
'ypos + 55',correct
'curveVertex(xpos + 11, ypos - 8);',correct
'ypos + 56',correct
'ypos = mouseY',correct
'ypos + 18',correct
'curveVertex(xpos + 118, ypos - 42);',correct
'curveVertex(xpos + 6, ypos - 14);',correct
'curveVertex(xpos - 119, ypos - 36)',correct
'xpos - 13.5f',correct
'ellipse(xpos - 30, ypos + 63, 45, 25);',correct
'Processing',correct
'curveVertex(xpos + 100, ypos)',correct
'Color = Color + 1;',DrawingStateChangeRule
'// teethfill(d, e, f);',correct
'// Background color globalfloat Color;',correct
'b = 0;',correct
'13.5f',correct
'curveVertex(xpos + 118, ypos - 30);',correct
'ypos + 25',correct
'curveVertex(xpos + 7, ypos + 70);',correct
'ypos + 27',correct
'ypos + 20',correct
'curveVertex(xpos + 46, ypos - 30);',correct
'width - 22',correct
'curveVertex(xpos - 10, ypos + 35);',correct
'curveVertex(xpos + 52, ypos - 38);',correct
'curveVertex(xpos - 112, ypos - 52)',correct
'width - 20',correct
'curveVertex(xpos + 82, ypos - 56)',correct
'curveVertex(xpos + 88, ypos - 58);',correct
'mousePressed && (mouseButton == LEFT)',DecentralizedEventHandlingRule
'ellipse(xpos + 30, ypos + 63, 45, 25)',correct
'curveVertex(xpos - 3, ypos - 16);',correct
'ypos + 30',correct
'curveVertex(xpos - 38, ypos - 27);',correct
'endShape()',correct
'ypos + 35',correct
'ypos + 36',correct
'setup',correct
'i = 0',correct
'xpos + 120',correct
'xpos + 58',correct
'curveVertex(xpos + 114, ypos - 24);',correct
'xpos + 52',correct
'fill(d, e, f)',correct
'curveVertex(xpos - 11, ypos - 8);',correct
'colorMode(HSB);',correct
'xpos > width - 20',correct
'curveVertex(xpos - 106, ypos - 3)',correct
'xpos + 119',correct
'curveVertex(xpos - 106, ypos - 3);',correct
'void run() {    // builds the character    strokeWeight(1);    // feet    fill(a, b, c);    ellipse(xpos - 30, ypos + 63, 45, 25);    ellipse(xpos + 30, ypos + 63, 45, 25);    // ears    beginShape();    curveVertex(xpos - 100, ypos);    curveVertex(xpos - 106, ypos - 3);    curveVertex(xpos - 112, ypos - 6);    curveVertex(xpos - 112, ypos - 18);    curveVertex(xpos - 114, ypos - 24);    curveVertex(xpos - 118, ypos - 30);    curveVertex(xpos - 119, ypos - 36);    curveVertex(xpos - 120, ypos - 39);    curveVertex(xpos - 118, ypos - 42);    curveVertex(xpos - 116, ypos - 49);    curveVertex(xpos - 112, ypos - 52);    curveVertex(xpos - 106, ypos - 54);    curveVertex(xpos - 100, ypos - 56);    curveVertex(xpos - 88, ypos - 58);    curveVertex(xpos - 82, ypos - 56);    curveVertex(xpos - 76, ypos - 54);    curveVertex(xpos - 58, ypos - 46);    curveVertex(xpos - 52, ypos - 38);    curveVertex(xpos - 46, ypos - 30);    curveVertex(xpos - 38, ypos - 27);    curveVertex(xpos - 37, ypos - 27);    endShape();    beginShape();    curveVertex(xpos + 100, ypos);    curveVertex(xpos + 106, ypos - 3);    curveVertex(xpos + 112, ypos - 6);    curveVertex(xpos + 112, ypos - 18);    curveVertex(xpos + 114, ypos - 24);    curveVertex(xpos + 118, ypos - 30);    curveVertex(xpos + 119, ypos - 36);    curveVertex(xpos + 120, ypos - 39);    curveVertex(xpos + 118, ypos - 42);    curveVertex(xpos + 116, ypos - 49);    curveVertex(xpos + 112, ypos - 52);    curveVertex(xpos + 106, ypos - 54);    curveVertex(xpos + 100, ypos - 56);    curveVertex(xpos + 88, ypos - 58);    curveVertex(xpos + 82, ypos - 56);    curveVertex(xpos + 76, ypos - 54);    curveVertex(xpos + 58, ypos - 46);    curveVertex(xpos + 52, ypos - 38);    curveVertex(xpos + 46, ypos - 30);    curveVertex(xpos + 38, ypos - 27);    curveVertex(xpos + 37, ypos - 27);    endShape();    // body    ellipse(xpos, ypos, 200, 130);    fill(d, e, f);    ellipse(xpos - 37, ypos - 18, 20, 20);    ellipse(xpos + 37, ypos - 18, 20, 20);    fill(255, 0, 0);    ellipse(xpos - 39, ypos - 19, 3, 3);    ellipse(xpos + 39, ypos - 19, 3, 3);    // teeth    fill(d, e, f);    ellipse(xpos - 20, ypos + 20, 13, 20);    ellipse(xpos + 20, ypos + 20, 13, 20);    // nose    fill(a, b, c);    beginShape();    curveVertex(xpos, ypos - 19);    curveVertex(xpos - 3, ypos - 16);    curveVertex(xpos - 6, ypos - 14);    curveVertex(xpos - 7, ypos - 12);    curveVertex(xpos - 9, ypos - 10);    curveVertex(xpos - 11, ypos - 8);    curveVertex(xpos - 12, ypos - 6);    curveVertex(xpos - 13, ypos - 4);    curveVertex(xpos - 14, ypos - 2);    curveVertex(xpos - 15, ypos);    curveVertex(xpos - 15, ypos + 5);    curveVertex(xpos - 14.5f, ypos + 10);    curveVertex(xpos - 14, ypos + 15);    curveVertex(xpos - 13.5f, ypos + 20);    curveVertex(xpos - 13, ypos + 25);    curveVertex(xpos - 12, ypos + 30);    curveVertex(xpos - 10, ypos + 35);    curveVertex(xpos - 9, ypos + 40);    curveVertex(xpos - 8, ypos + 45);    curveVertex(xpos - 6, ypos + 50);    curveVertex(xpos - 2, ypos + 55);    curveVertex(xpos - 2, ypos + 56);    curveVertex(xpos - 3, ypos + 58);    curveVertex(xpos - 4, ypos + 60);    curveVertex(xpos - 5, ypos + 62);    curveVertex(xpos - 5.5f, ypos + 64);    curveVertex(xpos - 6, ypos + 66);    curveVertex(xpos - 6.5f, ypos + 68);    curveVertex(xpos - 6.5f, ypos + 70);    curveVertex(xpos - 6, ypos + 72);    curveVertex(xpos - 5, ypos + 74);    curveVertex(xpos - 4.5f, ypos + 76);    curveVertex(xpos - 3.5f, ypos + 78);    curveVertex(xpos - 2, ypos + 80);    curveVertex(xpos, ypos + 82);    curveVertex(xpos + 2.5f, ypos + 80);    curveVertex(xpos + 4, ypos + 78);    curveVertex(xpos + 6, ypos + 74);    curveVertex(xpos + 7, ypos + 70);    curveVertex(xpos + 8, ypos + 66);    curveVertex(xpos + 8.5f, ypos + 62);    curveVertex(xpos + 9, ypos + 58);    curveVertex(xpos + 9.5f, ypos + 54);    curveVertex(xpos + 11, ypos + 45);    curveVertex(xpos + 12, ypos + 36);    curveVertex(xpos + 13, ypos + 27);    curveVertex(xpos + 14, ypos + 18);    curveVertex(xpos + 14.5f, ypos + 9);    curveVertex(xpos + 15, ypos);    curveVertex(xpos + 14, ypos - 2);    curveVertex(xpos + 13, ypos - 4);    curveVertex(xpos + 12, ypos - 6);    curveVertex(xpos + 11, ypos - 8);    curveVertex(xpos + 9, ypos - 10);    curveVertex(xpos + 7, ypos - 12);    curveVertex(xpos + 6, ypos - 14);    curveVertex(xpos + 3, ypos - 16);    curveVertex(xpos, ypos - 19);    endShape();}',correct
'curveVertex(xpos + 3, ypos - 16)',correct
'curveVertex(xpos - 14, ypos + 15)',correct
'curveVertex(xpos + 14, ypos + 18)',correct
'xpos + 46',correct
'curveVertex(xpos + 4, ypos + 78);',correct
'xpos + 116',correct
'xpos + 118',correct
'xpos + 112',correct
'xpos + 114',correct
'curveVertex(xpos - 100, ypos);',correct
'curveVertex(xpos - 112, ypos - 18)',correct
'xpos - 10',correct
'curveVertex(xpos - 116, ypos - 49);',correct
'xpos - 11',correct
'xpos - 12',correct
'xpos - 13',correct
'beginShape()',correct
'xpos - 14',correct
'xpos - 15',correct
'b = 0',correct
'if (xpos > width - 20 || xpos < 20) {    xdirection *= -1;}',correct
'curveVertex(xpos + 88, ypos - 58)',correct
'xpos + 39',correct
'xpos + 38',correct
'xpos + 37',correct
'curveVertex(xpos + 4, ypos + 78)',correct
'strokeWeight(1)',correct
'xpos + 30',correct
'curveVertex(xpos - 15, ypos);',correct
'xpos + 106',correct
'xpos + 100',correct
'e = 207;',correct
'xpos - 20',correct
'ellipse(xpos + 37, ypos - 18, 20, 20);',correct
'f = 255;',correct
'curveVertex(xpos - 52, ypos - 38);',correct
'curveVertex(xpos + 9.5f, ypos + 54);',correct
'curveVertex(xpos - 3, ypos + 58);',correct
'curveVertex(xpos - 6.5f, ypos + 70)',correct
'body[i].mouse()',correct
'curveVertex(xpos - 7, ypos - 12)',correct
'xpos + 20',correct
'draw',correct
'// Colorint a;',correct
'xpos - 30',correct
'// Created by Noa van der Klooster (s2174162)',correct
'curveVertex(xpos + 8, ypos + 66)',correct
'ydirection *= -1',correct
'/*By clicking the left mouse button, you group all Ollies and you can move them. By releasing the mouse button, you can set them free again. By clicking the right mouse button, the Ollies switch colors. */',correct
'void mouse() {    if (mousePressed && (mouseButton == LEFT)) {        // groups Ollies to mouse        xpos = mouseX;        ypos = mouseY;    }    // Mousepresses    if (mousePressed && (mouseButton == RIGHT)) {        // sets the HSB values for Ollie        a = 255;        b = 0;        c = 255;        d = 0;        e = 207;        f = 255;    } else {        // regulates the normal HSB values for Ollie        a = 201;        b = 125;        c = 59;        d = 255;        e = 0;        f = 255;    }}',correct
'{    if (mousePressed && (mouseButton == LEFT)) {        // groups Ollies to mouse        xpos = mouseX;        ypos = mouseY;    }    // Mousepresses    if (mousePressed && (mouseButton == RIGHT)) {        // sets the HSB values for Ollie        a = 255;        b = 0;        c = 255;        d = 0;        e = 207;        f = 255;    } else {        // regulates the normal HSB values for Ollie        a = 201;        b = 125;        c = 59;        d = 255;        e = 0;        f = 255;    }}',correct
'curveVertex(xpos + 112, ypos - 6);',correct
'curveVertex(xpos - 11, ypos - 8)',correct
'curveVertex(xpos, ypos + 82);',correct
'ypos = mouseY;',correct
'xpos - 37',correct
'xpos - 38',correct
'xpos - 39',correct
'curveVertex(xpos - 37, ypos - 27)',correct
'fill(255, 0, 0)',correct
'curveVertex(xpos + 14, ypos + 18);',correct
'Color = Color + 1',correct
'curveVertex(xpos - 82, ypos - 56)',correct
'xpos + 2.5f',correct
'body',correct
'curveVertex(xpos, ypos - 19);',correct
'curveVertex(xpos - 5, ypos + 74);',correct
'e = 0;',correct
'xpos > width - 20 || xpos < 20',correct
'// Movementfloat xspeed = 6;',correct
'curveVertex(xpos + 3, ypos - 16);',correct
'curveVertex(xpos - 76, ypos - 54)',correct
'void',correct
'-1',correct
'xpos + 88',correct
'-3',correct
'class Body {    float xpos;    float ypos;    // Color    int a;    int b;    int c;    int d;    int e;    int f;    // Movement    float xspeed = 6;    float yspeed = 6;    float xdirection = random(-3, 3);    float ydirection = random(-3, 3);    Body() {        // sets Ollies to different places every time        xpos = random(22, width - 22);        ypos = random(22, height - 22);    }    void run() {        // builds the character        strokeWeight(1);        // feet        fill(a, b, c);        ellipse(xpos - 30, ypos + 63, 45, 25);        ellipse(xpos + 30, ypos + 63, 45, 25);        // ears        beginShape();        curveVertex(xpos - 100, ypos);        curveVertex(xpos - 106, ypos - 3);        curveVertex(xpos - 112, ypos - 6);        curveVertex(xpos - 112, ypos - 18);        curveVertex(xpos - 114, ypos - 24);        curveVertex(xpos - 118, ypos - 30);        curveVertex(xpos - 119, ypos - 36);        curveVertex(xpos - 120, ypos - 39);        curveVertex(xpos - 118, ypos - 42);        curveVertex(xpos - 116, ypos - 49);        curveVertex(xpos - 112, ypos - 52);        curveVertex(xpos - 106, ypos - 54);        curveVertex(xpos - 100, ypos - 56);        curveVertex(xpos - 88, ypos - 58);        curveVertex(xpos - 82, ypos - 56);        curveVertex(xpos - 76, ypos - 54);        curveVertex(xpos - 58, ypos - 46);        curveVertex(xpos - 52, ypos - 38);        curveVertex(xpos - 46, ypos - 30);        curveVertex(xpos - 38, ypos - 27);        curveVertex(xpos - 37, ypos - 27);        endShape();        beginShape();        curveVertex(xpos + 100, ypos);        curveVertex(xpos + 106, ypos - 3);        curveVertex(xpos + 112, ypos - 6);        curveVertex(xpos + 112, ypos - 18);        curveVertex(xpos + 114, ypos - 24);        curveVertex(xpos + 118, ypos - 30);        curveVertex(xpos + 119, ypos - 36);        curveVertex(xpos + 120, ypos - 39);        curveVertex(xpos + 118, ypos - 42);        curveVertex(xpos + 116, ypos - 49);        curveVertex(xpos + 112, ypos - 52);        curveVertex(xpos + 106, ypos - 54);        curveVertex(xpos + 100, ypos - 56);        curveVertex(xpos + 88, ypos - 58);        curveVertex(xpos + 82, ypos - 56);        curveVertex(xpos + 76, ypos - 54);        curveVertex(xpos + 58, ypos - 46);        curveVertex(xpos + 52, ypos - 38);        curveVertex(xpos + 46, ypos - 30);        curveVertex(xpos + 38, ypos - 27);        curveVertex(xpos + 37, ypos - 27);        endShape();        // body        ellipse(xpos, ypos, 200, 130);        fill(d, e, f);        ellipse(xpos - 37, ypos - 18, 20, 20);        ellipse(xpos + 37, ypos - 18, 20, 20);        fill(255, 0, 0);        ellipse(xpos - 39, ypos - 19, 3, 3);        ellipse(xpos + 39, ypos - 19, 3, 3);        // teeth        fill(d, e, f);        ellipse(xpos - 20, ypos + 20, 13, 20);        ellipse(xpos + 20, ypos + 20, 13, 20);        // nose        fill(a, b, c);        beginShape();        curveVertex(xpos, ypos - 19);        curveVertex(xpos - 3, ypos - 16);        curveVertex(xpos - 6, ypos - 14);        curveVertex(xpos - 7, ypos - 12);        curveVertex(xpos - 9, ypos - 10);        curveVertex(xpos - 11, ypos - 8);        curveVertex(xpos - 12, ypos - 6);        curveVertex(xpos - 13, ypos - 4);        curveVertex(xpos - 14, ypos - 2);        curveVertex(xpos - 15, ypos);        curveVertex(xpos - 15, ypos + 5);        curveVertex(xpos - 14.5f, ypos + 10);        curveVertex(xpos - 14, ypos + 15);        curveVertex(xpos - 13.5f, ypos + 20);        curveVertex(xpos - 13, ypos + 25);        curveVertex(xpos - 12, ypos + 30);        curveVertex(xpos - 10, ypos + 35);        curveVertex(xpos - 9, ypos + 40);        curveVertex(xpos - 8, ypos + 45);        curveVertex(xpos - 6, ypos + 50);        curveVertex(xpos - 2, ypos + 55);        curveVertex(xpos - 2, ypos + 56);        curveVertex(xpos - 3, ypos + 58);        curveVertex(xpos - 4, ypos + 60);        curveVertex(xpos - 5, ypos + 62);        curveVertex(xpos - 5.5f, ypos + 64);        curveVertex(xpos - 6, ypos + 66);        curveVertex(xpos - 6.5f, ypos + 68);        curveVertex(xpos - 6.5f, ypos + 70);        curveVertex(xpos - 6, ypos + 72);        curveVertex(xpos - 5, ypos + 74);        curveVertex(xpos - 4.5f, ypos + 76);        curveVertex(xpos - 3.5f, ypos + 78);        curveVertex(xpos - 2, ypos + 80);        curveVertex(xpos, ypos + 82);        curveVertex(xpos + 2.5f, ypos + 80);        curveVertex(xpos + 4, ypos + 78);        curveVertex(xpos + 6, ypos + 74);        curveVertex(xpos + 7, ypos + 70);        curveVertex(xpos + 8, ypos + 66);        curveVertex(xpos + 8.5f, ypos + 62);        curveVertex(xpos + 9, ypos + 58);        curveVertex(xpos + 9.5f, ypos + 54);        curveVertex(xpos + 11, ypos + 45);        curveVertex(xpos + 12, ypos + 36);        curveVertex(xpos + 13, ypos + 27);        curveVertex(xpos + 14, ypos + 18);        curveVertex(xpos + 14.5f, ypos + 9);        curveVertex(xpos + 15, ypos);        curveVertex(xpos + 14, ypos - 2);        curveVertex(xpos + 13, ypos - 4);        curveVertex(xpos + 12, ypos - 6);        curveVertex(xpos + 11, ypos - 8);        curveVertex(xpos + 9, ypos - 10);        curveVertex(xpos + 7, ypos - 12);        curveVertex(xpos + 6, ypos - 14);        curveVertex(xpos + 3, ypos - 16);        curveVertex(xpos, ypos - 19);        endShape();    }    void move() {        // defines movement and wall bouncing        xpos = xpos + (xspeed * xdirection);        ypos = ypos + (yspeed * ydirection);        if (xpos > width - 20 || xpos < 20) {            xdirection *= -1;        }        if (ypos > height - 20 || ypos < 20) {            ydirection *= -1;        }    }    void mouse() {        if (mousePressed && (mouseButton == LEFT)) {            // groups Ollies to mouse            xpos = mouseX;            ypos = mouseY;        }        // Mousepresses        if (mousePressed && (mouseButton == RIGHT)) {            // sets the HSB values for Ollie            a = 255;            b = 0;            c = 255;            d = 0;            e = 207;            f = 255;        } else {            // regulates the normal HSB values for Ollie            a = 201;            b = 125;            c = 59;            d = 255;            e = 0;            f = 255;        }    }}',correct
'curveVertex(xpos - 46, ypos - 30);',correct
'{    ydirection *= -1;}',correct
'xpos + 82',correct
'curveVertex(xpos - 5, ypos + 62);',correct
'curveVertex(xpos - 58, ypos - 46)',correct
'curveVertex(xpos - 76, ypos - 54);',correct
'curveVertex(xpos + 13, ypos - 4);',correct
'curveVertex(xpos - 6, ypos + 50);',correct
'curveVertex(xpos - 116, ypos - 49)',correct
'{    colorMode(HSB);    // Array Setup    body = new Body[numBodies];    for (int i = 0; i < body.length; i++) {        body[i] = new Body();    }}',correct
'xpos + 76',correct
'curveVertex(xpos - 100, ypos - 56);',correct
'c = 59',correct
'i < body.length',correct
'// Mousepressesif (mousePressed && (mouseButton == RIGHT)) {    // sets the HSB values for Ollie    a = 255;    b = 0;    c = 255;    d = 0;    e = 207;    f = 255;} else {    // regulates the normal HSB values for Ollie    a = 201;    b = 125;    c = 59;    d = 255;    e = 0;    f = 255;}',correct
'beginShape();',correct
'curveVertex(xpos - 4, ypos + 60)',correct
'curveVertex(xpos + 12, ypos - 6)',correct
'ypos - 42',correct
'curveVertex(xpos + 106, ypos - 54);',correct
'void draw() {    // fancy background color changer    background(Color, 255, 255);    if (Color >= 255)        Color = 0;    else {        Color = Color + 1;    }    for (int i = 0; i < body.length; i++) {        // gives 20 Ollies        body[i].run();        body[i].move();        body[i].mouse();    }}',correct
'{    // sets the HSB values for Ollie    a = 255;    b = 0;    c = 255;    d = 0;    e = 207;    f = 255;}',DecentralizedEventHandlingRule
'yspeed = 6',correct
'curveVertex(xpos - 106, ypos - 54)',correct
'ypos - 49',correct
'curveVertex(xpos - 112, ypos - 52);',correct
'Body',correct
'ypos - 46',correct
'curveVertex(xpos + 118, ypos - 30)',correct
'ellipse(xpos + 37, ypos - 18, 20, 20)',correct
'body[i].run()',correct
'xdirection *= -1',correct
'curveVertex(xpos + 118, ypos - 42)',correct
'curveVertex(xpos + 2.5f, ypos + 80);',correct
'{    Color = Color + 1;}',correct
'ypos - 52',correct
'// regulates the normal HSB values for Olliea = 201;',correct
'ypos - 54',correct
'curveVertex(xpos - 6, ypos + 72);',correct
'curveVertex(xpos - 3, ypos - 16)',correct
'curveVertex(xpos - 12, ypos + 30)',correct
'endShape();',correct
'ypos - 56',correct
'ypos - 58',correct
'new Body[numBodies]',correct
'ypos > height - 20 || ypos < 20',correct
'// bodyellipse(xpos, ypos, 200, 130);',correct
'curveVertex(xpos + 116, ypos - 49);',correct
'curveVertex(xpos + 37, ypos - 27);',correct
'xpos - 82',correct
'xpos + 9.5f',correct
'curveVertex(xpos + 11, ypos + 45);',correct
'xpos - 88',correct
'curveVertex(xpos - 13, ypos - 4);',correct
'curveVertex(xpos - 3, ypos + 58)',correct
'2.5f',correct
'curveVertex(xpos - 15, ypos)',correct
'// earsbeginShape();',correct
'curveVertex(xpos - 5.5f, ypos + 64);',correct
'curveVertex(xpos, ypos - 19)',correct
'curveVertex(xpos - 112, ypos - 6);',correct
'ellipse(xpos, ypos, 200, 130)',correct
'curveVertex(xpos - 12, ypos - 6)',correct
'curveVertex(xpos - 46, ypos - 30)',correct
'a = 255',correct
'ellipse(xpos - 30, ypos + 63, 45, 25)',correct
'curveVertex(xpos - 114, ypos - 24);',correct
'Body() {    // sets Ollies to different places every time    xpos = random(22, width - 22);    ypos = random(22, height - 22);}',correct
'xpos - 4.5f',correct
'curveVertex(xpos + 14, ypos - 2);',correct
'for (int i = 0; i < body.length; i++) {    body[i] = new Body();}',correct
'fill(255, 0, 0);',correct
'curveVertex(xpos + 38, ypos - 27);',correct
'c = 255;',correct
'body.length',correct
'curveVertex(xpos + 120, ypos - 39)',correct
'Body[]',correct
'curveVertex(xpos + 15, ypos)',correct
'curveVertex(xpos - 118, ypos - 42);',correct
'ellipse(xpos + 39, ypos - 19, 3, 3)',correct
'curveVertex(xpos - 15, ypos + 5)',correct
'xdirection = random(-3, 3)',correct
'ellipse(xpos + 30, ypos + 63, 45, 25);',correct
'curveVertex(xpos + 112, ypos - 18)',correct
'curveVertex(xpos + 9.5f, ypos + 54)',correct
'curveVertex(xpos - 13.5f, ypos + 20)',correct
'Color + 1',correct
'f = 255',correct
'curveVertex(xpos - 118, ypos - 30);',correct
'Color >= 255',correct
'3.5f',correct
'ellipse(xpos - 39, ypos - 19, 3, 3);',correct
'// gives 20 Olliesbody[i].run();',correct
'curveVertex(xpos + 112, ypos - 18);',correct
'ypos = random(22, height - 22);',correct
'ellipse(xpos - 39, ypos - 19, 3, 3)',correct
'curveVertex(xpos - 14.5f, ypos + 10);',correct
'curveVertex(xpos - 6, ypos + 66)',correct
'run',LongMethodRule
'body[i]',correct
'ellipse(xpos - 20, ypos + 20, 13, 20)',correct
'mouse',correct
'curveVertex(xpos + 82, ypos - 56);',correct
'xpos - 46',correct
'// sets Ollies to different places every timexpos = random(22, width - 22);',correct
'ypos = random(22, height - 22)',correct
'curveVertex(xpos + 119, ypos - 36);',correct
'random(22, height - 22)',correct
'curveVertex(xpos - 14, ypos - 2);',correct
'random(-3, 3)',correct
'curveVertex(xpos - 8, ypos + 45);',correct
'curveVertex(xpos - 12, ypos + 30);',correct
'xpos - 100',correct
'ypos < 20',correct
'curveVertex(xpos + 52, ypos - 38)',correct
'curveVertex(xpos - 4, ypos + 60);',correct
'curveVertex(xpos + 46, ypos - 30)',correct
'xpos - 52',correct
'curveVertex(xpos - 106, ypos - 54);',correct
'curveVertex(xpos - 2, ypos + 55)',correct
'curveVertex(xpos + 100, ypos - 56)',correct
'curveVertex(xpos - 6, ypos - 14)',correct
'c = 59;',correct
'xpos - 58',correct
'{    // regulates the normal HSB values for Ollie    a = 201;    b = 125;    c = 59;    d = 255;    e = 0;    f = 255;}',DecentralizedEventHandlingRule
'curveVertex(xpos + 114, ypos - 24)',correct
'random(22, width - 22)',correct
'curveVertex(xpos - 3.5f, ypos + 78);',correct
'd = 0',correct
'curveVertex(xpos + 116, ypos - 49)',correct
'd = 255',correct
'curveVertex(xpos + 13, ypos - 4)',correct
'curveVertex(xpos + 8, ypos + 66);',correct
'xpos - 112',correct
'curveVertex(xpos + 58, ypos - 46)',correct
'xpos - 114',correct
'xpos - 116',correct
'xdirection *= -1;',correct
'curveVertex(xpos + 2.5f, ypos + 80)',correct
'xpos - 106',correct
'curveVertex(xpos + 100, ypos);',correct
'4.5f',correct
'curveVertex(xpos - 2, ypos + 56)',correct
'xpos - 3.5f',correct
'curveVertex(xpos + 8.5f, ypos + 62);',correct
'curveVertex(xpos - 112, ypos - 18);',correct
'curveVertex(xpos - 6.5f, ypos + 68);',correct
'curveVertex(xpos - 14.5f, ypos + 10)',correct
'body[i].move();',correct
'b = 125;',correct
'xpos',correct
'{    body[i] = new Body();}',correct
'xpos - 120',correct
'ypos + 9',correct
'ypos + 5',correct
'curveVertex(xpos - 8, ypos + 45)',correct
'xpos - 118',correct
'ellipse(xpos - 20, ypos + 20, 13, 20);',correct
'ypos = ypos + (yspeed * ydirection);',correct
'int i = 0',correct
'xpos - 119',correct
'// sets the HSB values for Olliea = 255;',correct
'curveVertex(xpos - 2, ypos + 80);',correct
'ypos + (yspeed * ydirection)',correct
'curveVertex(xpos + 76, ypos - 54);',correct
'xpos - 76',correct
'c = 255',correct
'ypos > height - 20',correct
'e = 207',correct
'ypos',correct
'curveVertex(xpos - 14, ypos - 2)',correct
'curveVertex(xpos - 6, ypos + 50)',correct
'xpos = random(22, width - 22)',correct
'// groups Ollies to mousexpos = mouseX;',correct
'{    // defines movement and wall bouncing    xpos = xpos + (xspeed * xdirection);    ypos = ypos + (yspeed * ydirection);    if (xpos > width - 20 || xpos < 20) {        xdirection *= -1;    }    if (ypos > height - 20 || ypos < 20) {        ydirection *= -1;    }}',correct
'curveVertex(xpos - 5, ypos + 62)',correct
'int f;',ShortVariable
'curveVertex(xpos - 5, ypos + 74)',correct
'float yspeed = 6;',correct
'// defines movement and wall bouncingxpos = xpos + (xspeed * xdirection);',correct
'background(Color, 255, 255)',correct
'xpos + 14.5f',correct
'curveVertex(xpos - 9, ypos - 10)',correct
'xpos + (xspeed * xdirection)',correct
'// Created by Noa van der Klooster (s2174162)/*By clicking the left mouse button, you group all Ollies and you can move them. By releasing the mouse button, you can set them free again. By clicking the right mouse button, the Ollies switch colors. */// Array globalBody[] body;',correct
'new Body()',correct
'curveVertex(xpos + 12, ypos - 6);',correct
'5.5f',correct
'int e;',ShortVariable
'curveVertex(xpos - 14, ypos + 15);',correct
'ypos + 15',correct
'ypos + 10',correct
'curveVertex(xpos + 76, ypos - 54)',correct
'curveVertex(xpos - 9, ypos + 40)',correct
'curveVertex(xpos - 88, ypos - 58);',correct
'ellipse(xpos + 20, ypos + 20, 13, 20)',correct
'curveVertex(xpos - 119, ypos - 36);',correct
'e = 0',correct
'ypos - 8',correct
'int d;',ShortVariable
'{    // sets Ollies to different places every time    xpos = random(22, width - 22);    ypos = random(22, height - 22);}',correct
'int numBodies = 20;',correct
'curveVertex(xpos - 10, ypos + 35)',correct
'void move() {    // defines movement and wall bouncing    xpos = xpos + (xspeed * xdirection);    ypos = ypos + (yspeed * ydirection);    if (xpos > width - 20 || xpos < 20) {        xdirection *= -1;    }    if (ypos > height - 20 || ypos < 20) {        ydirection *= -1;    }}',correct
'curveVertex(xpos + 106, ypos - 54)',correct
'curveVertex(xpos + 6, ypos - 14)',correct
'ydirection = random(-3, 3)',correct
'curveVertex(xpos + 8.5f, ypos + 62)',correct
'curveVertex(xpos + 9, ypos + 58);',correct
'mousePressed && (mouseButton == RIGHT)',DecentralizedEventHandlingRule
'ypos - 4',correct
'curveVertex(xpos + 37, ypos - 27)',correct
'ypos - 6',correct
'curveVertex(xpos + 38, ypos - 27)',correct
'ypos - 3',correct
'ypos - 2',correct
'curveVertex(xpos + 112, ypos - 52);',correct
'ydirection *= -1;',correct
'curveVertex(xpos + 12, ypos + 36);',correct
'curveVertex(xpos - 120, ypos - 39);',correct
'int c;',ShortVariable
'curveVertex(xpos - 37, ypos - 27);',correct
'curveVertex(xpos - 4.5f, ypos + 76)',correct
'i++',correct
'd = 0;',correct
'// Array Setupbody = new Body[numBodies];',correct
'curveVertex(xpos - 13.5f, ypos + 20);',correct
'6.5f',correct
'a = 201',correct
'curveVertex(xpos - 4.5f, ypos + 76);',correct
'xpos - 5.5f',correct
'Color = 0;',DrawingStateChangeRule
'curveVertex(xpos - 120, ypos - 39)',correct
'curveVertex(xpos - 12, ypos - 6);',correct
'ellipse(xpos - 37, ypos - 18, 20, 20)',correct
'for (int i = 0; i < body.length; i++) {    // gives 20 Ollies    body[i].run();    body[i].move();    body[i].mouse();}',correct
'{    xdirection *= -1;}',correct
'curveVertex(xpos + 119, ypos - 36)',correct
'xpos - 3',correct
'ellipse(xpos - 37, ypos - 18, 20, 20);',correct
'xpos - 4',correct
'xpos - 5',correct
'[numBodies]',correct
'xpos - 6',correct
'curveVertex(xpos + 106, ypos - 3);',correct
'xpos - 2',correct
'curveVertex(xpos - 112, ypos - 6)',correct
'curveVertex(xpos + 106, ypos - 3)',correct
'curveVertex(xpos - 6.5f, ypos + 68)',correct
'fill(a, b, c)',correct
'curveVertex(xpos + 112, ypos - 52)',correct
'xpos = mouseX',correct
'curveVertex(xpos + 6, ypos + 74)',correct
'body[i].mouse();',correct
'// nosefill(a, b, c);',correct
'curveVertex(xpos - 82, ypos - 56);',correct
'd = 255;',correct
'curveVertex(xpos - 58, ypos - 46);',correct
'float xpos;',correct
'xpos + 8.5f',correct
'curveVertex(xpos - 6, ypos + 72)',correct
'curveVertex(xpos - 15, ypos + 5);',correct
'curveVertex(xpos - 5.5f, ypos + 64)',correct
'xpos - 7',correct
'xpos - 8',correct
'xpos - 9',correct
'curveVertex(xpos - 114, ypos - 24)',correct
'curveVertex(xpos - 88, ypos - 58)',correct
'Color = 0',correct
'curveVertex(xpos - 9, ypos + 40);',correct
'curveVertex(xpos + 12, ypos + 36)',correct
'xpos < 20',correct
'move',correct
'// feetfill(a, b, c);',correct
'curveVertex(xpos - 13, ypos + 25)',correct
'curveVertex(xpos, ypos + 82)',correct
'curveVertex(xpos - 100, ypos - 56)',correct
'curveVertex(xpos - 52, ypos - 38)',correct
'curveVertex(xpos + 9, ypos + 58)',correct
'curveVertex(xpos - 7, ypos - 12);',correct
'xpos - 6.5f',correct
'curveVertex(xpos - 6, ypos - 14);',correct
'{    angle = atan2(my - y, mx - x);}',correct
'Creature',correct
'myCreature.update()',correct
'angry = true;',DrawingStateChangeRule
'size = ts',correct
'{    strokeWeight(0);    fill(c);    quad(xpos - gemWidth, ypos, xpos, ypos + gemHeight, xpos + gemWidth, ypos, xpos, ypos - gemHeight);}',correct
'eye2',correct
'arm2.display()',correct
'eye2.update(mouseX, mouseY)',correct
'eye1',correct
'eye1.update(myGem.xpos, myGem.ypos)',correct
'anger = prox;',correct
'float size;',correct
'strokeWeight(size * 3)',correct
'stroke(0);',correct
'stroke(0)',correct
'leftlegPosy = ypos + size * 140 + size * 10 * sin(time)',correct
'myGem = new Gem(30, 60, 0xff00FF9F)',correct
'leftlegPosy = ypos + size * 140;',correct
'angry',correct
'ypos - gemHeight',correct
'// as inspiration for the eyes and used the same principle to create the gemtracing arms. //',correct
'size',correct
'xpos = width / 2;',correct
'curveVertex(xpos - size * 13, ypos - size * 92)',correct
'color(255, 0, 0)',correct
'void update() {    prox = 300 / (dist(myGem.xpos, myGem.ypos, mouseX, mouseY));    if (prox <= size * 6) {        anger = prox;    } else {        anger = size * 6;    }    eye1 = new Eye(xpos - size * 10, ypos - size * 110, size * 10);    eye2 = new Eye(xpos + size * 10, ypos - size * 110, size * 10);    if (angry) {        eye1.update(myGem.xpos, myGem.ypos);        eye2.update(myGem.xpos, myGem.ypos);    } else {        eye1.update(mouseX, mouseY);        eye2.update(mouseX, mouseY);    }    arm1 = new Arm(xpos - size * 25, ypos - size * 30);    arm2 = new Arm(xpos + size * 25, ypos - size * 30);    arm1.update(myGem.xpos, myGem.ypos);    arm2.update(myGem.xpos, myGem.ypos);}',correct
'myCreature.size',correct
'new Creature(0.02f, 0.5f, 0xff98F4FF, color(255, 0, 0))',correct
'myGem',correct
'rightlegPosy = ypos + size * 140;',correct
'{    strokeWeight(size * 3);    line(xpos - size * 3, ypos - size * 112, xpos - size * 15, ypos - size * 118);    line(xpos + size * 3, ypos - size * 112, xpos + size * 15, ypos - size * 118);    fill(0);    strokeWeight(size * 0.5f);    beginShape();    vertex(xpos + size * 15, ypos - size * 75);    bezierVertex(xpos + size * 15, ypos - size * 110, xpos - size * 15, ypos - size * 110, xpos - size * 15, ypos - size * 75);    bezierVertex(xpos - size * 8, ypos - size * 100, xpos + size * 8, ypos - size * 100, xpos + size * 15, ypos - size * 75);    endShape();}',correct
'{    x = tx;    y = ty;}',correct
'eye2.update(myGem.xpos, myGem.ypos)',correct
'rotate(angle)',correct
'Eye eye1, eye2;',correct
'fill(0);',correct
'curveVertex(xpos, ypos - size * 100)',correct
'{    x = tx;    y = ty;    size = ts;}',correct
'speed * 30',correct
'ypos + size * 140 + size * 10 * sin(time)',correct
'xpos - size * 40 + size * 15 * sin(time)',correct
'colourAngry = cA;',correct
'c',correct
'colourAngry',correct
'my - y',correct
'Eye(float tx, float ty, float ts) {    x = tx;    y = ty;    size = ts;}',ShortVariable
'class Gem {    float xpos, ypos;    int gemWidth, gemHeight;    int c;    Gem(int gW, int gH, int cG) {        c = cG;        xpos = width / 2;        ypos = height / 2;        gemWidth = gW;        gemHeight = gH;    }    void display() {        strokeWeight(0);        fill(c);        quad(xpos - gemWidth, ypos, xpos, ypos + gemHeight, xpos + gemWidth, ypos, xpos, ypos - gemHeight);    }    void move() {        if (stealGem) {            xpos = mouseX;            ypos = mouseY;        }    }    boolean steal() {        if ((mouseX > xpos - gemWidth / 1.2f) && (mouseX < xpos + gemWidth / 1.2f) && (mouseY < ypos + gemHeight / 1.2f) && (mouseY > ypos - gemHeight / 1.2f)) {            return true;        } else {            return false;        }    }}',correct
'myGem.move()',correct
'strokeWeight(size * 0.5f)',correct
'x',correct
'y',correct
'vicinity',correct
'time = time + speed * 30;',correct
'Creature(float sp, float si, int c, int cA) {    speed = sp;    size = si;    colour = c;    colourAngry = cA;    stroke(0);    strokeWeight(size * 0.5f);    xpos = width / 2;    ypos = height / 2;    leftlegPosx = xpos - size * 40;    leftlegPosy = ypos + size * 140;    rightlegPosx = xpos + size * 40;    rightlegPosy = ypos + size * 140;    eye1 = new Eye(xpos - size * 10, ypos - size * 110, size * 10);    eye2 = new Eye(xpos + size * 10, ypos - size * 110, size * 10);    arm1 = new Arm(xpos - size * 25, ypos - size * 30);    arm2 = new Arm(xpos + size * 25, ypos - size * 30);    time = 0;}',ShortVariable
'rotate(angle);',correct
'arm2.update(myGem.xpos, myGem.ypos);',correct
'ypos - size * 100',correct
'{    if (myGem.steal()) {        stealGem = true;    }}',correct
'class Arm {    float x, y;    float angle = 0.0f;    Arm(float tx, float ty) {        x = tx;        y = ty;    }    void update(float mx, float my) {        angle = atan2(my - y, mx - x);    }    void display() {        pushMatrix();        strokeWeight(myCreature.size * 0.5f);        translate(x, y);        if (angry) {            fill(myCreature.colourAngry);        } else {            fill(myCreature.colour);        }        rotate(angle);        triangle(0, -myCreature.size * 10, 0, myCreature.size * 10, myCreature.size * 90, 0);        popMatrix();    }}',correct
'line(xpos + size * 3, ypos - size * 112, xpos + size * 15, ypos - size * 118)',correct
'size * 10 * sin(time)',correct
'size * 10',correct
'xpos - size * 8',correct
'size * 13',correct
'void display() {    pushMatrix();    strokeWeight(myCreature.size * 0.5f);    translate(x, y);    if (angry) {        fill(myCreature.colourAngry);    } else {        fill(myCreature.colour);    }    rotate(angle);    triangle(0, -myCreature.size * 10, 0, myCreature.size * 10, myCreature.size * 90, 0);    popMatrix();}',correct
'size * 15',correct
'myCreature.colour',correct
'xpos - size * 3',correct
'myCreature.size * 0.5f',correct
'myCreature = new Creature(0.02f, 0.5f, 0xff98F4FF, color(255, 0, 0))',correct
'rightlegPosy = ypos + size * 140',correct
'strokeWeight(myCreature.size * 0.5f)',correct
'0.0f',correct
'myCreature = new Creature(0.02f, 0.5f, 0xff98F4FF, color(255, 0, 0));',correct
'myCreature.size * 10',correct
'ypos = lerp(ypos, myGem.ypos, speed);',correct
'{    anger = size * 6;}',correct
'// The size (first and second inputs for a new Gem) and the color (third input for a new Gem) can be changed to your own liking. //',correct
'size * 25',correct
'float x, y;',correct
'strokeWeight(myCreature.size * 0.5f);',correct
'myGem = new Gem(30, 60, 0xff00FF9F);',correct
'prox = 300 / (dist(myGem.xpos, myGem.ypos, mouseX, mouseY));',DecentralizedEventHandlingRule
'ypos = mouseY',correct
'eye2 = new Eye(xpos + size * 10, ypos - size * 110, size * 10);',correct
'vicinity = 75;',correct
'Processing',correct
'background(255)',correct
'xpos + size * 40 + size * 15 * sin(time + PI)',correct
'new Arm(xpos + size * 25, ypos - size * 30)',correct
'gemHeight = gH;',correct
'size * 30',correct
'{    fill(colourAngry);}',correct
'pushMatrix()',correct
'y = ty',correct
'if (angry) {    strokeWeight(size * 3);    line(xpos - size * 3, ypos - size * 112, xpos - size * 15, ypos - size * 118);    line(xpos + size * 3, ypos - size * 112, xpos + size * 15, ypos - size * 118);    fill(0);    strokeWeight(size * 0.5f);    beginShape();    vertex(xpos + size * 15, ypos - size * 75);    bezierVertex(xpos + size * 15, ypos - size * 110, xpos - size * 15, ypos - size * 110, xpos - size * 15, ypos - size * 75);    bezierVertex(xpos - size * 8, ypos - size * 100, xpos + size * 8, ypos - size * 100, xpos + size * 15, ypos - size * 75);    endShape();} else {    strokeWeight(size * 3);    line(xpos - size * 3, ypos - size * 118 + anger, xpos - size * 15, ypos - size * 118);    line(xpos + size * 3, ypos - size * 118 + anger, xpos + size * 15, ypos - size * 118);    noFill();    strokeWeight(size * 0.5f);    beginShape();    curveVertex(xpos + size * 15, ypos - size * 75);    curveVertex(xpos + size * 13, ypos - size * 92);    curveVertex(xpos, ypos - size * 100);    curveVertex(xpos - size * 13, ypos - size * 92);    curveVertex(xpos - size * 15, ypos - size * 75);    endShape();}',correct
'xpos = width / 2',correct
'time = 0;',correct
'ypos - size * 118',correct
'xpos = mouseX;',DecentralizedEventHandlingRule
'fill(c)',correct
'false',correct
'ypos - size * 112',correct
'ypos - size * 110',correct
'// The speed (first input for a new Creature), size (second input for a new Creature) and colors (third and fourth inputs for a new Creature) of the Creature can be changed to your own liking. //',correct
'ellipse(xpos, ypos - size * 100, size * 70, size * 70)',correct
'size * 40',correct
'bezierVertex(xpos + size * 15, ypos - size * 110, xpos - size * 15, ypos - size * 110, xpos - size * 15, ypos - size * 75);',correct
'endShape()',correct
'xpos - gemWidth',correct
'if ((myCreature.xpos >= myGem.xpos - myCreature.size * vicinity) && (myCreature.xpos <= myGem.xpos + myCreature.size * vicinity) && (myCreature.ypos >= myGem.ypos - myCreature.size * vicinity) && (myCreature.ypos <= myGem.ypos + myCreature.size * vicinity)) {    angry = false;} else {    angry = true;}',correct
'// Whether the mouse is on the Gem or not is checked in this class to make it easier to eventually work with an array of Gems. //',correct
'ellipse(xpos, ypos, size * 80, size * 160)',correct
'lerp(ypos, myGem.ypos, speed)',correct
'float tx',correct
'float ty',correct
'rightlegPosy = ypos + size * 140 + size * 10 * sin(time)',correct
'float ts',correct
'if (prox <= size * 6) {    anger = prox;} else {    anger = size * 6;}',correct
'void setup() {    myCreature = new Creature(0.02f, 0.5f, 0xff98F4FF, color(255, 0, 0));    myGem = new Gem(30, 60, 0xff00FF9F);    vicinity = 75;}',correct
'size * 50',correct
'time + PI',correct
'eye2.display();',correct
'stealGem = false',correct
'fill(colourAngry)',correct
'int colour, colourAngry;',correct
'line(xpos + size * 3, ypos - size * 118 + anger, xpos + size * 15, ypos - size * 118);',correct
'int vicinity;',correct
'time = 0',correct
'{    strokeWeight(size * 0.5f);    if (angry) {        fill(colourAngry);    } else {        fill(colour);    }    triangle(xpos - size * 25, ypos + size * 40, xpos, ypos + size * 50, leftlegPosx, leftlegPosy);    triangle(xpos + size * 25, ypos + size * 40, xpos, ypos + size * 50, rightlegPosx, rightlegPosy);    ellipse(xpos, ypos, size * 80, size * 160);    ellipse(xpos, ypos - size * 100, size * 70, size * 70);    eye1.display();    eye2.display();    if (angry) {        strokeWeight(size * 3);        line(xpos - size * 3, ypos - size * 112, xpos - size * 15, ypos - size * 118);        line(xpos + size * 3, ypos - size * 112, xpos + size * 15, ypos - size * 118);        fill(0);        strokeWeight(size * 0.5f);        beginShape();        vertex(xpos + size * 15, ypos - size * 75);        bezierVertex(xpos + size * 15, ypos - size * 110, xpos - size * 15, ypos - size * 110, xpos - size * 15, ypos - size * 75);        bezierVertex(xpos - size * 8, ypos - size * 100, xpos + size * 8, ypos - size * 100, xpos + size * 15, ypos - size * 75);        endShape();    } else {        strokeWeight(size * 3);        line(xpos - size * 3, ypos - size * 118 + anger, xpos - size * 15, ypos - size * 118);        line(xpos + size * 3, ypos - size * 118 + anger, xpos + size * 15, ypos - size * 118);        noFill();        strokeWeight(size * 0.5f);        beginShape();        curveVertex(xpos + size * 15, ypos - size * 75);        curveVertex(xpos + size * 13, ypos - size * 92);        curveVertex(xpos, ypos - size * 100);        curveVertex(xpos - size * 13, ypos - size * 92);        curveVertex(xpos - size * 15, ypos - size * 75);        endShape();    }    arm1.display();    arm2.display();}',correct
'rightlegPosx = xpos + size * 40;',correct
'new Eye(xpos - size * 10, ypos - size * 110, size * 10)',correct
'beginShape()',correct
'myGem.xpos',correct
'leftlegPosx = xpos - size * 40',correct
'time + speed * 30',correct
'{    pushMatrix();    strokeWeight(myCreature.size * 0.5f);    translate(x, y);    fill(255);    ellipse(0, 0, size, size);    rotate(angle);    fill(0, 0, 255);    ellipse(size / 4, 0, size / 2, size / 2);    popMatrix();}',correct
'x = tx',correct
'size * 70',correct
'size * 75',correct
'float si',correct
'0.5f',correct
'0.02f',correct
'size = ts;',correct
'myCreature.update();',correct
'// I wanted to create an array of Creatures with individual Gems assigned to each Creature, but unfortunately I no longer had time for that :( . //',correct
'{    fill(myCreature.colour);}',correct
'fill(colourAngry);',correct
'strokeWeight(0)',correct
'// Anger determines how close you are to stealing the Gem; the closer you get to the Gem, the angrier the Creature gets! //',correct
'size * 80',correct
'{    angry = false;}',correct
'float sp',correct
'sin(time)',correct
'quad(xpos - gemWidth, ypos, xpos, ypos + gemHeight, xpos + gemWidth, ypos, xpos, ypos - gemHeight)',correct
'{    myCreature = new Creature(0.02f, 0.5f, 0xff98F4FF, color(255, 0, 0));    myGem = new Gem(30, 60, 0xff00FF9F);    vicinity = 75;}',correct
'bezierVertex(xpos - size * 8, ypos - size * 100, xpos + size * 8, ypos - size * 100, xpos + size * 15, ypos - size * 75);',correct
'ypos = height / 2',correct
'arm1',correct
'// I used the example for the use of arctangent from processing.org (https://processing.org/examples/arctangent.html) //',correct
'{    return true;}',correct
'ypos = mouseY;',DecentralizedEventHandlingRule
'arm2',correct
'(mouseX > xpos - gemWidth / 1.2f) && (mouseX < xpos + gemWidth / 1.2f) && (mouseY < ypos + gemHeight / 1.2f) && (mouseY > ypos - gemHeight / 1.2f)',correct
'size / 2',correct
'{    if (angry) {        time = time + speed * 30;        leftlegPosx = xpos - size * 40 + size * 15 * sin(time);        leftlegPosy = ypos + size * 140 + size * 10 * sin(time);        rightlegPosx = xpos + size * 40 + size * 15 * sin(time + PI);        rightlegPosy = ypos + size * 140 + size * 10 * sin(time);        xpos = lerp(xpos, myGem.xpos, speed);        ypos = lerp(ypos, myGem.ypos, speed);    } else {        leftlegPosx = xpos - size * 40;        leftlegPosy = ypos + size * 140;        rightlegPosx = xpos + size * 40;        rightlegPosy = ypos + size * 140;    }}',correct
'curveVertex(xpos + size * 15, ypos - size * 75);',correct
'{    stealGem = false;}',correct
'size / 4',correct
'atan2(my - y, mx - x)',correct
'int c',correct
'xpos + size * 25',correct
'anger',correct
'size * 92',correct
'eye2.display()',correct
'xpos + size * 15',correct
'rightlegPosx = xpos + size * 40',correct
'eye2.update(myGem.xpos, myGem.ypos);',correct
'anger = prox',correct
'void',correct
'colour = c;',correct
'xpos + size * 10',correct
'300 / (dist(myGem.xpos, myGem.ypos, mouseX, mouseY))',correct
'xpos + size * 13',correct
'void mousePressed() {    if (myGem.steal()) {        stealGem = true;    }}',correct
'xpos + gemWidth',correct
'fill(myCreature.colour);',correct
'(myCreature.xpos >= myGem.xpos - myCreature.size * vicinity) && (myCreature.xpos <= myGem.xpos + myCreature.size * vicinity)',correct
'(myCreature.xpos >= myGem.xpos - myCreature.size * vicinity) && (myCreature.xpos <= myGem.xpos + myCreature.size * vicinity) && (myCreature.ypos >= myGem.ypos - myCreature.size * vicinity) && (myCreature.ypos <= myGem.ypos + myCreature.size * vicinity)',correct
'prox = 300 / (dist(myGem.xpos, myGem.ypos, mouseX, mouseY))',correct
'myCreature.size * 90',correct
'if (angry) {    time = time + speed * 30;    leftlegPosx = xpos - size * 40 + size * 15 * sin(time);    leftlegPosy = ypos + size * 140 + size * 10 * sin(time);    rightlegPosx = xpos + size * 40 + size * 15 * sin(time + PI);    rightlegPosy = ypos + size * 140 + size * 10 * sin(time);    xpos = lerp(xpos, myGem.xpos, speed);    ypos = lerp(ypos, myGem.ypos, speed);} else {    leftlegPosx = xpos - size * 40;    leftlegPosy = ypos + size * 140;    rightlegPosx = xpos + size * 40;    rightlegPosy = ypos + size * 140;}',correct
'true',correct
'noFill();',correct
'void mouseReleased() {    stealGem = false;}',correct
'arm1 = new Arm(xpos - size * 25, ypos - size * 30)',correct
'triangle(xpos - size * 25, ypos + size * 40, xpos, ypos + size * 50, leftlegPosx, leftlegPosy)',correct
'line(xpos - size * 3, ypos - size * 112, xpos - size * 15, ypos - size * 118)',correct
'popMatrix()',correct
'eye1.display()',correct
'xpos + size * 40',correct
'void display() {    pushMatrix();    strokeWeight(myCreature.size * 0.5f);    translate(x, y);    fill(255);    ellipse(0, 0, size, size);    rotate(angle);    fill(0, 0, 255);    ellipse(size / 4, 0, size / 2, size / 2);    popMatrix();}',correct
'beginShape();',correct
'float time;',correct
'{    time = time + speed * 30;    leftlegPosx = xpos - size * 40 + size * 15 * sin(time);    leftlegPosy = ypos + size * 140 + size * 10 * sin(time);    rightlegPosx = xpos + size * 40 + size * 15 * sin(time + PI);    rightlegPosy = ypos + size * 140 + size * 10 * sin(time);    xpos = lerp(xpos, myGem.xpos, speed);    ypos = lerp(ypos, myGem.ypos, speed);}',correct
'triangle(0, -myCreature.size * 10, 0, myCreature.size * 10, myCreature.size * 90, 0)',correct
'fill(myCreature.colourAngry);',correct
'ellipse(xpos, ypos, size * 80, size * 160);',correct
'leftlegPosx = xpos - size * 40 + size * 15 * sin(time);',correct
'{    return false;}',correct
'time = time + speed * 30',correct
'ypos - size * 118 + anger',correct
'bezierVertex(xpos + size * 15, ypos - size * 110, xpos - size * 15, ypos - size * 110, xpos - size * 15, ypos - size * 75)',correct
'gemWidth = gW;',correct
'size * 15 * sin(time)',correct
'quad(xpos - gemWidth, ypos, xpos, ypos + gemHeight, xpos + gemWidth, ypos, xpos, ypos - gemHeight);',correct
'{    background(255);    if ((myCreature.xpos >= myGem.xpos - myCreature.size * vicinity) && (myCreature.xpos <= myGem.xpos + myCreature.size * vicinity) && (myCreature.ypos >= myGem.ypos - myCreature.size * vicinity) && (myCreature.ypos <= myGem.ypos + myCreature.size * vicinity)) {        angry = false;    } else {        angry = true;    }    myCreature.update();    myCreature.display();    myCreature.run();    myGem.display();    myGem.move();}',correct
'eye1.update(mouseX, mouseY);',DecentralizedEventHandlingRule
'prox <= size * 6',correct
'myCreature',correct
'triangle(xpos + size * 25, ypos + size * 40, xpos, ypos + size * 50, rightlegPosx, rightlegPosy)',correct
'// Changing the speed of the Creature will also (intuitively) make the legs move slower. //',correct
'endShape();',correct
'mx - x',correct
'fill(myCreature.colour)',correct
'angle = atan2(my - y, mx - x);',correct
'if (myGem.steal()) {    stealGem = true;}',correct
'float prox;',correct
'{    speed = sp;    size = si;    colour = c;    colourAngry = cA;    stroke(0);    strokeWeight(size * 0.5f);    xpos = width / 2;    ypos = height / 2;    leftlegPosx = xpos - size * 40;    leftlegPosy = ypos + size * 140;    rightlegPosx = xpos + size * 40;    rightlegPosy = ypos + size * 140;    eye1 = new Eye(xpos - size * 10, ypos - size * 110, size * 10);    eye2 = new Eye(xpos + size * 10, ypos - size * 110, size * 10);    arm1 = new Arm(xpos - size * 25, ypos - size * 30);    arm2 = new Arm(xpos + size * 25, ypos - size * 30);    time = 0;}',correct
'colour = c',correct
'Eye',correct
'angry = true',correct
'ypos + size * 40',correct
'Arm arm1, arm2;',correct
'size * 112',correct
'size * 110',correct
'myGem.display()',correct
'// Based on the arctangent use example from processing.org (https://processing.org/examples/arctangent.html) //',correct
'arm1 = new Arm(xpos - size * 25, ypos - size * 30);',correct
'float mx',correct
'myGem.move();',correct
'curveVertex(xpos - size * 13, ypos - size * 92);',correct
'ellipse(0, 0, size, size)',correct
'pushMatrix();',correct
'{    pushMatrix();    strokeWeight(myCreature.size * 0.5f);    translate(x, y);    if (angry) {        fill(myCreature.colourAngry);    } else {        fill(myCreature.colour);    }    rotate(angle);    triangle(0, -myCreature.size * 10, 0, myCreature.size * 10, myCreature.size * 90, 0);    popMatrix();}',correct
'arm1.display()',correct
'rightlegPosy = ypos + size * 140 + size * 10 * sin(time);',correct
'curveVertex(xpos + size * 13, ypos - size * 92)',correct
'size * 100',correct
'(mouseX > xpos - gemWidth / 1.2f) && (mouseX < xpos + gemWidth / 1.2f) && (mouseY < ypos + gemHeight / 1.2f)',correct
'ypos + size * 50',correct
'background(255);',correct
'ypos - size * 75',correct
'// Watch out when you steal the Gem of the Creature, it will get angry! //',correct
'Arm',correct
'float my',correct
'vicinity = 75',correct
'boolean steal() {    if ((mouseX > xpos - gemWidth / 1.2f) && (mouseX < xpos + gemWidth / 1.2f) && (mouseY < ypos + gemHeight / 1.2f) && (mouseY > ypos - gemHeight / 1.2f)) {        return true;    } else {        return false;    }}',correct
'// The vicinity to the Gem where the Creature will no longer be angry can be changed to your own liking. //',correct
'return false;',correct
'new Arm(xpos - size * 25, ypos - size * 30)',correct
'size = si;',correct
'// This program creates a Creature that chases a Gem. //',correct
'fill(0, 0, 255);',correct
'xpos + size * 8',correct
'rightlegPosx = xpos + size * 40 + size * 15 * sin(time + PI);',correct
'arm1.update(myGem.xpos, myGem.ypos);',correct
'ellipse(size / 4, 0, size / 2, size / 2)',correct
'class Eye {    float x, y;    float size;    float angle = 0.0f;    Eye(float tx, float ty, float ts) {        x = tx;        y = ty;        size = ts;    }    void update(float mx, float my) {        angle = atan2(my - y, mx - x);    }    void display() {        pushMatrix();        strokeWeight(myCreature.size * 0.5f);        translate(x, y);        fill(255);        ellipse(0, 0, size, size);        rotate(angle);        fill(0, 0, 255);        ellipse(size / 4, 0, size / 2, size / 2);        popMatrix();    }}',correct
'c = cG',correct
'xpos + size * 3',correct
'popMatrix();',correct
'size * 118',correct
'curveVertex(xpos, ypos - size * 100);',correct
'eye1 = new Eye(xpos - size * 10, ypos - size * 110, size * 10);',correct
'new Gem(30, 60, 0xff00FF9F)',correct
'strokeWeight(size * 0.5f);',correct
'line(xpos + size * 3, ypos - size * 112, xpos + size * 15, ypos - size * 118);',correct
'angry = false',correct
'ypos - size * 92',correct
'myGem.steal()',correct
'lerp(xpos, myGem.xpos, speed)',correct
'curveVertex(xpos - size * 15, ypos - size * 75);',correct
'// The Gem can be moved by pressing the mouse whilst hovering on the Gem and then dragging the mouse. //',correct
'xpos - size * 40',correct
'new Eye(xpos + size * 10, ypos - size * 110, size * 10)',correct
'{    angry = true;}',correct
'if ((mouseX > xpos - gemWidth / 1.2f) && (mouseX < xpos + gemWidth / 1.2f) && (mouseY < ypos + gemHeight / 1.2f) && (mouseY > ypos - gemHeight / 1.2f)) {    return true;} else {    return false;}',correct
'void run() {    if (angry) {        time = time + speed * 30;        leftlegPosx = xpos - size * 40 + size * 15 * sin(time);        leftlegPosy = ypos + size * 140 + size * 10 * sin(time);        rightlegPosx = xpos + size * 40 + size * 15 * sin(time + PI);        rightlegPosy = ypos + size * 140 + size * 10 * sin(time);        xpos = lerp(xpos, myGem.xpos, speed);        ypos = lerp(ypos, myGem.ypos, speed);    } else {        leftlegPosx = xpos - size * 40;        leftlegPosy = ypos + size * 140;        rightlegPosx = xpos + size * 40;        rightlegPosy = ypos + size * 140;    }}',correct
'myCreature.colourAngry',correct
'void display() {    strokeWeight(0);    fill(c);    quad(xpos - gemWidth, ypos, xpos, ypos + gemHeight, xpos + gemWidth, ypos, xpos, ypos - gemHeight);}',correct
'ypos + size * 140',correct
'ypos = height / 2;',correct
'myCreature.run()',correct
'fill(0)',correct
'{    stealGem = true;}',correct
'height / 2',correct
'float leftlegPosx, leftlegPosy, rightlegPosx, rightlegPosy;',correct
'ypos - size * 30',correct
'size * 140',correct
'fill(myCreature.colourAngry)',correct
'xpos - size * 25',correct
'void display() {    strokeWeight(size * 0.5f);    if (angry) {        fill(colourAngry);    } else {        fill(colour);    }    triangle(xpos - size * 25, ypos + size * 40, xpos, ypos + size * 50, leftlegPosx, leftlegPosy);    triangle(xpos + size * 25, ypos + size * 40, xpos, ypos + size * 50, rightlegPosx, rightlegPosy);    ellipse(xpos, ypos, size * 80, size * 160);    ellipse(xpos, ypos - size * 100, size * 70, size * 70);    eye1.display();    eye2.display();    if (angry) {        strokeWeight(size * 3);        line(xpos - size * 3, ypos - size * 112, xpos - size * 15, ypos - size * 118);        line(xpos + size * 3, ypos - size * 112, xpos + size * 15, ypos - size * 118);        fill(0);        strokeWeight(size * 0.5f);        beginShape();        vertex(xpos + size * 15, ypos - size * 75);        bezierVertex(xpos + size * 15, ypos - size * 110, xpos - size * 15, ypos - size * 110, xpos - size * 15, ypos - size * 75);        bezierVertex(xpos - size * 8, ypos - size * 100, xpos + size * 8, ypos - size * 100, xpos + size * 15, ypos - size * 75);        endShape();    } else {        strokeWeight(size * 3);        line(xpos - size * 3, ypos - size * 118 + anger, xpos - size * 15, ypos - size * 118);        line(xpos + size * 3, ypos - size * 118 + anger, xpos + size * 15, ypos - size * 118);        noFill();        strokeWeight(size * 0.5f);        beginShape();        curveVertex(xpos + size * 15, ypos - size * 75);        curveVertex(xpos + size * 13, ypos - size * 92);        curveVertex(xpos, ypos - size * 100);        curveVertex(xpos - size * 13, ypos - size * 92);        curveVertex(xpos - size * 15, ypos - size * 75);        endShape();    }    arm1.display();    arm2.display();}',LongMethodRule
'myCreature.display()',correct
'fill(colour);',correct
'float anger;',correct
'fill(255)',correct
'rightlegPosx = xpos + size * 40 + size * 15 * sin(time + PI)',correct
'speed',correct
'triangle(0, -myCreature.size * 10, 0, myCreature.size * 10, myCreature.size * 90, 0);',correct
'-myCreature.size',correct
'// The Arm and Eye classes are used here, as they are a part of the Creature. //',correct
'arm2 = new Arm(xpos + size * 25, ypos - size * 30)',correct
'xpos - size * 13',correct
'line(xpos - size * 3, ypos - size * 118 + anger, xpos - size * 15, ypos - size * 118)',correct
'if (angry) {    eye1.update(myGem.xpos, myGem.ypos);    eye2.update(myGem.xpos, myGem.ypos);} else {    eye1.update(mouseX, mouseY);    eye2.update(mouseX, mouseY);}',correct
'xpos - size * 15',correct
'gemWidth',correct
'stealGem = true;',correct
'myGem.ypos',correct
'xpos - size * 10',correct
'xpos',correct
'noFill()',correct
'{    eye1.update(mouseX, mouseY);    eye2.update(mouseX, mouseY);}',correct
'gemHeight = gH',correct
'colour',correct
'triangle(xpos - size * 25, ypos + size * 40, xpos, ypos + size * 50, leftlegPosx, leftlegPosy);',correct
'void draw() {    background(255);    if ((myCreature.xpos >= myGem.xpos - myCreature.size * vicinity) && (myCreature.xpos <= myGem.xpos + myCreature.size * vicinity) && (myCreature.ypos >= myGem.ypos - myCreature.size * vicinity) && (myCreature.ypos <= myGem.ypos + myCreature.size * vicinity)) {        angry = false;    } else {        angry = true;    }    myCreature.update();    myCreature.display();    myCreature.run();    myGem.display();    myGem.move();}',correct
'size * 160',correct
'stealGem = false;',correct
'time',correct
'eye2 = new Eye(xpos + size * 10, ypos - size * 110, size * 10)',correct
'ellipse(0, 0, size, size);',correct
'translate(x, y)',correct
'ypos',correct
'{    leftlegPosx = xpos - size * 40;    leftlegPosy = ypos + size * 140;    rightlegPosx = xpos + size * 40;    rightlegPosy = ypos + size * 140;}',correct
'arm2.display();',correct
'ypos = lerp(ypos, myGem.ypos, speed)',correct
'triangle(xpos + size * 25, ypos + size * 40, xpos, ypos + size * 50, rightlegPosx, rightlegPosy);',correct
'Arm(float tx, float ty) {    x = tx;    y = ty;}',ShortVariable
'{    c = cG;    xpos = width / 2;    ypos = height / 2;    gemWidth = gW;    gemHeight = gH;}',correct
'fill(colour)',correct
'// This program creates a Creature that chases a Gem. //// The Gem can be moved by pressing the mouse whilst hovering on the Gem and then dragging the mouse. //// Watch out when you steal the Gem of the Creature, it will get angry! //// The size (first and second inputs for a new Gem) and the color (third input for a new Gem) can be changed to your own liking. //// The speed (first input for a new Creature), size (second input for a new Creature) and colors (third and fourth inputs for a new Creature) of the Creature can be changed to your own liking. //// Changing the speed of the Creature will also (intuitively) make the legs move slower. //// The vicinity to the Gem where the Creature will no longer be angry can be changed to your own liking. //// I wanted to create an array of Creatures with individual Gems assigned to each Creature, but unfortunately I no longer had time for that :( . //Creature myCreature;',correct
'line(xpos + size * 3, ypos - size * 118 + anger, xpos + size * 15, ypos - size * 118)',correct
'c = cG;',correct
'if (angry) {    fill(colourAngry);} else {    fill(colour);}',correct
'myGem.display();',correct
'size * 0.5f',correct
'{    anger = prox;}',correct
'ellipse(xpos, ypos - size * 100, size * 70, size * 70);',correct
'angle = 0.0f',correct
'Gem',correct
'line(xpos - size * 3, ypos - size * 112, xpos - size * 15, ypos - size * 118);',correct
'{    prox = 300 / (dist(myGem.xpos, myGem.ypos, mouseX, mouseY));    if (prox <= size * 6) {        anger = prox;    } else {        anger = size * 6;    }    eye1 = new Eye(xpos - size * 10, ypos - size * 110, size * 10);    eye2 = new Eye(xpos + size * 10, ypos - size * 110, size * 10);    if (angry) {        eye1.update(myGem.xpos, myGem.ypos);        eye2.update(myGem.xpos, myGem.ypos);    } else {        eye1.update(mouseX, mouseY);        eye2.update(mouseX, mouseY);    }    arm1 = new Arm(xpos - size * 25, ypos - size * 30);    arm2 = new Arm(xpos + size * 25, ypos - size * 30);    arm1.update(myGem.xpos, myGem.ypos);    arm2.update(myGem.xpos, myGem.ypos);}',correct
'class Creature {    Eye eye1, eye2;    Arm arm1, arm2;    int colour, colourAngry;    float xpos, ypos;    float leftlegPosx, leftlegPosy, rightlegPosx, rightlegPosy;    float time;    float anger;    float prox;    float speed;    float size;    Creature(float sp, float si, int c, int cA) {        speed = sp;        size = si;        colour = c;        colourAngry = cA;        stroke(0);        strokeWeight(size * 0.5f);        xpos = width / 2;        ypos = height / 2;        leftlegPosx = xpos - size * 40;        leftlegPosy = ypos + size * 140;        rightlegPosx = xpos + size * 40;        rightlegPosy = ypos + size * 140;        eye1 = new Eye(xpos - size * 10, ypos - size * 110, size * 10);        eye2 = new Eye(xpos + size * 10, ypos - size * 110, size * 10);        arm1 = new Arm(xpos - size * 25, ypos - size * 30);        arm2 = new Arm(xpos + size * 25, ypos - size * 30);        time = 0;    }    void update() {        prox = 300 / (dist(myGem.xpos, myGem.ypos, mouseX, mouseY));        if (prox <= size * 6) {            anger = prox;        } else {            anger = size * 6;        }        eye1 = new Eye(xpos - size * 10, ypos - size * 110, size * 10);        eye2 = new Eye(xpos + size * 10, ypos - size * 110, size * 10);        if (angry) {            eye1.update(myGem.xpos, myGem.ypos);            eye2.update(myGem.xpos, myGem.ypos);        } else {            eye1.update(mouseX, mouseY);            eye2.update(mouseX, mouseY);        }        arm1 = new Arm(xpos - size * 25, ypos - size * 30);        arm2 = new Arm(xpos + size * 25, ypos - size * 30);        arm1.update(myGem.xpos, myGem.ypos);        arm2.update(myGem.xpos, myGem.ypos);    }    void display() {        strokeWeight(size * 0.5f);        if (angry) {            fill(colourAngry);        } else {            fill(colour);        }        triangle(xpos - size * 25, ypos + size * 40, xpos, ypos + size * 50, leftlegPosx, leftlegPosy);        triangle(xpos + size * 25, ypos + size * 40, xpos, ypos + size * 50, rightlegPosx, rightlegPosy);        ellipse(xpos, ypos, size * 80, size * 160);        ellipse(xpos, ypos - size * 100, size * 70, size * 70);        eye1.display();        eye2.display();        if (angry) {            strokeWeight(size * 3);            line(xpos - size * 3, ypos - size * 112, xpos - size * 15, ypos - size * 118);            line(xpos + size * 3, ypos - size * 112, xpos + size * 15, ypos - size * 118);            fill(0);            strokeWeight(size * 0.5f);            beginShape();            vertex(xpos + size * 15, ypos - size * 75);            bezierVertex(xpos + size * 15, ypos - size * 110, xpos - size * 15, ypos - size * 110, xpos - size * 15, ypos - size * 75);            bezierVertex(xpos - size * 8, ypos - size * 100, xpos + size * 8, ypos - size * 100, xpos + size * 15, ypos - size * 75);            endShape();        } else {            strokeWeight(size * 3);            line(xpos - size * 3, ypos - size * 118 + anger, xpos - size * 15, ypos - size * 118);            line(xpos + size * 3, ypos - size * 118 + anger, xpos + size * 15, ypos - size * 118);            noFill();            strokeWeight(size * 0.5f);            beginShape();            curveVertex(xpos + size * 15, ypos - size * 75);            curveVertex(xpos + size * 13, ypos - size * 92);            curveVertex(xpos, ypos - size * 100);            curveVertex(xpos - size * 13, ypos - size * 92);            curveVertex(xpos - size * 15, ypos - size * 75);            endShape();        }        arm1.display();        arm2.display();    }    void run() {        if (angry) {            time = time + speed * 30;            leftlegPosx = xpos - size * 40 + size * 15 * sin(time);            leftlegPosy = ypos + size * 140 + size * 10 * sin(time);            rightlegPosx = xpos + size * 40 + size * 15 * sin(time + PI);            rightlegPosy = ypos + size * 140 + size * 10 * sin(time);            xpos = lerp(xpos, myGem.xpos, speed);            ypos = lerp(ypos, myGem.ypos, speed);        } else {            leftlegPosx = xpos - size * 40;            leftlegPosy = ypos + size * 140;            rightlegPosx = xpos + size * 40;            rightlegPosy = ypos + size * 140;        }    }}',correct
'return true;',correct
'(myCreature.xpos >= myGem.xpos - myCreature.size * vicinity) && (myCreature.xpos <= myGem.xpos + myCreature.size * vicinity) && (myCreature.ypos >= myGem.ypos - myCreature.size * vicinity)',correct
'strokeWeight(size * 3);',correct
'eye2.update(mouseX, mouseY);',DecentralizedEventHandlingRule
'line(xpos - size * 3, ypos - size * 118 + anger, xpos - size * 15, ypos - size * 118);',correct
'size * 8',correct
'eye1.update(myGem.xpos, myGem.ypos);',correct
'size * 6',correct
'speed = sp',correct
'arm1.update(myGem.xpos, myGem.ypos)',correct
'eye1.display();',correct
'Gem(int gW, int gH, int cG) {    c = cG;    xpos = width / 2;    ypos = height / 2;    gemWidth = gW;    gemHeight = gH;}',ShortVariable
'translate(x, y);',correct
'gemHeight',correct
'ellipse(size / 4, 0, size / 2, size / 2);',correct
'y = ty;',correct
'int gemWidth, gemHeight;',correct
'vertex(xpos + size * 15, ypos - size * 75)',correct
'prox',correct
'myCreature.display();',correct
'{    xpos = mouseX;    ypos = mouseY;}',correct
'xpos = lerp(xpos, myGem.xpos, speed);',correct
'boolean stealGem;',correct
'int cG',correct
'float xpos, ypos;',correct
'float speed;',correct
'eye1 = new Eye(xpos - size * 10, ypos - size * 110, size * 10)',correct
'curveVertex(xpos + size * 13, ypos - size * 92);',correct
'anger = size * 6;',correct
'if (angry) {    fill(myCreature.colourAngry);} else {    fill(myCreature.colour);}',correct
'colourAngry = cA',correct
'int c;',ShortVariable
'Gem myGem;',correct
'// If the Creature is angry it will only focus on the Gem, if the Creature is not angry it will follow the cursor with its eyes, as it suspects you want te steal the Gem. //',correct
'size * 3',correct
'fill(0, 0, 255)',correct
'int cA',correct
'{    if ((mouseX > xpos - gemWidth / 1.2f) && (mouseX < xpos + gemWidth / 1.2f) && (mouseY < ypos + gemHeight / 1.2f) && (mouseY > ypos - gemHeight / 1.2f)) {        return true;    } else {        return false;    }}',correct
'{    if (stealGem) {        xpos = mouseX;        ypos = mouseY;    }}',correct
'float angle = 0.0f;',correct
'leftlegPosx = xpos - size * 40;',correct
'curveVertex(xpos + size * 15, ypos - size * 75)',correct
'gemWidth = gW',correct
'arm2 = new Arm(xpos + size * 25, ypos - size * 30);',correct
'fill(255);',correct
'void update(float mx, float my) {    angle = atan2(my - y, mx - x);}',ShortVariable
'leftlegPosy = ypos + size * 140',correct
'stealGem = true',correct
'arm2.update(myGem.xpos, myGem.ypos)',correct
'sin(time + PI)',correct
'rightlegPosx',correct
'rightlegPosy',correct
'curveVertex(xpos - size * 15, ypos - size * 75)',correct
'speed = sp;',correct
'angry = false;',DrawingStateChangeRule
'angle = atan2(my - y, mx - x)',correct
'myCreature.run();',correct
'(mouseX > xpos - gemWidth / 1.2f) && (mouseX < xpos + gemWidth / 1.2f)',correct
'{    fill(myCreature.colourAngry);}',correct
'anger = size * 6',correct
'xpos = mouseX',correct
'{    eye1.update(myGem.xpos, myGem.ypos);    eye2.update(myGem.xpos, myGem.ypos);}',correct
'{    fill(colour);}',correct
'void move() {    if (stealGem) {        xpos = mouseX;        ypos = mouseY;    }}',correct
'fill(c);',correct
'{    strokeWeight(size * 3);    line(xpos - size * 3, ypos - size * 118 + anger, xpos - size * 15, ypos - size * 118);    line(xpos + size * 3, ypos - size * 118 + anger, xpos + size * 15, ypos - size * 118);    noFill();    strokeWeight(size * 0.5f);    beginShape();    curveVertex(xpos + size * 15, ypos - size * 75);    curveVertex(xpos + size * 13, ypos - size * 92);    curveVertex(xpos, ypos - size * 100);    curveVertex(xpos - size * 13, ypos - size * 92);    curveVertex(xpos - size * 15, ypos - size * 75);    endShape();}',correct
'size * 15 * sin(time + PI)',correct
'leftlegPosx = xpos - size * 40 + size * 15 * sin(time)',correct
'int gW',correct
'size = si',correct
'if (stealGem) {    xpos = mouseX;    ypos = mouseY;}',correct
'arm1.display();',correct
'xpos = lerp(xpos, myGem.xpos, speed)',correct
'boolean angry;',correct
'stealGem',correct
'x = tx;',correct
'-myCreature.size * 10',correct
'leftlegPosy',correct
'int gH',correct
'bezierVertex(xpos - size * 8, ypos - size * 100, xpos + size * 8, ypos - size * 100, xpos + size * 15, ypos - size * 75)',correct
'leftlegPosx',correct
'leftlegPosy = ypos + size * 140 + size * 10 * sin(time);',correct
'strokeWeight(0);',correct
'eye1.update(mouseX, mouseY)',correct
'vertex(xpos + size * 15, ypos - size * 75);',correct
'width / 2',correct
'ypos + gemHeight',correct
'rect(x, y - 35, 75, 15, 7)',correct
'x + 110',correct
'x = initX;',correct
'y = -100',correct
'// end for loop wheel duplication',correct
'shoot = false',correct
'switch(keyCode) {    case 32:        space = true;        break;}',correct
'bullet = new Bullet();',correct
'Wheels(float initX, float initY) {    x = initX;    y = initY;}',correct
'// end keyPressed// if space is released, stop shooting bulletvoid keyReleased() {    switch(keyCode) {        case 32:            space = false;            break;    }// end keycode}',correct
'fill(50, 120, 30)',correct
'shot.setStartLocation(tank.x, tank.y);',correct
'// update and draw bulletshot.update();',correct
'if (x > width || x < 0 || y > height || y < 0) {    speed = 0;    shoot = false;}',correct
'line(x, y, x, y + 3)',correct
'boolean shoot;',correct
'stroke(0);',correct
'stroke(0)',correct
'x > width - 110 || x < 55',correct
'random(-height)',correct
'-height',correct
'shot = new Bullet()',correct
'speed += 2;',correct
'drops.length',correct
'pushMatrix();',correct
'{    drops[i].fall();}',correct
'strokeWeight(1);',correct
'// tankbarrelrect(x + 80, y, 60, 20);',correct
'drops[i] = new Rain()',correct
'y - 35',correct
'random(-200)',correct
'shot.display()',correct
'rect(0, 300, 600, 100)',correct
'// end classclass Rain {    float x = random(600);    float y = random(-height);    void fall() {        y = y + 7;        stroke(30, 144, 255);        line(x, y, x, y + 3);        if (y > height) {            x = random(600);            y = random(-200);        }    }}',correct
'for (int i = 0; i < drops.length; i++) {    drops[i].fall();}',correct
'space = true',correct
'speed < maxSpeed',correct
'wheel.display()',correct
'// end move bullet',correct
'drops = new Rain[600]',correct
'new Rain()',correct
'{    // accelerate bullet    if (speed < maxSpeed) {        speed += 2;    }    // end accelerate    x += speed;    if (x > width || x < 0 || y > height || y < 0) {        speed = 0;        shoot = false;    }// end check boundries}',SimplifyBooleanExpressions
'{    x = startX;    y = startY;    shoot = true;}',correct
'tank.display();',correct
'fill(0);',correct
'y = y + 7;',correct
'float x, y, w, h;',ShortVariable
'x = initX',correct
'random(600)',correct
'[600]',correct
'stroke(30, 144, 255);',correct
'x > width - 110',correct
'bullet.display();',correct
'{    speed += 2;}',correct
'fill(85, 107, 47);',correct
'rectMode(CENTER)',correct
'Bullet',correct
'x + speed',correct
'Wheels wheel;',correct
'h',correct
'y = random(-height)',correct
'y = random(-200)',correct
'rect(x + 110, y, 10, 30);',correct
'speed *= -1;',correct
'// tankbottomstrokeWeight(3);',correct
'popMatrix();',correct
'space = false',correct
'strokeWeight(2);',correct
'h = 10;',correct
'-200',correct
'{    if (shoot == false) {        x = startX;        y = startY;        shoot = true;    }}',correct
'shoot = false;',correct
'w',correct
'x',correct
'y',correct
'ellipse(x + i, y, 2, 2)',correct
'rectMode(CENTER);',correct
'maxSpeed = 15;',correct
'{    // move bullet    if (shoot == true) {        // accelerate bullet        if (speed < maxSpeed) {            speed += 2;        }        // end accelerate        x += speed;        if (x > width || x < 0 || y > height || y < 0) {            speed = 0;            shoot = false;        }    // end check boundries    }// end move bullet}',correct
'// check boundries',correct
'noStroke()',correct
'// end displayvoid updatePosition(float initX, float initY) {    x = initX;    y = initY;}',correct
'drops[i]',correct
'// end display',correct
'// end keyPressed',correct
'ellipse(x + i, y, 29, 29)',correct
'if (shoot == false) {    x = startX;    y = startY;    shoot = true;}',SimplifyBooleanExpressions
'ellipse(x + i, y, 29, 29);',correct
'for (float i = 0; i < 120; i = i + 30) {    stroke(0);    strokeWeight(2);    fill(139, 69, 19);    ellipse(x + i, y, 29, 29);    fill(255, 255, 255);    ellipse(x + i, y, 2, 2);}',correct
'{    speed = 0;    shoot = false;}',correct
'x = 300',correct
'shoot',correct
'{    switch(keyCode) {        case 32:            space = true;            break;    }// end keycode}',correct
'// end border width',correct
'// tankbasestroke(0);',correct
'x + i',correct
'fill(139, 69, 19);',correct
'for (int i = 0; i < drops.length; i++) {    drops[i] = new Rain();    rain = new Rain();}',correct
'rect(x + 110, y, 10, 30)',correct
'Rain[] drops = new Rain[600];',correct
'shoot = true',correct
'// end accelerate',correct
'rect(x, y + 40, 120, 30, 20);',correct
'break;',correct
'shot = new Bullet();',correct
'bullet = new Bullet()',correct
'new Tank(100, 300)',correct
'-100',correct
'fill(0)',correct
'y = startY',correct
'// end update',correct
'rect(x, y - 35, 75, 15, 7);',correct
'Wheels',correct
'// end classclass Wheels {    float x;    float y;    Wheels(float initX, float initY) {        x = initX;        y = initY;    }    // end init    void display() {        for (float i = 0; i < 120; i = i + 30) {            stroke(0);            strokeWeight(2);            fill(139, 69, 19);            ellipse(x + i, y, 29, 29);            fill(255, 255, 255);            ellipse(x + i, y, 2, 2);        }    // end for loop wheel duplication    }    // end display    void updatePosition(float initX, float initY) {        x = initX;        y = initY;    }    // end updatePosition}',correct
'update',correct
'float x;',correct
'i + 30',correct
'fill(85, 107, 47)',correct
'{    drops[i] = new Rain();    rain = new Rain();}',correct
'float i = 0',correct
'h = 10',correct
'speed',correct
'Processing',correct
'shot',correct
'speed *= -1',correct
'pushMatrix()',correct
'float speed, maxSpeed;',correct
'new Bullet()',correct
'float startX',correct
'bullet',correct
'tank',correct
'float startY',correct
'y > height',correct
'void setStartLocation(float startX, float startY) {    if (shoot == false) {        x = startX;        y = startY;        shoot = true;    }}',correct
'rect(w + 105, (-h / 2) + 5, w, h)',correct
'rect(w + 105, (-h / 2) + 5, w, h);',correct
'rectMode(CORNER);',correct
'false',correct
'float y;',correct
'x > width',correct
'{    stroke(0);    strokeWeight(2);    fill(139, 69, 19);    ellipse(x + i, y, 29, 29);    fill(255, 255, 255);    ellipse(x + i, y, 2, 2);}',correct
'maxSpeed',correct
'void fall() {    y = y + 7;    stroke(30, 144, 255);    line(x, y, x, y + 3);    if (y > height) {        x = random(600);        y = random(-200);    }}',AtLeastOneConstructor
'wheel.updatePosition(x - 45, y + 40)',correct
'x > width || x < 0 || y > height || y < 0',correct
'int i = 0',correct
'background(47, 79, 79);',correct
'x > width || x < 0 || y > height',correct
'shoot = true;',correct
'Bullet bullet;',correct
'// end keyReleasedclass Bullet {    float x, y, w, h;    float speed, maxSpeed;    boolean shoot;    Bullet() {        x = 300;        y = -100;        w = 20;        h = 10;        speed = 0;        maxSpeed = 15;        shoot = false;    }    void setStartLocation(float startX, float startY) {        if (shoot == false) {            x = startX;            y = startY;            shoot = true;        }    }    void update() {        // move bullet        if (shoot == true) {            // accelerate bullet            if (speed < maxSpeed) {                speed += 2;            }            // end accelerate            x += speed;            if (x > width || x < 0 || y > height || y < 0) {                speed = 0;                shoot = false;            }        // end check boundries        }    // end move bullet    }    // end update    void display() {        pushMatrix();        translate(x, y);        fill(0);        rect(w + 105, (-h / 2) + 5, w, h);        popMatrix();    }    // end display}',correct
'translate(x, y)',correct
'tank.update();',correct
'ellipse(x + i, y, 2, 2);',correct
'stroke(30, 144, 255)',correct
'tank = new Tank(100, 300)',correct
'i = 0',correct
'y = initY;',correct
'fill(139, 69, 19)',correct
'case 32:    space = false;    break;',correct
'case 32:    space = true;    break;',correct
'x < 55',correct
'tank.x',correct
'tank.y',correct
'x += speed',correct
'x < 0',correct
'y = initY',correct
'shoot == true',correct
'// tankwheels duplicate',correct
'// end class',correct
'x = startX',correct
'fill(255, 255, 255);',correct
'speed = 0;',correct
'rect(x + 80, y, 60, 20)',correct
'wheel.updatePosition(x - 45, y + 40);',correct
'width - 110',correct
'// end init',correct
'// end initvoid display() {    for (float i = 0; i < 120; i = i + 30) {        stroke(0);        strokeWeight(2);        fill(139, 69, 19);        ellipse(x + i, y, 29, 29);        fill(255, 255, 255);        ellipse(x + i, y, 2, 2);    }// end for loop wheel duplication}',correct
'tank = new Tank(100, 300);',correct
'x + 80',correct
'rectMode(CORNER)',correct
'speed += 2',correct
'Tank',correct
'switch(keyCode) {    case 32:        space = false;        break;}',correct
'new Wheels(x - 45, y + 40)',correct
'noStroke();',correct
'tank.display()',correct
'// move bulletif (shoot == true) {    // accelerate bullet    if (speed < maxSpeed) {        speed += 2;    }    // end accelerate    x += speed;    if (x > width || x < 0 || y > height || y < 0) {        speed = 0;        shoot = false;    }// end check boundries}',correct
'// display the wheels and bulletswheel.display();',correct
'void setup() {    tank = new Tank(100, 300);    shot = new Bullet();    space = false;    for (int i = 0; i < drops.length; i++) {        drops[i] = new Rain();        rain = new Rain();    }}',correct
'shot.display();',correct
'float x = random(600);',correct
'x = random(600)',correct
'strokeWeight(1)',correct
'y = -100;',correct
'translate(x, y);',correct
'shoot == false',correct
'// when space is clicked, set starting position bulletif (space) {    shot.setStartLocation(tank.x, tank.y);}',correct
'// end setup',correct
'line(x, y, x, y + 3);',correct
'// if tank hits boundries change directionif (x > width - 110 || x < 55) {    speed *= -1;}',correct
'{    x = initX;    y = initY;}',correct
'{    switch(keyCode) {        case 32:            space = false;            break;    }// end keycode}',correct
'// end updatevoid display() {    pushMatrix();    translate(x, y);    fill(0);    rect(w + 105, (-h / 2) + 5, w, h);    popMatrix();}',correct
'y = random(-200);',correct
'keyReleased',correct
'fill(50, 150, 30)',correct
'speed = 2;',correct
'{    x = initX;    y = initY;    speed = 2;    wheel = new Wheels(x - 45, y + 40);    bullet = new Bullet();}',correct
'x = random(600);',correct
'x - 45',correct
'updatePosition',correct
'Rain[]',correct
'shot.update()',correct
'// end initvoid update() {    // move the tank and wheels forward    x = x + speed;    wheel.updatePosition(x - 45, y + 40);    // if tank hits boundries change direction    if (x > width - 110 || x < 55) {        speed *= -1;    }// end border width}',correct
'space = true;',correct
'display',correct
'float speed;',correct
'{    pushMatrix();    translate(x, y);    fill(0);    rect(w + 105, (-h / 2) + 5, w, h);    popMatrix();}',correct
'draw',correct
'{    x = random(600);    y = random(-200);}',correct
'Bullet shot;',correct
'{    tank = new Tank(100, 300);    shot = new Bullet();    space = false;    for (int i = 0; i < drops.length; i++) {        drops[i] = new Rain();        rain = new Rain();    }}',correct
'Rain rain;',correct
'w = 20;',correct
'// end draw',correct
'// move the tank and wheels forwardx = x + speed;',correct
'float initX',correct
'rect(x, y, 100, 60, 7);',correct
'float initY',correct
'{    rectMode(CENTER);    // tankbase    stroke(0);    strokeWeight(1);    fill(50, 120, 30);    rect(x, y, 100, 60, 7);    fill(50, 150, 30);    rect(x, y - 35, 75, 15, 7);    // tankbarrel    rect(x + 80, y, 60, 20);    rect(x + 110, y, 10, 30);    // tankbottom    strokeWeight(3);    fill(205, 133, 63);    rect(x, y + 40, 120, 30, 20);    // display the wheels and bullets    wheel.display();    bullet.display();}',correct
'i++',correct
'background(47, 79, 79)',correct
'y + 40',correct
'space',correct
'// end setupvoid draw() {    background(47, 79, 79);    fill(85, 107, 47);    noStroke();    rectMode(CORNER);    rect(0, 300, 600, 100);    tank.display();    tank.update();    // when space is clicked, set starting position bullet    if (space) {        shot.setStartLocation(tank.x, tank.y);    }    // update and draw bullet    shot.update();    shot.display();    for (int i = 0; i < drops.length; i++) {        drops[i].fall();    }}',correct
'drops[i].fall()',correct
'Rain',correct
'x > width || x < 0',correct
'x = 300;',correct
'w + 105',correct
'strokeWeight(3)',correct
'// end draw// if space is pressed, shoot bulletvoid keyPressed() {    switch(keyCode) {        case 32:            space = true;            break;    }// end keycode}',correct
'fill(205, 133, 63)',correct
'maxSpeed = 15',correct
'fill(255, 255, 255)',correct
'i < drops.length',correct
'y < 0',correct
'rain',correct
'void',correct
'keyPressed',correct
'rect(x, y, 100, 60, 7)',correct
'-1',correct
'{    for (float i = 0; i < 120; i = i + 30) {        stroke(0);        strokeWeight(2);        fill(139, 69, 19);        ellipse(x + i, y, 29, 29);        fill(255, 255, 255);        ellipse(x + i, y, 2, 2);    }// end for loop wheel duplication}',correct
'// end updatevoid display() {    rectMode(CENTER);    // tankbase    stroke(0);    strokeWeight(1);    fill(50, 120, 30);    rect(x, y, 100, 60, 7);    fill(50, 150, 30);    rect(x, y - 35, 75, 15, 7);    // tankbarrel    rect(x + 80, y, 60, 20);    rect(x + 110, y, 10, 30);    // tankbottom    strokeWeight(3);    fill(205, 133, 63);    rect(x, y + 40, 120, 30, 20);    // display the wheels and bullets    wheel.display();    bullet.display();}',correct
'class Tank {    float x;    float y;    float speed;    Wheels wheel;    Bullet bullet;    Tank(float initX, float initY) {        x = initX;        y = initY;        speed = 2;        wheel = new Wheels(x - 45, y + 40);        bullet = new Bullet();    }    // end init    void update() {        // move the tank and wheels forward        x = x + speed;        wheel.updatePosition(x - 45, y + 40);        // if tank hits boundries change direction        if (x > width - 110 || x < 55) {            speed *= -1;        }    // end border width    }    // end update    void display() {        rectMode(CENTER);        // tankbase        stroke(0);        strokeWeight(1);        fill(50, 120, 30);        rect(x, y, 100, 60, 7);        fill(50, 150, 30);        rect(x, y - 35, 75, 15, 7);        // tankbarrel        rect(x + 80, y, 60, 20);        rect(x + 110, y, 10, 30);        // tankbottom        strokeWeight(3);        fill(205, 133, 63);        rect(x, y + 40, 120, 30, 20);        // display the wheels and bullets        wheel.display();        bullet.display();    }    // end display}',correct
'Tank(float initX, float initY) {    x = initX;    y = initY;    speed = 2;    wheel = new Wheels(x - 45, y + 40);    bullet = new Bullet();}',correct
'// end acceleratex += speed;',correct
'wheel = new Wheels(x - 45, y + 40);',correct
'float y = random(-height);',AtLeastOneConstructor
'{    shot.setStartLocation(tank.x, tank.y);}',correct
'drops[i] = new Rain();',correct
'i < 120',correct
'speed = 0',correct
'fill(50, 150, 30);',correct
'speed = 2',correct
'strokeWeight(2)',correct
'true',correct
'rect(0, 300, 600, 100);',PixelHardcodeIgnoranceRule
'y = y + 7',correct
'(-h / 2) + 5',correct
'y = startY;',correct
'rain = new Rain();',correct
'// accelerate bulletif (speed < maxSpeed) {    speed += 2;}',correct
'drops[i].fall();',correct
'i = i + 30',correct
'popMatrix()',correct
'// end check boundries',correct
'Bullet() {    x = 300;    y = -100;    w = 20;    h = 10;    speed = 0;    maxSpeed = 15;    shoot = false;}',correct
'// end updatePosition',correct
'tank.update()',correct
'shot.setStartLocation(tank.x, tank.y)',correct
'x = x + speed',correct
'wheel = new Wheels(x - 45, y + 40)',correct
'{    x = 300;    y = -100;    w = 20;    h = 10;    speed = 0;    maxSpeed = 15;    shoot = false;}',correct
'new Rain[600]',correct
'boolean space;',correct
'Tank tank;',correct
'rect(x, y + 40, 120, 30, 20)',correct
'space = false;',correct
'if (y > height) {    x = random(600);    y = random(-200);}',correct
'y + 7',correct
'w = 20',correct
'wheel',correct
'{    // move the tank and wheels forward    x = x + speed;    wheel.updatePosition(x - 45, y + 40);    // if tank hits boundries change direction    if (x > width - 110 || x < 55) {        speed *= -1;    }// end border width}',correct
'{    y = y + 7;    stroke(30, 144, 255);    line(x, y, x, y + 3);    if (y > height) {        x = random(600);        y = random(-200);    }}',correct
'y + 3',correct
'fill(205, 133, 63);',correct
'void update() {    // move bullet    if (shoot == true) {        // accelerate bullet        if (speed < maxSpeed) {            speed += 2;        }        // end accelerate        x += speed;        if (x > width || x < 0 || y > height || y < 0) {            speed = 0;            shoot = false;        }    // end check boundries    }// end move bullet}',correct
'// end keycode',correct
'bullet.display()',correct
'fill(50, 120, 30);',correct
'{    speed *= -1;}',correct
'{    background(47, 79, 79);    fill(85, 107, 47);    noStroke();    rectMode(CORNER);    rect(0, 300, 600, 100);    tank.display();    tank.update();    // when space is clicked, set starting position bullet    if (space) {        shot.setStartLocation(tank.x, tank.y);    }    // update and draw bullet    shot.update();    shot.display();    for (int i = 0; i < drops.length; i++) {        drops[i].fall();    }}',correct
'x = startX;',correct
'rain = new Rain()',correct
'random(-50, -100)',correct
'dragonY - dragonSpeed',correct
'x <= dragonX + 35',correct
'Dragondied();',correct
'if (isDeaD == true) {    textAlign(CENTER);    textSize(60);    fill(0);    text("YOU DIED", width / 2, height / 2);    textSize(20);    fill(255, 255, 255);    text("Play again", width / 2, 200);}',SimplifyBooleanExpressions
'dragonY + 45',correct
'y = y + arrowSpeed;',correct
'{    cloud1Y = -100;    cloud1X = PApplet.parseInt(random(width));}',correct
'dragonA.dragonX = -200;',correct
'"You survived " + dragonA.time',correct
'dragonX = x;',correct
'for (int i = 0; i < 100; i++) {    blooddrops[i] = new Blood(random(width), random(height), 25);}',correct
'{    background(0, 100, 150);    frameRate(120);    if (dragonA.isDeaD == true) {        for (int i = 0; i < 100; i++) {            blooddrops[i].display();        }    }    for (int i = 0; i < 100; i++) {        blooddrops[i].clean();    }    Timer();    arrowA.display();    arrowB.display();    arrowC.display();    dragonA.display();    arrowA.hitDragon();    arrowB.hitDragon();    arrowC.hitDragon();    backgroundClouds();    Dragondied();    println(dragonA.fireBreathing);}',correct
'ellipse(cloud2X - 40, cloud2Y - 40, 80, 60);',correct
'quad(x, y, x, y + 6, x - 5, y + 2, x - 5, y - 4);',correct
'keyCode == UP || key == w',correct
'd = dist(bloodx, bloody, mouseX, mouseY)',correct
'cloud2Y = -60;',DrawingStateChangeRule
'Arrow',correct
'',correct
'void fire() {    if (key ==   && fireBreathing == true) {        fireBreathing = false;    } else if (key == v) {        fireBreathing = true;    }    if (fireBreathing == true) {        noStroke();        fill(255, 100, 0);        triangle(dragonX + 7, dragonY - 30, dragonX - 5, dragonY - 65, dragonX + 20, dragonY - 65);        fill(255, 50, 0);        triangle(dragonX - 5, dragonY - 65, dragonX, dragonY - 80, dragonX + 5, dragonY - 65);        triangle(dragonX + 20, dragonY - 65, dragonX + 10, dragonY - 65, dragonX + 15, dragonY - 80);        triangle(dragonX + 2, dragonY - 65, dragonX + 12, dragonY - 65, dragonX + 6, dragonY - 90);        fill(255, 200, 0);        triangle(dragonX + 7, dragonY - 30, dragonX + 3, dragonY - 60, dragonX + 12, dragonY - 60);    }}',correct
'dist(bloodx, bloody, mouseX, mouseY)',correct
'void Dragondied() {    if (dragonA.isDeaD == true) {        dragonA.dragonSpeed = 0;        arrowA.arrowSpeed = 0;        arrowB.arrowSpeed = 0;        arrowC.arrowSpeed = 0;        cloudspeed1 = 0;        cloudspeed2 = 0;        dragonA.dragonX = -200;        dragonA.dragonY = -200;    }}',correct
'void mouseDragged() {    dragonA.move(mouseX, mouseY);}',correct
'fill(arrowColor);',correct
'{    fill(255, 255, 255, 0);    noStroke();    rect(dragonX - 10, dragonY - 35, 35, 150);    if (x >= dragonX - 10 && x <= dragonX + 35 && y >= dragonY - 35 && y <= dragonY + 150) {        isDeaD = true;        time = millis();    }}',correct
'fire();',correct
'height + 150',correct
'triangle(dragonX + 2, dragonY - 65, dragonX + 12, dragonY - 65, dragonX + 6, dragonY - 90);',DecentralizedDrawingRule
'dragonA.fireBreathing',correct
'int cloud2Y;',correct
'"You survived " + dragonA.time + "ms"',correct
'fill(0);',correct
'fill(255, 50, 0)',correct
'dragonA.fireBreathing = false',correct
'Dragon',correct
'second()',correct
'x = initX',correct
'arrowC = new Arrow(random(width), random(-100, 0), 1.5f, color(0, 200, 0), dragonA);',correct
'textAlign(CENTER)',correct
'if (cloud2Y == height + 60) {    cloud2Y = -60;    cloud2X = PApplet.parseInt(random(width));}',correct
'{    dragonY = dragonY - dragonSpeed;}',correct
'text("YOU DIED", width / 2, height / 2);',correct
'background(0, 100, 150);',correct
'dragonA.dragonSpeed = 0;',correct
'key == CODED || key != CODED',correct
'dragonA.dragonX',correct
'fill(209, 67, 35);',correct
'a',correct
'dragonX < -50',correct
'dragonA.dragonY',correct
'arrowA.hitDragon()',correct
'd',correct
'int cloud2X;',correct
'random(height)',correct
'arrowB.hitDragon()',correct
'fireBreathing = true',correct
'arrowC.hitDragon()',correct
'dragonA = new Dragon(150, 150, 10)',correct
'backgroundClouds();',correct
'fill(130, 120, 120);',correct
'dragonY + 37',correct
'cloudspeed1 = 0',correct
'noBlood = true',correct
'{    noBlood = true;}',correct
'cloudspeed1 = 1',correct
'dragonA.move(mouseX, mouseY);',correct
'float bloodx;',correct
'dragonY + 30',correct
's',correct
'v',correct
'arrowB.display();',correct
'w',correct
'if (s % 4 == 0) {    triangle(dragonX, dragonY + 75, dragonX + 15, dragonY + 75, dragonX - 15, dragonY + 120);} else {    triangle(dragonX, dragonY + 75, dragonX + 15, dragonY + 75, dragonX + 30, dragonY + 120);}',correct
'x',correct
'y',correct
'if (key ==   && fireBreathing == true) {    fireBreathing = false;} else if (key == v) {    fireBreathing = true;}',DecentralizedEventHandlingRule
'noBlood = true;',correct
'{    dragonA.move(mouseX, mouseY);}',correct
'arrowB.arrowSpeed = 0',correct
'arrowColor = initColor',correct
'class Blood {    float bloodx;    float bloody;    float bloodSize;    boolean noBlood = false;    Blood(float initX, float initY, float size) {        bloodx = initX;        bloody = initY;        bloodSize = size;    }    void display() {        if (noBlood == false) {            noStroke();            fill(209, 67, 35);            ellipseMode(CENTER);            ellipse(bloodx, bloody, bloodSize, bloodSize);        }    }    void clean() {        float d = dist(bloodx, bloody, mouseX, mouseY);        if (d <= bloodSize && noBlood == false) {            noBlood = true;        }    }}',correct
'boolean noBlood = false;',correct
'cloudspeed2 = 0;',DrawingStateChangeRule
'float bloody;',correct
'{    if (keyCode == RIGHT || key == d) {        dragonX = dragonX + dragonSpeed;    } else if (keyCode == LEFT || key == a) {        dragonX = dragonX - dragonSpeed;    } else if (keyCode == UP || key == w) {        dragonY = dragonY - dragonSpeed;    } else if (keyCode == DOWN || key == s) {        dragonY = dragonY + dragonSpeed;    }}',correct
'Blood[] blooddrops = new Blood[100];',correct
'int cloud1Y;',correct
'cloud1Y',correct
'cloud1X',correct
'dragonA.isDeaD == true',correct
'ellipse(bloodx, bloody, bloodSize, bloodSize)',correct
'cloud2Y = -60',correct
'dragonA.isDeaD == false',correct
'height + 100',correct
'void display() {    if (noBlood == false) {        noStroke();        fill(209, 67, 35);        ellipseMode(CENTER);        ellipse(bloodx, bloody, bloodSize, bloodSize);    }}',correct
'fill(255, 200, 0);',correct
'ellipse(cloud1X + 90, cloud1Y - 60, 180, 90);',correct
'blooddrops = new Blood[100]',correct
'int cloud1X;',correct
'"You survived " + millis() + "ms"',correct
'y = random(-50, -100)',correct
'float size',correct
'println(dragonA.fireBreathing);',correct
'float initSpeed',correct
'cloudspeed1',correct
'{    for (int i = 0; i < 100; i++) {        blooddrops[i].display();    }}',correct
'int initColor',correct
'void display() {    noStroke();    if (y >= random(height, height + 150)) {        y = random(-50, -100);        x = random(width);        arrowSpeed = arrowSpeed + 0.2f;    }    fill(130, 120, 120);    rect(x, y, 6, 50);    fill(200);    triangle(x - 3, y + 50, x + 9, y + 50, x + 3, y + 60);    fill(arrowColor);    quad(x, y, x, y + 6, x - 5, y + 2, x - 5, y - 4);    quad(x + 6, y, x + 6, y + 6, x + 11, y + 2, x + 11, y - 4);    y = y + arrowSpeed;}',correct
'dragonX + 20',correct
'cloud1X + 90',correct
'y + arrowSpeed',correct
'cloud1Y = 50;',correct
'triangle(dragonX + 2, dragonY - 65, dragonX + 12, dragonY - 65, dragonX + 6, dragonY - 90)',correct
'ellipse(cloud2X + 40, cloud2Y + 30, 60, 40)',correct
'cloudspeed2',correct
'float x;',correct
'triangle(dragonX + 15, dragonY - 15, dragonX + 10, dragonY - 15, dragonX + 12, dragonY - 5)',correct
'Processing',correct
'textSize(20);',correct
'y <= dragonY + 150',correct
'x = random(width)',correct
'// right wingtriangle(dragonX + 15, dragonY + 30, dragonX + 30, dragonY, dragonX + 60, dragonY + 45);',correct
'triangle(dragonX - 1, dragonY - 15, dragonX + 4, dragonY - 15, dragonX + 1, dragonY - 5)',correct
'bloodx',correct
'bloody',correct
'{    dragonX = dragonX + 400;}',correct
'arrowB.display()',correct
'dragonY + 150',correct
'0.2f',correct
'dragonA.fly()',correct
'dragonX + 10',correct
'dragonX + dragonSpeed',correct
'float y;',correct
'false',correct
'Dragon dragonA;',correct
'cloud1Y == height + 100',correct
'dragonX - dragonSpeed',correct
'cloudspeed2 = 1;',correct
'height + 60',correct
'bloodx = initX',correct
'setup',correct
'triangle(dragonX + 15, dragonY - 15, dragonX + 10, dragonY - 15, dragonX + 12, dragonY - 5);',correct
'dragonY + dragonSpeed',correct
'triangle(dragonX, dragonY + 30, dragonX - 15, dragonY, dragonX - 45, dragonY + 45)',correct
'dragonX + 12',correct
'cloud2Y',correct
'class Dragon {    float dragonX;    float dragonY;    float dragonSpeed;    boolean isDeaD = false;    boolean fireBreathing = false;    int time;    Dragon(float initX, float initY, float initSpeed) {        dragonX = initX;        dragonY = initY;        dragonSpeed = initSpeed;    }    void hitDragon(float x, float y) {        fill(255, 255, 255, 0);        noStroke();        rect(dragonX - 10, dragonY - 35, 35, 150);        if (x >= dragonX - 10 && x <= dragonX + 35 && y >= dragonY - 35 && y <= dragonY + 150) {            isDeaD = true;            time = millis();        }    }    void display() {        if (dragonX > width + 50) {            dragonX = dragonX - 350;        }        if (dragonX < -50) {            dragonX = dragonX + 400;        }        // body        fill(99, 155, 85);        stroke(57, 102, 57);        rect(dragonX, dragonY, 15, 75);        // tail        int s = second();        if (s % 4 == 0) {            triangle(dragonX, dragonY + 75, dragonX + 15, dragonY + 75, dragonX - 15, dragonY + 120);        } else {            triangle(dragonX, dragonY + 75, dragonX + 15, dragonY + 75, dragonX + 30, dragonY + 120);        }        // left wing        triangle(dragonX, dragonY + 30, dragonX - 15, dragonY, dragonX - 45, dragonY + 45);        line(dragonX - 15, dragonY, dragonX - 24, dragonY + 37);        // right wing        triangle(dragonX + 15, dragonY + 30, dragonX + 30, dragonY, dragonX + 60, dragonY + 45);        line(dragonX + 30, dragonY, dragonX + 39, dragonY + 37);        // head        rect(dragonX + 2, dragonY - 15, 11, 15);        quad(dragonX - 2, dragonY - 15, dragonX + 16, dragonY - 15, dragonX + 12, dragonY - 30, dragonX + 4, dragonY - 30);        fill(200);        triangle(dragonX - 1, dragonY - 15, dragonX + 4, dragonY - 15, dragonX + 1, dragonY - 5);        triangle(dragonX + 15, dragonY - 15, dragonX + 10, dragonY - 15, dragonX + 12, dragonY - 5);        isDead();        fire();    }    void fly() {        if (key == CODED || key != CODED) {            if (keyCode == RIGHT || key == d) {                dragonX = dragonX + dragonSpeed;            } else if (keyCode == LEFT || key == a) {                dragonX = dragonX - dragonSpeed;            } else if (keyCode == UP || key == w) {                dragonY = dragonY - dragonSpeed;            } else if (keyCode == DOWN || key == s) {                dragonY = dragonY + dragonSpeed;            }        }    }    void fire() {        if (key ==   && fireBreathing == true) {            fireBreathing = false;        } else if (key == v) {            fireBreathing = true;        }        if (fireBreathing == true) {            noStroke();            fill(255, 100, 0);            triangle(dragonX + 7, dragonY - 30, dragonX - 5, dragonY - 65, dragonX + 20, dragonY - 65);            fill(255, 50, 0);            triangle(dragonX - 5, dragonY - 65, dragonX, dragonY - 80, dragonX + 5, dragonY - 65);            triangle(dragonX + 20, dragonY - 65, dragonX + 10, dragonY - 65, dragonX + 15, dragonY - 80);            triangle(dragonX + 2, dragonY - 65, dragonX + 12, dragonY - 65, dragonX + 6, dragonY - 90);            fill(255, 200, 0);            triangle(dragonX + 7, dragonY - 30, dragonX + 3, dragonY - 60, dragonX + 12, dragonY - 60);        }    }    void isDead() {        if (isDeaD == true) {            textAlign(CENTER);            textSize(60);            fill(0);            text("YOU DIED", width / 2, height / 2);            textSize(20);            fill(255, 255, 255);            text("Play again", width / 2, 200);        }    }    void move(float x, float y) {        dragonX = x;        dragonY = y;    }}',correct
'cloud2X',correct
'cloudspeed2 = 0',correct
'dragonX + 15',correct
'cloudspeed2 = 1',correct
'dragonX + 16',correct
'i = 0',correct
'stroke(57, 102, 57);',correct
'fill(179, 191, 209, 230);',correct
'width + 50',correct
'line(dragonX + 30, dragonY, dragonX + 39, dragonY + 37);',correct
'arrowA.display()',correct
'bloodSize',correct
'y = initY',correct
'arrowB = new Arrow(random(width), random(-100, 0), 1.5f, color(0, 0, 200), dragonA)',correct
'd <= bloodSize',correct
'key ==   && fireBreathing == true',correct
'// bodyfill(99, 155, 85);',correct
'dragonA = new Dragon(150, 150, 10);',correct
'fill(255, 255, 255);',correct
'Blood(float initX, float initY, float size) {    bloodx = initX;    bloody = initY;    bloodSize = size;}',correct
'quad(dragonX - 2, dragonY - 15, dragonX + 16, dragonY - 15, dragonX + 12, dragonY - 30, dragonX + 4, dragonY - 30)',correct
'dragonX = dragonX - 350',correct
'dragonX + 30',correct
'bloodSize = size;',correct
'ellipse(cloud2X - 40, cloud2Y - 40, 80, 60)',correct
'arrowC.hitDragon();',correct
'fireBreathing = true;',correct
'dragonX = dragonX + 400',correct
'isDeaD == true',correct
'rect(dragonX, dragonY, 15, 75)',correct
'random(height, height + 150)',correct
'dragonA.fire()',correct
'noStroke();',correct
'dragonA.fly();',correct
'dragonY = y;',correct
'dragonX + 35',correct
'cloud2Y = 130',correct
'{    textSize(25);    if (dragonA.isDeaD == false) {        textAlign(CENTER);        text("You survived " + millis() + "ms", width / 2, 20);    }    if (dragonA.isDeaD == true) {        textAlign(CENTER);        text("You survived " + dragonA.time + "ms", width / 2, 20);    }}',correct
'float dragonSpeed;',correct
'dragonX + 39',correct
'dragonY + 120',correct
'dragonA.dragonX = -200',correct
'textSize(60)',correct
'dragonX + 60',correct
'dragon = dragonA;',correct
'fireBreathing == true',correct
'arrowSpeed = initSpeed;',correct
'if (x >= dragonX - 10 && x <= dragonX + 35 && y >= dragonY - 35 && y <= dragonY + 150) {    isDeaD = true;    time = millis();}',correct
'{    dragonX = x;    dragonY = y;}',correct
'isDeaD = true;',correct
'bloody = initY;',correct
'new Arrow(random(width), random(-100, 0), 1.5f, color(0, 0, 200), dragonA)',correct
'triangle(dragonX, dragonY + 75, dragonX + 15, dragonY + 75, dragonX - 15, dragonY + 120);',correct
'keyCode == UP',correct
'fireBreathing = false;',correct
'text("Play again", width / 2, 200);',PixelHardcodeIgnoranceRule
'dragonX - 350',correct
'{    if (noBlood == false) {        noStroke();        fill(209, 67, 35);        ellipseMode(CENTER);        ellipse(bloodx, bloody, bloodSize, bloodSize);    }}',correct
'Dragondied()',correct
'arrowC',correct
'cloud1Y = -100;',DrawingStateChangeRule
'dragonY',correct
'dragonX',correct
'arrowA',correct
'arrowB',correct
'if (fireBreathing == true) {    noStroke();    fill(255, 100, 0);    triangle(dragonX + 7, dragonY - 30, dragonX - 5, dragonY - 65, dragonX + 20, dragonY - 65);    fill(255, 50, 0);    triangle(dragonX - 5, dragonY - 65, dragonX, dragonY - 80, dragonX + 5, dragonY - 65);    triangle(dragonX + 20, dragonY - 65, dragonX + 10, dragonY - 65, dragonX + 15, dragonY - 80);    triangle(dragonX + 2, dragonY - 65, dragonX + 12, dragonY - 65, dragonX + 6, dragonY - 90);    fill(255, 200, 0);    triangle(dragonX + 7, dragonY - 30, dragonX + 3, dragonY - 60, dragonX + 12, dragonY - 60);}',SimplifyBooleanExpressions
'Dragon dragonA',correct
'textSize(60);',correct
'line(dragonX - 15, dragonY, dragonX - 24, dragonY + 37);',correct
'fill(255, 50, 0);',correct
'Dragon dragon;',correct
'{    dragonA.fireBreathing = false;}',correct
'blooddrops[i].clean();',correct
'new Blood[100]',correct
's = second()',correct
'void backgroundClouds() {    fill(179, 191, 209, 230);    ellipse(cloud1X, cloud1Y, 200, 100);    ellipse(cloud1X + 90, cloud1Y - 60, 180, 90);    cloud1Y = cloud1Y + cloudspeed1;    if (cloud1Y == height + 100) {        cloud1Y = -100;        cloud1X = PApplet.parseInt(random(width));    }    ellipse(cloud2X, cloud2Y, 120, 80);    ellipse(cloud2X - 40, cloud2Y - 40, 80, 60);    ellipse(cloud2X + 40, cloud2Y + 30, 60, 40);    cloud2Y = cloud2Y + cloudspeed2;    if (cloud2Y == height + 60) {        cloud2Y = -60;        cloud2X = PApplet.parseInt(random(width));    }}',correct
'blooddrops[i].display();',correct
'triangle(dragonX + 7, dragonY - 30, dragonX - 5, dragonY - 65, dragonX + 20, dragonY - 65);',DecentralizedDrawingRule
'keyCode == DOWN || key == s',correct
'ellipse(bloodx, bloody, bloodSize, bloodSize);',correct
'// headrect(dragonX + 2, dragonY - 15, 11, 15);',correct
'cloud2X = PApplet.parseInt(random(width));',correct
'dragonA',correct
'dragonX = dragonX - dragonSpeed;',correct
'cloud1Y = cloud1Y + cloudspeed1',correct
'text("You survived " + millis() + "ms", width / 2, 20);',PixelHardcodeIgnoranceRule
'dragonX = dragonX + dragonSpeed;',correct
'dragonA.fireBreathing = true',correct
'rect(dragonX - 10, dragonY - 35, 35, 150)',correct
'arrowSpeed',correct
'dragon = dragonA',correct
'text("You survived " + dragonA.time + "ms", width / 2, 20);',PixelHardcodeIgnoranceRule
'if (dragonA.isDeaD == true) {    dragonA.dragonSpeed = 0;    arrowA.arrowSpeed = 0;    arrowB.arrowSpeed = 0;    arrowC.arrowSpeed = 0;    cloudspeed1 = 0;    cloudspeed2 = 0;    dragonA.dragonX = -200;    dragonA.dragonY = -200;}',SimplifyBooleanExpressions
'"YOU DIED"',correct
'color(0, 0, 200)',correct
'ellipseMode(CENTER)',correct
'{    float d = dist(bloodx, bloody, mouseX, mouseY);    if (d <= bloodSize && noBlood == false) {        noBlood = true;    }}',correct
'new Arrow(random(width), random(-100, 0), 1.5f, color(0, 200, 0), dragonA)',correct
'boolean isDeaD = false;',AvoidFieldNameMatchingMethodName
'{    isDeaD = true;    time = millis();}',correct
'cloud1X = PApplet.parseInt(random(width));',correct
'dragonX - 24',correct
'cloud1Y - 60',correct
'dragonX + 400',correct
'fill(255, 255, 255)',correct
'{    x = initX;    y = initY;    arrowSpeed = initSpeed;    arrowColor = initColor;    dragon = dragonA;}',correct
'void',correct
'triangle(dragonX + 15, dragonY + 30, dragonX + 30, dragonY, dragonX + 60, dragonY + 45)',correct
'x >= dragonX - 10 && x <= dragonX + 35',correct
'{    dragonA.fly();    dragonA.fire();}',correct
'y + 50',correct
'key != CODED',correct
'dragonX - 10',correct
'float bloodSize;',correct
'arrowB.hitDragon();',correct
'{    textAlign(CENTER);    text("You survived " + millis() + "ms", width / 2, 20);}',correct
'arrowA.hitDragon();',correct
'dragonA.fireBreathing = false;',correct
'line(dragonX + 30, dragonY, dragonX + 39, dragonY + 37)',correct
'{    blooddrops[i] = new Blood(random(width), random(height), 25);}',correct
'quad(x, y, x, y + 6, x - 5, y + 2, x - 5, y - 4)',correct
'float d = dist(bloodx, bloody, mouseX, mouseY)',correct
'ellipse(cloud2X, cloud2Y, 120, 80);',correct
'arrowSpeed = arrowSpeed + 0.2f;',correct
'true',correct
'1.5f',correct
'dragonX - 15',correct
'isDeaD = true',correct
'bloody = initY',correct
'background(0, 100, 150)',correct
'fire()',correct
'fill(arrowColor)',correct
'fireBreathing = false',correct
'triangle(dragonX + 7, dragonY - 30, dragonX + 3, dragonY - 60, dragonX + 12, dragonY - 60);',DecentralizedDrawingRule
'dragonY = dragonY - dragonSpeed;',correct
'for (int i = 0; i < 100; i++) {    blooddrops[i].clean();}',correct
'void Timer() {    textSize(25);    if (dragonA.isDeaD == false) {        textAlign(CENTER);        text("You survived " + millis() + "ms", width / 2, 20);    }    if (dragonA.isDeaD == true) {        textAlign(CENTER);        text("You survived " + dragonA.time + "ms", width / 2, 20);    }}',MethodNamingConventions
'dragonX - 45',correct
'dragon.hitDragon(x, y);',correct
'quad(x + 6, y, x + 6, y + 6, x + 11, y + 2, x + 11, y - 4);',correct
'{    bloodx = initX;    bloody = initY;    bloodSize = size;}',correct
'{    triangle(dragonX, dragonY + 75, dragonX + 15, dragonY + 75, dragonX - 15, dragonY + 120);}',correct
'"You survived "',correct
'arrowA.arrowSpeed = 0',correct
'triangle(dragonX, dragonY + 75, dragonX + 15, dragonY + 75, dragonX + 30, dragonY + 120)',correct
'blooddrops[i] = new Blood(random(width), random(height), 25);',correct
'dragonY = dragonY + dragonSpeed',correct
'time = millis()',correct
'blooddrops[i]',correct
'println(dragonA.fireBreathing)',correct
'if (dragonA.isDeaD == true) {    for (int i = 0; i < 100; i++) {        blooddrops[i].display();    }}',SimplifyBooleanExpressions
'triangle(dragonX, dragonY + 75, dragonX + 15, dragonY + 75, dragonX - 15, dragonY + 120)',correct
'if (noBlood == false) {    noStroke();    fill(209, 67, 35);    ellipseMode(CENTER);    ellipse(bloodx, bloody, bloodSize, bloodSize);}',SimplifyBooleanExpressions
'float x',correct
'float y',correct
'{    dragonX = dragonX + dragonSpeed;}',correct
'arrowC.arrowSpeed = 0;',correct
'color(0, 200, 0)',correct
'{    blooddrops[i].clean();}',correct
'void fly() {    if (key == CODED || key != CODED) {        if (keyCode == RIGHT || key == d) {            dragonX = dragonX + dragonSpeed;        } else if (keyCode == LEFT || key == a) {            dragonX = dragonX - dragonSpeed;        } else if (keyCode == UP || key == w) {            dragonY = dragonY - dragonSpeed;        } else if (keyCode == DOWN || key == s) {            dragonY = dragonY + dragonSpeed;        }    }}',correct
'if (keyCode == LEFT || key == a) {    dragonX = dragonX - dragonSpeed;} else if (keyCode == UP || key == w) {    dragonY = dragonY - dragonSpeed;} else if (keyCode == DOWN || key == s) {    dragonY = dragonY + dragonSpeed;}',correct
'i < 100',correct
'void mousePressed() {    dragonA.move(mouseX, mouseY);    dragonA.fireBreathing = true;}',correct
'int arrowColor;',correct
'fill(209, 67, 35)',correct
'rect(x, y, 6, 50)',correct
'blooddrops[i].clean()',correct
'bloodSize = size',correct
's % 4 == 0',correct
'dragonA.time',correct
'Timer()',correct
'Timer();',correct
'random(width)',correct
'int cloudspeed2;',correct
'Dragon(float initX, float initY, float initSpeed) {    dragonX = initX;    dragonY = initY;    dragonSpeed = initSpeed;}',correct
'float d = dist(bloodx, bloody, mouseX, mouseY);',DecentralizedEventHandlingRule
'x = initX;',correct
'{    if (dragonX > width + 50) {        dragonX = dragonX - 350;    }    if (dragonX < -50) {        dragonX = dragonX + 400;    }    // body    fill(99, 155, 85);    stroke(57, 102, 57);    rect(dragonX, dragonY, 15, 75);    // tail    int s = second();    if (s % 4 == 0) {        triangle(dragonX, dragonY + 75, dragonX + 15, dragonY + 75, dragonX - 15, dragonY + 120);    } else {        triangle(dragonX, dragonY + 75, dragonX + 15, dragonY + 75, dragonX + 30, dragonY + 120);    }    // left wing    triangle(dragonX, dragonY + 30, dragonX - 15, dragonY, dragonX - 45, dragonY + 45);    line(dragonX - 15, dragonY, dragonX - 24, dragonY + 37);    // right wing    triangle(dragonX + 15, dragonY + 30, dragonX + 30, dragonY, dragonX + 60, dragonY + 45);    line(dragonX + 30, dragonY, dragonX + 39, dragonY + 37);    // head    rect(dragonX + 2, dragonY - 15, 11, 15);    quad(dragonX - 2, dragonY - 15, dragonX + 16, dragonY - 15, dragonX + 12, dragonY - 30, dragonX + 4, dragonY - 30);    fill(200);    triangle(dragonX - 1, dragonY - 15, dragonX + 4, dragonY - 15, dragonX + 1, dragonY - 5);    triangle(dragonX + 15, dragonY - 15, dragonX + 10, dragonY - 15, dragonX + 12, dragonY - 5);    isDead();    fire();}',correct
'x = random(width);',correct
'cloud2X + 40',correct
'Blood',correct
'arrowA = new Arrow(random(width), random(-100, 0), 1.5f, color(200, 0, 0), dragonA)',correct
'if (key == v) {    fireBreathing = true;}',DecentralizedEventHandlingRule
'dragonSpeed',correct
'void move(float x, float y) {    dragonX = x;    dragonY = y;}',correct
'rect(dragonX - 10, dragonY - 35, 35, 150);',correct
'textSize(25);',correct
'blooddrops[i] = new Blood(random(width), random(height), 25)',correct
'keyCode == RIGHT || key == d',correct
'arrowSpeed = initSpeed',correct
'void hitDragon(float x, float y) {    fill(255, 255, 255, 0);    noStroke();    rect(dragonX - 10, dragonY - 35, 35, 150);    if (x >= dragonX - 10 && x <= dragonX + 35 && y >= dragonY - 35 && y <= dragonY + 150) {        isDeaD = true;        time = millis();    }}',correct
'dragonY = initY;',correct
'"Play again"',correct
'stroke(57, 102, 57)',correct
'cloud1Y + cloudspeed1',correct
'{    dragonA.move(mouseX, mouseY);    dragonA.fireBreathing = true;}',correct
'triangle(dragonX + 7, dragonY - 30, dragonX - 5, dragonY - 65, dragonX + 20, dragonY - 65)',correct
'arrowA.arrowSpeed = 0;',correct
'cloud2Y = cloud2Y + cloudspeed2;',DrawingStateChangeRule
'textSize(20)',correct
'x + 11',correct
'dragonSpeed = initSpeed',correct
'triangle(dragonX - 5, dragonY - 65, dragonX, dragonY - 80, dragonX + 5, dragonY - 65)',correct
'y + 60',correct
'noBlood = false',correct
'isDeaD = false',correct
'y >= dragonY - 35',correct
'fill(255, 255, 255, 0)',correct
'cloud2Y = 130;',correct
'Arrow(float initX, float initY, float initSpeed, int initColor, Dragon dragonA) {    x = initX;    y = initY;    arrowSpeed = initSpeed;    arrowColor = initColor;    dragon = dragonA;}',correct
'dragonA.isDeaD',correct
'text("Play again", width / 2, 200)',correct
'y >= random(height, height + 150)',correct
'triangle(dragonX + 20, dragonY - 65, dragonX + 10, dragonY - 65, dragonX + 15, dragonY - 80);',DecentralizedDrawingRule
'{    textAlign(CENTER);    textSize(60);    fill(0);    text("YOU DIED", width / 2, height / 2);    textSize(20);    fill(255, 255, 255);    text("Play again", width / 2, 200);}',correct
'time = millis();',correct
'y - 4',correct
'arrowB = new Arrow(random(width), random(-100, 0), 1.5f, color(0, 0, 200), dragonA);',correct
'cloud2Y - 40',correct
'fill(255, 100, 0);',correct
'arrowA.display();',correct
'{    y = random(-50, -100);    x = random(width);    arrowSpeed = arrowSpeed + 0.2f;}',correct
'if (dragonA.isDeaD == false) {    textAlign(CENTER);    text("You survived " + millis() + "ms", width / 2, 20);}',SimplifyBooleanExpressions
'-200',correct
'quad(dragonX - 2, dragonY - 15, dragonX + 16, dragonY - 15, dragonX + 12, dragonY - 30, dragonX + 4, dragonY - 30);',correct
'new Dragon(150, 150, 10)',correct
'void setup() {    background(0, 100, 150);    cloud1X = PApplet.parseInt(random(width));    cloud1Y = 50;    cloud2X = PApplet.parseInt(random(width));    cloud2Y = 130;    cloudspeed1 = 1;    cloudspeed2 = 1;    for (int i = 0; i < 100; i++) {        blooddrops[i] = new Blood(random(width), random(height), 25);    }    dragonA = new Dragon(150, 150, 10);    // Arrows    arrowA = new Arrow(random(width), random(-100, 0), 1.5f, color(200, 0, 0), dragonA);    arrowB = new Arrow(random(width), random(-100, 0), 1.5f, color(0, 0, 200), dragonA);    arrowC = new Arrow(random(width), random(-100, 0), 1.5f, color(0, 200, 0), dragonA);}',correct
'millis()',correct
'[100]',correct
'noStroke()',correct
'dragonA.fire();',correct
'{    noStroke();    fill(255, 100, 0);    triangle(dragonX + 7, dragonY - 30, dragonX - 5, dragonY - 65, dragonX + 20, dragonY - 65);    fill(255, 50, 0);    triangle(dragonX - 5, dragonY - 65, dragonX, dragonY - 80, dragonX + 5, dragonY - 65);    triangle(dragonX + 20, dragonY - 65, dragonX + 10, dragonY - 65, dragonX + 15, dragonY - 80);    triangle(dragonX + 2, dragonY - 65, dragonX + 12, dragonY - 65, dragonX + 6, dragonY - 90);    fill(255, 200, 0);    triangle(dragonX + 7, dragonY - 30, dragonX + 3, dragonY - 60, dragonX + 12, dragonY - 60);}',correct
'void display() {    if (dragonX > width + 50) {        dragonX = dragonX - 350;    }    if (dragonX < -50) {        dragonX = dragonX + 400;    }    // body    fill(99, 155, 85);    stroke(57, 102, 57);    rect(dragonX, dragonY, 15, 75);    // tail    int s = second();    if (s % 4 == 0) {        triangle(dragonX, dragonY + 75, dragonX + 15, dragonY + 75, dragonX - 15, dragonY + 120);    } else {        triangle(dragonX, dragonY + 75, dragonX + 15, dragonY + 75, dragonX + 30, dragonY + 120);    }    // left wing    triangle(dragonX, dragonY + 30, dragonX - 15, dragonY, dragonX - 45, dragonY + 45);    line(dragonX - 15, dragonY, dragonX - 24, dragonY + 37);    // right wing    triangle(dragonX + 15, dragonY + 30, dragonX + 30, dragonY, dragonX + 60, dragonY + 45);    line(dragonX + 30, dragonY, dragonX + 39, dragonY + 37);    // head    rect(dragonX + 2, dragonY - 15, 11, 15);    quad(dragonX - 2, dragonY - 15, dragonX + 16, dragonY - 15, dragonX + 12, dragonY - 30, dragonX + 4, dragonY - 30);    fill(200);    triangle(dragonX - 1, dragonY - 15, dragonX + 4, dragonY - 15, dragonX + 1, dragonY - 5);    triangle(dragonX + 15, dragonY - 15, dragonX + 10, dragonY - 15, dragonX + 12, dragonY - 5);    isDead();    fire();}',correct
'cloudspeed1 = 0;',DrawingStateChangeRule
'textSize(25)',correct
'dragonA.dragonSpeed',correct
'dragonY - 5',correct
'triangle(dragonX + 20, dragonY - 65, dragonX + 10, dragonY - 65, dragonX + 15, dragonY - 80)',correct
'cloud1Y = -100',correct
'key ==',correct
'class Arrow {    float x;    float y;    float arrowSpeed;    int arrowColor;    Dragon dragon;    Arrow(float initX, float initY, float initSpeed, int initColor, Dragon dragonA) {        x = initX;        y = initY;        arrowSpeed = initSpeed;        arrowColor = initColor;        dragon = dragonA;    }    void display() {        noStroke();        if (y >= random(height, height + 150)) {            y = random(-50, -100);            x = random(width);            arrowSpeed = arrowSpeed + 0.2f;        }        fill(130, 120, 120);        rect(x, y, 6, 50);        fill(200);        triangle(x - 3, y + 50, x + 9, y + 50, x + 3, y + 60);        fill(arrowColor);        quad(x, y, x, y + 6, x - 5, y + 2, x - 5, y - 4);        quad(x + 6, y, x + 6, y + 6, x + 11, y + 2, x + 11, y - 4);        y = y + arrowSpeed;    }    void hitDragon() {        dragon.hitDragon(x, y);    }}',correct
'Arrow arrowB;',correct
'dragonX = dragonX - dragonSpeed',correct
'dragonX = dragonX + dragonSpeed',correct
'arrowC = new Arrow(random(width), random(-100, 0), 1.5f, color(0, 200, 0), dragonA)',correct
'arrowA.arrowSpeed',correct
'cloud2Y = cloud2Y + cloudspeed2',correct
'dragonY = initY',correct
'frameRate(120)',correct
'isDead()',correct
'cloudspeed1 = 1;',correct
'rect(dragonX + 2, dragonY - 15, 11, 15)',correct
'key == CODED',correct
'{    if (dragonA.isDeaD == true) {        dragonA.dragonSpeed = 0;        arrowA.arrowSpeed = 0;        arrowB.arrowSpeed = 0;        arrowC.arrowSpeed = 0;        cloudspeed1 = 0;        cloudspeed2 = 0;        dragonA.dragonX = -200;        dragonA.dragonY = -200;    }}',correct
'triangle(x - 3, y + 50, x + 9, y + 50, x + 3, y + 60)',correct
'Arrow arrowC;',correct
'new Blood(random(width), random(height), 25)',correct
'rect(x, y, 6, 50);',correct
'-100',correct
'fill(0)',correct
'if (keyCode == RIGHT || key == d) {    dragonX = dragonX + dragonSpeed;} else if (keyCode == LEFT || key == a) {    dragonX = dragonX - dragonSpeed;} else if (keyCode == UP || key == w) {    dragonY = dragonY - dragonSpeed;} else if (keyCode == DOWN || key == s) {    dragonY = dragonY + dragonSpeed;}',correct
'height / 2',correct
'frameRate(120);',correct
'{    dragonY = dragonY + dragonSpeed;}',correct
'void hitDragon() {    dragon.hitDragon(x, y);}',correct
'{    if (key ==   && fireBreathing == true) {        fireBreathing = false;    } else if (key == v) {        fireBreathing = true;    }    if (fireBreathing == true) {        noStroke();        fill(255, 100, 0);        triangle(dragonX + 7, dragonY - 30, dragonX - 5, dragonY - 65, dragonX + 20, dragonY - 65);        fill(255, 50, 0);        triangle(dragonX - 5, dragonY - 65, dragonX, dragonY - 80, dragonX + 5, dragonY - 65);        triangle(dragonX + 20, dragonY - 65, dragonX + 10, dragonY - 65, dragonX + 15, dragonY - 80);        triangle(dragonX + 2, dragonY - 65, dragonX + 12, dragonY - 65, dragonX + 6, dragonY - 90);        fill(255, 200, 0);        triangle(dragonX + 7, dragonY - 30, dragonX + 3, dragonY - 60, dragonX + 12, dragonY - 60);    }}',correct
'if (y >= random(height, height + 150)) {    y = random(-50, -100);    x = random(width);    arrowSpeed = arrowSpeed + 0.2f;}',correct
'dragonX > width + 50',correct
'dragonY = dragonY + dragonSpeed;',correct
'cloud2X - 40',correct
'bloodx = initX;',correct
'cloud2X = PApplet.parseInt(random(width))',correct
'isDead();',correct
'{    cloud2Y = -60;    cloud2X = PApplet.parseInt(random(width));}',correct
'dragonY = y',correct
'dragonA.dragonY = -200;',correct
'for (int i = 0; i < 100; i++) {    blooddrops[i].display();}',correct
'triangle(dragonX - 5, dragonY - 65, dragonX, dragonY - 80, dragonX + 5, dragonY - 65);',DecentralizedDrawingRule
'rect(dragonX, dragonY, 15, 75);',correct
'dragonY - 80',correct
'boolean fireBreathing = false;',correct
'{    blooddrops[i].display();}',correct
'if (dragonX > width + 50) {    dragonX = dragonX - 350;}',correct
'int cloudspeed1;',correct
'if (dragonA.isDeaD == true) {    textAlign(CENTER);    text("You survived " + dragonA.time + "ms", width / 2, 20);}',SimplifyBooleanExpressions
'Arrow arrowA;',correct
'PApplet.parseInt(random(width))',correct
'line(dragonX - 15, dragonY, dragonX - 24, dragonY + 37)',correct
'dragonA.display();',correct
'textAlign(CENTER);',correct
'void isDead() {    if (isDeaD == true) {        textAlign(CENTER);        textSize(60);        fill(0);        text("YOU DIED", width / 2, height / 2);        textSize(20);        fill(255, 255, 255);        text("Play again", width / 2, 200);    }}',correct
'int i = 0',correct
'ellipseMode(CENTER);',correct
'fill(200);',correct
'{    dragonX = dragonX - 350;}',correct
'if (cloud1Y == height + 100) {    cloud1Y = -100;    cloud1X = PApplet.parseInt(random(width));}',correct
'quad(x + 6, y, x + 6, y + 6, x + 11, y + 2, x + 11, y - 4)',correct
'dragonY - 90',correct
'time',correct
'dragonA.move(mouseX, mouseY)',correct
'void draw() {    background(0, 100, 150);    frameRate(120);    if (dragonA.isDeaD == true) {        for (int i = 0; i < 100; i++) {            blooddrops[i].display();        }    }    for (int i = 0; i < 100; i++) {        blooddrops[i].clean();    }    Timer();    arrowA.display();    arrowB.display();    arrowC.display();    dragonA.display();    arrowA.hitDragon();    arrowB.hitDragon();    arrowC.hitDragon();    backgroundClouds();    Dragondied();    println(dragonA.fireBreathing);}',correct
'int s = second()',correct
'dragonA.dragonY = -200',correct
'random(-100, 0)',correct
'dragonX - 1',correct
'y = initY;',correct
'dragonX = dragonX - 350;',correct
'if (key == CODED || key != CODED) {    if (keyCode == RIGHT || key == d) {        dragonX = dragonX + dragonSpeed;    } else if (keyCode == LEFT || key == a) {        dragonX = dragonX - dragonSpeed;    } else if (keyCode == UP || key == w) {        dragonY = dragonY - dragonSpeed;    } else if (keyCode == DOWN || key == s) {        dragonY = dragonY + dragonSpeed;    }}',correct
'dragonX - 2',correct
'dragonX - 5',correct
'{    dragonA.dragonSpeed = 0;    arrowA.arrowSpeed = 0;    arrowB.arrowSpeed = 0;    arrowC.arrowSpeed = 0;    cloudspeed1 = 0;    cloudspeed2 = 0;    dragonA.dragonX = -200;    dragonA.dragonY = -200;}',correct
'float arrowSpeed;',correct
'dragon',correct
'ellipse(cloud2X + 40, cloud2Y + 30, 60, 40);',correct
'if (d <= bloodSize && noBlood == false) {    noBlood = true;}',SimplifyBooleanExpressions
'y = random(-50, -100);',correct
'{    background(0, 100, 150);    cloud1X = PApplet.parseInt(random(width));    cloud1Y = 50;    cloud2X = PApplet.parseInt(random(width));    cloud2Y = 130;    cloudspeed1 = 1;    cloudspeed2 = 1;    for (int i = 0; i < 100; i++) {        blooddrops[i] = new Blood(random(width), random(height), 25);    }    dragonA = new Dragon(150, 150, 10);    // Arrows    arrowA = new Arrow(random(width), random(-100, 0), 1.5f, color(200, 0, 0), dragonA);    arrowB = new Arrow(random(width), random(-100, 0), 1.5f, color(0, 0, 200), dragonA);    arrowC = new Arrow(random(width), random(-100, 0), 1.5f, color(0, 200, 0), dragonA);}',correct
'keyCode == LEFT || key == a',correct
'{    dragonX = dragonX - dragonSpeed;}',correct
'dragonY - 65',correct
'x >= dragonX - 10 && x <= dragonX + 35 && y >= dragonY - 35',correct
'cloud1Y = cloud1Y + cloudspeed1;',DrawingStateChangeRule
'dragonY - 60',correct
'y = y + arrowSpeed',correct
'{    noStroke();    if (y >= random(height, height + 150)) {        y = random(-50, -100);        x = random(width);        arrowSpeed = arrowSpeed + 0.2f;    }    fill(130, 120, 120);    rect(x, y, 6, 50);    fill(200);    triangle(x - 3, y + 50, x + 9, y + 50, x + 3, y + 60);    fill(arrowColor);    quad(x, y, x, y + 6, x - 5, y + 2, x - 5, y - 4);    quad(x + 6, y, x + 6, y + 6, x + 11, y + 2, x + 11, y - 4);    y = y + arrowSpeed;}',correct
'triangle(x - 3, y + 50, x + 9, y + 50, x + 3, y + 60);',correct
'ellipse(cloud2X, cloud2Y, 120, 80)',correct
'if (keyCode == DOWN || key == s) {    dragonY = dragonY + dragonSpeed;}',correct
'keyCode == LEFT',correct
'dragonA.dragonSpeed = 0',correct
'fill(255, 255, 255, 0);',correct
'// left wingtriangle(dragonX, dragonY + 30, dragonX - 15, dragonY, dragonX - 45, dragonY + 45);',correct
'triangle(dragonX - 1, dragonY - 15, dragonX + 4, dragonY - 15, dragonX + 1, dragonY - 5);',correct
'fill(179, 191, 209, 230)',correct
'dragonX = initX;',correct
'blooddrops[i].display()',correct
'void clean() {    float d = dist(bloodx, bloody, mouseX, mouseY);    if (d <= bloodSize && noBlood == false) {        noBlood = true;    }}',correct
'dragonA.display()',correct
'fill(130, 120, 120)',correct
'arrowC.arrowSpeed',correct
'arrowC.display();',correct
'fill(255, 200, 0)',correct
'dragonX = dragonX + 400;',correct
'dragonX = initX',correct
'cloud2Y + 30',correct
'key == d',correct
'Blood[]',correct
'arrowC.arrowSpeed = 0',correct
'arrowB.arrowSpeed = 0;',correct
'key == a',correct
'arrowB.arrowSpeed',correct
'd <= bloodSize && noBlood == false',correct
'key == w',correct
'dragonSpeed = initSpeed;',correct
'cloud2Y == height + 60',correct
'key == s',correct
'key == v',correct
'dragonA.fireBreathing = true;',correct
'dragonX = x',correct
'text("YOU DIED", width / 2, height / 2)',correct
'arrowC.display()',correct
'keyCode == RIGHT',correct
'display',correct
'fill(200)',correct
'float dragonX;',correct
'cloud1X = PApplet.parseInt(random(width))',correct
'{    fill(179, 191, 209, 230);    ellipse(cloud1X, cloud1Y, 200, 100);    ellipse(cloud1X + 90, cloud1Y - 60, 180, 90);    cloud1Y = cloud1Y + cloudspeed1;    if (cloud1Y == height + 100) {        cloud1Y = -100;        cloud1X = PApplet.parseInt(random(width));    }    ellipse(cloud2X, cloud2Y, 120, 80);    ellipse(cloud2X - 40, cloud2Y - 40, 80, 60);    ellipse(cloud2X + 40, cloud2Y + 30, 60, 40);    cloud2Y = cloud2Y + cloudspeed2;    if (cloud2Y == height + 60) {        cloud2Y = -60;        cloud2X = PApplet.parseInt(random(width));    }}',correct
'x + 6',correct
'cloud1Y = 50',correct
'x >= dragonX - 10 && x <= dragonX + 35 && y >= dragonY - 35 && y <= dragonY + 150',correct
'fill(99, 155, 85)',correct
'backgroundClouds()',correct
'x + 9',correct
'{    textAlign(CENTER);    text("You survived " + dragonA.time + "ms", width / 2, 20);}',correct
'if (keyCode == UP || key == w) {    dragonY = dragonY - dragonSpeed;} else if (keyCode == DOWN || key == s) {    dragonY = dragonY + dragonSpeed;}',correct
'x + 3',correct
'triangle(dragonX, dragonY + 75, dragonX + 15, dragonY + 75, dragonX + 30, dragonY + 120);',correct
'dragonX + 1',correct
'arrowColor',correct
'dragonX + 3',correct
'dragonX + 2',correct
'dragonX + 5',correct
'dragonX + 4',correct
'float initX',correct
'dragonX + 7',correct
'float initY',correct
'dragonX + 6',correct
'-50',correct
'i++',correct
'arrowSpeed = arrowSpeed + 0.2f',correct
'"You survived " + millis()',correct
'if (dragonX < -50) {    dragonX = dragonX + 400;}',correct
'arrowColor = initColor;',correct
'float dragonY;',correct
'{    fireBreathing = true;}',correct
'color(200, 0, 0)',correct
'cloud2Y + cloudspeed2',correct
'keyCode == DOWN',correct
'triangle(dragonX + 7, dragonY - 30, dragonX + 3, dragonY - 60, dragonX + 12, dragonY - 60)',correct
'new Arrow(random(width), random(-100, 0), 1.5f, color(200, 0, 0), dragonA)',correct
'fill(255, 100, 0)',correct
'-60',correct
'// ArrowsarrowA = new Arrow(random(width), random(-100, 0), 1.5f, color(200, 0, 0), dragonA);',correct
'dragonY = dragonY - dragonSpeed',correct
's % 4',correct
'dragonY - 35',correct
'{    if (key == CODED || key != CODED) {        if (keyCode == RIGHT || key == d) {            dragonX = dragonX + dragonSpeed;        } else if (keyCode == LEFT || key == a) {            dragonX = dragonX - dragonSpeed;        } else if (keyCode == UP || key == w) {            dragonY = dragonY - dragonSpeed;        } else if (keyCode == DOWN || key == s) {            dragonY = dragonY + dragonSpeed;        }    }}',correct
'dragon.hitDragon(x, y)',correct
'ellipse(cloud1X + 90, cloud1Y - 60, 180, 90)',correct
'dragonY - 30',correct
'noBlood == false',correct
'x >= dragonX - 10',correct
'{    triangle(dragonX, dragonY + 75, dragonX + 15, dragonY + 75, dragonX + 30, dragonY + 120);}',correct
'{    noStroke();    fill(209, 67, 35);    ellipseMode(CENTER);    ellipse(bloodx, bloody, bloodSize, bloodSize);}',correct
'{    dragonX = initX;    dragonY = initY;    dragonSpeed = initSpeed;}',correct
'int time;',correct
'text("You survived " + dragonA.time + "ms", width / 2, 20)',correct
'"ms"',correct
'{    dragon.hitDragon(x, y);}',correct
'arrowSpeed + 0.2f',correct
'y + 6',correct
'ellipse(cloud1X, cloud1Y, 200, 100);',correct
'text("You survived " + millis() + "ms", width / 2, 20)',correct
'dragonY - 15',correct
'y + 2',correct
'// tailint s = second();',correct
'x - 5',correct
'x - 3',correct
'width / 2',correct
'void mouseReleased() {    dragonA.fireBreathing = false;}',correct
'dragonY + 75',correct
'{    if (isDeaD == true) {        textAlign(CENTER);        textSize(60);        fill(0);        text("YOU DIED", width / 2, height / 2);        textSize(20);        fill(255, 255, 255);        text("Play again", width / 2, 200);    }}',correct
'void keyPressed() {    dragonA.fly();    dragonA.fire();}',correct
'ellipse(cloud1X, cloud1Y, 200, 100)',correct
'{    fireBreathing = false;}',correct
'koala = new Koala()',correct
'255 - grow * 35',correct
'koalaX < foodies[n].foodX + 25 && koalaX > foodies[n].foodX - 25',correct
'void face() {    // no lines    noStroke();    // grey fill    fill(167, 170, 172);    // square head koala    rect(koalaX, koalaY, 100 + 20 * grow, 100 + 20 * grow, 25);    // ear left koala    ellipse(koalaX - 50 - 10 * grow, koalaY - 40 - 8 * grow, 60 + 20 * grow, 60 + 20 * grow);    // ear right koala    ellipse(koalaX + 50 + 10 * grow, koalaY - 40 - 8 * grow, 60 + 20 * grow, 60 + 20 * grow);    // dark grey fill    fill(88, 88, 90);    // eye left koala    ellipse(koalaX - 20 - 4 * grow, koalaY - 5 - 6 * grow, 10 + 2 * grow, 10 + 2 * grow);    // eye right koala    ellipse(koalaX + 20 + 4 * grow, koalaY - 5 - 6 * grow, 10 + 2 * grow, 10 + 2 * grow);    // nose koala    ellipse(koalaX, koalaY + 5, 25 + 5 * grow, 30 + 6 * grow);    noFill();    // dark grey fill    stroke(88, 88, 90);    // earline left    arc(koalaX - 50 - 10 * grow, koalaY - 40 - 8 * grow, 40 + (13 + (1 / 3)) * grow, 40 + (13 + (1 / 3)) * grow, PI, PI + HALF_PI);    // earline right    arc(koalaX + 50 + 10 * grow, koalaY - 40 - 8 * grow, 40 + (13 + (1 / 3)) * grow, 40 + (13 + (1 / 3)) * grow, PI + HALF_PI, TWO_PI);}',correct
'koalaY - 5',correct
'koala.update()',correct
'count = 0',correct
'koalaX',correct
'AudioPlayer',correct
'koalaY',correct
'new Koala()',correct
'void newPosition() {    // set time to live again to 110    timeToLive = 110;    // change X position of food to random position    foodX = random(100, (width - 100));    // change Y position of food to random position    foodY = random(100, (height - 100));}',correct
'// thickness of linestrokeWeight(5 + grow);',correct
'{    alive = false;}',correct
'// everytime the program draws, the time to live will count 1 down. The framerate will be about 60 frames per second. so in almost two seconds a new position will be given to the foodtimeToLive--;',correct
'count % 5',correct
'// eye right koalaellipse(koalaX + 20 + 4 * grow, koalaY - 5 - 6 * grow, 10 + 2 * grow, 10 + 2 * grow);',correct
'foodies[n].foodX + 25',correct
'float foodY;',correct
'koalaY - 40 - 8 * grow',correct
'75 + grow * 30',correct
'// setting a variable eatdelay to 250 msint eatdelay = 250;',correct
'background(75 + grow * 30, 204 - grow * 33, 255 - grow * 35)',correct
'// grey fillfill(167, 170, 172);',correct
'newPosition();',correct
'foodies = new Food[3]',correct
'foodY = random(100, (height - 100))',correct
'foodies[n].newPosition()',correct
'koala.koalaX = mouseX',correct
'timeToLive--',correct
'[3]',correct
'{    // everytime the program draws, the time to live will count 1 down. The framerate will be about 60 frames per second. so in almost two seconds a new position will be given to the food    timeToLive--;    if (timeToLive == 0) {        newPosition();    }    if (koala.alive) {        // when the koala is allive, it will draw a koala        // gives the colour green        fill(0, 98, 0);        noStroke();        // draws the head of the koala        rect(foodX, foodY, 6, 100, 50);        // leaf on top bovenaan        arc(foodX, foodY - 40, 70, 40, PI + QUARTER_PI, PI + PI - 0.5f);        // leaf 1 left        arc(foodX, foodY - 20, 70, 35, PI + QUARTER_PI, PI + HALF_PI);        // leaf 2 left        arc(foodX, foodY, 65, 30, PI + QUARTER_PI, PI + HALF_PI);        // leaf 3 left        arc(foodX, foodY + 20, 60, 25, PI + QUARTER_PI, PI + HALF_PI);        // leaf 1 right        arc(foodX, foodY - 10, 70, 35, PI + HALF_PI, TWO_PI - QUARTER_PI);        // leaf 2 right        arc(foodX, foodY + 10, 65, 30, PI + HALF_PI, TWO_PI - QUARTER_PI);        // leaf 3 right        arc(foodX, foodY + 30, 60, 25, PI + HALF_PI, TWO_PI - QUARTER_PI);    }}',correct
'{    // if the koala has eaten for longer than the eatdelay, the mouth closes because the boolean eat will return false    eat = false;}',correct
'koala = new Koala();',correct
'koala.koalaX = mouseX;',correct
'// import the minim library// defining a name with which you use the minimMinim minim;',correct
'// when the koala is allive, it will draw a koala',correct
'koala.alive',correct
'if (koala.alive) {    face();    if (eat) {        mouthOpen();    } else {        mouthClosed();    }}',correct
'stroke(88, 88, 90)',correct
'float foodX;',correct
'void setup() {    // creating a new minim thing    minim = new Minim(this);    // creating the eating audio    eating = minim.loadFile("eating.mp3");    // creating the happy audio    happy = minim.loadFile("happy.mp3");    // creating the fat audio    fat = minim.loadFile("fat.mp3");    // playing the happy audio using a loop    happy.loop();    for (int n = 0; n < foodies.length; n++) {        // making sure that this loop goes as many times the food as there are items in the food array. in this case 3 three times        foodies[n] = new Food();    }    koala = new Koala();    // setting the size of the screen    // setting rectangle mode to center    rectMode(CENTER);    // setting the boolean food to false    food = false;}',correct
'koalaX + 50',correct
'timeToLive == 0',correct
'// creating the eating audioeating = minim.loadFile("eating.mp3");',correct
'// setting the size of the screen',correct
'25 + 5 * grow',correct
'arc(foodX, foodY - 20, 70, 35, PI + QUARTER_PI, PI + HALF_PI)',correct
'System.out',correct
'{    // check if food is there    for (int n = 0; n < foodies.length; n++) {        if (koalaX < foodies[n].foodX + 25 && koalaX > foodies[n].foodX - 25 && koalaY < foodies[n].foodY + 25 && koalaY > foodies[n].foodY - 25 && koala.alive == true) {            eating.play();            eating.rewind();            eat = true;            // sets the foodtime to that current time            foodtime = millis();            // gives sets count to count+1            count++;            // gives new position to food            foodies[n].newPosition();            // prints count            System.out.println(count);            if (count % 5 == 0) {                // with using modulo, every 5 times that the koala eats, grow gets one bigger                grow++;                if (grow == 6) {                    alive = false;                }                System.out.println(grow);            }        }    }    if (millis() > foodtime + eatdelay) {        // if the koala has eaten for longer than the eatdelay, the mouth closes because the boolean eat will return false        eat = false;    }}',correct
'// earline leftarc(koalaX - 50 - 10 * grow, koalaY - 40 - 8 * grow, 40 + (13 + (1 / 3)) * grow, 40 + (13 + (1 / 3)) * grow, PI, PI + HALF_PI);',correct
'{    // thickness of line    strokeWeight(5 + grow);    noFill();    // closed mouth left koala    arc(koalaX - 15 - 3 * grow, koalaY + 10 + 5 * grow, 30 + 6 * grow, 30 + 6 * grow, 0, HALF_PI);    // closed mouth right koala    arc(koalaX + 15 + 3 * grow, koalaY + 10 + 5 * grow, 30 + 6 * grow, 30 + 6 * grow, HALF_PI, PI);}',correct
'koalaY < foodies[n].foodY + 25',correct
'koalaX - 15 - 3 * grow',correct
'koalaX < foodies[n].foodX + 25',correct
'{    eating.play();    eating.rewind();    eat = true;    // sets the foodtime to that current time    foodtime = millis();    // gives sets count to count+1    count++;    // gives new position to food    foodies[n].newPosition();    // prints count    System.out.println(count);    if (count % 5 == 0) {        // with using modulo, every 5 times that the koala eats, grow gets one bigger        grow++;        if (grow == 6) {            alive = false;        }        System.out.println(grow);    }}',SimplifyBooleanExpressions
'minim.loadFile("eating.mp3")',correct
'void display() {    if (koala.alive) {        face();        if (eat) {            mouthOpen();        } else {            mouthClosed();        }    }}',correct
'koalaX + 15 + 3 * grow',correct
'n = 0',correct
'// dark grey fillfill(88, 88, 90);',correct
'"You are fat!"',correct
'eatdelay = 250',correct
'{    // set time to live again to 110    timeToLive = 110;    // change X position of food to random position    foodX = random(100, (width - 100));    // change Y position of food to random position    foodY = random(100, (height - 100));}',correct
'fill(0);',correct
'foodY + 10',correct
'// square head koalarect(koalaX, koalaY, 100 + 20 * grow, 100 + 20 * grow, 25);',correct
'n++',correct
'if (count % 5 == 0) {    // with using modulo, every 5 times that the koala eats, grow gets one bigger    grow++;    if (grow == 6) {        alive = false;    }    System.out.println(grow);}',correct
'food = false',correct
'System.out.println(grow);',correct
'Food() {    foodX = random(100, (width - 100));    foodY = random(100, (height - 100));}',correct
'n < foodies.length',correct
'arc(foodX, foodY + 30, 60, 25, PI + HALF_PI, TWO_PI - QUARTER_PI)',correct
'// ear right koalaellipse(koalaX + 50 + 10 * grow, koalaY - 40 - 8 * grow, 60 + 20 * grow, 60 + 20 * grow);',correct
'Food',correct
'rectMode(CENTER)',correct
'// making integer x coordinate koalaint koalaX;',correct
'// earline rightarc(koalaX + 50 + 10 * grow, koalaY - 40 - 8 * grow, 40 + (13 + (1 / 3)) * grow, 40 + (13 + (1 / 3)) * grow, PI + HALF_PI, TWO_PI);',correct
'random(100, (height - 100))',correct
'// with using modulo, every 5 times that the koala eats, grow gets one biggergrow++;',correct
'koala.koalaY = mouseY;',correct
'foodY',correct
'// check if food is therefor (int n = 0; n < foodies.length; n++) {    if (koalaX < foodies[n].foodX + 25 && koalaX > foodies[n].foodX - 25 && koalaY < foodies[n].foodY + 25 && koalaY > foodies[n].foodY - 25 && koala.alive == true) {        eating.play();        eating.rewind();        eat = true;        // sets the foodtime to that current time        foodtime = millis();        // gives sets count to count+1        count++;        // gives new position to food        foodies[n].newPosition();        // prints count        System.out.println(count);        if (count % 5 == 0) {            // with using modulo, every 5 times that the koala eats, grow gets one bigger            grow++;            if (grow == 6) {                alive = false;            }            System.out.println(grow);        }    }}',correct
'foodX',correct
'koalaX - 15',correct
'eating',correct
'eating.rewind();',correct
'food',correct
'foodies[n].display();',correct
'// leaf 3 leftarc(foodX, foodY + 20, 60, 25, PI + QUARTER_PI, PI + HALF_PI);',correct
'PI + PI - 0.5f',correct
'fat = minim.loadFile("fat.mp3")',correct
'arc(koalaX - 15 - 3 * grow, koalaY + 10 + 5 * grow, 30 + 6 * grow, 30 + 6 * grow, 0, HALF_PI)',correct
'face',correct
'// setting the variable grow globally because the background will change with it in the setup just like the koala in the Koala classint grow = 0;',correct
'happy = minim.loadFile("happy.mp3")',correct
'millis()',correct
'fat.play()',correct
'for (int n = 0; n < foodies.length; n++) {    foodies[n].display();}',correct
'fill(167, 170, 172)',correct
'noStroke()',correct
'// change X position of food to random positionfoodX = random(100, (width - 100));',correct
'happy.pause();',correct
'foodY + 30',correct
'foodies[n]',correct
'koalaY + 10',correct
'arc(foodX, foodY + 10, 65, 30, PI + HALF_PI, TWO_PI - QUARTER_PI)',correct
'koalaX < foodies[n].foodX + 25 && koalaX > foodies[n].foodX - 25 && koalaY < foodies[n].foodY + 25 && koalaY > foodies[n].foodY - 25',correct
'foodtime',correct
'alive = false;',correct
'grow * 30',correct
'{    mouthClosed();}',correct
'koalaX = width / 2',correct
'grow * 33',correct
'5 + grow',correct
'koalaY + 5',correct
'fill(0, 98, 0)',correct
'grow * 35',correct
'grow++',correct
'5 * grow',correct
'eat = true',correct
'minim = new Minim(this)',correct
'{    // when the koala is allive, it will draw a koala    // gives the colour green    fill(0, 98, 0);    noStroke();    // draws the head of the koala    rect(foodX, foodY, 6, 100, 50);    // leaf on top bovenaan    arc(foodX, foodY - 40, 70, 40, PI + QUARTER_PI, PI + PI - 0.5f);    // leaf 1 left    arc(foodX, foodY - 20, 70, 35, PI + QUARTER_PI, PI + HALF_PI);    // leaf 2 left    arc(foodX, foodY, 65, 30, PI + QUARTER_PI, PI + HALF_PI);    // leaf 3 left    arc(foodX, foodY + 20, 60, 25, PI + QUARTER_PI, PI + HALF_PI);    // leaf 1 right    arc(foodX, foodY - 10, 70, 35, PI + HALF_PI, TWO_PI - QUARTER_PI);    // leaf 2 right    arc(foodX, foodY + 10, 65, 30, PI + HALF_PI, TWO_PI - QUARTER_PI);    // leaf 3 right    arc(foodX, foodY + 30, 60, 25, PI + HALF_PI, TWO_PI - QUARTER_PI);}',correct
'3 * grow',correct
'6 * grow',correct
'8 * grow',correct
'// set time to live again to 110timeToLive = 110;',correct
'// defining eating as audioAudioPlayer eating;',correct
'{    newPosition();}',correct
'PI + HALF_PI',correct
'count',correct
'this',correct
'koalaX + 15',correct
'// draw the thing thats found in the void display of the koala classkoala.display();',correct
'foodtime + eatdelay',correct
'foodY + 20',correct
'fill(0)',correct
'random(100, (width - 100))',correct
'height / 2',correct
'foodies[n].foodY - 25',correct
'Minim',correct
'// defining koalaXkoalaX = width / 2;',correct
'new Food()',correct
'textAlign(CENTER, BOTTOM);',correct
'koalaY + 25',correct
'eat = false',correct
'koalaY = height / 2',correct
'// making boolean eat and aliveboolean eat, alive;',correct
'void draw() {    // drawing a background which changes when grow gets another value    background(75 + grow * 30, 204 - grow * 33, 255 - grow * 35);    // draw the thing thats found in the void display of the koala class    koala.display();    // draw the thing thats found in the void update of the koala class    koala.update();    for (int n = 0; n < foodies.length; n++) {        foodies[n].display();    }    if (!koala.alive) {        textAlign(CENTER, BOTTOM);        textSize(50);        fill(0);        text("You are fat!", width / 2, height / 2);        happy.pause();        fat.play();    }}',correct
'"eating.mp3"',correct
'foodies[n].foodX',correct
'foodies[n].foodY',correct
'text("You are fat!", width / 2, height / 2)',correct
'minim',correct
'{    foodX = random(100, (width - 100));    foodY = random(100, (height - 100));}',correct
'update',correct
'ellipse(koalaX - 20 - 4 * grow, koalaY - 5 - 6 * grow, 10 + 2 * grow, 10 + 2 * grow)',correct
'{    textAlign(CENTER, BOTTOM);    textSize(50);    fill(0);    text("You are fat!", width / 2, height / 2);    happy.pause();    fat.play();}',correct
'Processing',correct
'foodies[n].foodX - 25',correct
'10 * grow',correct
'// leaf 1 rightarc(foodX, foodY - 10, 70, 35, PI + HALF_PI, TWO_PI - QUARTER_PI);',correct
'{    // with using modulo, every 5 times that the koala eats, grow gets one bigger    grow++;    if (grow == 6) {        alive = false;    }    System.out.println(grow);}',correct
'10 + 2 * grow',correct
'koalaX + 20 + 4 * grow',correct
'koalaX + 20',correct
'minim.loadFile("fat.mp3")',correct
'arc(foodX, foodY, 65, 30, PI + QUARTER_PI, PI + HALF_PI)',correct
'koalaY > foodies[n].foodY - 25',correct
'foodies[n] = new Food()',correct
'if (eat) {    mouthOpen();} else {    mouthClosed();}',correct
'ellipse(koalaX + 20 + 4 * grow, koalaY - 5 - 6 * grow, 10 + 2 * grow, 10 + 2 * grow)',correct
'// creating a new minim thingminim = new Minim(this);',correct
'noFill()',correct
'false',correct
'for (int n = 0; n < foodies.length; n++) {    // making sure that this loop goes as many times the food as there are items in the food array. in this case 3 three times    foodies[n] = new Food();}',correct
'// defining koalaYkoalaY = height / 2;',correct
'setup',correct
'eating.rewind()',correct
'foodY = random(100, (height - 100));',correct
'// making integer countint count;',correct
'class Koala {    // making integer x coordinate koala    int koalaX;    // making integer y coordinate koala    int koalaY;    // making boolean eat and alive    boolean eat, alive;    // making integer count    int count;    Koala() {        // defining koalaX        koalaX = width / 2;        // defining koalaY        koalaY = height / 2;        // setting boolean eat to false        eat = false;        // setting count to 0        count = 0;        // setting boolean alive to true        alive = true;    }    void display() {        if (koala.alive) {            face();            if (eat) {                mouthOpen();            } else {                mouthClosed();            }        }    }    void face() {        // no lines        noStroke();        // grey fill        fill(167, 170, 172);        // square head koala        rect(koalaX, koalaY, 100 + 20 * grow, 100 + 20 * grow, 25);        // ear left koala        ellipse(koalaX - 50 - 10 * grow, koalaY - 40 - 8 * grow, 60 + 20 * grow, 60 + 20 * grow);        // ear right koala        ellipse(koalaX + 50 + 10 * grow, koalaY - 40 - 8 * grow, 60 + 20 * grow, 60 + 20 * grow);        // dark grey fill        fill(88, 88, 90);        // eye left koala        ellipse(koalaX - 20 - 4 * grow, koalaY - 5 - 6 * grow, 10 + 2 * grow, 10 + 2 * grow);        // eye right koala        ellipse(koalaX + 20 + 4 * grow, koalaY - 5 - 6 * grow, 10 + 2 * grow, 10 + 2 * grow);        // nose koala        ellipse(koalaX, koalaY + 5, 25 + 5 * grow, 30 + 6 * grow);        noFill();        // dark grey fill        stroke(88, 88, 90);        // earline left        arc(koalaX - 50 - 10 * grow, koalaY - 40 - 8 * grow, 40 + (13 + (1 / 3)) * grow, 40 + (13 + (1 / 3)) * grow, PI, PI + HALF_PI);        // earline right        arc(koalaX + 50 + 10 * grow, koalaY - 40 - 8 * grow, 40 + (13 + (1 / 3)) * grow, 40 + (13 + (1 / 3)) * grow, PI + HALF_PI, TWO_PI);    }    void mouthClosed() {        // thickness of line        strokeWeight(5 + grow);        noFill();        // closed mouth left koala        arc(koalaX - 15 - 3 * grow, koalaY + 10 + 5 * grow, 30 + 6 * grow, 30 + 6 * grow, 0, HALF_PI);        // closed mouth right koala        arc(koalaX + 15 + 3 * grow, koalaY + 10 + 5 * grow, 30 + 6 * grow, 30 + 6 * grow, HALF_PI, PI);    }    void mouthOpen() {        // open mouth koala        ellipse(koalaX, koalaY + 25 + 5 * grow, 30 + 6 * grow, 20 + 4 * grow);    }    void update() {        // check if food is there        for (int n = 0; n < foodies.length; n++) {            if (koalaX < foodies[n].foodX + 25 && koalaX > foodies[n].foodX - 25 && koalaY < foodies[n].foodY + 25 && koalaY > foodies[n].foodY - 25 && koala.alive == true) {                eating.play();                eating.rewind();                eat = true;                // sets the foodtime to that current time                foodtime = millis();                // gives sets count to count+1                count++;                // gives new position to food                foodies[n].newPosition();                // prints count                System.out.println(count);                if (count % 5 == 0) {                    // with using modulo, every 5 times that the koala eats, grow gets one bigger                    grow++;                    if (grow == 6) {                        alive = false;                    }                    System.out.println(grow);                }            }        }        if (millis() > foodtime + eatdelay) {            // if the koala has eaten for longer than the eatdelay, the mouth closes because the boolean eat will return false            eat = false;        }    }}',correct
'Koala() {    // defining koalaX    koalaX = width / 2;    // defining koalaY    koalaY = height / 2;    // setting boolean eat to false    eat = false;    // setting count to 0    count = 0;    // setting boolean alive to true    alive = true;}',correct
'ellipse(koalaX, koalaY + 25 + 5 * grow, 30 + 6 * grow, 20 + 4 * grow)',correct
'foodies[n].foodY + 25',correct
'happy.pause()',correct
'// drawing a background which changes when grow gets another valuebackground(75 + grow * 30, 204 - grow * 33, 255 - grow * 35);',correct
'happy',correct
'// leaf 2 rightarc(foodX, foodY + 10, 65, 30, PI + HALF_PI, TWO_PI - QUARTER_PI);',correct
'// defining the Koala class in the koala documentKoala koala;',correct
'if (millis() > foodtime + eatdelay) {    // if the koala has eaten for longer than the eatdelay, the mouth closes because the boolean eat will return false    eat = false;}',correct
'koala.koalaY',correct
'foodY - 10',correct
'koala.koalaX',correct
'// using long because its/can be a big number, foodtime will be used as the time when the koala eatslong foodtime;',correct
'System.out.println(mouseY)',correct
'koala.display()',correct
'koalaY + 25 + 5 * grow',correct
'fat',correct
'{    foodies[n].display();}',correct
'arc(koalaX + 50 + 10 * grow, koalaY - 40 - 8 * grow, 40 + (13 + (1 / 3)) * grow, 40 + (13 + (1 / 3)) * grow, PI + HALF_PI, TWO_PI)',correct
'System.out.println(grow)',correct
'// making integer y coordinate koalaint koalaY;',correct
'koalaX > foodies[n].foodX - 25',correct
'strokeWeight(5 + grow)',correct
'rect(foodX, foodY, 6, 100, 50)',correct
'textAlign(CENTER, BOTTOM)',correct
'if (grow == 6) {    alive = false;}',correct
'TWO_PI - QUARTER_PI',correct
'// creating the fat audiofat = minim.loadFile("fat.mp3");',correct
'{    face();    if (eat) {        mouthOpen();    } else {        mouthClosed();    }}',correct
'fat.play();',correct
'// prints countSystem.out.println(count);',correct
'grow == 6',correct
'// closed mouth left koalaarc(koalaX - 15 - 3 * grow, koalaY + 10 + 5 * grow, 30 + 6 * grow, 30 + 6 * grow, 0, HALF_PI);',correct
'int n = 0',correct
'foodtime = millis()',correct
'foodX = random(100, (width - 100));',correct
'noStroke();',correct
'40 + (13 + (1 / 3)) * grow',correct
'ellipse(koalaX + 50 + 10 * grow, koalaY - 40 - 8 * grow, 60 + 20 * grow, 60 + 20 * grow)',correct
'arc(koalaX + 15 + 3 * grow, koalaY + 10 + 5 * grow, 30 + 6 * grow, 30 + 6 * grow, HALF_PI, PI)',correct
'mouthClosed()',correct
'int timeToLive = 110;',correct
'{    if (koalaX < foodies[n].foodX + 25 && koalaX > foodies[n].foodX - 25 && koalaY < foodies[n].foodY + 25 && koalaY > foodies[n].foodY - 25 && koala.alive == true) {        eating.play();        eating.rewind();        eat = true;        // sets the foodtime to that current time        foodtime = millis();        // gives sets count to count+1        count++;        // gives new position to food        foodies[n].newPosition();        // prints count        System.out.println(count);        if (count % 5 == 0) {            // with using modulo, every 5 times that the koala eats, grow gets one bigger            grow++;            if (grow == 6) {                alive = false;            }            System.out.println(grow);        }    }}',correct
'happy.loop()',correct
'face();',correct
'rect(koalaX, koalaY, 100 + 20 * grow, 100 + 20 * grow, 25)',correct
'// setting the boolean food to falsefood = false;',correct
'// gives new position to foodfoodies[n].newPosition();',correct
'(13 + (1 / 3)) * grow',correct
'alive',correct
'ellipse(koalaX - 50 - 10 * grow, koalaY - 40 - 8 * grow, 60 + 20 * grow, 60 + 20 * grow)',correct
'mouthOpen()',correct
'eating.play()',correct
'eat = true;',correct
'// ear left koalaellipse(koalaX - 50 - 10 * grow, koalaY - 40 - 8 * grow, 60 + 20 * grow, 60 + 20 * grow);',correct
'// nose koalaellipse(koalaX, koalaY + 5, 25 + 5 * grow, 30 + 6 * grow);',correct
'{    // no lines    noStroke();    // grey fill    fill(167, 170, 172);    // square head koala    rect(koalaX, koalaY, 100 + 20 * grow, 100 + 20 * grow, 25);    // ear left koala    ellipse(koalaX - 50 - 10 * grow, koalaY - 40 - 8 * grow, 60 + 20 * grow, 60 + 20 * grow);    // ear right koala    ellipse(koalaX + 50 + 10 * grow, koalaY - 40 - 8 * grow, 60 + 20 * grow, 60 + 20 * grow);    // dark grey fill    fill(88, 88, 90);    // eye left koala    ellipse(koalaX - 20 - 4 * grow, koalaY - 5 - 6 * grow, 10 + 2 * grow, 10 + 2 * grow);    // eye right koala    ellipse(koalaX + 20 + 4 * grow, koalaY - 5 - 6 * grow, 10 + 2 * grow, 10 + 2 * grow);    // nose koala    ellipse(koalaX, koalaY + 5, 25 + 5 * grow, 30 + 6 * grow);    noFill();    // dark grey fill    stroke(88, 88, 90);    // earline left    arc(koalaX - 50 - 10 * grow, koalaY - 40 - 8 * grow, 40 + (13 + (1 / 3)) * grow, 40 + (13 + (1 / 3)) * grow, PI, PI + HALF_PI);    // earline right    arc(koalaX + 50 + 10 * grow, koalaY - 40 - 8 * grow, 40 + (13 + (1 / 3)) * grow, 40 + (13 + (1 / 3)) * grow, PI + HALF_PI, TWO_PI);}',correct
'if (timeToLive == 0) {    newPosition();}',correct
'arc(foodX, foodY - 40, 70, 40, PI + QUARTER_PI, PI + PI - 0.5f)',correct
'{    mouthOpen();}',correct
'204 - grow * 33',correct
'// leaf 2 leftarc(foodX, foodY, 65, 30, PI + QUARTER_PI, PI + HALF_PI);',correct
'{    koala.koalaX = mouseX;    koala.koalaY = mouseY;}',correct
'!koala.alive',correct
'eat',correct
'0.5f',correct
'// setting boolean eat to falseeat = false;',correct
'void mouthClosed() {    // thickness of line    strokeWeight(5 + grow);    noFill();    // closed mouth left koala    arc(koalaX - 15 - 3 * grow, koalaY + 10 + 5 * grow, 30 + 6 * grow, 30 + 6 * grow, 0, HALF_PI);    // closed mouth right koala    arc(koalaX + 15 + 3 * grow, koalaY + 10 + 5 * grow, 30 + 6 * grow, 30 + 6 * grow, HALF_PI, PI);}',correct
'void update() {    // check if food is there    for (int n = 0; n < foodies.length; n++) {        if (koalaX < foodies[n].foodX + 25 && koalaX > foodies[n].foodX - 25 && koalaY < foodies[n].foodY + 25 && koalaY > foodies[n].foodY - 25 && koala.alive == true) {            eating.play();            eating.rewind();            eat = true;            // sets the foodtime to that current time            foodtime = millis();            // gives sets count to count+1            count++;            // gives new position to food            foodies[n].newPosition();            // prints count            System.out.println(count);            if (count % 5 == 0) {                // with using modulo, every 5 times that the koala eats, grow gets one bigger                grow++;                if (grow == 6) {                    alive = false;                }                System.out.println(grow);            }        }    }    if (millis() > foodtime + eatdelay) {        // if the koala has eaten for longer than the eatdelay, the mouth closes because the boolean eat will return false        eat = false;    }}',correct
'alive = true',correct
'mouthOpen',correct
'// leaf on top bovenaanarc(foodX, foodY - 40, 70, 40, PI + QUARTER_PI, PI + PI - 0.5f);',correct
'eating = minim.loadFile("eating.mp3")',correct
'display',correct
'foodies[n].display()',correct
'arc(foodX, foodY + 20, 60, 25, PI + QUARTER_PI, PI + HALF_PI)',correct
'draw',correct
'koalaY + 10 + 5 * grow',correct
'// change Y position of food to random positionfoodY = random(100, (height - 100));',correct
'foodY - 20',correct
'void mouthOpen() {    // open mouth koala    ellipse(koalaX, koalaY + 25 + 5 * grow, 30 + 6 * grow, 20 + 4 * grow);}',correct
'// gives sets count to count+1count++;',correct
'60 + 20 * grow',correct
'{    // creating a new minim thing    minim = new Minim(this);    // creating the eating audio    eating = minim.loadFile("eating.mp3");    // creating the happy audio    happy = minim.loadFile("happy.mp3");    // creating the fat audio    fat = minim.loadFile("fat.mp3");    // playing the happy audio using a loop    happy.loop();    for (int n = 0; n < foodies.length; n++) {        // making sure that this loop goes as many times the food as there are items in the food array. in this case 3 three times        foodies[n] = new Food();    }    koala = new Koala();    // setting the size of the screen    // setting rectangle mode to center    rectMode(CENTER);    // setting the boolean food to false    food = false;}',correct
'System.out.println(mouseX)',correct
'// setting count to 0count = 0;',correct
'newPosition()',correct
'void mousePressed() {    // zorgt ervoor dat wanneer je op een punt klikt, de X positie geprint wordt    System.out.println(mouseX);    // zorgt ervoor dat wanneer je op een punt klikt, de Y positie geprint wordt    System.out.println(mouseY);}',correct
'count % 5 == 0',correct
'foodX = random(100, (width - 100))',correct
'foodies.length',correct
'arc(koalaX - 50 - 10 * grow, koalaY - 40 - 8 * grow, 40 + (13 + (1 / 3)) * grow, 40 + (13 + (1 / 3)) * grow, PI, PI + HALF_PI)',correct
'// defining happy as audioAudioPlayer happy;',correct
'// creating the happy audiohappy = minim.loadFile("happy.mp3");',correct
'void display() {    // everytime the program draws, the time to live will count 1 down. The framerate will be about 60 frames per second. so in almost two seconds a new position will be given to the food    timeToLive--;    if (timeToLive == 0) {        newPosition();    }    if (koala.alive) {        // when the koala is allive, it will draw a koala        // gives the colour green        fill(0, 98, 0);        noStroke();        // draws the head of the koala        rect(foodX, foodY, 6, 100, 50);        // leaf on top bovenaan        arc(foodX, foodY - 40, 70, 40, PI + QUARTER_PI, PI + PI - 0.5f);        // leaf 1 left        arc(foodX, foodY - 20, 70, 35, PI + QUARTER_PI, PI + HALF_PI);        // leaf 2 left        arc(foodX, foodY, 65, 30, PI + QUARTER_PI, PI + HALF_PI);        // leaf 3 left        arc(foodX, foodY + 20, 60, 25, PI + QUARTER_PI, PI + HALF_PI);        // leaf 1 right        arc(foodX, foodY - 10, 70, 35, PI + HALF_PI, TWO_PI - QUARTER_PI);        // leaf 2 right        arc(foodX, foodY + 10, 65, 30, PI + HALF_PI, TWO_PI - QUARTER_PI);        // leaf 3 right        arc(foodX, foodY + 30, 60, 25, PI + HALF_PI, TWO_PI - QUARTER_PI);    }}',correct
'alive = false',correct
'// leaf 1 leftarc(foodX, foodY - 20, 70, 35, PI + QUARTER_PI, PI + HALF_PI);',correct
'face()',correct
'PI + PI',correct
'mousePressed',correct
'// eye left koalaellipse(koalaX - 20 - 4 * grow, koalaY - 5 - 6 * grow, 10 + 2 * grow, 10 + 2 * grow);',correct
'koalaX - 20',correct
'newPosition',correct
'new Minim(this)',correct
'2 * grow',correct
'4 * grow',correct
'20 * grow',correct
'mouthClosed',correct
'// draws the head of the koalarect(foodX, foodY, 6, 100, 50);',correct
'PI + QUARTER_PI',correct
'30 + 6 * grow',correct
'void',correct
'Food[]',correct
'// defining the array of the Food classFood[] foodies = new Food[3];',correct
'grow = 0',correct
'koala',correct
'koalaY - 40',correct
'koalaX < foodies[n].foodX + 25 && koalaX > foodies[n].foodX - 25 && koalaY < foodies[n].foodY + 25 && koalaY > foodies[n].foodY - 25 && koala.alive == true',correct
'20 + 4 * grow',correct
'foodY - 40',correct
'// defining the boolean food for if the koala is eating (true or false)boolean food;',correct
'"fat.mp3"',correct
'void mouseMoved() {    koala.koalaX = mouseX;    koala.koalaY = mouseY;}',correct
'// draw the thing thats found in the void update of the koala classkoala.update();',correct
'"happy.mp3"',correct
'{    if (koala.alive) {        face();        if (eat) {            mouthOpen();        } else {            mouthClosed();        }    }}',correct
'noFill();',correct
'count++',correct
'true',correct
'arc(foodX, foodY - 10, 70, 35, PI + HALF_PI, TWO_PI - QUARTER_PI)',correct
'// playing the happy audio using a loophappy.loop();',correct
'new Food[3]',correct
'minim.loadFile("happy.mp3")',correct
'// dark grey fillstroke(88, 88, 90);',correct
'{    // defining koalaX    koalaX = width / 2;    // defining koalaY    koalaY = height / 2;    // setting boolean eat to false    eat = false;    // setting count to 0    count = 0;    // setting boolean alive to true    alive = true;}',correct
'System.out.println(count)',correct
'koalaX - 50 - 10 * grow',correct
'Koala',correct
'// defining fat as audioAudioPlayer fat;',correct
'koala.koalaY = mouseY',correct
'koalaX - 20 - 4 * grow',correct
'mouthOpen();',correct
'// no linesnoStroke();',correct
'eating.play();',correct
'koala.alive == true',correct
'if (koala.alive) {    // when the koala is allive, it will draw a koala    // gives the colour green    fill(0, 98, 0);    noStroke();    // draws the head of the koala    rect(foodX, foodY, 6, 100, 50);    // leaf on top bovenaan    arc(foodX, foodY - 40, 70, 40, PI + QUARTER_PI, PI + PI - 0.5f);    // leaf 1 left    arc(foodX, foodY - 20, 70, 35, PI + QUARTER_PI, PI + HALF_PI);    // leaf 2 left    arc(foodX, foodY, 65, 30, PI + QUARTER_PI, PI + HALF_PI);    // leaf 3 left    arc(foodX, foodY + 20, 60, 25, PI + QUARTER_PI, PI + HALF_PI);    // leaf 1 right    arc(foodX, foodY - 10, 70, 35, PI + HALF_PI, TWO_PI - QUARTER_PI);    // leaf 2 right    arc(foodX, foodY + 10, 65, 30, PI + HALF_PI, TWO_PI - QUARTER_PI);    // leaf 3 right    arc(foodX, foodY + 30, 60, 25, PI + HALF_PI, TWO_PI - QUARTER_PI);}',correct
'{    // making sure that this loop goes as many times the food as there are items in the food array. in this case 3 three times    foodies[n] = new Food();}',correct
'// setting the size of the screen// setting rectangle mode to centerrectMode(CENTER);',correct
'// leaf 3 rightarc(foodX, foodY + 30, 60, 25, PI + HALF_PI, TWO_PI - QUARTER_PI);',correct
'// setting boolean alive to truealive = true;',correct
'{    // drawing a background which changes when grow gets another value    background(75 + grow * 30, 204 - grow * 33, 255 - grow * 35);    // draw the thing thats found in the void display of the koala class    koala.display();    // draw the thing thats found in the void update of the koala class    koala.update();    for (int n = 0; n < foodies.length; n++) {        foodies[n].display();    }    if (!koala.alive) {        textAlign(CENTER, BOTTOM);        textSize(50);        fill(0);        text("You are fat!", width / 2, height / 2);        happy.pause();        fat.play();    }}',correct
'koalaX < foodies[n].foodX + 25 && koalaX > foodies[n].foodX - 25 && koalaY < foodies[n].foodY + 25',correct
'if (!koala.alive) {    textAlign(CENTER, BOTTOM);    textSize(50);    fill(0);    text("You are fat!", width / 2, height / 2);    happy.pause();    fat.play();}',correct
'ellipse(koalaX, koalaY + 5, 25 + 5 * grow, 30 + 6 * grow)',correct
'{    // open mouth koala    ellipse(koalaX, koalaY + 25 + 5 * grow, 30 + 6 * grow, 20 + 4 * grow);}',correct
'class Food {    float foodX;    float foodY;    int timeToLive = 110;    Food() {        foodX = random(100, (width - 100));        foodY = random(100, (height - 100));    }    void display() {        // everytime the program draws, the time to live will count 1 down. The framerate will be about 60 frames per second. so in almost two seconds a new position will be given to the food        timeToLive--;        if (timeToLive == 0) {            newPosition();        }        if (koala.alive) {            // when the koala is allive, it will draw a koala            // gives the colour green            fill(0, 98, 0);            noStroke();            // draws the head of the koala            rect(foodX, foodY, 6, 100, 50);            // leaf on top bovenaan            arc(foodX, foodY - 40, 70, 40, PI + QUARTER_PI, PI + PI - 0.5f);            // leaf 1 left            arc(foodX, foodY - 20, 70, 35, PI + QUARTER_PI, PI + HALF_PI);            // leaf 2 left            arc(foodX, foodY, 65, 30, PI + QUARTER_PI, PI + HALF_PI);            // leaf 3 left            arc(foodX, foodY + 20, 60, 25, PI + QUARTER_PI, PI + HALF_PI);            // leaf 1 right            arc(foodX, foodY - 10, 70, 35, PI + HALF_PI, TWO_PI - QUARTER_PI);            // leaf 2 right            arc(foodX, foodY + 10, 65, 30, PI + HALF_PI, TWO_PI - QUARTER_PI);            // leaf 3 right            arc(foodX, foodY + 30, 60, 25, PI + HALF_PI, TWO_PI - QUARTER_PI);        }    }    void newPosition() {        // set time to live again to 110        timeToLive = 110;        // change X position of food to random position        foodX = random(100, (width - 100));        // change Y position of food to random position        foodY = random(100, (height - 100));    }}',correct
'100 + 20 * grow',correct
'// when the koala is allive, it will draw a koala// gives the colour greenfill(0, 98, 0);',correct
'// import the minim library',correct
'// sets the foodtime to that current timefoodtime = millis();',correct
'koalaX + 50 + 10 * grow',correct
'{    // zorgt ervoor dat wanneer je op een punt klikt, de X positie geprint wordt    System.out.println(mouseX);    // zorgt ervoor dat wanneer je op een punt klikt, de Y positie geprint wordt    System.out.println(mouseY);}',correct
'koalaY - 5 - 6 * grow',correct
'timeToLive = 110',correct
'koalaX - 50',correct
'// zorgt ervoor dat wanneer je op een punt klikt, de Y positie geprint wordtSystem.out.println(mouseY);',correct
'width / 2',correct
'millis() > foodtime + eatdelay',correct
'// closed mouth right koalaarc(koalaX + 15 + 3 * grow, koalaY + 10 + 5 * grow, 30 + 6 * grow, 30 + 6 * grow, HALF_PI, PI);',correct
'// zorgt ervoor dat wanneer je op een punt klikt, de X positie geprint wordtSystem.out.println(mouseX);',correct
'mouthClosed();',correct
'fill(88, 88, 90)',correct
'textSize(50);',correct
'textSize(50)',correct
'text("You are fat!", width / 2, height / 2);',correct
'background(b1)',correct
'void draw() {    // Pink background or blue background    if (mouseX < width / 3) {        background(b1);    } else {        background(b2);    }    // display creature    cup.run();}',correct
'height / 2.63f',correct
'height / 6.09f',correct
'mouseDragged',correct
'width / 11',correct
'x = initX;',correct
'{    background(b2);}',DecentralizedEventHandlingRule
'// text for creaturecup.say();',correct
'String',correct
'isPressed == true',SimplifyBooleanExpressions
'background(b1);',correct
'fill(190, 190, 190)',correct
'ellipse(x + width / 14.29f, y - height / 14.29f, width / 40, height / 20);',correct
'x + width / 11 * i',correct
'line(x + width / 25, y - height / 12.5f, x + width / 12.5f, y - height / 10);',correct
'width / 5.68f',correct
'x + width / 11',correct
'2.5f',correct
'{    // isPressed is true, then the textsize place and colour change    if (isPressed == true) {        textSize(width / 22);        textAlign(CENTER, CENTER);        fill(255);        // this changes the place, x and y and also text starts in middle usually, now more to the left        for (int i = 0; i < smoke.length; i++) {            text(smoke[i], x + width / 11 * i - width / 11, y - height / 4);        }    }}',correct
'ellipse(x - width / 14.9f, y - height / 18, width / 80, height / 60)',correct
'background(b2)',correct
'y - height / 50',correct
'width / 25',correct
'{    textSize(width / 22);    textAlign(CENTER, CENTER);    fill(255);    // this changes the place, x and y and also text starts in middle usually, now more to the left    for (int i = 0; i < smoke.length; i++) {        text(smoke[i], x + width / 11 * i - width / 11, y - height / 4);    }}',SimplifyBooleanExpressions
'// Pink background or blue backgroundif (mouseX < width / 3) {    background(b1);} else {    background(b2);}',correct
'smoke();',correct
'arc(x + width / 5.88f, y - height / 10, width / 16.66f, height / 12.5f, -3, 3, CHORD)',correct
'ellipse(x, y, width / 5, height / 12.5f)',correct
'[3]',correct
'println("Do you think Im hot?")',correct
'width / 22',correct
'width / 20',correct
'// width and height',correct
'{    fill(b1);    arc(x + width / 5.88f, y - height / 10, width / 16.66f, height / 12.5f, -3, 3, CHORD);}',DecentralizedEventHandlingRule
'String[] smoke = new String[3];',AvoidFieldNameMatchingMethodName
'width / 14.29f',correct
'// draw circles under cupfill(211, 211, 211);',correct
'14.9f',correct
'// coffeeellipse(x, y - height / 6.25f, width / 3.33f, height / 14.7f);',correct
'x + width / 25',correct
'14.29f',correct
'arc(x + width / 5.68f, y - height / 10, width / 12.5f, height / 10, -3, 3, OPEN)',correct
'y = pmouseY',correct
'new Koffie(width / 2, height / 2)',correct
'faceH',correct
'"Do you think Im hot?"',correct
'// move the cupx = pmouseX;',correct
'void mouseDragged() {    // creature movement    cup.move();}',correct
'x = initX',correct
'13.9f',correct
'boolean isPressed = false;',correct
'void smoke() {    // isPressed is true, then the textsize place and colour change    if (isPressed == true) {        textSize(width / 22);        textAlign(CENTER, CENTER);        fill(255);        // this changes the place, x and y and also text starts in middle usually, now more to the left        for (int i = 0; i < smoke.length; i++) {            text(smoke[i], x + width / 11 * i - width / 11, y - height / 4);        }    }}',correct
'// display creaturecup.run();',correct
'faceN',correct
'color(70, 130, 180)',correct
'width / 100',correct
'void faceH() {    // if isPressed is true the face becomes cute, this is when the mouse is pressed    if (isPressed == true) {        // eyes        fill(0);        ellipse(x - width / 14.29f, y - height / 14.29f, width / 40, height / 20);        ellipse(x + width / 14.29f, y - height / 14.29f, width / 40, height / 20);        fill(255);        // left sparkle        ellipse(x - width / 13.9f, y - height / 12, width / 80, height / 60);        ellipse(x - width / 14.9f, y - height / 18, width / 80, height / 60);        // right sparkle        ellipse(x + width / 14.9f, y - height / 12, width / 80, height / 60);        ellipse(x + width / 13.9f, y - height / 18, width / 80, height / 60);        // blush        fill(220, 20, 60);        ellipse(x - width / 11, y - height / 30, width / 80, height / 60);        ellipse(x + width / 11, y - height / 30, width / 80, height / 60);        // mouth        fill(220, 90, 90);        arc(x, y - height / 50, width / 30, height / 20, 0, PI, CHORD);    }}',correct
'x + width / 13.9f',correct
'rectMode(CENTER)',correct
'arc(x + width / 5.88f, y - height / 10, width / 16.66f, height / 12.5f, -3, 3, CHORD);',correct
'y - height / 6.25f',correct
'arc(x, y - height / 6.25f, width / 3.33f, height / 2.63f, 0, PI, OPEN)',correct
'cup.say()',correct
'fill(b1);',correct
'text(smoke[i], x + width / 11 * i - width / 11, y - height / 4)',correct
'// blushfill(220, 20, 60);',correct
'{    // draw circles under cup    fill(211, 211, 211);    ellipse(x, y, width / 2.5f, height / 6.25f);    fill(190, 190, 190);    ellipse(x, y, width / 5, height / 12.5f);    // draw cup    arc(x, y - height / 6.25f, width / 3.33f, height / 2.63f, 0, PI, OPEN);    ellipse(x, y - height / 6.09f, width / 3.33f, height / 12.5f);    // brown coffee colour    fill(139, 69, 19);    // coffee    ellipse(x, y - height / 6.25f, width / 3.33f, height / 14.7f);    // coffee handle    fill(190, 190, 190);    arc(x + width / 5.68f, y - height / 10, width / 12.5f, height / 10, -3, 3, OPEN);    // colour inside coffee handle(background)    if (mouseX < width / 3) {        fill(b1);        arc(x + width / 5.88f, y - height / 10, width / 16.66f, height / 12.5f, -3, 3, CHORD);    } else {        fill(b2);        arc(x + width / 5.88f, y - height / 10, width / 16.66f, height / 12.5f, -3, 3, CHORD);    }}',correct
'b1 = color(199, 21, 133)',correct
'// colour inside coffee handle(background)if (mouseX < width / 3) {    fill(b1);    arc(x + width / 5.88f, y - height / 10, width / 16.66f, height / 12.5f, -3, 3, CHORD);} else {    fill(b2);    arc(x + width / 5.88f, y - height / 10, width / 16.66f, height / 12.5f, -3, 3, CHORD);}',correct
'{    // alles runnen    display();    smoke();    faceN();    faceH();}',correct
'14.7f',correct
'smoke[i] = "S"',correct
'x',correct
'y',correct
'faceH();',correct
'{    // width and height    // everything starts in the center    rectMode(CENTER);    ellipseMode(CENTER);    // class    cup = new Koffie(width / 2, height / 2);}',correct
'textSize(width / 22);',correct
'fill(b2)',correct
'void faceN() {    // if isPressed is false the face becomes normal, this is when the mouse is released    if (isPressed == false) {        // face        // eyebrows        line(x - width / 11.11f, y - height / 10, x - width / 20, y - height / 12.5f);        line(x + width / 25, y - height / 12.5f, x + width / 12.5f, y - height / 10);        // eyes        fill(0);        ellipse(x - width / 14.29f, y - height / 14.29f, width / 100, height / 100);        ellipse(x + width / 14.29f, y - height / 14.29f, width / 100, height / 100);        // mouth        line(x - width / 33.33f, y - height / 50, x + width / 25, y - height / 50);    }}',correct
'ellipse(x, y, width / 2.5f, height / 6.25f)',correct
'run',correct
'{    text(smoke[i], x + width / 11 * i - width / 11, y - height / 4);}',correct
'ellipse(x + width / 14.29f, y - height / 14.29f, width / 100, height / 100);',correct
'line(x + width / 25, y - height / 12.5f, x + width / 12.5f, y - height / 10)',correct
'x - width / 20',correct
'33.33f',correct
'x - width / 13.9f',correct
'fill(b1)',correct
'width / 11 * i',correct
'y - height / 10',correct
'ellipse(x + width / 13.9f, y - height / 18, width / 80, height / 60);',correct
'x - width / 11',correct
'faceN()',correct
'fill(0)',correct
'height / 2',correct
'// right sparkleellipse(x + width / 14.9f, y - height / 12, width / 80, height / 60);',correct
'void display() {    // draw circles under cup    fill(211, 211, 211);    ellipse(x, y, width / 2.5f, height / 6.25f);    fill(190, 190, 190);    ellipse(x, y, width / 5, height / 12.5f);    // draw cup    arc(x, y - height / 6.25f, width / 3.33f, height / 2.63f, 0, PI, OPEN);    ellipse(x, y - height / 6.09f, width / 3.33f, height / 12.5f);    // brown coffee colour    fill(139, 69, 19);    // coffee    ellipse(x, y - height / 6.25f, width / 3.33f, height / 14.7f);    // coffee handle    fill(190, 190, 190);    arc(x + width / 5.68f, y - height / 10, width / 12.5f, height / 10, -3, 3, OPEN);    // colour inside coffee handle(background)    if (mouseX < width / 3) {        fill(b1);        arc(x + width / 5.88f, y - height / 10, width / 16.66f, height / 12.5f, -3, 3, CHORD);    } else {        fill(b2);        arc(x + width / 5.88f, y - height / 10, width / 16.66f, height / 12.5f, -3, 3, CHORD);    }}',correct
'height / 4',correct
'y = pmouseY;',correct
'void mousePressed() {    // text for creature    cup.say();    cup.isPressed = true;}',correct
'y - height / 12',correct
'ellipse(x - width / 14.29f, y - height / 14.29f, width / 40, height / 20)',correct
'y - height / 18',correct
'// draw cuparc(x, y - height / 6.25f, width / 3.33f, height / 2.63f, 0, PI, OPEN);',correct
'i < smoke.length',correct
'void run() {    // alles runnen    display();    smoke();    faceN();    faceH();}',correct
'arc(x, y - height / 50, width / 30, height / 20, 0, PI, CHORD)',correct
'height / 12.5f',correct
'float x;',correct
'fill(255)',correct
'6.09f',correct
'ellipse(x - width / 11, y - height / 30, width / 80, height / 60)',correct
'width / 12.5f',correct
'Processing',correct
'isPressed == false',SimplifyBooleanExpressions
'cup.isPressed = false;',correct
'{    x = initX;    y = initY;    // 3 strings, letter "S"    for (int i = 0; i < smoke.length; i++) {        smoke[i] = "S";    }}',correct
'height / 14.29f',correct
'ellipse(x, y - height / 6.09f, width / 3.33f, height / 12.5f);',correct
'ellipse(x + width / 14.29f, y - height / 14.29f, width / 40, height / 20)',correct
'new String[3]',correct
'ellipse(x - width / 11, y - height / 30, width / 80, height / 60);',correct
'x + width / 5.68f',correct
'y - height / 30',correct
'// this changes the place, x and y and also text starts in middle usually, now more to the leftfor (int i = 0; i < smoke.length; i++) {    text(smoke[i], x + width / 11 * i - width / 11, y - height / 4);}',correct
'y - height / 14.29f',correct
'false',correct
'float y;',correct
'ellipse(x - width / 14.29f, y - height / 14.29f, width / 40, height / 20);',correct
'{    // face    // eyebrows    line(x - width / 11.11f, y - height / 10, x - width / 20, y - height / 12.5f);    line(x + width / 25, y - height / 12.5f, x + width / 12.5f, y - height / 10);    // eyes    fill(0);    ellipse(x - width / 14.29f, y - height / 14.29f, width / 100, height / 100);    ellipse(x + width / 14.29f, y - height / 14.29f, width / 100, height / 100);    // mouth    line(x - width / 33.33f, y - height / 50, x + width / 25, y - height / 50);}',SimplifyBooleanExpressions
'// left sparkleellipse(x - width / 13.9f, y - height / 12, width / 80, height / 60);',correct
'x - width / 11.11f',correct
'16.66f',correct
'int i = 0',correct
'ellipseMode(CENTER);',correct
'ellipse(x - width / 13.9f, y - height / 12, width / 80, height / 60)',correct
'text(smoke[i], x + width / 11 * i - width / 11, y - height / 4);',correct
'void setup() {    // width and height    // everything starts in the center    rectMode(CENTER);    ellipseMode(CENTER);    // class    cup = new Koffie(width / 2, height / 2);}',correct
'// brown coffee colourfill(139, 69, 19);',correct
'setup',correct
'x + width / 14.9f',correct
'i = 0',correct
'ellipse(x, y - height / 6.25f, width / 3.33f, height / 14.7f)',correct
'y = initY;',correct
'fill(139, 69, 19)',correct
'{    // Pink background or blue background    if (mouseX < width / 3) {        background(b1);    } else {        background(b2);    }    // display creature    cup.run();}',correct
'cup.run()',correct
'smoke()',correct
'Koffie cup = new Koffie(0, 0);',correct
'y = initY',correct
'cup = new Koffie(width / 2, height / 2)',correct
'ellipse(x + width / 14.9f, y - height / 12, width / 80, height / 60)',correct
'fill(211, 211, 211)',correct
'textSize(width / 22)',correct
'{    background(b1);}',DecentralizedEventHandlingRule
'11.11f',correct
'cup.isPressed = true;',correct
'{    // creature movement    cup.move();}',correct
'Koffie',correct
'fill(220, 90, 90)',correct
'isPressed = false',correct
'ellipse(x - width / 14.9f, y - height / 18, width / 80, height / 60);',correct
'5.88f',correct
'3.33f',correct
'faceH()',correct
'{    // if isPressed is true the face becomes cute, this is when the mouse is pressed    if (isPressed == true) {        // eyes        fill(0);        ellipse(x - width / 14.29f, y - height / 14.29f, width / 40, height / 20);        ellipse(x + width / 14.29f, y - height / 14.29f, width / 40, height / 20);        fill(255);        // left sparkle        ellipse(x - width / 13.9f, y - height / 12, width / 80, height / 60);        ellipse(x - width / 14.9f, y - height / 18, width / 80, height / 60);        // right sparkle        ellipse(x + width / 14.9f, y - height / 12, width / 80, height / 60);        ellipse(x + width / 13.9f, y - height / 18, width / 80, height / 60);        // blush        fill(220, 20, 60);        ellipse(x - width / 11, y - height / 30, width / 80, height / 60);        ellipse(x + width / 11, y - height / 30, width / 80, height / 60);        // mouth        fill(220, 90, 90);        arc(x, y - height / 50, width / 30, height / 20, 0, PI, CHORD);    }}',correct
'x - width / 14.9f',correct
'void move() {    // move the cup    x = pmouseX;    y = pmouseY;}',correct
'// alles runnendisplay();',correct
'x + width / 12.5f',correct
'height / 6.25f',correct
'y - height / 12.5f',correct
'smoke[i] = "S";',correct
'ellipse(x + width / 11, y - height / 30, width / 80, height / 60);',correct
'smoke = new String[3]',correct
'int b1 = color(199, 21, 133);',ShortVariable
'x - width / 14.29f',correct
'{    fill(b2);    arc(x + width / 5.88f, y - height / 10, width / 16.66f, height / 12.5f, -3, 3, CHORD);}',DecentralizedEventHandlingRule
'textAlign(CENTER, CENTER);',correct
'ellipse(x, y - height / 6.09f, width / 3.33f, height / 12.5f)',correct
'smoke[i]',correct
'ellipse(x + width / 13.9f, y - height / 18, width / 80, height / 60)',correct
'{    // make text    println("Do you think Im hot?");}',correct
'width / 3.33f',correct
'// 3 strings, letter "S"for (int i = 0; i < smoke.length; i++) {    smoke[i] = "S";}',correct
'fill(220, 20, 60)',correct
'height / 50',correct
'line(x - width / 11.11f, y - height / 10, x - width / 20, y - height / 12.5f)',correct
'2.63f',correct
'height / 100',correct
'x + width / 5.88f',correct
'x + width / 14.29f',correct
'width / 11.11f',correct
'display',correct
'x - width / 33.33f',correct
'ellipse(x - width / 14.29f, y - height / 14.29f, width / 100, height / 100);',correct
'draw',correct
'// mouthline(x - width / 33.33f, y - height / 50, x + width / 25, y - height / 50);',correct
'y - height / 6.09f',correct
'width / 80',correct
'{    cup.isPressed = false;}',correct
'ellipse(x + width / 14.29f, y - height / 14.29f, width / 100, height / 100)',correct
'12.5f',correct
'height / 60',correct
'cup.isPressed',correct
'// width and height// everything starts in the centerrectMode(CENTER);',correct
'// eyesfill(0);',correct
'width / 16.66f',correct
'display()',correct
'float initX',correct
'// coffee handlefill(190, 190, 190);',correct
'float initY',correct
'i++',correct
'color(199, 21, 133)',correct
'String[]',correct
'mousePressed',correct
'fill(255);',correct
'ellipseMode(CENTER)',correct
'width / 14.9f',correct
'width / 5.88f',correct
'height / 30',correct
'width / 2.5f',correct
'cup.move()',correct
'void',correct
'b2 = color(70, 130, 180)',correct
'-3',correct
'smoke.length',correct
'x + width / 11 * i - width / 11',correct
'5.68f',correct
'mouseX < width / 3',DecentralizedEventHandlingRule
'fill(b2);',correct
'cup = new Koffie(0, 0)',correct
'// mouthfill(220, 90, 90);',correct
'cup.isPressed = true',correct
'true',correct
'// face',correct
'textAlign(CENTER, CENTER)',correct
'arc(x, y - height / 50, width / 30, height / 20, 0, PI, CHORD);',correct
'int b2 = color(70, 130, 180);',ShortVariable
'faceN();',correct
'class Koffie {    float x;    float y;    String[] smoke = new String[3];    boolean isPressed = false;    Koffie(float initX, float initY) {        x = initX;        y = initY;        // 3 strings, letter "S"        for (int i = 0; i < smoke.length; i++) {            smoke[i] = "S";        }    }    void run() {        // alles runnen        display();        smoke();        faceN();        faceH();    }    void display() {        // draw circles under cup        fill(211, 211, 211);        ellipse(x, y, width / 2.5f, height / 6.25f);        fill(190, 190, 190);        ellipse(x, y, width / 5, height / 12.5f);        // draw cup        arc(x, y - height / 6.25f, width / 3.33f, height / 2.63f, 0, PI, OPEN);        ellipse(x, y - height / 6.09f, width / 3.33f, height / 12.5f);        // brown coffee colour        fill(139, 69, 19);        // coffee        ellipse(x, y - height / 6.25f, width / 3.33f, height / 14.7f);        // coffee handle        fill(190, 190, 190);        arc(x + width / 5.68f, y - height / 10, width / 12.5f, height / 10, -3, 3, OPEN);        // colour inside coffee handle(background)        if (mouseX < width / 3) {            fill(b1);            arc(x + width / 5.88f, y - height / 10, width / 16.66f, height / 12.5f, -3, 3, CHORD);        } else {            fill(b2);            arc(x + width / 5.88f, y - height / 10, width / 16.66f, height / 12.5f, -3, 3, CHORD);        }    }    void say() {        // make text        println("Do you think Im hot?");    }    void move() {        // move the cup        x = pmouseX;        y = pmouseY;    }    void smoke() {        // isPressed is true, then the textsize place and colour change        if (isPressed == true) {            textSize(width / 22);            textAlign(CENTER, CENTER);            fill(255);            // this changes the place, x and y and also text starts in middle usually, now more to the left            for (int i = 0; i < smoke.length; i++) {                text(smoke[i], x + width / 11 * i - width / 11, y - height / 4);            }        }    }    void faceN() {        // if isPressed is false the face becomes normal, this is when the mouse is released        if (isPressed == false) {            // face            // eyebrows            line(x - width / 11.11f, y - height / 10, x - width / 20, y - height / 12.5f);            line(x + width / 25, y - height / 12.5f, x + width / 12.5f, y - height / 10);            // eyes            fill(0);            ellipse(x - width / 14.29f, y - height / 14.29f, width / 100, height / 100);            ellipse(x + width / 14.29f, y - height / 14.29f, width / 100, height / 100);            // mouth            line(x - width / 33.33f, y - height / 50, x + width / 25, y - height / 50);        }    }    void faceH() {        // if isPressed is true the face becomes cute, this is when the mouse is pressed        if (isPressed == true) {            // eyes            fill(0);            ellipse(x - width / 14.29f, y - height / 14.29f, width / 40, height / 20);            ellipse(x + width / 14.29f, y - height / 14.29f, width / 40, height / 20);            fill(255);            // left sparkle            ellipse(x - width / 13.9f, y - height / 12, width / 80, height / 60);            ellipse(x - width / 14.9f, y - height / 18, width / 80, height / 60);            // right sparkle            ellipse(x + width / 14.9f, y - height / 12, width / 80, height / 60);            ellipse(x + width / 13.9f, y - height / 18, width / 80, height / 60);            // blush            fill(220, 20, 60);            ellipse(x - width / 11, y - height / 30, width / 80, height / 60);            ellipse(x + width / 11, y - height / 30, width / 80, height / 60);            // mouth            fill(220, 90, 90);            arc(x, y - height / 50, width / 30, height / 20, 0, PI, CHORD);        }    }}',correct
'{    // if isPressed is false the face becomes normal, this is when the mouse is released    if (isPressed == false) {        // face        // eyebrows        line(x - width / 11.11f, y - height / 10, x - width / 20, y - height / 12.5f);        line(x + width / 25, y - height / 12.5f, x + width / 12.5f, y - height / 10);        // eyes        fill(0);        ellipse(x - width / 14.29f, y - height / 14.29f, width / 100, height / 100);        ellipse(x + width / 14.29f, y - height / 14.29f, width / 100, height / 100);        // mouth        line(x - width / 33.33f, y - height / 50, x + width / 25, y - height / 50);    }}',correct
'void say() {    // make text    println("Do you think Im hot?");}',correct
'height / 14.7f',correct
'6.25f',correct
'width / 30',correct
'background(b2);',correct
'new Koffie(0, 0)',correct
'height / 18',correct
'"S"',correct
'// face// eyebrowsline(x - width / 11.11f, y - height / 10, x - width / 20, y - height / 12.5f);',correct
'line(x - width / 33.33f, y - height / 50, x + width / 25, y - height / 50)',correct
'height / 12',correct
'{    smoke[i] = "S";}',correct
'height / 10',correct
'x = pmouseX',correct
'move',correct
'Koffie(float initX, float initY) {    x = initX;    y = initY;    // 3 strings, letter "S"    for (int i = 0; i < smoke.length; i++) {        smoke[i] = "S";    }}',correct
'y - height / 4',correct
'smoke',correct
'width / 40',correct
'say',correct
'width / 33.33f',correct
'{    // text for creature    cup.say();    cup.isPressed = true;}',correct
'width / 13.9f',correct
'{    // move the cup    x = pmouseX;    y = pmouseY;}',correct
'width / 2',correct
'ellipse(x, y, width / 2.5f, height / 6.25f);',correct
'void mouseReleased() {    cup.isPressed = false;}',correct
'arc(x + width / 5.68f, y - height / 10, width / 12.5f, height / 10, -3, 3, OPEN);',correct
'height / 20',correct
'cup.isPressed = false',correct
'fill(190, 190, 190);',correct
'ellipse(x + width / 11, y - height / 30, width / 80, height / 60)',correct
'ellipse(x - width / 14.29f, y - height / 14.29f, width / 100, height / 100)',correct
'{    // eyes    fill(0);    ellipse(x - width / 14.29f, y - height / 14.29f, width / 40, height / 20);    ellipse(x + width / 14.29f, y - height / 14.29f, width / 40, height / 20);    fill(255);    // left sparkle    ellipse(x - width / 13.9f, y - height / 12, width / 80, height / 60);    ellipse(x - width / 14.9f, y - height / 18, width / 80, height / 60);    // right sparkle    ellipse(x + width / 14.9f, y - height / 12, width / 80, height / 60);    ellipse(x + width / 13.9f, y - height / 18, width / 80, height / 60);    // blush    fill(220, 20, 60);    ellipse(x - width / 11, y - height / 30, width / 80, height / 60);    ellipse(x + width / 11, y - height / 30, width / 80, height / 60);    // mouth    fill(220, 90, 90);    arc(x, y - height / 50, width / 30, height / 20, 0, PI, CHORD);}',SimplifyBooleanExpressions
'width / 3',correct
'// classcup = new Koffie(width / 2, height / 2);',correct
'ellipse(x, y, width / 5, height / 12.5f);',correct
'width / 5',correct
'cursor(ARROW);',correct
'mouseDragged',correct
'{    x = mouseX;    mondje.updatePosition(x, y + mouthHeight);}',correct
'mouseX > 0',correct
'y - 20',correct
'Animal[]',correct
'float treeY = 200;',correct
'{    // Distance can be made larger or smaller for calibration. I chose 20 so the character is (almost) fully under the tree.    // Sad mouth, is pushed down (sadMouthOffset) to match the face height.    mondje.updateEmotion(PI, 2 * PI, sadMouthOffset);}',correct
'arc(x - 75, y - 80, 100, 150, HALF_PI, PI)',correct
'fill(190, 190, 190)',correct
'rect(treeX - 40 - 65, 200, 250, 200)',correct
'{    // Initialise the creature using a for loop.    for (int i = 0; i < creature.length; i++) {        creature[i] = new Animal(groundX + 200, groundY - 50);    }}',correct
'// Drawing of the tree and leavesvoid tree() {    ellipseMode(CENTER);    fill(160, 82, 45);    rect(treeX, treeY, 50, 200);    fill(46, 139, 87);    ellipse(treeX - 40, treeY, 130, 130);    ellipse(treeX + 80, treeY, 130, 130);    ellipse(treeX + 20, treeY - 60, 130, 130);}',correct
'float sadMouthOffset = 30;',correct
'// Draw body and legs.noStroke();',correct
'ellipse(x + 20, y - 5, 20, 25);',correct
'// Same color as the new background.fill(95, 176, 250);',correct
'ellipse(x - 50, y + 70, 40, 70)',correct
'creature[i] = new Animal(groundX + 200, groundY - 50)',correct
'// Distance can be made larger or smaller for calibration. I chose 20 so the character is (almost) fully under the tree.',correct
'mondje.updateEmotion(PI, 2 * PI, sadMouthOffset)',correct
'arc(x + 75, y - 80, 100, 150, 0, HALF_PI)',correct
'{    clicked = !clicked;}',correct
'treeY - 60',correct
'{    cursor(HAND);}',DecentralizedEventHandlingRule
'arc(x, y + mouthHeight, 100, 80, a1, a2);',correct
'cloud();',correct
'frameRate(30);',correct
'creature.length == 1',correct
'// Sets a forest green color.fill(34, 139, 34);',correct
'cursor(ARROW)',correct
'{    creature[i].move();}',correct
'{    x = xpos;    y = ypos;    // Initialise the mouth.    mondje = new Mouth(x, y + mouthHeight, 0, PI);}',correct
'fill(46, 139, 87)',correct
'cloud()',correct
'new Animal(groundX + 200, groundY - 50)',correct
'fill(160, 82, 45)',correct
'// Drawing of the cloudvoid cloud() {    ellipseMode(CENTER);    fill(255);    ellipse(cloudX, cloudY, 50, 50);    ellipse(cloudX + 50, cloudY, 50, 50);    ellipse(cloudX + 25, cloudY + 25, 50, 50);    ellipse(cloudX + 25, cloudY - 25, 50, 50);}',correct
'treeY = 200',correct
'treeX + 20',correct
'{    if (dist(mouseX, mouseY, cloudX + 25, cloudY) <= 50) {        clicked = !clicked;    }}',correct
'cloudY - 25',correct
'mondje',correct
'mondje.display()',correct
'ellipse(x - 50, y + 70, 40, 70);',correct
'mondje.updatePosition(x, y + mouthHeight);',correct
'cloudY = 100',correct
'cursor(HAND)',correct
'mouthHeight',correct
'y - 5',correct
'y + 70',correct
'{    // New background.    background(95, 176, 250);    // Disables drawing the stroke, so there is no stroke.    noStroke();    // the color of the next shapes is blue.    fill(0, 0, 255);    for (int i = 0; i <= width; i = i + (width / 70)) {        // Draws multiple rain drops using for loop.        // The position of the driplets increases incrementally because the x-position is equal to the counter i.        ellipse(i, random(groundY), 5, 8);        frameRate(30);    }    // Same color as the new background.    fill(95, 176, 250);    // creates a rectangle as a layer between the tree and the sky, to make it seem like it is dry underneath the tree.    rect(treeX - 40 - 65, 200, 250, 200);    // to set the soil layer on top, so no rain driples are shown on it.    fill(34, 139, 90);    // draws the soil block.    rect(groundX, groundY, groundW, groundH);}',correct
'mouthHeight = 20',correct
'x + 20',correct
'ellipse(x - 20, y - 5, 20, 25);',correct
'// Processing project for Mod 1, Creative Technology',correct
'ellipse(x + 50, y + 70, 40, 70)',correct
'{    // Happy mouth, same as initalised.    mondje.updateEmotion(0, PI, 0);}',correct
'x',correct
'fill(255, 120, 90)',correct
'y',correct
'// Draw the background shapes.',correct
'noStroke()',correct
'// October 2018',correct
'clicked = !clicked',correct
'x = mouseX',correct
'{    // Checks if the array size is indeed equal to 1. Otherwise an error will occur. Safety measure.    assert creature.length == 1;    // Draw the background shapes.    // Sets the background color to sky blue.    background(135, 206, 250);    // Disables drawing the stroke, so there is no stroke.    noStroke();    // Sets a forest green color.    fill(34, 139, 34);    // draws the soil block.    rect(groundX, groundY, groundW, groundH);    // If the cloud is clicked with mousePressed(); the following code draws the rain over a new background with a rainy atmosphere.    if (clicked) {        // New background.        background(95, 176, 250);        // Disables drawing the stroke, so there is no stroke.        noStroke();        // the color of the next shapes is blue.        fill(0, 0, 255);        for (int i = 0; i <= width; i = i + (width / 70)) {            // Draws multiple rain drops using for loop.            // The position of the driplets increases incrementally because the x-position is equal to the counter i.            ellipse(i, random(groundY), 5, 8);            frameRate(30);        }        // Same color as the new background.        fill(95, 176, 250);        // creates a rectangle as a layer between the tree and the sky, to make it seem like it is dry underneath the tree.        rect(treeX - 40 - 65, 200, 250, 200);        // to set the soil layer on top, so no rain driples are shown on it.        fill(34, 139, 90);        // draws the soil block.        rect(groundX, groundY, groundW, groundH);    }    // draw the objects tree, cloud and the array (1) of creatures    tree();    cloud();    for (int i = 0; i < creature.length; i++) {        creature[i].display();    }    // Interactive cursor    if (dist(mouseX, mouseY, cloudX + 25, cloudY) <= 50) {        cursor(HAND);    } else {        cursor(ARROW);    }}',correct
'float a1;',ShortVariable
'// to set the soil layer on top, so no rain driples are shown on it.fill(34, 139, 90);',correct
'creature = new Animal[1]',correct
'x - 50',correct
'y = ypos',correct
'(dist(mouseX, mouseY, x, y) <= 100) && mouseX > 0',correct
'if ((dist(mouseX, mouseY, x, y) <= 100) && mouseX > 0 && mouseX < 1000) {    x = mouseX;    mondje.updatePosition(x, y + mouthHeight);}',correct
'mouseX < 1000',correct
'a2 = angle2',correct
'// Distance can be made larger or smaller for calibration. I chose 20 so the character is (almost) fully under the tree.// Sad mouth, is pushed down (sadMouthOffset) to match the face height.mondje.updateEmotion(PI, 2 * PI, sadMouthOffset);',correct
'new Mouth(x, y + mouthHeight, 0, PI)',correct
'for (int i = 0; i <= width; i = i + (width / 70)) {    // Draws multiple rain drops using for loop.    // The position of the driplets increases incrementally because the x-position is equal to the counter i.    ellipse(i, random(groundY), 5, 8);    frameRate(30);}',correct
'void draw() {    // Checks if the array size is indeed equal to 1. Otherwise an error will occur. Safety measure.    assert creature.length == 1;    // Draw the background shapes.    // Sets the background color to sky blue.    background(135, 206, 250);    // Disables drawing the stroke, so there is no stroke.    noStroke();    // Sets a forest green color.    fill(34, 139, 34);    // draws the soil block.    rect(groundX, groundY, groundW, groundH);    // If the cloud is clicked with mousePressed(); the following code draws the rain over a new background with a rainy atmosphere.    if (clicked) {        // New background.        background(95, 176, 250);        // Disables drawing the stroke, so there is no stroke.        noStroke();        // the color of the next shapes is blue.        fill(0, 0, 255);        for (int i = 0; i <= width; i = i + (width / 70)) {            // Draws multiple rain drops using for loop.            // The position of the driplets increases incrementally because the x-position is equal to the counter i.            ellipse(i, random(groundY), 5, 8);            frameRate(30);        }        // Same color as the new background.        fill(95, 176, 250);        // creates a rectangle as a layer between the tree and the sky, to make it seem like it is dry underneath the tree.        rect(treeX - 40 - 65, 200, 250, 200);        // to set the soil layer on top, so no rain driples are shown on it.        fill(34, 139, 90);        // draws the soil block.        rect(groundX, groundY, groundW, groundH);    }    // draw the objects tree, cloud and the array (1) of creatures    tree();    cloud();    for (int i = 0; i < creature.length; i++) {        creature[i].display();    }    // Interactive cursor    if (dist(mouseX, mouseY, cloudX + 25, cloudY) <= 50) {        cursor(HAND);    } else {        cursor(ARROW);    }}',correct
'cloudY + 25',correct
'// Updates position of the creature and the mouth.void move() {    if ((dist(mouseX, mouseY, x, y) <= 100) && mouseX > 0 && mouseX < 1000) {        x = mouseX;        mondje.updatePosition(x, y + mouthHeight);    }}',correct
'{    // Draws multiple rain drops using for loop.    // The position of the driplets increases incrementally because the x-position is equal to the counter i.    ellipse(i, random(groundY), 5, 8);    frameRate(30);}',correct
'treeX + 80',correct
'frameRate(30)',correct
'// If the cloud is clicked with mousePressed(); the following code draws the rain over a new background with a rainy atmosphere.if (clicked) {    // New background.    background(95, 176, 250);    // Disables drawing the stroke, so there is no stroke.    noStroke();    // the color of the next shapes is blue.    fill(0, 0, 255);    for (int i = 0; i <= width; i = i + (width / 70)) {        // Draws multiple rain drops using for loop.        // The position of the driplets increases incrementally because the x-position is equal to the counter i.        ellipse(i, random(groundY), 5, 8);        frameRate(30);    }    // Same color as the new background.    fill(95, 176, 250);    // creates a rectangle as a layer between the tree and the sky, to make it seem like it is dry underneath the tree.    rect(treeX - 40 - 65, 200, 250, 200);    // to set the soil layer on top, so no rain driples are shown on it.    fill(34, 139, 90);    // draws the soil block.    rect(groundX, groundY, groundW, groundH);}',correct
'ellipse(x - 20, y - 20, 30, 60);',correct
'float a2;',ShortVariable
'// Drawing of the mouth (happy smile initially).void display() {    ellipseMode(CENTER);    fill(255, 120, 90);    arc(x, y + mouthHeight, 100, 80, a1, a2);}',correct
'mondje = new Mouth(x, y + mouthHeight, 0, PI)',correct
'ellipse(treeX - 40, treeY, 130, 130);',correct
'updateEmotion',correct
'ellipse(cloudX, cloudY, 50, 50)',correct
'fill(0)',correct
'// Initialise the creature using a for loop.for (int i = 0; i < creature.length; i++) {    creature[i] = new Animal(groundX + 200, groundY - 50);}',correct
'dist(mouseX, mouseY, cloudX + 25, cloudY)',correct
'fill(95, 176, 250)',correct
'mondje.updateEmotion(0, PI, 0)',correct
'{    creature[i].display();}',correct
'// Position is relative to the Animal creature.void updatePosition(float xpos, float ypos) {    x = xpos;    y = ypos;}',correct
'// Declares a boolean as false, which turns true when the user clicks in the clouds proximity.boolean clicked = false;',correct
'{    if ((dist(mouseX, mouseY, x, y) <= 100) && mouseX > 0 && mouseX < 1000) {        x = mouseX;        mondje.updatePosition(x, y + mouthHeight);    }}',correct
'random(groundY)',correct
'sadMouthOffset = 30',correct
'background(135, 206, 250)',correct
'x - 75',correct
'y = ypos;',correct
'fill(120, 120, 120)',correct
'float x;',correct
'// New background.background(95, 176, 250);',correct
'fill(255)',correct
'groundY - 50',correct
'ellipse(cloudX, cloudY, 50, 50);',correct
'fill(34, 139, 34)',correct
'Processing',correct
'dist(mouseX, mouseY, cloudX + 25, cloudY) <= 50',correct
'Mouth mondje;',correct
'ellipse(x, y, 150, 150)',correct
'{    ellipseMode(CENTER);    fill(160, 82, 45);    rect(treeX, treeY, 50, 200);    fill(46, 139, 87);    ellipse(treeX - 40, treeY, 130, 130);    ellipse(treeX + 80, treeY, 130, 130);    ellipse(treeX + 20, treeY - 60, 130, 130);}',correct
'Mouth',correct
'groundX = 0',correct
'ellipse(x + 20, y - 20, 30, 60);',correct
'// Click the clound and/or drag the creature, see if he likes it!',correct
'// draw the objects tree, cloud and the array (1) of creaturestree();',correct
'mouthHeight = offset;',correct
'for (int i = 0; i < creature.length; i++) {    creature[i].display();}',correct
'arc(x + 75, y - 80, 100, 150, 0, HALF_PI);',correct
'float y;',correct
'false',correct
'// Initialise the mouth.mondje = new Mouth(x, y + mouthHeight, 0, PI);',correct
'treeX - 40 - 65',correct
'void setup() {    // Initialise the creature using a for loop.    for (int i = 0; i < creature.length; i++) {        creature[i] = new Animal(groundX + 200, groundY - 50);    }}',correct
'class Mouth {    float x;    float y;    float a1;    float a2;    float mouthHeight;    Mouth(float xpos, float ypos, float angle1, float angle2) {        x = xpos;        y = ypos;        a1 = angle1;        a2 = angle2;    }    // Drawing of the mouth (happy smile initially).    void display() {        ellipseMode(CENTER);        fill(255, 120, 90);        arc(x, y + mouthHeight, 100, 80, a1, a2);    }    // Position is relative to the Animal creature.    void updatePosition(float xpos, float ypos) {        x = xpos;        y = ypos;    }    // Used in Animal class when animal is sad in the rain.    void updateEmotion(float angle1, float angle2, float offset) {        a1 = angle1;        a2 = angle2;        mouthHeight = offset;    }}',correct
'ellipseMode(CENTER);',correct
'int i = 0',correct
'Mouth(float xpos, float ypos, float angle1, float angle2) {    x = xpos;    y = ypos;    a1 = angle1;    a2 = angle2;}',correct
'creature[i]',correct
'creature.length',correct
'setup',correct
'// the color of the next shapes is blue.fill(0, 0, 255);',correct
'for (int i = 0; i < creature.length; i++) {    creature[i].move();}',correct
'void display() {    // Draw arms.    fill(120, 120, 120);    arc(x + 75, y - 80, 100, 150, 0, HALF_PI);    arc(x - 75, y - 80, 100, 150, HALF_PI, PI);    // Draw body and legs.    noStroke();    ellipseMode(CENTER);    fill(190, 190, 190);    ellipse(x, y, 150, 150);    ellipse(x - 50, y + 70, 40, 70);    ellipse(x + 50, y + 70, 40, 70);    // Draw eyes.    fill(255);    ellipse(x - 20, y - 20, 30, 60);    ellipse(x + 20, y - 20, 30, 60);    // Draw iris.    fill(0);    ellipse(x - 20, y - 5, 20, 25);    ellipse(x + 20, y - 5, 20, 25);    // Requisites for the creature being sad or happy.    if (clicked && dist(x, y, (treeX + 25), y) >= 20) {        // Distance can be made larger or smaller for calibration. I chose 20 so the character is (almost) fully under the tree.        // Sad mouth, is pushed down (sadMouthOffset) to match the face height.        mondje.updateEmotion(PI, 2 * PI, sadMouthOffset);    } else {        // Happy mouth, same as initalised.        mondje.updateEmotion(0, PI, 0);    }    // Draw mouth.    mondje.display();}',correct
'// Draw eyes.fill(255);',correct
'fill(34, 139, 90)',correct
'// Sets the window size to 1000x600.',correct
'arc(x - 75, y - 80, 100, 150, HALF_PI, PI);',correct
'i = 0',correct
'x + 75',correct
'clicked = false',correct
'{    // Draw arms.    fill(120, 120, 120);    arc(x + 75, y - 80, 100, 150, 0, HALF_PI);    arc(x - 75, y - 80, 100, 150, HALF_PI, PI);    // Draw body and legs.    noStroke();    ellipseMode(CENTER);    fill(190, 190, 190);    ellipse(x, y, 150, 150);    ellipse(x - 50, y + 70, 40, 70);    ellipse(x + 50, y + 70, 40, 70);    // Draw eyes.    fill(255);    ellipse(x - 20, y - 20, 30, 60);    ellipse(x + 20, y - 20, 30, 60);    // Draw iris.    fill(0);    ellipse(x - 20, y - 5, 20, 25);    ellipse(x + 20, y - 5, 20, 25);    // Requisites for the creature being sad or happy.    if (clicked && dist(x, y, (treeX + 25), y) >= 20) {        // Distance can be made larger or smaller for calibration. I chose 20 so the character is (almost) fully under the tree.        // Sad mouth, is pushed down (sadMouthOffset) to match the face height.        mondje.updateEmotion(PI, 2 * PI, sadMouthOffset);    } else {        // Happy mouth, same as initalised.        mondje.updateEmotion(0, PI, 0);    }    // Draw mouth.    mondje.display();}',correct
'mondje.updatePosition(x, y + mouthHeight)',correct
'// Draws multiple rain drops using for loop.// The position of the driplets increases incrementally because the x-position is equal to the counter i.ellipse(i, random(groundY), 5, 8);',correct
'float groundH = 600;',correct
'float cloudY = 100;',correct
'float groundY = 400;',correct
'creature[i].move()',correct
'x = xpos;',correct
'groundY = 400',correct
'groundX + 200',correct
'cloudX + 50',correct
'// Declares the values for the tree, global because required for the mouth and the rectangle that hides the rain.float treeX = 500;',correct
'creature[i] = new Animal(groundX + 200, groundY - 50);',correct
'{    for (int i = 0; i < creature.length; i++) {        creature[i].move();    }}',correct
'rect(groundX, groundY, groundW, groundH)',correct
'x - 20',correct
'ellipse(treeX + 80, treeY, 130, 130);',correct
'fill(46, 139, 87);',correct
'i < creature.length',correct
'Animal(float xpos, float ypos) {    x = xpos;    y = ypos;    // Initialise the mouth.    mondje = new Mouth(x, y + mouthHeight, 0, PI);}',correct
'{    creature[i] = new Animal(groundX + 200, groundY - 50);}',correct
'// Used in Animal class when animal is sad in the rain.void updateEmotion(float angle1, float angle2, float offset) {    a1 = angle1;    a2 = angle2;    mouthHeight = offset;}',correct
'new Animal[1]',correct
'creature[i].move();',correct
'// Drag to move the creaturevoid mouseDragged() {    for (int i = 0; i < creature.length; i++) {        creature[i].move();    }}',correct
'Animal',correct
'{    cursor(ARROW);}',DecentralizedEventHandlingRule
'ellipse(cloudX + 25, cloudY - 25, 50, 50);',correct
'treeX = 500',correct
'// Declares the values of the cloud, global because they are also used in mousePressed and the cursor icon.float cloudX = 100;',correct
'y - 80',correct
'{    a1 = angle1;    a2 = angle2;    mouthHeight = offset;}',correct
'a1 = angle1',correct
'// Draw iris.fill(0);',correct
'float mouthHeight = 20;',correct
'i = i + (width / 70)',correct
'ellipse(treeX + 80, treeY, 130, 130)',correct
'ellipse(cloudX + 50, cloudY, 50, 50)',correct
'x = mouseX;',correct
'// Press on the cloud for rainvoid mouseClicked() {    if (dist(mouseX, mouseY, cloudX + 25, cloudY) <= 50) {        clicked = !clicked;    }}',correct
'ellipse(treeX + 20, treeY - 60, 130, 130);',correct
'ellipse(x - 20, y - 5, 20, 25)',correct
'// draws the soil block.rect(groundX, groundY, groundW, groundH);',correct
'ellipse(x + 20, y - 5, 20, 25)',correct
'// Requisites for the creature being sad or happy.if (clicked && dist(x, y, (treeX + 25), y) >= 20) {    // Distance can be made larger or smaller for calibration. I chose 20 so the character is (almost) fully under the tree.    // Sad mouth, is pushed down (sadMouthOffset) to match the face height.    mondje.updateEmotion(PI, 2 * PI, sadMouthOffset);} else {    // Happy mouth, same as initalised.    mondje.updateEmotion(0, PI, 0);}',correct
'treeX - 40',correct
'clicked && dist(x, y, (treeX + 25), y) >= 20',correct
'updatePosition',correct
'cloudX + 25',correct
'a2 = angle2;',correct
'display',correct
'mouthHeight = offset',correct
'draw',correct
'clicked',correct
'// Thomas van Wanrooij',correct
'// Checks if the array size is indeed equal to 1. Otherwise an error will occur. Safety measure.assert creature.length == 1;',correct
'// Draw the background shapes.// Sets the background color to sky blue.background(135, 206, 250);',correct
'tree()',correct
'groundW = 1000',correct
'// Draw mouth.mondje.display();',correct
'fill(0, 0, 255)',correct
'dist(x, y, (treeX + 25), y) >= 20',correct
'// Thomas van Wanrooij// Processing project for Mod 1, Creative Technology// Interactive creature// October 2018// Click the clound and/or drag the creature, see if he likes it!// Declares the values for the ground box, global because they are also used in the creatures and the raindrops positions.float groundX = 0;',correct
'i++',correct
'float mouthHeight;',correct
'arc(x, y + mouthHeight, 100, 80, a1, a2)',correct
'fill(160, 82, 45);',correct
'fill(255);',correct
'cloud',correct
'ellipseMode(CENTER)',correct
'float ypos',correct
'if (dist(mouseX, mouseY, cloudX + 25, cloudY) <= 50) {    clicked = !clicked;}',correct
'i <= width',correct
'cloudX = 100',correct
'{    ellipseMode(CENTER);    fill(255);    ellipse(cloudX, cloudY, 50, 50);    ellipse(cloudX + 50, cloudY, 50, 50);    ellipse(cloudX + 25, cloudY + 25, 50, 50);    ellipse(cloudX + 25, cloudY - 25, 50, 50);}',correct
'float angle2',correct
'float angle1',correct
'// Draws multiple rain drops using for loop.',correct
'ellipse(x, y, 150, 150);',correct
'void',correct
'y + mouthHeight',correct
'// Interactive cursorif (dist(mouseX, mouseY, cloudX + 25, cloudY) <= 50) {    cursor(HAND);} else {    cursor(ARROW);}',correct
'groundH = 600',correct
'ellipse(x + 50, y + 70, 40, 70);',correct
'tree',correct
'rect(treeX, treeY, 50, 200);',correct
'a1 = angle1;',correct
'ellipse(i, random(groundY), 5, 8)',correct
'ellipse(treeX + 20, treeY - 60, 130, 130)',correct
'ellipse(x - 20, y - 20, 30, 60)',correct
'!clicked',correct
'mouseClicked',correct
'fill(255, 120, 90);',correct
'{    x = xpos;    y = ypos;}',correct
'dist(x, y, (treeX + 25), y)',correct
'ellipse(cloudX + 25, cloudY + 25, 50, 50);',correct
'cursor(HAND);',correct
'x + 50',correct
'creature[i].display();',correct
'float offset',correct
'ellipse(cloudX + 25, cloudY - 25, 50, 50)',correct
'float xpos',correct
'ellipse(cloudX + 25, cloudY + 25, 50, 50)',correct
'// Initialise an array of class Animal with 1 creature in it.Animal[] creature = new Animal[1];',correct
'// Draw arms.fill(120, 120, 120);',correct
'float groundW = 1000;',correct
'clicked = !clicked;',correct
'x = xpos',correct
'move',correct
'ellipse(cloudX + 50, cloudY, 50, 50);',correct
'// Disables drawing the stroke, so there is no stroke.noStroke();',correct
'ellipse(x + 20, y - 20, 30, 60)',correct
'[1]',correct
'(dist(mouseX, mouseY, x, y) <= 100) && mouseX > 0 && mouseX < 1000',correct
'background(95, 176, 250)',correct
'{    x = xpos;    y = ypos;    a1 = angle1;    a2 = angle2;}',correct
'creature[i].display()',correct
'a1',correct
'a2',correct
'class Animal {    float x;    float y;    Mouth mondje;    float mouthHeight = 20;    float sadMouthOffset = 30;    Animal(float xpos, float ypos) {        x = xpos;        y = ypos;        // Initialise the mouth.        mondje = new Mouth(x, y + mouthHeight, 0, PI);    }    void display() {        // Draw arms.        fill(120, 120, 120);        arc(x + 75, y - 80, 100, 150, 0, HALF_PI);        arc(x - 75, y - 80, 100, 150, HALF_PI, PI);        // Draw body and legs.        noStroke();        ellipseMode(CENTER);        fill(190, 190, 190);        ellipse(x, y, 150, 150);        ellipse(x - 50, y + 70, 40, 70);        ellipse(x + 50, y + 70, 40, 70);        // Draw eyes.        fill(255);        ellipse(x - 20, y - 20, 30, 60);        ellipse(x + 20, y - 20, 30, 60);        // Draw iris.        fill(0);        ellipse(x - 20, y - 5, 20, 25);        ellipse(x + 20, y - 5, 20, 25);        // Requisites for the creature being sad or happy.        if (clicked && dist(x, y, (treeX + 25), y) >= 20) {            // Distance can be made larger or smaller for calibration. I chose 20 so the character is (almost) fully under the tree.            // Sad mouth, is pushed down (sadMouthOffset) to match the face height.            mondje.updateEmotion(PI, 2 * PI, sadMouthOffset);        } else {            // Happy mouth, same as initalised.            mondje.updateEmotion(0, PI, 0);        }        // Draw mouth.        mondje.display();    }    // Updates position of the creature and the mouth.    void move() {        if ((dist(mouseX, mouseY, x, y) <= 100) && mouseX > 0 && mouseX < 1000) {            x = mouseX;            mondje.updatePosition(x, y + mouthHeight);        }    }}',correct
'2 * PI',correct
'// creates a rectangle as a layer between the tree and the sky, to make it seem like it is dry underneath the tree.rect(treeX - 40 - 65, 200, 250, 200);',correct
'i + (width / 70)',correct
'ellipse(treeX - 40, treeY, 130, 130)',correct
'fill(190, 190, 190);',correct
'// Interactive creature',correct
'rect(treeX, treeY, 50, 200)',correct
'{    ellipseMode(CENTER);    fill(255, 120, 90);    arc(x, y + mouthHeight, 100, 80, a1, a2);}',correct
'ballX = ballX + speedX',correct
'fill(73, 61, 41)',correct
'+50',correct
'digletX - 50',correct
'if (keyCode == UP) {    digletY = digletY - 5;}',correct
'class Flowers {    float x = random(width);    float y = random(height - 170, height);    float sizex = random(x - 5, x + 5);    float sizey = random(y - 30, y - 40);    int flowercolor = color(random(0, 255), random(0, 100), random(50, 170));    void display() {        stroke(10, 100, 70);        line(x, y, sizex, sizey);        // petals        noStroke();        fill(flowercolor);        for (int i = 0; i < 8; i++) {            ellipse(sizex + cos(i) * 8, sizey + sin(i) * 8, 10, 10);        }        fill(255, 255, 0);        ellipse(sizex, sizey, 8, 8);    }}',correct
'if (cos(angle) < 0) {    speedX = speedX * (-1);}',correct
'arc(0, +15, 15, 20, PI, PI + PI, OPEN)',correct
'+55',correct
'random(0, 255)',correct
'bubbles[i].ascend();',correct
'bezier(0, 350, width / 2, 0, width / 2 + 50, 350, width, 300);',correct
'int digletY;',correct
'line(x, y, sizex, sizey);',correct
'if (key == CODED) {    if (keyCode == RIGHT) {        digletX = digletX + 5;    }    if (keyCode == LEFT) {        digletX = digletX - 5;    }    if (keyCode == UP) {        digletY = digletY - 5;    }    if (keyCode == DOWN) {        digletY = digletY + 5;    }}',correct
'legs',correct
'ellipse(sizex + cos(i) * 8, sizey + sin(i) * 8, 10, 10)',correct
'stroke(255, 255, 255);',correct
'i < bubbles.length',correct
'flower[i] = new Flowers()',correct
'stroke(0);',correct
'Hair',correct
'stroke(0)',correct
'{    background(10, 200, 10);    stroke(0, 0, 0);    // bubbles    background(200, 200, 200);    for (int i = 0; i < bubbles.length; i++) {        bubbles[i].show();        bubbles[i].ascend();    }    // ground    fill(50, 200, 50);    bezier(0, 350, width / 2, 0, width / 2 + 50, 350, width, 300);    bezier(-40, 200, 80, 200, 350, 200, 0, height + height);    bezier(100, height, 280, 200, 350, 100, width + 100, 300);    stroke(50, 200, 50);    ellipse(width, height, 500, 200);    for (int i = 0; i < flower.length; i++) flower[i].display();    // red ball    ball.display();    ball.move();    ball.colide(jig.digletX, jig.digletY);    // my monster    jig.display();}',correct
'+60',correct
'fill(0, 0, 0)',correct
'digletY = digletY - 5;',correct
'speedY < 0',correct
'{    jig.isHurt = false;}',correct
'stroke(0, 153, 255)',correct
'Cheeks',StatelessClassRule
'sizey = random(y - 30, y - 40)',correct
'int digletX;',correct
'if (ballX > width) {    speedX = speedX * (-1);}',correct
'atan2(digletX - ballX, digletY - ballY)',correct
'ballY > height && speedY > 0',correct
'ellipse(sizex, sizey, 8, 8)',correct
'hurt',correct
'{    if (ballY > height && speedY > 0) {        speedY = speedY * (-1);    }    if (ballY < 0 && speedY < 0) {        speedY = speedY * (-1);    }    if (ballX > width) {        speedX = speedX * (-1);    }    if (ballX < 0 && speedX < 0) {        speedX = speedX * (-1);    }    ballX = ballX + speedX;    ballY = ballY + speedY;}',correct
'+70',correct
'speedX = 2',correct
'digletX = digletX - 5',correct
'float x = random(width);',AtLeastOneConstructor
'digletX = digletX + 5;',correct
'// making the Jigglypuff movevoid keyPressed() {    jig.processKey();    jig.isHurt = true;}',correct
'// left eyefill(255, 255, 255);',correct
'distance < minDist',correct
'jig.isDefensive = true;',correct
'{    bubbles[i].show();    bubbles[i].ascend();}',correct
'digletX - 30',correct
'ellipse(x, y, diam, diam)',correct
'jigSong = new SoundFile(this, "jigSong.mp3");',correct
'void display() {    // body    stroke(0, 0, 0);    fill(bodyColor);    pushMatrix();    translate(digletX, digletY);    ellipse(0, 0, 100, 100);    // eyes    eye.display(isHurt, isDefensive);    eye.blink();    // mouth    mouth.display(isHurt, isDefensive, bodyColor);    // cheeks    cheeks.display(isHurt);    // ears    ears.display(0, 0);    // hair    hair.display();    // legs    legs.display(isDefensive);    // hands    arms.display(isDefensive);    popMatrix();}',correct
'Jigglypuff() {    // pink    bodyColor = color(255, 198, 249);    digletX = width / 2;    digletY = height / 2;    eye = new Eyes(bodyColor);    mouth = new Mouth(bodyColor);    cheeks = new Cheeks();    ears = new Ears(digletX, digletY, bodyColor);    hair = new Hair(bodyColor);    legs = new Legs(digletX, digletY, bodyColor);    arms = new Arms(bodyColor);    isHurt = false;    isDefensive = false;}',correct
'{    stroke(0, 0, 0);    fill(bodyColor);    bezier(+5, -20, +7, -15, +7, -15, +30, -35);    bezier(-5, -20, -7, -15, -7, -15, -30, -35);}',correct
'fill(255, 102, 102)',correct
'Legs',correct
'bubbles[i].show();',correct
'+80',correct
'Arms(int pink) {    bodyColor = pink;}',correct
'{    bubbles[i] = new Bubble();}',correct
'SoundFile',correct
'jigSong',correct
'bezier(100, height, 280, 200, 350, 100, width + 100, 300)',correct
'boolean isHurt, isDefensive;',correct
'frameCount % 150',correct
'new Bubble[60]',correct
'digletX - 48',correct
'bezier(+15, -30, +7, -25, +10, -25, +40, -18)',correct
'fill(235, 168, 255)',correct
'for (int i = 0; i < flower.length; i++) flower[i] = new Flowers();',ForLoopsMustUseBraces
'new Bubble()',correct
'{    jig.isDefensive = true;}',correct
'ellipse(+25, -15, 8, 8)',correct
'{// Sorry wont need this}',correct
'digletX - 45',correct
'legs.display(isDefensive)',correct
'digletX + 70',correct
'{    speedY = speedY * (-1);}',correct
'ellipse(+20, -10, 25, 25);',correct
'if (isHurt || isDefensive) {    stroke(0, 0, 0);    fill(bodyColor);    arc(0, +15, 15, 20, PI, PI + PI, OPEN);} else {    stroke(0, 0, 0);    fill(255, 77, 77);    arc(0, +10, 12, 25, 0, PI, PIE);}',correct
'bezier(-15, -30, -7, -25, -10, -25, -40, -18);',correct
'{    // left eye    fill(255, 255, 255);    ellipse(-20, -10, 30, 30);    stroke(255, 255, 255);    fill(0, 153, 255);    ellipse(-20, -10, 25, 25);    stroke(0, 153, 255);    fill(0, 0, 0);    ellipse(-20, -10, 19, 19);    stroke(255, 255, 255);    fill(255, 255, 255);    ellipse(-15, -15, 8, 8);    // right eye    stroke(0);    fill(255, 255, 255);    ellipse(+20, -10, 30, 30);    stroke(255, 255, 255);    fill(0, 153, 255);    ellipse(+20, -10, 25, 25);    stroke(0, 153, 255);    fill(0, 0, 0);    ellipse(+20, -10, 19, 19);    stroke(255, 255, 255);    fill(255, 255, 255);    ellipse(+25, -15, 8, 8);    if (isDefensive) {        stroke(0, 0, 0);        fill(bodyColor);        bezier(+5, -20, +7, -15, +7, -15, +30, -35);        bezier(-5, -20, -7, -15, -7, -15, -30, -35);    }    if (isHurt) {        stroke(0, 0, 0);        fill(bodyColor);        bezier(+15, -30, +7, -25, +10, -25, +40, -18);        bezier(-15, -30, -7, -25, -10, -25, -40, -18);    }}',LongMethodRule
'ellipse(0, 0, 100, 100)',correct
'flower[i]',correct
'jig.isDefensive',correct
'bubbles[i].ascend()',correct
'fill(bodyColor)',correct
'jigSong = new SoundFile(this, "jigSong.mp3")',correct
'Eyes',correct
'arc(0, +15, 15, 20, PI, PI + PI, OPEN);',correct
'// red ballball.display();',correct
'angle = atan2(digletX - ballX, digletY - ballY)',correct
'{    if (frameCount % 150 == 0) {        fill(bodyColor);        ellipse(-20, -10, 30, 30);        ellipse(+20, -10, 30, 30);    }}',correct
'stroke(0, 0, 0)',correct
'ellipse(-32, +10, 15, 10)',correct
'diam = random(10, 25)',correct
'bubbles.length',correct
'eye.blink();',correct
'ellipse(sizex, sizey, 8, 8);',correct
'speedX = speedX * (-1)',correct
'ballX = width / 2',correct
'flowercolor = color(random(0, 255), random(0, 100), random(50, 170))',correct
'fill(73, 61, 41);',correct
'fill(bodyColor);',correct
'random(410, 500)',correct
'{    stroke(0, 0, 0);    fill(255, 77, 77);    arc(0, +10, 12, 25, 0, PI, PIE);}',correct
'speedX < 0',correct
'digletX - 22',correct
'{    float dx = digletX - ballX;    float dy = digletY - ballY;    float distance = sqrt(dx * dx + dy * dy);    float minDist = 100 / 2 + 30 / 2;    float angle = atan2(digletX - ballX, digletY - ballY);    if (distance < minDist) {        if (cos(angle) < 0) {            speedX = speedX * (-1);        }        if (sin(angle) < 0) {            speedY = speedY * (-1);        }    }}',correct
'void ascend() {    y = y - yspeed;    if (y < 0) {        y = random(410, 500);    }}',correct
'{    fill(235, 168, 255);    ellipse(-25, +40, 20, 40);}',correct
'float y = random(50, 150);',correct
'i < 8',correct
'ballX > width',correct
'Flowers',correct
'float distance = sqrt(dx * dx + dy * dy)',correct
'if (isHurt) {    stroke(0, 0, 0);    fill(bodyColor);    bezier(+15, -30, +7, -25, +10, -25, +40, -18);    bezier(-15, -30, -7, -25, -10, -25, -40, -18);}',correct
'random(0, 100)',correct
'Processing',correct
'fill(flowercolor);',correct
'Mouth',correct
'pushMatrix()',correct
'sizex = random(x - 5, x + 5)',correct
'stroke(0, 153, 255);',correct
'isHurt = false',correct
'digletX + 50',correct
'x = random(width)',correct
'{    if (keyCode == RIGHT) {        digletX = digletX + 5;    }    if (keyCode == LEFT) {        digletX = digletX - 5;    }    if (keyCode == UP) {        digletY = digletY - 5;    }    if (keyCode == DOWN) {        digletY = digletY + 5;    }}',correct
'dx * dx',correct
'height - 170',correct
'digletY = digletY - 5',correct
'Flowers[]',correct
'{    digletY = digletY - 5;}',correct
'line(x, y, sizex, sizey)',correct
'0.2f',correct
'// eyeseye.display(isHurt, isDefensive);',correct
'arms = new Arms(bodyColor)',correct
'frameCount % 150 == 0',correct
'class Jigglypuff {    int digletX;    int digletY;    int bodyColor;    boolean isHurt, isDefensive;    Eyes eye;    Mouth mouth;    Cheeks cheeks;    Ears ears;    Hair hair;    Legs legs;    Arms arms;    Jigglypuff() {        // pink        bodyColor = color(255, 198, 249);        digletX = width / 2;        digletY = height / 2;        eye = new Eyes(bodyColor);        mouth = new Mouth(bodyColor);        cheeks = new Cheeks();        ears = new Ears(digletX, digletY, bodyColor);        hair = new Hair(bodyColor);        legs = new Legs(digletX, digletY, bodyColor);        arms = new Arms(bodyColor);        isHurt = false;        isDefensive = false;    }    void display() {        // body        stroke(0, 0, 0);        fill(bodyColor);        pushMatrix();        translate(digletX, digletY);        ellipse(0, 0, 100, 100);        // eyes        eye.display(isHurt, isDefensive);        eye.blink();        // mouth        mouth.display(isHurt, isDefensive, bodyColor);        // cheeks        cheeks.display(isHurt);        // ears        ears.display(0, 0);        // hair        hair.display();        // legs        legs.display(isDefensive);        // hands        arms.display(isDefensive);        popMatrix();    }    void processKey() {        if (key == CODED) {            if (keyCode == RIGHT) {                digletX = digletX + 5;            }            if (keyCode == LEFT) {                digletX = digletX - 5;            }            if (keyCode == UP) {                digletY = digletY - 5;            }            if (keyCode == DOWN) {                digletY = digletY + 5;            }        }    }}',correct
'false',correct
'jig.isHurt',correct
'if (frameCount % 150 == 0) {    fill(bodyColor);    ellipse(-20, -10, 30, 30);    ellipse(+20, -10, 30, 30);}',correct
'class Bubble {    float x = random(width);    float y = random(50, 150);    float yspeed = random(0.2f, 3);    float diam = random(10, 25);    float blue = random(100, 200), green = random(150, 255);    void ascend() {        y = y - yspeed;        if (y < 0) {            y = random(410, 500);        }    }    void show() {        fill(100, green, blue);        ellipse(x, y, diam, diam);    }}',correct
'if (ballY > height && speedY > 0) {    speedY = speedY * (-1);}',correct
'digletX = digletX - 5;',correct
'pink = bodyColor',correct
'cos(i) * 8',correct
'boolean isRosy',correct
'float sizex = random(x - 5, x + 5);',AtLeastOneConstructor
'class Arms {    int bodyColor;    boolean isDefensive;    Arms(int pink) {        bodyColor = pink;    }    void display(boolean isDefensive) {        fill(bodyColor);        if (isDefensive) {            bezier(+50, -10, +80, -20, +80, -20, +45, +15);        } else {            bezier(+50, +10, +60, +30, +60, +30, +40, +25);        }        bezier(-50, +10, -60, +30, -60, +30, -40, +25);    }}',correct
'flower.length',correct
'int digletX, digletY;',correct
'ellipse(+25, -15, 8, 8);',correct
'new SoundFile(this, "jigSong.mp3")',correct
'void processKey() {    if (key == CODED) {        if (keyCode == RIGHT) {            digletX = digletX + 5;        }        if (keyCode == LEFT) {            digletX = digletX - 5;        }        if (keyCode == UP) {            digletY = digletY - 5;        }        if (keyCode == DOWN) {            digletY = digletY + 5;        }    }}',correct
'i = 0',correct
'void show() {    fill(100, green, blue);    ellipse(x, y, diam, diam);}',correct
'stroke(10, 100, 70)',correct
'sin(i)',correct
'stroke(10, 100, 70);',correct
'fill(255, 102, 102);',correct
'boolean hurt;',correct
'{    // body    stroke(0, 0, 0);    fill(bodyColor);    pushMatrix();    translate(digletX, digletY);    ellipse(0, 0, 100, 100);    // eyes    eye.display(isHurt, isDefensive);    eye.blink();    // mouth    mouth.display(isHurt, isDefensive, bodyColor);    // cheeks    cheeks.display(isHurt);    // ears    ears.display(0, 0);    // hair    hair.display();    // legs    legs.display(isDefensive);    // hands    arms.display(isDefensive);    popMatrix();}',correct
'digletY - 55',correct
'if (isDefensive) {    fill(235, 168, 255);    ellipse(-25, +40, 20, 40);} else {    bezier(-30, +40, -55, +50, -50, +70, -10, +50);}',correct
'distance = sqrt(dx * dx + dy * dy)',correct
'blue = random(100, 200)',correct
'{    jig.processKey();    jig.isHurt = true;}',correct
'if (ballX < 0 && speedX < 0) {    speedX = speedX * (-1);}',correct
'fill(255, 255, 255);',correct
'void move() {    if (ballY > height && speedY > 0) {        speedY = speedY * (-1);    }    if (ballY < 0 && speedY < 0) {        speedY = speedY * (-1);    }    if (ballX > width) {        speedX = speedX * (-1);    }    if (ballX < 0 && speedX < 0) {        speedX = speedX * (-1);    }    ballX = ballX + speedX;    ballY = ballY + speedY;}',correct
'digletX + 30',correct
'class Cheeks {    Cheeks() {    // Sorry wont need this    }    void display(boolean isRosy) {        if (isRosy) {            fill(255, 102, 102);            ellipse(+32, +10, 15, 10);            ellipse(-32, +10, 15, 10);        }    }}',correct
'ellipse(-25, +40, 20, 40)',correct
'bezier(-30, +40, -55, +50, -50, +70, -10, +50);',correct
'digletX - 5',correct
'digletY - 45',correct
'y - yspeed',correct
'Mouth mouth;',correct
'ellipse(-15, -15, 8, 8)',correct
'void mouseReleased() {    jig.isDefensive = false;}',correct
'digletX + 48',correct
'ellipse(-15, -15, 8, 8);',correct
'void colide(int digletX, int digletY) {    float dx = digletX - ballX;    float dy = digletY - ballY;    float distance = sqrt(dx * dx + dy * dy);    float minDist = 100 / 2 + 30 / 2;    float angle = atan2(digletX - ballX, digletY - ballY);    if (distance < minDist) {        if (cos(angle) < 0) {            speedX = speedX * (-1);        }        if (sin(angle) < 0) {            speedY = speedY * (-1);        }    }}',correct
'// mouthmouth.display(isHurt, isDefensive, bodyColor);',correct
'int pink',correct
'cheeks',correct
'bezier(digletX + 22, digletY - 45, digletX + 70, digletY - 85, digletX + 50, digletY - 15, digletX + 48, digletY - 13)',correct
'noStroke();',correct
'jig.digletX = mouseX;',correct
'bezier(+5, -47, -30, -80, -40, +5, 0, -15);',PixelHardcodeIgnoranceRule
'ball = new Ball();',correct
'// bubblesbackground(200, 200, 200);',correct
'digletY + 5',correct
'fill(0, 153, 255);',correct
'digletX + 45',correct
'{    for (int i = 0; i < bubbles.length; i++) {        bubbles[i] = new Bubble();    }    for (int i = 0; i < flower.length; i++) flower[i] = new Flowers();    ball = new Ball();    jig = new Jigglypuff();    jigSong = new SoundFile(this, "jigSong.mp3");    jigSong.play();}',correct
'bezier(0, -15, +10, -25, 0, -35, -7, -25)',correct
'pink',correct
'jig.digletX = mouseX',correct
'cheeks = new Cheeks()',correct
'{    bezier(+50, -10, +80, -20, +80, -20, +45, +15);}',correct
'digletY - 35',correct
'{    stroke(0);    fill(240, 0, 0);    ellipse(ballX, ballY, 70, 70);    noStroke();    fill(255, 100, 100);    triangle(ballX, ballY, ballX - 30, ballY - 18, ballX - 7, ballY - 32);}',correct
'jig.processKey()',correct
'isDefensive = false;',correct
'y = y - yspeed',correct
'ellipse(+32, +10, 15, 10)',correct
'keyCode == UP',correct
'bezier(digletX + 30, digletY - 35, digletX + 50, digletY - 55, digletX + 50, digletY - 55, digletX + 45, digletY - 20);',correct
'digletX + 5',correct
'ears.display(0, 0)',correct
'ellipse(-20, -10, 30, 30)',correct
'bezier(digletX + 30, digletY - 35, digletX + 50, digletY - 55, digletX + 50, digletY - 55, digletX + 45, digletY - 20)',correct
'hair.display()',correct
'class Legs {    int pink;    Legs(int x, int y, int bodyColor) {        pink = bodyColor;    }    void display(boolean isDefensive) {        fill(pink);        bezier(+30, +40, +55, +50, +50, +70, +10, +50);        if (isDefensive) {            fill(235, 168, 255);            ellipse(-25, +40, 20, 40);        } else {            bezier(-30, +40, -55, +50, -50, +70, -10, +50);        }    }}',correct
'arc(0, +10, 12, 25, 0, PI, PIE)',correct
'for (int i = 0; i < 8; i++) {    ellipse(sizex + cos(i) * 8, sizey + sin(i) * 8, 10, 10);}',correct
'bezier(+30, +40, +55, +50, +50, +70, +10, +50)',correct
'isDefensive = false',correct
'{    bezier(-30, +40, -55, +50, -50, +70, -10, +50);}',correct
'+5',correct
'class Hair {    int bodyColor;    Hair(int pink) {        bodyColor = pink;    }    void display() {        fill(bodyColor);        bezier(+5, -47, -30, -80, -40, +5, 0, -15);        bezier(0, -15, +10, -25, 0, -35, -7, -25);    }}',correct
'{    ellipse(sizex + cos(i) * 8, sizey + sin(i) * 8, 10, 10);}',correct
'draw',correct
'legs = new Legs(digletX, digletY, bodyColor);',correct
'+7',correct
'digletY - 20',correct
'int y',correct
'void draw() {    background(10, 200, 10);    stroke(0, 0, 0);    // bubbles    background(200, 200, 200);    for (int i = 0; i < bubbles.length; i++) {        bubbles[i].show();        bubbles[i].ascend();    }    // ground    fill(50, 200, 50);    bezier(0, 350, width / 2, 0, width / 2 + 50, 350, width, 300);    bezier(-40, 200, 80, 200, 350, 200, 0, height + height);    bezier(100, height, 280, 200, 350, 100, width + 100, 300);    stroke(50, 200, 50);    ellipse(width, height, 500, 200);    for (int i = 0; i < flower.length; i++) flower[i].display();    // red ball    ball.display();    ball.move();    ball.colide(jig.digletX, jig.digletY);    // my monster    jig.display();}',correct
'ballX + speedX',correct
'new Ears(digletX, digletY, bodyColor)',correct
'int x',correct
'digletX + 22',correct
'digletX = x',correct
'100 / 2',correct
'// earsears.display(0, 0);',correct
'if (distance < minDist) {    if (cos(angle) < 0) {        speedX = speedX * (-1);    }    if (sin(angle) < 0) {        speedY = speedY * (-1);    }}',correct
'30 / 2',correct
'void blink() {    if (frameCount % 150 == 0) {        fill(bodyColor);        ellipse(-20, -10, 30, 30);        ellipse(+20, -10, 30, 30);    }}',correct
'stroke(255, 255, 255)',correct
'PI + PI',correct
'bezier(digletX - 22, digletY - 45, digletX - 70, digletY - 85, digletX - 50, digletY - 15, digletX - 48, digletY - 13)',correct
'ellipse(-20, -10, 30, 30);',correct
'fill(255, 255, 0)',correct
'Legs legs;',correct
'speedY > 0',correct
'digletX = width / 2',correct
'flower[i].display();',correct
'boolean isDefensive;',correct
'sin(i) * 8',correct
'bezier(digletX - 30, digletY - 35, digletX - 50, digletY - 55, digletX - 50, digletY - 55, digletX - 45, digletY - 20)',correct
'y = random(410, 500)',correct
'fill(255, 255, 255)',correct
'fill(pink)',correct
'float dx = digletX - ballX;',correct
'void',correct
'class Mouth {    boolean isHurt, isDefensive;    int bodyColor;    Mouth(int pink) {        bodyColor = pink;    }    void display(boolean isHurt, boolean isDefensive, int pink) {        bodyColor = pink;        if (isHurt || isDefensive) {            stroke(0, 0, 0);            fill(bodyColor);            arc(0, +15, 15, 20, PI, PI + PI, OPEN);        } else {            stroke(0, 0, 0);            fill(255, 77, 77);            arc(0, +10, 12, 25, 0, PI, PIE);        }    }}',correct
'-5',correct
'Arms',correct
'for (int i = 0; i < flower.length; i++) flower[i].display();',correct
'-7',correct
'ellipse(-20, -10, 25, 25)',correct
'{    y = random(410, 500);}',correct
'bezier(digletX + 22, digletY - 45, digletX + 70, digletY - 85, digletX + 50, digletY - 15, digletX + 48, digletY - 13);',correct
'digletY - 85',correct
'jigSong.play()',correct
'if (isDefensive) {    bezier(+50, -10, +80, -20, +80, -20, +45, +15);} else {    bezier(+50, +10, +60, +30, +60, +30, +40, +25);}',correct
'digletX - ballX',correct
'bezier(+5, -47, -30, -80, -40, +5, 0, -15)',correct
'ballX = ballX + speedX;',correct
'{    digletX = digletX - 5;}',correct
'float sizey = random(y - 30, y - 40);',AtLeastOneConstructor
'true',correct
'if (sin(angle) < 0) {    speedY = speedY * (-1);}',correct
'arms',correct
'digletY - 5',correct
'bubbles[i] = new Bubble()',correct
'ellipse(+20, -10, 19, 19)',correct
'bezier(-5, -20, -7, -15, -7, -15, -30, -35);',correct
'jig.isHurt = false',correct
'// right eyestroke(0);',correct
'void display(boolean isDefensive) {    fill(bodyColor);    if (isDefensive) {        bezier(+50, -10, +80, -20, +80, -20, +45, +15);    } else {        bezier(+50, +10, +60, +30, +60, +30, +40, +25);    }    bezier(-50, +10, -60, +30, -60, +30, -40, +25);}',correct
'// legslegs.display(isDefensive);',correct
'popMatrix()',correct
'ellipse(0, 0, 100, 100);',correct
'jig.isHurt = true;',correct
'bezier(100, height, 280, 200, 350, 100, width + 100, 300);',correct
'arc(0, +10, 12, 25, 0, PI, PIE);',correct
'{    fill(bodyColor);    ellipse(-20, -10, 30, 30);    ellipse(+20, -10, 30, 30);}',correct
'ball',correct
'// cheekscheeks.display(isHurt);',correct
'bezier(+5, -20, +7, -15, +7, -15, +30, -35);',correct
'class Eyes {    boolean isHurt, isDefensive;    int bodyColor;    Eyes(int pink) {        bodyColor = pink;    }    void display(boolean isHurt, boolean isDefensive) {        // left eye        fill(255, 255, 255);        ellipse(-20, -10, 30, 30);        stroke(255, 255, 255);        fill(0, 153, 255);        ellipse(-20, -10, 25, 25);        stroke(0, 153, 255);        fill(0, 0, 0);        ellipse(-20, -10, 19, 19);        stroke(255, 255, 255);        fill(255, 255, 255);        ellipse(-15, -15, 8, 8);        // right eye        stroke(0);        fill(255, 255, 255);        ellipse(+20, -10, 30, 30);        stroke(255, 255, 255);        fill(0, 153, 255);        ellipse(+20, -10, 25, 25);        stroke(0, 153, 255);        fill(0, 0, 0);        ellipse(+20, -10, 19, 19);        stroke(255, 255, 255);        fill(255, 255, 255);        ellipse(+25, -15, 8, 8);        if (isDefensive) {            stroke(0, 0, 0);            fill(bodyColor);            bezier(+5, -20, +7, -15, +7, -15, +30, -35);            bezier(-5, -20, -7, -15, -7, -15, -30, -35);        }        if (isHurt) {            stroke(0, 0, 0);            fill(bodyColor);            bezier(+15, -30, +7, -25, +10, -25, +40, -18);            bezier(-15, -30, -7, -25, -10, -25, -40, -18);        }    }    void blink() {        if (frameCount % 150 == 0) {            fill(bodyColor);            ellipse(-20, -10, 30, 30);            ellipse(+20, -10, 30, 30);        }    }}',correct
'speedY = 3',correct
'new Legs(digletX, digletY, bodyColor)',correct
'stroke(0, 0, 0);',correct
'digletX = width / 2;',correct
'Ears ears;',correct
'float angle = atan2(digletX - ballX, digletY - ballY);',correct
'ball.move();',correct
'arms = new Arms(bodyColor);',correct
'{    digletX = digletX + 5;}',correct
'fill(255, 77, 77)',correct
'bezier(+50, +10, +60, +30, +60, +30, +40, +25)',correct
'"jigSong.mp3"',correct
'ellipse(+20, -10, 19, 19);',correct
'fill(255, 100, 100)',correct
'class Ball {    float ballX = width / 2, ballY = height / 2;    void display() {        stroke(0);        fill(240, 0, 0);        ellipse(ballX, ballY, 70, 70);        noStroke();        fill(255, 100, 100);        triangle(ballX, ballY, ballX - 30, ballY - 18, ballX - 7, ballY - 32);    }    float speedX = 2, speedY = 3;    void move() {        if (ballY > height && speedY > 0) {            speedY = speedY * (-1);        }        if (ballY < 0 && speedY < 0) {            speedY = speedY * (-1);        }        if (ballX > width) {            speedX = speedX * (-1);        }        if (ballX < 0 && speedX < 0) {            speedX = speedX * (-1);        }        ballX = ballX + speedX;        ballY = ballY + speedY;    }    void colide(int digletX, int digletY) {        float dx = digletX - ballX;        float dy = digletY - ballY;        float distance = sqrt(dx * dx + dy * dy);        float minDist = 100 / 2 + 30 / 2;        float angle = atan2(digletX - ballX, digletY - ballY);        if (distance < minDist) {            if (cos(angle) < 0) {                speedX = speedX * (-1);            }            if (sin(angle) < 0) {                speedY = speedY * (-1);            }        }    }}',correct
'Eyes eye;',correct
'digletY = y',correct
'jig.digletY',correct
'Ball ball;',correct
'jig.isHurt = false;',correct
'jig.digletX',correct
'flower[i].display()',correct
'dy = digletY - ballY',correct
'ears = new Ears(digletX, digletY, bodyColor);',correct
'isHurt',correct
'ball.display()',correct
'class Ears {    int digletX, digletY;    int bodyColor;    Ears(int x, int y, int pink) {        digletX = x;        digletY = y;        bodyColor = pink;    }    void display(int x, int y) {        digletX = x;        digletY = y;        fill(bodyColor);        bezier(digletX + 22, digletY - 45, digletX + 70, digletY - 85, digletX + 50, digletY - 15, digletX + 48, digletY - 13);        bezier(digletX - 22, digletY - 45, digletX - 70, digletY - 85, digletX - 50, digletY - 15, digletX - 48, digletY - 13);        fill(73, 61, 41);        bezier(digletX + 30, digletY - 35, digletX + 50, digletY - 55, digletX + 50, digletY - 55, digletX + 45, digletY - 20);        bezier(digletX - 30, digletY - 35, digletX - 50, digletY - 55, digletX - 50, digletY - 55, digletX - 45, digletY - 20);    }}',correct
'ears = new Ears(digletX, digletY, bodyColor)',correct
'{    fill(bodyColor);    bezier(+5, -47, -30, -80, -40, +5, 0, -15);    bezier(0, -15, +10, -25, 0, -35, -7, -25);}',correct
'Ball',correct
'random(width)',correct
'Hair hair;',correct
'float dx = digletX - ballX',correct
'bezier(-50, +10, -60, +30, -60, +30, -40, +25);',correct
'int pink;',correct
'new Arms(bodyColor)',correct
'if (isRosy) {    fill(255, 102, 102);    ellipse(+32, +10, 15, 10);    ellipse(-32, +10, 15, 10);}',correct
'float minDist = 100 / 2 + 30 / 2',correct
'{    speedX = speedX * (-1);}',correct
'color(255, 198, 249)',correct
'speedX * (-1)',correct
'void keyReleased() {    jig.isHurt = false;}',correct
'new Eyes(bodyColor)',correct
'ellipse(width, height, 500, 200)',correct
'if (keyCode == DOWN) {    digletY = digletY + 5;}',correct
'100 / 2 + 30 / 2',correct
'float dy = digletY - ballY;',correct
'Hair(int pink) {    bodyColor = pink;}',correct
'boolean isDefensive',correct
'dx * dx + dy * dy',correct
'fill(50, 200, 50)',correct
'bubbles[i]',correct
'eye = new Eyes(bodyColor)',correct
'y = random(50, 150)',correct
'y - 30',correct
'if (ballY < 0 && speedY < 0) {    speedY = speedY * (-1);}',correct
'pushMatrix();',correct
'void mouseDragged() {    jig.digletX = mouseX;    jig.digletY = mouseY;}',correct
'jig = new Jigglypuff();',correct
'cheeks = new Cheeks();',correct
'bezier(0, 350, width / 2, 0, width / 2 + 50, 350, width, 300)',correct
'eye',correct
'bezier(digletX - 30, digletY - 35, digletX - 50, digletY - 55, digletX - 50, digletY - 55, digletX - 45, digletY - 20);',correct
'fill(240, 0, 0)',correct
'random(height - 170, height)',correct
'digletX = x;',correct
'minDist = 100 / 2 + 30 / 2',correct
'random(x - 5, x + 5)',correct
'{    if (key == CODED) {        if (keyCode == RIGHT) {            digletX = digletX + 5;        }        if (keyCode == LEFT) {            digletX = digletX - 5;        }        if (keyCode == UP) {            digletY = digletY - 5;        }        if (keyCode == DOWN) {            digletY = digletY + 5;        }    }}',correct
'ballX < 0',correct
'fill(pink);',correct
'Jigglypuff jig;',correct
'bubbles[i] = new Bubble();',correct
'bodyColor = pink;',correct
'translate(digletX, digletY)',correct
'ballX - 7',correct
'float diam = random(10, 25);',correct
'Arms arms;',correct
'{    y = y - yspeed;    if (y < 0) {        y = random(410, 500);    }}',correct
'{    if (cos(angle) < 0) {        speedX = speedX * (-1);    }    if (sin(angle) < 0) {        speedY = speedY * (-1);    }}',correct
'bezier(+50, -10, +80, -20, +80, -20, +45, +15);',correct
'ellipse(-20, -10, 19, 19);',correct
'{    bodyColor = pink;    if (isHurt || isDefensive) {        stroke(0, 0, 0);        fill(bodyColor);        arc(0, +15, 15, 20, PI, PI + PI, OPEN);    } else {        stroke(0, 0, 0);        fill(255, 77, 77);        arc(0, +10, 12, 25, 0, PI, PIE);    }}',correct
'bezier(+30, +40, +55, +50, +50, +70, +10, +50);',correct
'ellipse(+20, -10, 25, 25)',correct
'bezier(+5, -20, +7, -15, +7, -15, +30, -35)',correct
'speedY = speedY * (-1)',correct
'void mousePressed() {    jig.isDefensive = true;}',correct
'width + 100',correct
'ellipse(-20, -10, 19, 19)',correct
'{    digletX = x;    digletY = y;    fill(bodyColor);    bezier(digletX + 22, digletY - 45, digletX + 70, digletY - 85, digletX + 50, digletY - 15, digletX + 48, digletY - 13);    bezier(digletX - 22, digletY - 45, digletX - 70, digletY - 85, digletX - 50, digletY - 15, digletX - 48, digletY - 13);    fill(73, 61, 41);    bezier(digletX + 30, digletY - 35, digletX + 50, digletY - 55, digletX + 50, digletY - 55, digletX + 45, digletY - 20);    bezier(digletX - 30, digletY - 35, digletX - 50, digletY - 55, digletX - 50, digletY - 55, digletX - 45, digletY - 20);}',correct
'{    if (isRosy) {        fill(255, 102, 102);        ellipse(+32, +10, 15, 10);        ellipse(-32, +10, 15, 10);    }}',correct
'{    jig.isDefensive = false;}',correct
'ballY = ballY + speedY;',correct
'ball.colide(jig.digletX, jig.digletY);',correct
'popMatrix();',correct
'void display(boolean isDefensive) {    fill(pink);    bezier(+30, +40, +55, +50, +50, +70, +10, +50);    if (isDefensive) {        fill(235, 168, 255);        ellipse(-25, +40, 20, 40);    } else {        bezier(-30, +40, -55, +50, -50, +70, -10, +50);    }}',correct
'eye.blink()',correct
'bezier(+15, -30, +7, -25, +10, -25, +40, -18);',correct
'digletY = height / 2;',correct
'Flowers[] flower = new Flowers[100];',correct
'random(50, 170)',correct
'SoundFile jigSong;',correct
'void display() {    fill(bodyColor);    bezier(+5, -47, -30, -80, -40, +5, 0, -15);    bezier(0, -15, +10, -25, 0, -35, -7, -25);}',correct
'[100]',correct
'noStroke()',correct
'arms.display(isDefensive)',correct
'ballY < 0',correct
'for (int i = 0; i < bubbles.length; i++) {    bubbles[i].show();    bubbles[i].ascend();}',correct
'[60]',correct
'ballY = height / 2',correct
'jig.isDefensive = true',correct
'digletY - 15',correct
'digletY - 13',correct
'fill(235, 168, 255);',correct
'{    // pink    bodyColor = color(255, 198, 249);    digletX = width / 2;    digletY = height / 2;    eye = new Eyes(bodyColor);    mouth = new Mouth(bodyColor);    cheeks = new Cheeks();    ears = new Ears(digletX, digletY, bodyColor);    hair = new Hair(bodyColor);    legs = new Legs(digletX, digletY, bodyColor);    arms = new Arms(bodyColor);    isHurt = false;    isDefensive = false;}',correct
'speedX = speedX * (-1);',correct
'// petalsnoStroke();',correct
'{    digletX = x;    digletY = y;    bodyColor = pink;}',correct
'int digletY',correct
'int digletX',correct
'{    stroke(0, 0, 0);    fill(bodyColor);    arc(0, +15, 15, 20, PI, PI + PI, OPEN);}',correct
'void display(boolean isHurt, boolean isDefensive) {    // left eye    fill(255, 255, 255);    ellipse(-20, -10, 30, 30);    stroke(255, 255, 255);    fill(0, 153, 255);    ellipse(-20, -10, 25, 25);    stroke(0, 153, 255);    fill(0, 0, 0);    ellipse(-20, -10, 19, 19);    stroke(255, 255, 255);    fill(255, 255, 255);    ellipse(-15, -15, 8, 8);    // right eye    stroke(0);    fill(255, 255, 255);    ellipse(+20, -10, 30, 30);    stroke(255, 255, 255);    fill(0, 153, 255);    ellipse(+20, -10, 25, 25);    stroke(0, 153, 255);    fill(0, 0, 0);    ellipse(+20, -10, 19, 19);    stroke(255, 255, 255);    fill(255, 255, 255);    ellipse(+25, -15, 8, 8);    if (isDefensive) {        stroke(0, 0, 0);        fill(bodyColor);        bezier(+5, -20, +7, -15, +7, -15, +30, -35);        bezier(-5, -20, -7, -15, -7, -15, -30, -35);    }    if (isHurt) {        stroke(0, 0, 0);        fill(bodyColor);        bezier(+15, -30, +7, -25, +10, -25, +40, -18);        bezier(-15, -30, -7, -25, -10, -25, -40, -18);    }}',correct
'hair = new Hair(bodyColor)',correct
'ballX - 30',correct
'float blue = random(100, 200), green = random(150, 255);',correct
'jig.isDefensive = false;',correct
'new Cheeks()',correct
'cos(angle) < 0',correct
'random(10, 25)',correct
'bubbles = new Bubble[60]',correct
'flower = new Flowers[100]',correct
'float speedX = 2, speedY = 3;',FieldDeclarationsShouldBeAtStartOfClass
'ellipse(-20, -10, 25, 25);',correct
'jig = new Jigglypuff()',correct
'this',correct
'eye.display(isHurt, isDefensive)',correct
'key == CODED',correct
'new Flowers[100]',correct
'if (y < 0) {    y = random(410, 500);}',correct
'y = random(410, 500);',correct
'bubbles[i].show()',correct
'bezier(+50, +10, +60, +30, +60, +30, +40, +25);',correct
'Bubble[] bubbles = new Bubble[60];',correct
'height / 2',correct
'legs = new Legs(digletX, digletY, bodyColor)',correct
'dy * dy',correct
'{    pink = bodyColor;}',correct
'ballX < 0 && speedX < 0',correct
'ballY - 32',correct
'if (isDefensive) {    stroke(0, 0, 0);    fill(bodyColor);    bezier(+5, -20, +7, -15, +7, -15, +30, -35);    bezier(-5, -20, -7, -15, -7, -15, -30, -35);}',correct
'ellipse(sizex + cos(i) * 8, sizey + sin(i) * 8, 10, 10);',correct
'// pinkbodyColor = color(255, 198, 249);',correct
'ball = new Ball()',correct
'isDefensive',correct
'ballY - 18',correct
'triangle(ballX, ballY, ballX - 30, ballY - 18, ballX - 7, ballY - 32);',correct
'y - 40',correct
'int bodyColor;',correct
'jig.isHurt = true',correct
'void display(boolean isHurt, boolean isDefensive, int pink) {    bodyColor = pink;    if (isHurt || isDefensive) {        stroke(0, 0, 0);        fill(bodyColor);        arc(0, +15, 15, 20, PI, PI + PI, OPEN);    } else {        stroke(0, 0, 0);        fill(255, 77, 77);        arc(0, +10, 12, 25, 0, PI, PIE);    }}',correct
'void setup() {    for (int i = 0; i < bubbles.length; i++) {        bubbles[i] = new Bubble();    }    for (int i = 0; i < flower.length; i++) flower[i] = new Flowers();    ball = new Ball();    jig = new Jigglypuff();    jigSong = new SoundFile(this, "jigSong.mp3");    jigSong.play();}',correct
'new Ball()',correct
'eye = new Eyes(bodyColor);',correct
'void display(int x, int y) {    digletX = x;    digletY = y;    fill(bodyColor);    bezier(digletX + 22, digletY - 45, digletX + 70, digletY - 85, digletX + 50, digletY - 15, digletX + 48, digletY - 13);    bezier(digletX - 22, digletY - 45, digletX - 70, digletY - 85, digletX - 50, digletY - 15, digletX - 48, digletY - 13);    fill(73, 61, 41);    bezier(digletX + 30, digletY - 35, digletX + 50, digletY - 55, digletX + 50, digletY - 55, digletX + 45, digletY - 20);    bezier(digletX - 30, digletY - 35, digletX - 50, digletY - 55, digletX - 50, digletY - 55, digletX - 45, digletY - 20);}',correct
'random(100, 200)',correct
'new Flowers()',correct
'digletY - ballY',correct
'ellipse(+32, +10, 15, 10);',correct
'{    fill(255, 102, 102);    ellipse(+32, +10, 15, 10);    ellipse(-32, +10, 15, 10);}',correct
'jig.digletY = mouseY;',correct
'int i = 0',correct
'mouth',correct
'ellipse(ballX, ballY, 70, 70)',correct
'int flowercolor = color(random(0, 255), random(0, 100), random(50, 170));',correct
'ballY > height',correct
'sqrt(dx * dx + dy * dy)',correct
'ellipse(+20, -10, 30, 30);',correct
'Eyes(int pink) {    bodyColor = pink;}',correct
'random(50, 150)',correct
'fill(255, 77, 77);',correct
'height + height',correct
'sizex + cos(i) * 8',correct
'stroke(50, 200, 50);',correct
'pink = bodyColor;',correct
'jig',correct
'bezier(+50, -10, +80, -20, +80, -20, +45, +15)',correct
'if (keyCode == LEFT) {    digletX = digletX - 5;}',correct
'-10',correct
'i < flower.length',correct
'flower[i] = new Flowers();',correct
'yspeed = random(0.2f, 3)',correct
'-15',correct
'Mouth(int pink) {    bodyColor = pink;}',correct
'speedY * (-1)',correct
'-18',correct
'void display() {    stroke(10, 100, 70);    line(x, y, sizex, sizey);    // petals    noStroke();    fill(flowercolor);    for (int i = 0; i < 8; i++) {        ellipse(sizex + cos(i) * 8, sizey + sin(i) * 8, 10, 10);    }    fill(255, 255, 0);    ellipse(sizex, sizey, 8, 8);}',AtLeastOneConstructor
'float distance = sqrt(dx * dx + dy * dy);',correct
'Bubble[]',correct
'boolean isHurt',LongMethodRule
'{    bodyColor = pink;}',correct
'digletY = y;',correct
'sin(angle) < 0',correct
'jig.processKey();',correct
'if (keyCode == RIGHT) {    digletX = digletX + 5;}',correct
'mouth.display(isHurt, isDefensive, bodyColor)',correct
'dx = digletX - ballX',correct
'keyCode == LEFT',correct
'// bodystroke(0, 0, 0);',correct
'Ears(int x, int y, int pink) {    digletX = x;    digletY = y;    bodyColor = pink;}',correct
'bezier(-15, -30, -7, -25, -10, -25, -40, -18)',correct
'-20',correct
'speedY = speedY * (-1);',correct
'-25',correct
'ballY < 0 && speedY < 0',correct
'{    stroke(0, 0, 0);    fill(bodyColor);    bezier(+15, -30, +7, -25, +10, -25, +40, -18);    bezier(-15, -30, -7, -25, -10, -25, -40, -18);}',correct
'void display(boolean isRosy) {    if (isRosy) {        fill(255, 102, 102);        ellipse(+32, +10, 15, 10);        ellipse(-32, +10, 15, 10);    }}',StatelessClassRule
'background(200, 200, 200)',correct
'{    bezier(+50, +10, +60, +30, +60, +30, +40, +25);}',correct
'// handsarms.display(isDefensive);',correct
'bodyColor = color(255, 198, 249)',correct
'-30',correct
'-32',correct
'hair = new Hair(bodyColor);',correct
'jig.isDefensive = false',correct
'-35',correct
'stroke(50, 200, 50)',correct
'y = y - yspeed;',correct
'{    digletY = digletY + 5;}',correct
'bezier(0, -15, +10, -25, 0, -35, -7, -25);',PixelHardcodeIgnoranceRule
'mouth = new Mouth(bodyColor)',correct
'fill(0, 153, 255)',correct
'mouth = new Mouth(bodyColor);',correct
'background(10, 200, 10)',correct
'ball.colide(jig.digletX, jig.digletY)',correct
'float dy = digletY - ballY',correct
'digletY = height / 2',correct
'sizey + sin(i) * 8',correct
'green = random(150, 255)',correct
'keyCode == RIGHT',correct
'Jigglypuff',correct
'cos(i)',correct
'ellipse(-25, +40, 20, 40);',correct
'fill(flowercolor)',correct
'digletY = digletY + 5',correct
'display',LongMethodRule
'bezier(-50, +10, -60, +30, -60, +30, -40, +25)',correct
'-40',correct
'bodyColor = pink',correct
'-47',correct
'Cheeks() {// Sorry wont need this}',StatelessClassRule
'x + 5',correct
'bezier(-40, 200, 80, 200, 350, 200, 0, height + height)',correct
'bezier(digletX - 22, digletY - 45, digletX - 70, digletY - 85, digletX - 50, digletY - 15, digletX - 48, digletY - 13);',correct
'float ballX = width / 2, ballY = height / 2;',correct
'cos(angle)',correct
'ellipse(x, y, diam, diam);',correct
'isHurt || isDefensive',correct
'i++',correct
'-50',correct
'sin(angle)',correct
'+10',correct
'fill(255, 100, 100);',correct
'-55',correct
'ellipse(-32, +10, 15, 10);',correct
'width / 2 + 50',correct
'+15',correct
'ball.move()',correct
'bezier(-5, -20, -7, -15, -7, -15, -30, -35)',correct
'Bubble',correct
'for (int i = 0; i < bubbles.length; i++) {    bubbles[i] = new Bubble();}',correct
'y = random(height - 170, height)',correct
'jig.digletY = mouseY',correct
'new Jigglypuff()',correct
'keyCode == DOWN',correct
'jigSong.play();',correct
'{    jig.digletX = mouseX;    jig.digletY = mouseY;}',correct
'// hairhair.display();',correct
'y < 0',correct
'new Mouth(bodyColor)',correct
'keyPressed',correct
'fill(100, green, blue);',correct
'ballY = ballY + speedY',correct
'-60',correct
'+20',correct
'random(0.2f, 3)',correct
'{    fill(bodyColor);    if (isDefensive) {        bezier(+50, -10, +80, -20, +80, -20, +45, +15);    } else {        bezier(+50, +10, +60, +30, +60, +30, +40, +25);    }    bezier(-50, +10, -60, +30, -60, +30, -40, +25);}',correct
'+25',correct
'float y = random(height - 170, height);',AtLeastOneConstructor
'{    fill(pink);    bezier(+30, +40, +55, +50, +50, +70, +10, +50);    if (isDefensive) {        fill(235, 168, 255);        ellipse(-25, +40, 20, 40);    } else {        bezier(-30, +40, -55, +50, -50, +70, -10, +50);    }}',correct
'new Hair(bodyColor)',correct
'fill(100, green, blue)',correct
'random(150, 255)',correct
'ellipse(ballX, ballY, 70, 70);',correct
'Cheeks cheeks;',correct
'fill(255, 255, 0);',correct
'// groundfill(50, 200, 50);',correct
'ellipse(width, height, 500, 200);',correct
'random(y - 30, y - 40)',correct
'fill(240, 0, 0);',correct
'float minDist = 100 / 2 + 30 / 2;',correct
'Legs(int x, int y, int bodyColor) {    pink = bodyColor;}',UnusedFormalParameter
'{    fill(100, green, blue);    ellipse(x, y, diam, diam);}',correct
'bodyColor',correct
'digletX - 70',correct
'// my monsterjig.display();',correct
'jig.display()',correct
'+30',correct
'+32',correct
'color(random(0, 255), random(0, 100), random(50, 170))',correct
'fill(0, 0, 0);',correct
'bezier(-40, 200, 80, 200, 350, 200, 0, height + height);',correct
'background(10, 200, 10);',correct
'digletX = digletX + 5',correct
'hair',correct
'void display() {    stroke(0);    fill(240, 0, 0);    ellipse(ballX, ballY, 70, 70);    noStroke();    fill(255, 100, 100);    triangle(ballX, ballY, ballX - 30, ballY - 18, ballX - 7, ballY - 32);}',correct
'cheeks.display(isHurt)',correct
'triangle(ballX, ballY, ballX - 30, ballY - 18, ballX - 7, ballY - 32)',correct
'digletY',correct
'Ears',correct
'float yspeed = random(0.2f, 3);',correct
'digletX',correct
'-80',correct
'translate(digletX, digletY);',correct
'+40',correct
'digletY = digletY + 5;',correct
'bezier(-30, +40, -55, +50, -50, +70, -10, +50)',correct
'ballY + speedY',correct
'float angle = atan2(digletX - ballX, digletY - ballY)',correct
'+45',correct
'x - 5',correct
'width / 2',correct
'ears',correct
'int bodyColor',correct
'ellipse(+20, -10, 30, 30)',correct
'isHurt = false;',correct
'{    stroke(10, 100, 70);    line(x, y, sizex, sizey);    // petals    noStroke();    fill(flowercolor);    for (int i = 0; i < 8; i++) {        ellipse(sizex + cos(i) * 8, sizey + sin(i) * 8, 10, 10);    }    fill(255, 255, 0);    ellipse(sizex, sizey, 8, 8);}',correct
'width / 2 + 3',correct
'foxLeft.foxSpeed();',correct
'rect(creatureX, creatureY + 45, 100, 110)',correct
'width / 2 + 12',correct
'image(honey, width / 2 - 93, height - 200, 70, 70)',correct
'creatureX = width / 2',correct
'image(honey, width / 2 + 41, height - 200, 70, 70);',correct
'rect(creatureX - 40, creatureY + 150, 45, 60);',correct
'void foxSpeed() {    if (keyPressed && key ==   && creatureX - foxX < 180 && foxX - creatureX < 200 && foxSpeed < 0) {        foxSpeed = -foxSpeed * 3;    }    if (foxX < width / 2 + 200) {        foxSpeed = -foxSpeed * 2;    }    if (foxX > width + 800 && foxSpeed > 0) {        foxSpeed = -foxSpeed / 3 * 1.1f;        if (foxSpeed < -16) {            foxSpeed = -5;        }    }}',correct
'PImage bg;',correct
'imgY - 120',correct
'rect(creatureX, creatureY - 40, 18, 6);',correct
'rect(foxX + 157, foxY - 32, 16, 25)',correct
'foxSpeed = -foxSpeed * 3;',correct
'// arms',correct
'file = new SoundFile(this, "Roar.mp3");',correct
'imgX = imgX - 220',correct
'{    foxX = -400;    foxY = height - 180;    imgX = width / 2 + 70;    imgY = height - 200;    foxSpeed = 4;    imgSpeed = 0;}',correct
'rect(creatureX, creatureY + 75, 60, 61);',correct
'bg = loadImage("bg.png")',correct
'stroke(0);',correct
'',correct
'stroke(0)',correct
'foxY + 55',correct
'rect(creatureX + 84, creatureY - 108, 33, 33);',correct
'rect(foxX - 100, foxY - 55, 70, 70)',correct
'rect(foxX + 85, foxY + 80, 30, 90)',correct
'rect(creatureX - 74, creatureY + 103, 3, 12);',correct
'width + 800',correct
'quad(creatureX + 50, creatureY + 10, creatureX + 80, creatureY + 10, creatureX + 90, creatureY + 100, creatureX + 60, creatureY + 100);',correct
'foxY + 50',correct
'width / 2 - 130',correct
'triangle(creatureX + 93, creatureY - 120, creatureX + 100, creatureY - 115, creatureX + 103, creatureY - 131);',correct
'line(foxX - 98, foxY - 115, foxX - 83, foxY - 80);',correct
'creatureX - 200',correct
'quad(creatureX - 47, creatureY - 8, creatureX - 62, creatureY + 30, creatureX - 100, creatureY - 100, creatureX - 70, creatureY - 115);',correct
'triangle(creatureX + 70, creatureY - 122, creatureX + 80, creatureY - 122, creatureX + 74, creatureY - 133);',correct
'foxSpeed = -foxSpeed * 2;',correct
'creatureY + 150',correct
'bg',correct
'foxRight.foxSpeed();',correct
'creatureX',correct
'stroke(bodyColor)',correct
'triangle(creatureX + 15, creatureY - 18, creatureX + 10, creatureY - 18, creatureX + 12, creatureY - 24)',correct
'fill(0);',correct
'creatureY',correct
'creatureX + 5',correct
'rect(creatureX, creatureY - 34, 6, 6);',correct
'fill(229, 142, 55)',correct
'creatureX + 7',correct
'rect(creatureX + 18, creatureY - 64, 6, 6)',correct
'rect(creatureX + 30, creatureY + 174, 3, 12);',correct
'foxLeft.move()',correct
'image(honey, width / 2 - 130, height - 140, 70, 70);',correct
'rect(creatureX - 83, creatureY - 108, 33, 33);',correct
'creatureX + 2',correct
'foxRight.display();',correct
'new SoundFile(this, "Roar.mp3")',correct
'rectMode(CENTER)',correct
'foxY + 75',correct
'rect(creatureX, creatureY - 50, 75, 60)',correct
'rect(creatureX, creatureY - 40, 18, 6)',correct
'{    foxSpeed = -foxSpeed * 3;}',correct
'SoundFile',correct
'rect(foxX - 68, foxY + 80, 30, 90)',correct
'width / 2 + 41',correct
'{    if (key ==  ) {        file.play();    }}',correct
'triangle(creatureX + 69, creatureY - 106, creatureX + 69, creatureY - 118, creatureX + 58, creatureY - 120)',correct
'image(honey, width / 2 - 63, height - 140, 70, 70);',correct
'void draw() {    background(bg);    foxLeft.display();    foxLeft.move();    foxLeft.foxSpeed();    foxRight.display();    foxRight.move();    foxRight.foxSpeed();    // honey    image(honey, width / 2 + 70, height - 140, 70, 70);    image(honey, width / 2 - 130, height - 140, 70, 70);    image(honey, width / 2 - 63, height - 140, 70, 70);    image(honey, width / 2 + 3, height - 140, 70, 70);    image(honey, width / 2 - 93, height - 200, 70, 70);    image(honey, width / 2 - 26, height - 200, 70, 70);    image(honey, width / 2 + 41, height - 200, 70, 70);    image(honey, width / 2 + 12, height - 260, 70, 70);    image(honey, width / 2 - 51, height - 260, 70, 70);    if (keyPressed && key ==  ) {        stroke(bodyColor);        strokeWeight(1);        fill(bodyColor);        rect(creatureX, creatureY - 50, 75, 60);        rect(creatureX, creatureY - 17, 60, 5);        rect(creatureX, creatureY - 12, 50, 5);        rect(creatureX - 33, creatureY - 74, 25, 25);        rect(creatureX + 33, creatureY - 74, 25, 25);        stroke(219, 173, 138);        fill(219, 173, 138);        rect(creatureX, creatureY - 31, 42, 24);        rect(creatureX, creatureY - 26, 34, 24);        stroke(0);        fill(175, 26, 28);        rect(creatureX, creatureY - 26, 32, 16);        stroke(0);        fill(0);        rect(creatureX, creatureY - 40, 18, 6);        rect(creatureX, creatureY - 34, 6, 6);        rect(creatureX - 18, creatureY - 64, 8, 8);        rect(creatureX + 18, creatureY - 64, 8, 8);        stroke(219, 173, 138);        fill(219, 173, 138);        rect(creatureX - 34, creatureY - 75, 13, 13);        rect(creatureX + 34, creatureY - 75, 13, 13);        stroke(0);        fill(255);        triangle(creatureX - 10, creatureY - 34, creatureX - 15, creatureY - 34, creatureX - 13, creatureY - 28);        triangle(creatureX - 5, creatureY - 34, creatureX - 10, creatureY - 34, creatureX - 8, creatureY - 28);        triangle(creatureX, creatureY - 34, creatureX - 5, creatureY - 34, creatureX - 3, creatureY - 28);        triangle(creatureX + 5, creatureY - 34, creatureX, creatureY - 34, creatureX + 2, creatureY - 28);        triangle(creatureX + 10, creatureY - 34, creatureX + 5, creatureY - 34, creatureX + 7, creatureY - 28);        triangle(creatureX + 15, creatureY - 34, creatureX + 10, creatureY - 34, creatureX + 12, creatureY - 28);        triangle(creatureX - 10, creatureY - 18, creatureX - 15, creatureY - 18, creatureX - 13, creatureY - 24);        triangle(creatureX - 5, creatureY - 18, creatureX - 10, creatureY - 18, creatureX - 8, creatureY - 24);        triangle(creatureX, creatureY - 18, creatureX - 5, creatureY - 18, creatureX - 3, creatureY - 24);        triangle(creatureX + 5, creatureY - 18, creatureX, creatureY - 18, creatureX + 2, creatureY - 24);        triangle(creatureX + 10, creatureY - 18, creatureX + 5, creatureY - 18, creatureX + 7, creatureY - 24);        triangle(creatureX + 15, creatureY - 18, creatureX + 10, creatureY - 18, creatureX + 12, creatureY - 24);    } else {        stroke(bodyColor);        strokeWeight(1);        fill(bodyColor);        rect(creatureX, creatureY - 50, 75, 60);        rect(creatureX, creatureY - 17, 60, 5);        rect(creatureX, creatureY - 12, 50, 5);        rect(creatureX - 33, creatureY - 74, 25, 25);        rect(creatureX + 33, creatureY - 74, 25, 25);        stroke(219, 173, 138);        fill(219, 173, 138);        rect(creatureX, creatureY - 28, 42, 20);        stroke(0);        fill(0);        rect(creatureX, creatureY - 35, 18, 6);        rect(creatureX, creatureY - 29, 6, 6);        rect(creatureX - 18, creatureY - 64, 6, 6);        rect(creatureX + 18, creatureY - 64, 6, 6);        stroke(219, 173, 138);        fill(219, 173, 138);        rect(creatureX - 34, creatureY - 75, 13, 13);        rect(creatureX + 34, creatureY - 75, 13, 13);    }    // body    stroke(bodyColor);    fill(bodyColor);    rect(creatureX, creatureY + 65, 125, 110);    rect(creatureX, creatureY + 55, 110, 110);    rect(creatureX, creatureY + 45, 100, 110);    rect(creatureX, creatureY + 75, 135, 75);    rect(creatureX, creatureY + 88, 100, 75);    stroke(219, 173, 138);    fill(219, 173, 138);    rect(creatureX, creatureY + 75, 85, 50);    rect(creatureX, creatureY + 75, 60, 61);    rect(creatureX, creatureY + 75, 95, 40);    // legs    stroke(bodyColor);    fill(bodyColor);    rect(creatureX - 40, creatureY + 150, 45, 60);    rect(creatureX + 40, creatureY + 150, 45, 60);    stroke(bodyColor);    fill(219, 173, 138);    rect(creatureX - 40, creatureY + 170, 35, 20);    rect(creatureX + 40, creatureY + 170, 35, 20);    fill(0);    rect(creatureX + 51, creatureY + 174, 3, 12);    rect(creatureX + 44, creatureY + 174, 3, 12);    rect(creatureX + 37, creatureY + 174, 3, 12);    rect(creatureX + 30, creatureY + 174, 3, 12);    rect(creatureX - 51, creatureY + 174, 3, 12);    rect(creatureX - 44, creatureY + 174, 3, 12);    rect(creatureX - 37, creatureY + 174, 3, 12);    rect(creatureX - 30, creatureY + 174, 3, 12);    if (keyPressed && key ==  ) {        stroke(0);        strokeWeight(1);        fill(bodyColor);        quad(creatureX - 47, creatureY - 8, creatureX - 62, creatureY + 30, creatureX - 100, creatureY - 100, creatureX - 70, creatureY - 115);        quad(creatureX + 47, creatureY - 8, creatureX + 62, creatureY + 30, creatureX + 100, creatureY - 100, creatureX + 70, creatureY - 115);        stroke(bodyColor);        fill(bodyColor);        rect(creatureX - 83, creatureY - 108, 33, 33);        rect(creatureX + 84, creatureY - 108, 33, 33);        stroke(219, 173, 138);        fill(219, 173, 138);        rect(creatureX - 83, creatureY - 106, 20, 16);        rect(creatureX + 83, creatureY - 106, 20, 16);        stroke(0);        fill(255);        triangle(creatureX - 69, creatureY - 106, creatureX - 69, creatureY - 118, creatureX - 58, creatureY - 120);        triangle(creatureX - 70, creatureY - 122, creatureX - 80, creatureY - 122, creatureX - 74, creatureY - 133);        triangle(creatureX - 83, creatureY - 122, creatureX - 93, creatureY - 122, creatureX - 87, creatureY - 133);        triangle(creatureX - 93, creatureY - 120, creatureX - 100, creatureY - 115, creatureX - 103, creatureY - 131);        triangle(creatureX + 69, creatureY - 106, creatureX + 69, creatureY - 118, creatureX + 58, creatureY - 120);        triangle(creatureX + 70, creatureY - 122, creatureX + 80, creatureY - 122, creatureX + 74, creatureY - 133);        triangle(creatureX + 83, creatureY - 122, creatureX + 93, creatureY - 122, creatureX + 87, creatureY - 133);        triangle(creatureX + 93, creatureY - 120, creatureX + 100, creatureY - 115, creatureX + 103, creatureY - 131);    } else {        stroke(0);        fill(bodyColor);        strokeWeight(1);        quad(creatureX - 50, creatureY + 10, creatureX - 80, creatureY + 10, creatureX - 90, creatureY + 100, creatureX - 60, creatureY + 100);        quad(creatureX + 50, creatureY + 10, creatureX + 80, creatureY + 10, creatureX + 90, creatureY + 100, creatureX + 60, creatureY + 100);        rect(creatureX - 74, creatureY + 95, 33, 33);        rect(creatureX + 74, creatureY + 95, 33, 33);        stroke(219, 173, 138);        fill(219, 173, 138);        rect(creatureX + 64, creatureY + 103, 3, 12);        rect(creatureX + 74, creatureY + 103, 3, 12);        rect(creatureX + 84, creatureY + 103, 3, 12);        rect(creatureX - 64, creatureY + 103, 3, 12);        rect(creatureX - 74, creatureY + 103, 3, 12);        rect(creatureX - 84, creatureY + 103, 3, 12);    }}',correct
'foxX = width + 800',correct
'triangle(creatureX + 10, creatureY - 34, creatureX + 5, creatureY - 34, creatureX + 7, creatureY - 28)',correct
'rect(creatureX + 64, creatureY + 103, 3, 12);',correct
'FoxB foxRight;',correct
'rect(creatureX - 37, creatureY + 174, 3, 12)',correct
'rectMode(CENTER);',correct
'rect(foxX, foxY, 200, 85)',correct
'if (foxSpeed > 16) {    foxSpeed = 5;}',correct
'creatureY + 174',correct
'FoxA foxLeft;',correct
'triangle(creatureX + 69, creatureY - 106, creatureX + 69, creatureY - 118, creatureX + 58, creatureY - 120);',correct
'PImage honey;',correct
'width / 2 - 200',correct
'foxSpeed = -6',correct
'background(bg)',correct
'foxSpeed = -5',correct
'{    background(143, 238, 239);    rectMode(CENTER);    bodyColor = color(119, 76, 44);    creatureX = width / 2;    creatureY = height - 260;    file = new SoundFile(this, "Roar.mp3");    bg = loadImage("bg.png");    honey = loadImage("honey.png");    foxLeft = new FoxA();    foxRight = new FoxB();}',correct
'void keyPressed() {    if (keyPressed && keyCode == LEFT) {        creatureX = creatureX - 200;    }    if (keyPressed && keyCode == RIGHT) {        creatureX = creatureX + 200;    }}',correct
'if (keyPressed && key ==  ) {    stroke(bodyColor);    strokeWeight(1);    fill(bodyColor);    rect(creatureX, creatureY - 50, 75, 60);    rect(creatureX, creatureY - 17, 60, 5);    rect(creatureX, creatureY - 12, 50, 5);    rect(creatureX - 33, creatureY - 74, 25, 25);    rect(creatureX + 33, creatureY - 74, 25, 25);    stroke(219, 173, 138);    fill(219, 173, 138);    rect(creatureX, creatureY - 31, 42, 24);    rect(creatureX, creatureY - 26, 34, 24);    stroke(0);    fill(175, 26, 28);    rect(creatureX, creatureY - 26, 32, 16);    stroke(0);    fill(0);    rect(creatureX, creatureY - 40, 18, 6);    rect(creatureX, creatureY - 34, 6, 6);    rect(creatureX - 18, creatureY - 64, 8, 8);    rect(creatureX + 18, creatureY - 64, 8, 8);    stroke(219, 173, 138);    fill(219, 173, 138);    rect(creatureX - 34, creatureY - 75, 13, 13);    rect(creatureX + 34, creatureY - 75, 13, 13);    stroke(0);    fill(255);    triangle(creatureX - 10, creatureY - 34, creatureX - 15, creatureY - 34, creatureX - 13, creatureY - 28);    triangle(creatureX - 5, creatureY - 34, creatureX - 10, creatureY - 34, creatureX - 8, creatureY - 28);    triangle(creatureX, creatureY - 34, creatureX - 5, creatureY - 34, creatureX - 3, creatureY - 28);    triangle(creatureX + 5, creatureY - 34, creatureX, creatureY - 34, creatureX + 2, creatureY - 28);    triangle(creatureX + 10, creatureY - 34, creatureX + 5, creatureY - 34, creatureX + 7, creatureY - 28);    triangle(creatureX + 15, creatureY - 34, creatureX + 10, creatureY - 34, creatureX + 12, creatureY - 28);    triangle(creatureX - 10, creatureY - 18, creatureX - 15, creatureY - 18, creatureX - 13, creatureY - 24);    triangle(creatureX - 5, creatureY - 18, creatureX - 10, creatureY - 18, creatureX - 8, creatureY - 24);    triangle(creatureX, creatureY - 18, creatureX - 5, creatureY - 18, creatureX - 3, creatureY - 24);    triangle(creatureX + 5, creatureY - 18, creatureX, creatureY - 18, creatureX + 2, creatureY - 24);    triangle(creatureX + 10, creatureY - 18, creatureX + 5, creatureY - 18, creatureX + 7, creatureY - 24);    triangle(creatureX + 15, creatureY - 18, creatureX + 10, creatureY - 18, creatureX + 12, creatureY - 24);} else {    stroke(bodyColor);    strokeWeight(1);    fill(bodyColor);    rect(creatureX, creatureY - 50, 75, 60);    rect(creatureX, creatureY - 17, 60, 5);    rect(creatureX, creatureY - 12, 50, 5);    rect(creatureX - 33, creatureY - 74, 25, 25);    rect(creatureX + 33, creatureY - 74, 25, 25);    stroke(219, 173, 138);    fill(219, 173, 138);    rect(creatureX, creatureY - 28, 42, 20);    stroke(0);    fill(0);    rect(creatureX, creatureY - 35, 18, 6);    rect(creatureX, creatureY - 29, 6, 6);    rect(creatureX - 18, creatureY - 64, 6, 6);    rect(creatureX + 18, creatureY - 64, 6, 6);    stroke(219, 173, 138);    fill(219, 173, 138);    rect(creatureX - 34, creatureY - 75, 13, 13);    rect(creatureX + 34, creatureY - 75, 13, 13);}',DecentralizedEventHandlingRule
'rect(creatureX + 44, creatureY + 174, 3, 12);',correct
'quad(foxX - 183, foxY + 75, foxX - 211, foxY + 55, foxX - 240, foxY + 80, foxX - 210, foxY + 100);',correct
'quad(foxX - 100, foxY, foxX - 100, foxY - 43, foxX - 240, foxY + 80, foxX - 210, foxY + 100);',correct
'creatureY + 170',correct
'fill(bodyColor)',correct
'creatureY + 10',correct
'foxLeft.move();',correct
'foxLeft.foxSpeed()',correct
'quad(foxX + 100, foxY, foxX + 100, foxY - 43, foxX + 240, foxY + 80, foxX + 210, foxY + 100)',correct
'foxX + 183',correct
'file.play();',correct
'rect(foxX + 85, foxY + 80, 30, 90);',correct
'triangle(creatureX - 10, creatureY - 18, creatureX - 15, creatureY - 18, creatureX - 13, creatureY - 24)',correct
'if (foxX > width / 2 - 200) {    foxSpeed = -foxSpeed * 2;}',correct
'rect(creatureX - 34, creatureY - 75, 13, 13)',correct
'foxSpeed = -foxSpeed / 3 * 1.1f;',correct
'fill(bodyColor);',correct
'void display() {    // honey    image(honey, imgX - 90, imgY - 120, 70, 70);    if (foxX > width / 2 - 200) {        imgSpeed = foxSpeed;        imgX = imgX - 220;        imgY = imgY + 40;    }    if (imgX < -200) {        imgX = -300;        imgSpeed = 0;        imgY = height - 200;    }    if (foxSpeed > 0) {        stroke(0);        strokeWeight(4);        line(foxX + 98, foxY - 115, foxX + 83, foxY - 80);        line(foxX + 100, foxY - 115, foxX + 119, foxY - 80);        stroke(0);        strokeWeight(1);        fill(229, 142, 55);        rect(foxX - 85, foxY + 80, 30, 90);        rect(foxX - 68, foxY + 80, 30, 90);        rect(foxX + 68, foxY + 80, 30, 90);        rect(foxX + 84, foxY + 80, 30, 90);        noStroke();        rect(foxX, foxY, 200, 85);        rect(foxX + 100, foxY - 55, 70, 70);        rect(foxX + 145, foxY - 32, 40, 25);        quad(foxX - 100, foxY, foxX - 100, foxY - 43, foxX - 240, foxY + 80, foxX - 210, foxY + 100);        triangle(foxX + 119, foxY - 75, foxX + 85, foxY - 75, foxX + 100, foxY - 113);        fill(255);        rect(foxX + 125, foxY - 60, 16, 32);        rect(foxX + 10, foxY + 22, 150, 35);        quad(foxX - 155, foxY + 50, foxX - 183, foxY + 30, foxX - 240, foxY + 80, foxX - 210, foxY + 100);        fill(0);        rect(foxX + 157, foxY - 32, 16, 25);        rect(foxX + 128, foxY - 53, 8, 16);        quad(foxX - 183, foxY + 75, foxX - 211, foxY + 55, foxX - 240, foxY + 80, foxX - 210, foxY + 100);        fill(226, 142, 200);        stroke(0);        strokeWeight(4);        triangle(foxX + 105, foxY - 80, foxX + 75, foxY - 80, foxX + 90, foxY - 110);    } else {        stroke(0);        strokeWeight(4);        line(foxX - 98, foxY - 115, foxX - 83, foxY - 80);        line(foxX - 100, foxY - 115, foxX - 119, foxY - 80);        stroke(0);        strokeWeight(1);        fill(229, 142, 55);        rect(foxX + 85, foxY + 80, 30, 90);        rect(foxX + 68, foxY + 80, 30, 90);        rect(foxX - 68, foxY + 80, 30, 90);        rect(foxX - 84, foxY + 80, 30, 90);        noStroke();        rect(foxX, foxY, 200, 85);        rect(foxX - 100, foxY - 55, 70, 70);        rect(foxX - 145, foxY - 32, 40, 25);        quad(foxX + 100, foxY, foxX + 100, foxY - 43, foxX + 240, foxY + 80, foxX + 210, foxY + 100);        triangle(foxX - 119, foxY - 75, foxX - 85, foxY - 75, foxX - 100, foxY - 113);        fill(255);        rect(foxX - 125, foxY - 60, 16, 32);        rect(foxX - 10, foxY + 22, 150, 35);        quad(foxX + 155, foxY + 50, foxX + 183, foxY + 30, foxX + 240, foxY + 80, foxX + 210, foxY + 100);        fill(0);        rect(foxX - 157, foxY - 32, 16, 25);        rect(foxX - 128, foxY - 53, 8, 16);        quad(foxX + 183, foxY + 75, foxX + 211, foxY + 55, foxX + 240, foxY + 80, foxX + 210, foxY + 100);        fill(226, 142, 200);        stroke(0);        strokeWeight(4);        triangle(foxX - 105, foxY - 80, foxX - 75, foxY - 80, foxX - 90, foxY - 110);    }}',correct
'rect(foxX - 125, foxY - 60, 16, 32);',correct
'rect(foxX + 100, foxY - 55, 70, 70);',correct
'foxY - 113',correct
'height - 180',correct
'foxY + 22',correct
'imgX',correct
'background(bg);',correct
'triangle(foxX + 105, foxY - 80, foxX + 75, foxY - 80, foxX + 90, foxY - 110);',correct
'foxX - creatureX < 199',correct
'foxY - 115',correct
'creatureY + 45',correct
'imgY',correct
'foxY - 110',correct
'rect(creatureX + 83, creatureY - 106, 20, 16);',correct
'{    stroke(bodyColor);    strokeWeight(1);    fill(bodyColor);    rect(creatureX, creatureY - 50, 75, 60);    rect(creatureX, creatureY - 17, 60, 5);    rect(creatureX, creatureY - 12, 50, 5);    rect(creatureX - 33, creatureY - 74, 25, 25);    rect(creatureX + 33, creatureY - 74, 25, 25);    stroke(219, 173, 138);    fill(219, 173, 138);    rect(creatureX, creatureY - 31, 42, 24);    rect(creatureX, creatureY - 26, 34, 24);    stroke(0);    fill(175, 26, 28);    rect(creatureX, creatureY - 26, 32, 16);    stroke(0);    fill(0);    rect(creatureX, creatureY - 40, 18, 6);    rect(creatureX, creatureY - 34, 6, 6);    rect(creatureX - 18, creatureY - 64, 8, 8);    rect(creatureX + 18, creatureY - 64, 8, 8);    stroke(219, 173, 138);    fill(219, 173, 138);    rect(creatureX - 34, creatureY - 75, 13, 13);    rect(creatureX + 34, creatureY - 75, 13, 13);    stroke(0);    fill(255);    triangle(creatureX - 10, creatureY - 34, creatureX - 15, creatureY - 34, creatureX - 13, creatureY - 28);    triangle(creatureX - 5, creatureY - 34, creatureX - 10, creatureY - 34, creatureX - 8, creatureY - 28);    triangle(creatureX, creatureY - 34, creatureX - 5, creatureY - 34, creatureX - 3, creatureY - 28);    triangle(creatureX + 5, creatureY - 34, creatureX, creatureY - 34, creatureX + 2, creatureY - 28);    triangle(creatureX + 10, creatureY - 34, creatureX + 5, creatureY - 34, creatureX + 7, creatureY - 28);    triangle(creatureX + 15, creatureY - 34, creatureX + 10, creatureY - 34, creatureX + 12, creatureY - 28);    triangle(creatureX - 10, creatureY - 18, creatureX - 15, creatureY - 18, creatureX - 13, creatureY - 24);    triangle(creatureX - 5, creatureY - 18, creatureX - 10, creatureY - 18, creatureX - 8, creatureY - 24);    triangle(creatureX, creatureY - 18, creatureX - 5, creatureY - 18, creatureX - 3, creatureY - 24);    triangle(creatureX + 5, creatureY - 18, creatureX, creatureY - 18, creatureX + 2, creatureY - 24);    triangle(creatureX + 10, creatureY - 18, creatureX + 5, creatureY - 18, creatureX + 7, creatureY - 24);    triangle(creatureX + 15, creatureY - 18, creatureX + 10, creatureY - 18, creatureX + 12, creatureY - 24);}',correct
'Processing',correct
'rect(creatureX + 84, creatureY + 103, 3, 12);',correct
'creatureX - 3',correct
'creatureX - 5',correct
'quad(foxX - 155, foxY + 50, foxX - 183, foxY + 30, foxX - 240, foxY + 80, foxX - 210, foxY + 100)',correct
'rect(creatureX + 51, creatureY + 174, 3, 12);',correct
'{    // honey    image(honey, imgX - 90, imgY - 120, 70, 70);    if (foxX < width / 2 + 200) {        imgSpeed = foxSpeed;        imgX = imgX + 220;        imgY = imgY + 40;    }    if (imgX > width + 200) {        imgX = width + 200;        imgSpeed = 0;        imgY = height - 200;    }    // fox    if (foxSpeed > 0) {        stroke(0);        strokeWeight(4);        line(foxX + 98, foxY - 115, foxX + 83, foxY - 80);        line(foxX + 100, foxY - 115, foxX + 119, foxY - 80);        stroke(0);        strokeWeight(1);        fill(229, 142, 55);        rect(foxX - 85, foxY + 80, 30, 90);        rect(foxX - 68, foxY + 80, 30, 90);        rect(foxX + 68, foxY + 80, 30, 90);        rect(foxX + 84, foxY + 80, 30, 90);        noStroke();        rect(foxX, foxY, 200, 85);        rect(foxX + 100, foxY - 55, 70, 70);        rect(foxX + 145, foxY - 32, 40, 25);        quad(foxX - 100, foxY, foxX - 100, foxY - 43, foxX - 240, foxY + 80, foxX - 210, foxY + 100);        triangle(foxX + 119, foxY - 75, foxX + 85, foxY - 75, foxX + 100, foxY - 113);        fill(255);        rect(foxX + 125, foxY - 60, 16, 32);        rect(foxX + 10, foxY + 22, 150, 35);        quad(foxX - 155, foxY + 50, foxX - 183, foxY + 30, foxX - 240, foxY + 80, foxX - 210, foxY + 100);        fill(0);        rect(foxX + 157, foxY - 32, 16, 25);        rect(foxX + 128, foxY - 53, 8, 16);        quad(foxX - 183, foxY + 75, foxX - 211, foxY + 55, foxX - 240, foxY + 80, foxX - 210, foxY + 100);        fill(226, 142, 200);        stroke(0);        strokeWeight(4);        triangle(foxX + 105, foxY - 80, foxX + 75, foxY - 80, foxX + 90, foxY - 110);    } else {        stroke(0);        strokeWeight(4);        line(foxX - 98, foxY - 115, foxX - 83, foxY - 80);        line(foxX - 100, foxY - 115, foxX - 119, foxY - 80);        stroke(0);        strokeWeight(1);        fill(229, 142, 55);        rect(foxX + 85, foxY + 80, 30, 90);        rect(foxX + 68, foxY + 80, 30, 90);        rect(foxX - 68, foxY + 80, 30, 90);        rect(foxX - 84, foxY + 80, 30, 90);        noStroke();        rect(foxX, foxY, 200, 85);        rect(foxX - 100, foxY - 55, 70, 70);        rect(foxX - 145, foxY - 32, 40, 25);        quad(foxX + 100, foxY, foxX + 100, foxY - 43, foxX + 240, foxY + 80, foxX + 210, foxY + 100);        triangle(foxX - 119, foxY - 75, foxX - 85, foxY - 75, foxX - 100, foxY - 113);        fill(255);        rect(foxX - 125, foxY - 60, 16, 32);        rect(foxX - 10, foxY + 22, 150, 35);        quad(foxX + 155, foxY + 50, foxX + 183, foxY + 30, foxX + 240, foxY + 80, foxX + 210, foxY + 100);        fill(0);        rect(foxX - 157, foxY - 32, 16, 25);        rect(foxX - 128, foxY - 53, 8, 16);        quad(foxX + 183, foxY + 75, foxX + 211, foxY + 55, foxX + 240, foxY + 80, foxX + 210, foxY + 100);        fill(226, 142, 200);        stroke(0);        strokeWeight(4);        triangle(foxX - 105, foxY - 80, foxX - 75, foxY - 80, foxX - 90, foxY - 110);    }}',LongMethodRule
'creatureX - 8',correct
'rect(creatureX, creatureY + 75, 60, 61)',correct
'foxRight.move()',correct
'rect(creatureX, creatureY - 26, 32, 16);',correct
'rect(foxX - 100, foxY - 55, 70, 70);',correct
'fill(219, 173, 138);',correct
'rect(creatureX + 37, creatureY + 174, 3, 12);',correct
'triangle(foxX + 119, foxY - 75, foxX + 85, foxY - 75, foxX + 100, foxY - 113);',correct
'foxY + 30',correct
'rect(creatureX, creatureY - 50, 75, 60);',correct
'triangle(creatureX - 93, creatureY - 120, creatureX - 100, creatureY - 115, creatureX - 103, creatureY - 131);',correct
'creatureY + 30',correct
'rect(creatureX + 30, creatureY + 174, 3, 12)',correct
'foxX < width / 2 + 200',correct
'{    foxSpeed = 5;}',correct
'creatureX - 103',correct
'{    foxSpeed = -foxSpeed * 2;}',correct
'rect(creatureX + 34, creatureY - 75, 13, 13);',correct
'quad(foxX + 100, foxY, foxX + 100, foxY - 43, foxX + 240, foxY + 80, foxX + 210, foxY + 100);',correct
'rect(creatureX + 18, creatureY - 64, 8, 8)',correct
'stroke(bodyColor);',correct
'image(honey, imgX - 90, imgY - 120, 70, 70)',correct
'rect(creatureX - 83, creatureY - 108, 33, 33)',correct
'creatureX - 100',correct
'rect(creatureX + 44, creatureY + 174, 3, 12)',correct
'rect(foxX - 10, foxY + 22, 150, 35)',correct
'creatureY + 65',correct
'foxX - creatureX',correct
'imgX = imgX + imgSpeed;',correct
'rect(creatureX - 74, creatureY + 103, 3, 12)',correct
'rect(creatureX - 33, creatureY - 74, 25, 25);',correct
'{    stroke(0);    fill(bodyColor);    strokeWeight(1);    quad(creatureX - 50, creatureY + 10, creatureX - 80, creatureY + 10, creatureX - 90, creatureY + 100, creatureX - 60, creatureY + 100);    quad(creatureX + 50, creatureY + 10, creatureX + 80, creatureY + 10, creatureX + 90, creatureY + 100, creatureX + 60, creatureY + 100);    rect(creatureX - 74, creatureY + 95, 33, 33);    rect(creatureX + 74, creatureY + 95, 33, 33);    stroke(219, 173, 138);    fill(219, 173, 138);    rect(creatureX + 64, creatureY + 103, 3, 12);    rect(creatureX + 74, creatureY + 103, 3, 12);    rect(creatureX + 84, creatureY + 103, 3, 12);    rect(creatureX - 64, creatureY + 103, 3, 12);    rect(creatureX - 74, creatureY + 103, 3, 12);    rect(creatureX - 84, creatureY + 103, 3, 12);}',correct
'imgSpeed = 0',correct
'foxX = foxX + foxSpeed;',correct
'imgX = -300',correct
'rect(foxX + 128, foxY - 53, 8, 16)',correct
'rect(foxX + 84, foxY + 80, 30, 90)',correct
'image(honey, width / 2 + 12, height - 260, 70, 70)',correct
'creatureX = creatureX - 200;',correct
'rect(creatureX, creatureY - 17, 60, 5);',correct
'foxLeft = new FoxA()',correct
'imgY = imgY + 40',correct
'creatureX + 200',correct
'rect(creatureX, creatureY - 31, 42, 24)',correct
'-foxSpeed / 3',correct
'creatureY + 55',correct
'{    if (keyPressed && key ==   && creatureX - foxX < 180 && foxX - creatureX < 200 && foxSpeed < 0) {        foxSpeed = -foxSpeed * 3;    }    if (foxX < width / 2 + 200) {        foxSpeed = -foxSpeed * 2;    }    if (foxX > width + 800 && foxSpeed > 0) {        foxSpeed = -foxSpeed / 3 * 1.1f;        if (foxSpeed < -16) {            foxSpeed = -5;        }    }}',correct
'foxX - 210',correct
'rect(creatureX + 33, creatureY - 74, 25, 25);',correct
'rect(foxX, foxY, 200, 85);',correct
'1.1f',correct
'triangle(foxX - 119, foxY - 75, foxX - 85, foxY - 75, foxX - 100, foxY - 113);',correct
'triangle(creatureX - 83, creatureY - 122, creatureX - 93, creatureY - 122, creatureX - 87, creatureY - 133)',correct
'image(honey, width / 2 + 3, height - 140, 70, 70);',correct
'if (foxSpeed < -16) {    foxSpeed = -5;}',correct
'image(honey, width / 2 - 93, height - 200, 70, 70);',correct
'rect(creatureX - 18, creatureY - 64, 6, 6)',correct
'foxX - 211',correct
'foxX = width + 800;',correct
'triangle(creatureX - 5, creatureY - 18, creatureX - 10, creatureY - 18, creatureX - 8, creatureY - 24);',correct
'noStroke();',correct
'line(foxX + 100, foxY - 115, foxX + 119, foxY - 80)',correct
'if (foxX < width / 2 + 200) {    foxSpeed = -foxSpeed * 2;}',correct
'creatureY = height - 260;',correct
'creatureX = creatureX + 200;',correct
'"Roar.mp3"',correct
'creatureY + 88',correct
'creatureY - 26',correct
'creatureY - 28',correct
'creatureY - 120',correct
'creatureY - 24',correct
'creatureY - 122',correct
'strokeWeight(1)',correct
'stroke(219, 173, 138);',correct
'{    imgSpeed = foxSpeed;    imgX = imgX + 220;    imgY = imgY + 40;}',correct
'rect(creatureX - 30, creatureY + 174, 3, 12)',correct
'image(honey, width / 2 + 70, height - 140, 70, 70)',correct
'foxX > width + 800 && foxSpeed > 0',correct
'rect(creatureX, creatureY + 75, 135, 75);',correct
'{    foxSpeed = -5;}',correct
'FoxB',correct
'triangle(creatureX - 5, creatureY - 18, creatureX - 10, creatureY - 18, creatureX - 8, creatureY - 24)',correct
'FoxA',correct
'file',correct
'rect(creatureX, creatureY - 26, 32, 16)',correct
'honey = loadImage("honey.png")',correct
'keyPressed && key ==   && creatureX - foxX < 180 && foxX - creatureX < 199',correct
'foxX',correct
'quad(foxX - 155, foxY + 50, foxX - 183, foxY + 30, foxX - 240, foxY + 80, foxX - 210, foxY + 100);',correct
'foxY',correct
'creatureY - 18',correct
'creatureY + 75',correct
'creatureY - 17',correct
'triangle(creatureX - 5, creatureY - 34, creatureX - 10, creatureY - 34, creatureX - 8, creatureY - 28)',correct
'creatureY - 12',correct
'creatureY - 131',correct
'creatureY - 133',correct
'rect(foxX + 157, foxY - 32, 16, 25);',correct
'{    imgSpeed = foxSpeed;    imgX = imgX - 220;    imgY = imgY + 40;}',correct
'rect(foxX - 84, foxY + 80, 30, 90);',correct
'draw',LongMethodRule
'triangle(creatureX + 5, creatureY - 34, creatureX, creatureY - 34, creatureX + 2, creatureY - 28)',correct
'{    foxSpeed = -foxSpeed / 3 * 1.1f;    if (foxSpeed > 16) {        foxSpeed = 5;    }}',correct
'rect(creatureX, creatureY - 26, 34, 24)',correct
'imgX = width + 200;',correct
'triangle(creatureX + 5, creatureY - 18, creatureX, creatureY - 18, creatureX + 2, creatureY - 24)',correct
'if (keyPressed && key ==   && creatureX - foxX < 180 && foxX - creatureX < 200 && foxSpeed < 0) {    foxSpeed = -foxSpeed * 3;}',DecentralizedEventHandlingRule
'creatureX + 12',correct
'fill(175, 26, 28)',correct
'{    stroke(0);    strokeWeight(4);    line(foxX + 98, foxY - 115, foxX + 83, foxY - 80);    line(foxX + 100, foxY - 115, foxX + 119, foxY - 80);    stroke(0);    strokeWeight(1);    fill(229, 142, 55);    rect(foxX - 85, foxY + 80, 30, 90);    rect(foxX - 68, foxY + 80, 30, 90);    rect(foxX + 68, foxY + 80, 30, 90);    rect(foxX + 84, foxY + 80, 30, 90);    noStroke();    rect(foxX, foxY, 200, 85);    rect(foxX + 100, foxY - 55, 70, 70);    rect(foxX + 145, foxY - 32, 40, 25);    quad(foxX - 100, foxY, foxX - 100, foxY - 43, foxX - 240, foxY + 80, foxX - 210, foxY + 100);    triangle(foxX + 119, foxY - 75, foxX + 85, foxY - 75, foxX + 100, foxY - 113);    fill(255);    rect(foxX + 125, foxY - 60, 16, 32);    rect(foxX + 10, foxY + 22, 150, 35);    quad(foxX - 155, foxY + 50, foxX - 183, foxY + 30, foxX - 240, foxY + 80, foxX - 210, foxY + 100);    fill(0);    rect(foxX + 157, foxY - 32, 16, 25);    rect(foxX + 128, foxY - 53, 8, 16);    quad(foxX - 183, foxY + 75, foxX - 211, foxY + 55, foxX - 240, foxY + 80, foxX - 210, foxY + 100);    fill(226, 142, 200);    stroke(0);    strokeWeight(4);    triangle(foxX + 105, foxY - 80, foxX + 75, foxY - 80, foxX + 90, foxY - 110);}',correct
'creatureX + 10',correct
'rect(creatureX - 84, creatureY + 103, 3, 12);',correct
'fill(175, 26, 28);',correct
'foxX + foxSpeed',correct
'(foxX > width && foxSpeed > 0) || (foxX < -400 && foxSpeed < 0)',correct
'image(honey, width / 2 - 51, height - 260, 70, 70);',correct
'rect(foxX + 145, foxY - 32, 40, 25);',correct
'creatureY - 40',correct
'quad(creatureX - 50, creatureY + 10, creatureX - 80, creatureY + 10, creatureX - 90, creatureY + 100, creatureX - 60, creatureY + 100);',correct
'imgX = width / 2 + 70;',correct
'foxSpeed = 5;',correct
'triangle(creatureX - 70, creatureY - 122, creatureX - 80, creatureY - 122, creatureX - 74, creatureY - 133)',correct
'foxX > width + 800',correct
'foxX - 90',correct
'float foxY;',correct
'rect(creatureX - 83, creatureY - 106, 20, 16)',correct
'rect(foxX + 68, foxY + 80, 30, 90);',correct
'foxX - 98',correct
'triangle(creatureX + 83, creatureY - 122, creatureX + 93, creatureY - 122, creatureX + 87, creatureY - 133);',correct
'void',LongMethodRule
'creatureY - 34',correct
'creatureY - 35',correct
'// honeyimage(honey, width / 2 + 70, height - 140, 70, 70);',correct
'-5',correct
'foxX = -400',correct
'-6',correct
'if (foxX < width / 2 + 200) {    imgSpeed = foxSpeed;    imgX = imgX + 220;    imgY = imgY + 40;}',correct
'creatureY - 31',correct
'rect(creatureX - 51, creatureY + 174, 3, 12);',correct
'creatureY + 95',correct
'quad(creatureX + 50, creatureY + 10, creatureX + 80, creatureY + 10, creatureX + 90, creatureY + 100, creatureX + 60, creatureY + 100)',correct
'line(foxX - 100, foxY - 115, foxX - 119, foxY - 80)',correct
'foxSpeed',correct
'rect(foxX + 145, foxY - 32, 40, 25)',correct
'rect(creatureX, creatureY + 45, 100, 110);',correct
'triangle(foxX - 105, foxY - 80, foxX - 75, foxY - 80, foxX - 90, foxY - 110)',correct
'triangle(creatureX - 5, creatureY - 34, creatureX - 10, creatureY - 34, creatureX - 8, creatureY - 28);',correct
'quad(creatureX - 47, creatureY - 8, creatureX - 62, creatureY + 30, creatureX - 100, creatureY - 100, creatureX - 70, creatureY - 115)',correct
'rect(creatureX, creatureY - 12, 50, 5);',correct
'rect(creatureX - 74, creatureY + 95, 33, 33);',correct
'image(honey, width / 2 - 63, height - 140, 70, 70)',correct
'creatureY - 29',correct
'image(honey, width / 2 + 3, height - 140, 70, 70)',correct
'// honeyimage(honey, imgX - 90, imgY - 120, 70, 70);',correct
'imgY = height - 200',correct
'float imgSpeed;',correct
'quad(creatureX + 47, creatureY - 8, creatureX + 62, creatureY + 30, creatureX + 100, creatureY - 100, creatureX + 70, creatureY - 115);',correct
'rect(creatureX, creatureY - 26, 34, 24);',correct
'{    if (keyPressed && keyCode == LEFT) {        creatureX = creatureX - 200;    }    if (keyPressed && keyCode == RIGHT) {        creatureX = creatureX + 200;    }}',correct
'creatureY - 64',correct
'fill(229, 142, 55);',correct
'rect(creatureX + 40, creatureY + 170, 35, 20);',correct
'rect(foxX - 128, foxY - 53, 8, 16);',correct
'SoundFile file;',correct
'creatureX + 103',correct
'rect(creatureX + 37, creatureY + 174, 3, 12)',correct
'if (foxX > width + 800 && foxSpeed > 0) {    foxSpeed = -foxSpeed / 3 * 1.1f;    if (foxSpeed < -16) {        foxSpeed = -5;    }}',correct
'loadImage("honey.png")',correct
'creatureX + 100',correct
'foxX - 75',correct
'rect(foxX - 10, foxY + 22, 150, 35);',correct
'{    imgX = -300;    imgSpeed = 0;    imgY = height - 200;}',correct
'rect(creatureX + 40, creatureY + 150, 45, 60);',correct
'line(foxX + 100, foxY - 115, foxX + 119, foxY - 80);',correct
'rect(creatureX, creatureY - 17, 60, 5)',correct
'creatureY + 100',correct
'{    stroke(0);    strokeWeight(1);    fill(bodyColor);    quad(creatureX - 47, creatureY - 8, creatureX - 62, creatureY + 30, creatureX - 100, creatureY - 100, creatureX - 70, creatureY - 115);    quad(creatureX + 47, creatureY - 8, creatureX + 62, creatureY + 30, creatureX + 100, creatureY - 100, creatureX + 70, creatureY - 115);    stroke(bodyColor);    fill(bodyColor);    rect(creatureX - 83, creatureY - 108, 33, 33);    rect(creatureX + 84, creatureY - 108, 33, 33);    stroke(219, 173, 138);    fill(219, 173, 138);    rect(creatureX - 83, creatureY - 106, 20, 16);    rect(creatureX + 83, creatureY - 106, 20, 16);    stroke(0);    fill(255);    triangle(creatureX - 69, creatureY - 106, creatureX - 69, creatureY - 118, creatureX - 58, creatureY - 120);    triangle(creatureX - 70, creatureY - 122, creatureX - 80, creatureY - 122, creatureX - 74, creatureY - 133);    triangle(creatureX - 83, creatureY - 122, creatureX - 93, creatureY - 122, creatureX - 87, creatureY - 133);    triangle(creatureX - 93, creatureY - 120, creatureX - 100, creatureY - 115, creatureX - 103, creatureY - 131);    triangle(creatureX + 69, creatureY - 106, creatureX + 69, creatureY - 118, creatureX + 58, creatureY - 120);    triangle(creatureX + 70, creatureY - 122, creatureX + 80, creatureY - 122, creatureX + 74, creatureY - 133);    triangle(creatureX + 83, creatureY - 122, creatureX + 93, creatureY - 122, creatureX + 87, creatureY - 133);    triangle(creatureX + 93, creatureY - 120, creatureX + 100, creatureY - 115, creatureX + 103, creatureY - 131);}',correct
'triangle(creatureX - 69, creatureY - 106, creatureX - 69, creatureY - 118, creatureX - 58, creatureY - 120);',correct
'creatureY - 50',correct
'creatureY + 103',correct
'rect(creatureX + 74, creatureY + 103, 3, 12)',correct
'foxSpeed = 4;',correct
'{    creatureX = creatureX - 200;}',correct
'foxSpeed > 16',correct
'foxX - 83',correct
'if ((foxX > width && foxSpeed > 0) || (foxX < -400 && foxSpeed < 0)) {    foxSpeed = -foxSpeed / 3 * 1.1f;    if (foxSpeed > 16) {        foxSpeed = 5;    }}',correct
'-400',correct
'foxX - 84',correct
'foxX - 85',correct
'strokeWeight(4)',correct
'imgSpeed = foxSpeed;',correct
'float foxX;',correct
'foxRight.display()',correct
'line(foxX + 98, foxY - 115, foxX + 83, foxY - 80)',correct
'rect(creatureX + 33, creatureY - 74, 25, 25)',correct
'quad(foxX + 183, foxY + 75, foxX + 211, foxY + 55, foxX + 240, foxY + 80, foxX + 210, foxY + 100)',correct
'loadImage("bg.png")',correct
'honey = loadImage("honey.png");',correct
'triangle(creatureX, creatureY - 18, creatureX - 5, creatureY - 18, creatureX - 3, creatureY - 24);',correct
'if (imgX > width + 200) {    imgX = width + 200;    imgSpeed = 0;    imgY = height - 200;}',correct
'rect(foxX + 125, foxY - 60, 16, 32);',correct
'creatureX + 60',correct
'rect(creatureX - 18, creatureY - 64, 6, 6);',correct
'image(honey, width / 2 - 130, height - 140, 70, 70)',correct
'void setup() {    background(143, 238, 239);    rectMode(CENTER);    bodyColor = color(119, 76, 44);    creatureX = width / 2;    creatureY = height - 260;    file = new SoundFile(this, "Roar.mp3");    bg = loadImage("bg.png");    honey = loadImage("honey.png");    foxLeft = new FoxA();    foxRight = new FoxB();}',correct
'rect(creatureX + 84, creatureY + 103, 3, 12)',correct
'creatureX + 69',correct
'creatureX + 64',correct
'triangle(creatureX + 10, creatureY - 18, creatureX + 5, creatureY - 18, creatureX + 7, creatureY - 24);',correct
'creatureX + 62',correct
'line(foxX + 98, foxY - 115, foxX + 83, foxY - 80);',correct
'imgX = width / 2 + 70',correct
'{    if (keyPressed && key ==   && creatureX - foxX < 180 && foxX - creatureX < 199 && foxSpeed > 0) {        foxSpeed = -foxSpeed * 3;    }    if (foxX > width / 2 - 200) {        foxSpeed = -foxSpeed * 2;    }    if ((foxX > width && foxSpeed > 0) || (foxX < -400 && foxSpeed < 0)) {        foxSpeed = -foxSpeed / 3 * 1.1f;        if (foxSpeed > 16) {            foxSpeed = 5;        }    }}',correct
'rect(creatureX, creatureY - 31, 42, 24);',correct
'float imgX;',correct
'imgX > width + 200',correct
'fill(226, 142, 200)',correct
'rect(creatureX - 37, creatureY + 174, 3, 12);',correct
'FoxB() {    foxX = width + 800;    foxY = height - 180;    foxSpeed = -6;    imgSpeed = 0;    imgX = width / 2 + 70;    imgY = height - 200;}',correct
'creatureX = creatureX + 200',correct
'strokeWeight(1);',correct
'creatureY - 74',correct
'creatureY - 75',correct
'triangle(creatureX + 93, creatureY - 120, creatureX + 100, creatureY - 115, creatureX + 103, creatureY - 131)',correct
'imgY + 40',correct
'foxRight.foxSpeed()',correct
'creatureX + 70',correct
'-300',correct
'rect(creatureX - 30, creatureY + 174, 3, 12);',correct
'foxSpeed < 0',correct
'rect(creatureX, creatureY - 28, 42, 20);',correct
'foxX - 68',correct
'creatureX - 15',correct
'imgX = width + 200',correct
'creatureX - 13',correct
'triangle(creatureX - 10, creatureY - 18, creatureX - 15, creatureY - 18, creatureX - 13, creatureY - 24);',correct
'background(143, 238, 239)',correct
'creatureX - 10',correct
'creatureX + 74',correct
'keyPressed && key ==   && creatureX - foxX < 180 && foxX - creatureX < 199 && foxSpeed > 0',correct
'float imgY;',correct
'rect(creatureX, creatureY + 65, 125, 110)',correct
'triangle(creatureX + 5, creatureY - 18, creatureX, creatureY - 18, creatureX + 2, creatureY - 24);',correct
'rect(creatureX + 74, creatureY + 103, 3, 12);',correct
'creatureX - 18',correct
'"bg.png"',correct
'image(honey, width / 2 - 51, height - 260, 70, 70)',correct
'void keyReleased() {    if (key ==  ) {        file.play();    }}',correct
'foxX + 210',correct
'foxX - 145',correct
'rect(foxX + 100, foxY - 55, 70, 70)',correct
'foxX + 211',correct
'foxSpeed = -5;',correct
'PImage',correct
'foxX + 90',correct
'imgX < -200',correct
'creatureX + 83',correct
'line(foxX - 98, foxY - 115, foxX - 83, foxY - 80)',correct
'creatureX + 80',correct
'line(foxX - 100, foxY - 115, foxX - 119, foxY - 80);',correct
'foxX + 98',correct
'creatureY = height - 260',correct
'creatureX + 87',correct
'rect(creatureX - 33, creatureY - 74, 25, 25)',correct
'rect(creatureX + 18, creatureY - 64, 8, 8);',correct
'creatureX + 84',correct
'rect(creatureX, creatureY + 65, 125, 110);',correct
'foxSpeed = -6;',correct
'foxX - 155',correct
'foxRight = new FoxB()',correct
'imgSpeed = foxSpeed',correct
'foxLeft.display()',correct
'foxX - creatureX < 200',correct
'if (keyPressed && keyCode == RIGHT) {    creatureX = creatureX + 200;}',correct
'foxX - 157',correct
'triangle(creatureX + 83, creatureY - 122, creatureX + 93, creatureY - 122, creatureX + 87, creatureY - 133)',correct
'rect(foxX - 85, foxY + 80, 30, 90)',correct
'// foxif (foxSpeed > 0) {    stroke(0);    strokeWeight(4);    line(foxX + 98, foxY - 115, foxX + 83, foxY - 80);    line(foxX + 100, foxY - 115, foxX + 119, foxY - 80);    stroke(0);    strokeWeight(1);    fill(229, 142, 55);    rect(foxX - 85, foxY + 80, 30, 90);    rect(foxX - 68, foxY + 80, 30, 90);    rect(foxX + 68, foxY + 80, 30, 90);    rect(foxX + 84, foxY + 80, 30, 90);    noStroke();    rect(foxX, foxY, 200, 85);    rect(foxX + 100, foxY - 55, 70, 70);    rect(foxX + 145, foxY - 32, 40, 25);    quad(foxX - 100, foxY, foxX - 100, foxY - 43, foxX - 240, foxY + 80, foxX - 210, foxY + 100);    triangle(foxX + 119, foxY - 75, foxX + 85, foxY - 75, foxX + 100, foxY - 113);    fill(255);    rect(foxX + 125, foxY - 60, 16, 32);    rect(foxX + 10, foxY + 22, 150, 35);    quad(foxX - 155, foxY + 50, foxX - 183, foxY + 30, foxX - 240, foxY + 80, foxX - 210, foxY + 100);    fill(0);    rect(foxX + 157, foxY - 32, 16, 25);    rect(foxX + 128, foxY - 53, 8, 16);    quad(foxX - 183, foxY + 75, foxX - 211, foxY + 55, foxX - 240, foxY + 80, foxX - 210, foxY + 100);    fill(226, 142, 200);    stroke(0);    strokeWeight(4);    triangle(foxX + 105, foxY - 80, foxX + 75, foxY - 80, foxX + 90, foxY - 110);} else {    stroke(0);    strokeWeight(4);    line(foxX - 98, foxY - 115, foxX - 83, foxY - 80);    line(foxX - 100, foxY - 115, foxX - 119, foxY - 80);    stroke(0);    strokeWeight(1);    fill(229, 142, 55);    rect(foxX + 85, foxY + 80, 30, 90);    rect(foxX + 68, foxY + 80, 30, 90);    rect(foxX - 68, foxY + 80, 30, 90);    rect(foxX - 84, foxY + 80, 30, 90);    noStroke();    rect(foxX, foxY, 200, 85);    rect(foxX - 100, foxY - 55, 70, 70);    rect(foxX - 145, foxY - 32, 40, 25);    quad(foxX + 100, foxY, foxX + 100, foxY - 43, foxX + 240, foxY + 80, foxX + 210, foxY + 100);    triangle(foxX - 119, foxY - 75, foxX - 85, foxY - 75, foxX - 100, foxY - 113);    fill(255);    rect(foxX - 125, foxY - 60, 16, 32);    rect(foxX - 10, foxY + 22, 150, 35);    quad(foxX + 155, foxY + 50, foxX + 183, foxY + 30, foxX + 240, foxY + 80, foxX + 210, foxY + 100);    fill(0);    rect(foxX - 157, foxY - 32, 16, 25);    rect(foxX - 128, foxY - 53, 8, 16);    quad(foxX + 183, foxY + 75, foxX + 211, foxY + 55, foxX + 240, foxY + 80, foxX + 210, foxY + 100);    fill(226, 142, 200);    stroke(0);    strokeWeight(4);    triangle(foxX - 105, foxY - 80, foxX - 75, foxY - 80, foxX - 90, foxY - 110);}',correct
'creatureX + 93',correct
'creatureX - 30',correct
'-200',correct
'if (keyPressed && keyCode == LEFT) {    creatureX = creatureX - 200;}',correct
'triangle(creatureX + 10, creatureY - 34, creatureX + 5, creatureY - 34, creatureX + 7, creatureY - 28);',correct
'creatureX + 90',correct
'foxSpeed = 4',correct
'creatureX - 37',correct
'rect(foxX - 157, foxY - 32, 16, 25)',correct
'rect(creatureX, creatureY - 35, 18, 6);',correct
'void display() {    // honey    image(honey, imgX - 90, imgY - 120, 70, 70);    if (foxX < width / 2 + 200) {        imgSpeed = foxSpeed;        imgX = imgX + 220;        imgY = imgY + 40;    }    if (imgX > width + 200) {        imgX = width + 200;        imgSpeed = 0;        imgY = height - 200;    }    // fox    if (foxSpeed > 0) {        stroke(0);        strokeWeight(4);        line(foxX + 98, foxY - 115, foxX + 83, foxY - 80);        line(foxX + 100, foxY - 115, foxX + 119, foxY - 80);        stroke(0);        strokeWeight(1);        fill(229, 142, 55);        rect(foxX - 85, foxY + 80, 30, 90);        rect(foxX - 68, foxY + 80, 30, 90);        rect(foxX + 68, foxY + 80, 30, 90);        rect(foxX + 84, foxY + 80, 30, 90);        noStroke();        rect(foxX, foxY, 200, 85);        rect(foxX + 100, foxY - 55, 70, 70);        rect(foxX + 145, foxY - 32, 40, 25);        quad(foxX - 100, foxY, foxX - 100, foxY - 43, foxX - 240, foxY + 80, foxX - 210, foxY + 100);        triangle(foxX + 119, foxY - 75, foxX + 85, foxY - 75, foxX + 100, foxY - 113);        fill(255);        rect(foxX + 125, foxY - 60, 16, 32);        rect(foxX + 10, foxY + 22, 150, 35);        quad(foxX - 155, foxY + 50, foxX - 183, foxY + 30, foxX - 240, foxY + 80, foxX - 210, foxY + 100);        fill(0);        rect(foxX + 157, foxY - 32, 16, 25);        rect(foxX + 128, foxY - 53, 8, 16);        quad(foxX - 183, foxY + 75, foxX - 211, foxY + 55, foxX - 240, foxY + 80, foxX - 210, foxY + 100);        fill(226, 142, 200);        stroke(0);        strokeWeight(4);        triangle(foxX + 105, foxY - 80, foxX + 75, foxY - 80, foxX + 90, foxY - 110);    } else {        stroke(0);        strokeWeight(4);        line(foxX - 98, foxY - 115, foxX - 83, foxY - 80);        line(foxX - 100, foxY - 115, foxX - 119, foxY - 80);        stroke(0);        strokeWeight(1);        fill(229, 142, 55);        rect(foxX + 85, foxY + 80, 30, 90);        rect(foxX + 68, foxY + 80, 30, 90);        rect(foxX - 68, foxY + 80, 30, 90);        rect(foxX - 84, foxY + 80, 30, 90);        noStroke();        rect(foxX, foxY, 200, 85);        rect(foxX - 100, foxY - 55, 70, 70);        rect(foxX - 145, foxY - 32, 40, 25);        quad(foxX + 100, foxY, foxX + 100, foxY - 43, foxX + 240, foxY + 80, foxX + 210, foxY + 100);        triangle(foxX - 119, foxY - 75, foxX - 85, foxY - 75, foxX - 100, foxY - 113);        fill(255);        rect(foxX - 125, foxY - 60, 16, 32);        rect(foxX - 10, foxY + 22, 150, 35);        quad(foxX + 155, foxY + 50, foxX + 183, foxY + 30, foxX + 240, foxY + 80, foxX + 210, foxY + 100);        fill(0);        rect(foxX - 157, foxY - 32, 16, 25);        rect(foxX - 128, foxY - 53, 8, 16);        quad(foxX + 183, foxY + 75, foxX + 211, foxY + 55, foxX + 240, foxY + 80, foxX + 210, foxY + 100);        fill(226, 142, 200);        stroke(0);        strokeWeight(4);        triangle(foxX - 105, foxY - 80, foxX - 75, foxY - 80, foxX - 90, foxY - 110);    }}',correct
'foxSpeed = 5',correct
'triangle(creatureX, creatureY - 34, creatureX - 5, creatureY - 34, creatureX - 3, creatureY - 28);',correct
'creatureX - 34',correct
'creatureX - 33',correct
'class FoxA {    float foxX;    float foxY;    float imgX;    float imgY;    float foxSpeed;    float imgSpeed;    FoxA() {        foxX = -400;        foxY = height - 180;        imgX = width / 2 + 70;        imgY = height - 200;        foxSpeed = 4;        imgSpeed = 0;    }    void display() {        // honey        image(honey, imgX - 90, imgY - 120, 70, 70);        if (foxX > width / 2 - 200) {            imgSpeed = foxSpeed;            imgX = imgX - 220;            imgY = imgY + 40;        }        if (imgX < -200) {            imgX = -300;            imgSpeed = 0;            imgY = height - 200;        }        if (foxSpeed > 0) {            stroke(0);            strokeWeight(4);            line(foxX + 98, foxY - 115, foxX + 83, foxY - 80);            line(foxX + 100, foxY - 115, foxX + 119, foxY - 80);            stroke(0);            strokeWeight(1);            fill(229, 142, 55);            rect(foxX - 85, foxY + 80, 30, 90);            rect(foxX - 68, foxY + 80, 30, 90);            rect(foxX + 68, foxY + 80, 30, 90);            rect(foxX + 84, foxY + 80, 30, 90);            noStroke();            rect(foxX, foxY, 200, 85);            rect(foxX + 100, foxY - 55, 70, 70);            rect(foxX + 145, foxY - 32, 40, 25);            quad(foxX - 100, foxY, foxX - 100, foxY - 43, foxX - 240, foxY + 80, foxX - 210, foxY + 100);            triangle(foxX + 119, foxY - 75, foxX + 85, foxY - 75, foxX + 100, foxY - 113);            fill(255);            rect(foxX + 125, foxY - 60, 16, 32);            rect(foxX + 10, foxY + 22, 150, 35);            quad(foxX - 155, foxY + 50, foxX - 183, foxY + 30, foxX - 240, foxY + 80, foxX - 210, foxY + 100);            fill(0);            rect(foxX + 157, foxY - 32, 16, 25);            rect(foxX + 128, foxY - 53, 8, 16);            quad(foxX - 183, foxY + 75, foxX - 211, foxY + 55, foxX - 240, foxY + 80, foxX - 210, foxY + 100);            fill(226, 142, 200);            stroke(0);            strokeWeight(4);            triangle(foxX + 105, foxY - 80, foxX + 75, foxY - 80, foxX + 90, foxY - 110);        } else {            stroke(0);            strokeWeight(4);            line(foxX - 98, foxY - 115, foxX - 83, foxY - 80);            line(foxX - 100, foxY - 115, foxX - 119, foxY - 80);            stroke(0);            strokeWeight(1);            fill(229, 142, 55);            rect(foxX + 85, foxY + 80, 30, 90);            rect(foxX + 68, foxY + 80, 30, 90);            rect(foxX - 68, foxY + 80, 30, 90);            rect(foxX - 84, foxY + 80, 30, 90);            noStroke();            rect(foxX, foxY, 200, 85);            rect(foxX - 100, foxY - 55, 70, 70);            rect(foxX - 145, foxY - 32, 40, 25);            quad(foxX + 100, foxY, foxX + 100, foxY - 43, foxX + 240, foxY + 80, foxX + 210, foxY + 100);            triangle(foxX - 119, foxY - 75, foxX - 85, foxY - 75, foxX - 100, foxY - 113);            fill(255);            rect(foxX - 125, foxY - 60, 16, 32);            rect(foxX - 10, foxY + 22, 150, 35);            quad(foxX + 155, foxY + 50, foxX + 183, foxY + 30, foxX + 240, foxY + 80, foxX + 210, foxY + 100);            fill(0);            rect(foxX - 157, foxY - 32, 16, 25);            rect(foxX - 128, foxY - 53, 8, 16);            quad(foxX + 183, foxY + 75, foxX + 211, foxY + 55, foxX + 240, foxY + 80, foxX + 210, foxY + 100);            fill(226, 142, 200);            stroke(0);            strokeWeight(4);            triangle(foxX - 105, foxY - 80, foxX - 75, foxY - 80, foxX - 90, foxY - 110);        }    }    void foxSpeed() {        if (keyPressed && key ==   && creatureX - foxX < 180 && foxX - creatureX < 199 && foxSpeed > 0) {            foxSpeed = -foxSpeed * 3;        }        if (foxX > width / 2 - 200) {            foxSpeed = -foxSpeed * 2;        }        if ((foxX > width && foxSpeed > 0) || (foxX < -400 && foxSpeed < 0)) {            foxSpeed = -foxSpeed / 3 * 1.1f;            if (foxSpeed > 16) {                foxSpeed = 5;            }        }    }    void move() {        imgX = imgX + imgSpeed;        foxX = foxX + foxSpeed;    }}',correct
'noStroke()',correct
'imgSpeed = 0;',correct
'foxX - 240',correct
'if (keyPressed && key ==  ) {    stroke(0);    strokeWeight(1);    fill(bodyColor);    quad(creatureX - 47, creatureY - 8, creatureX - 62, creatureY + 30, creatureX - 100, creatureY - 100, creatureX - 70, creatureY - 115);    quad(creatureX + 47, creatureY - 8, creatureX + 62, creatureY + 30, creatureX + 100, creatureY - 100, creatureX + 70, creatureY - 115);    stroke(bodyColor);    fill(bodyColor);    rect(creatureX - 83, creatureY - 108, 33, 33);    rect(creatureX + 84, creatureY - 108, 33, 33);    stroke(219, 173, 138);    fill(219, 173, 138);    rect(creatureX - 83, creatureY - 106, 20, 16);    rect(creatureX + 83, creatureY - 106, 20, 16);    stroke(0);    fill(255);    triangle(creatureX - 69, creatureY - 106, creatureX - 69, creatureY - 118, creatureX - 58, creatureY - 120);    triangle(creatureX - 70, creatureY - 122, creatureX - 80, creatureY - 122, creatureX - 74, creatureY - 133);    triangle(creatureX - 83, creatureY - 122, creatureX - 93, creatureY - 122, creatureX - 87, creatureY - 133);    triangle(creatureX - 93, creatureY - 120, creatureX - 100, creatureY - 115, creatureX - 103, creatureY - 131);    triangle(creatureX + 69, creatureY - 106, creatureX + 69, creatureY - 118, creatureX + 58, creatureY - 120);    triangle(creatureX + 70, creatureY - 122, creatureX + 80, creatureY - 122, creatureX + 74, creatureY - 133);    triangle(creatureX + 83, creatureY - 122, creatureX + 93, creatureY - 122, creatureX + 87, creatureY - 133);    triangle(creatureX + 93, creatureY - 120, creatureX + 100, creatureY - 115, creatureX + 103, creatureY - 131);} else {    stroke(0);    fill(bodyColor);    strokeWeight(1);    quad(creatureX - 50, creatureY + 10, creatureX - 80, creatureY + 10, creatureX - 90, creatureY + 100, creatureX - 60, creatureY + 100);    quad(creatureX + 50, creatureY + 10, creatureX + 80, creatureY + 10, creatureX + 90, creatureY + 100, creatureX + 60, creatureY + 100);    rect(creatureX - 74, creatureY + 95, 33, 33);    rect(creatureX + 74, creatureY + 95, 33, 33);    stroke(219, 173, 138);    fill(219, 173, 138);    rect(creatureX + 64, creatureY + 103, 3, 12);    rect(creatureX + 74, creatureY + 103, 3, 12);    rect(creatureX + 84, creatureY + 103, 3, 12);    rect(creatureX - 64, creatureY + 103, 3, 12);    rect(creatureX - 74, creatureY + 103, 3, 12);    rect(creatureX - 84, creatureY + 103, 3, 12);}',correct
'creatureX + 18',correct
'creatureX + 15',correct
'rect(creatureX + 40, creatureY + 170, 35, 20)',correct
'void move() {    imgX = imgX + imgSpeed;    foxX = foxX + foxSpeed;}',correct
'{    file.play();}',correct
'creatureY - 100',correct
'foxSpeed = -foxSpeed / 3 * 1.1f',correct
'foxX - 128',correct
'foxRight = new FoxB();',correct
'triangle(creatureX, creatureY - 18, creatureX - 5, creatureY - 18, creatureX - 3, creatureY - 24)',correct
'key ==',correct
'rect(creatureX, creatureY + 75, 135, 75)',correct
'rect(creatureX + 83, creatureY - 106, 20, 16)',correct
'creatureY - 106',correct
'foxX - 125',correct
'triangle(creatureX - 69, creatureY - 106, creatureX - 69, creatureY - 118, creatureX - 58, creatureY - 120)',correct
'foxLeft',correct
'void foxSpeed() {    if (keyPressed && key ==   && creatureX - foxX < 180 && foxX - creatureX < 199 && foxSpeed > 0) {        foxSpeed = -foxSpeed * 3;    }    if (foxX > width / 2 - 200) {        foxSpeed = -foxSpeed * 2;    }    if ((foxX > width && foxSpeed > 0) || (foxX < -400 && foxSpeed < 0)) {        foxSpeed = -foxSpeed / 3 * 1.1f;        if (foxSpeed > 16) {            foxSpeed = 5;        }    }}',correct
'imgX + 220',correct
'foxX + 75',correct
'rect(creatureX - 64, creatureY + 103, 3, 12);',correct
'triangle(creatureX - 70, creatureY - 122, creatureX - 80, creatureY - 122, creatureX - 74, creatureY - 133);',correct
'foxX - 10',correct
'width + 200',correct
'rect(creatureX, creatureY + 75, 85, 50)',correct
'rect(foxX + 68, foxY + 80, 30, 90)',correct
'rect(creatureX + 74, creatureY + 95, 33, 33);',correct
'this',correct
'creatureX = width / 2;',correct
'imgY = imgY + 40;',correct
'// legsstroke(bodyColor);',correct
'creatureY - 115',correct
'creatureY - 118',correct
'creatureY - 108',correct
'foxY = height - 180;',correct
'fill(0)',correct
'foxX + 83',correct
'triangle(creatureX + 15, creatureY - 34, creatureX + 10, creatureY - 34, creatureX + 12, creatureY - 28);',correct
'foxSpeed > 0',correct
'rect(creatureX, creatureY - 34, 6, 6)',correct
'foxX + 85',correct
'creatureX + 33',correct
'rect(creatureX, creatureY + 88, 100, 75);',correct
'new FoxA()',correct
'creatureX + 34',correct
'foxX + 84',correct
'rect(creatureX, creatureY + 75, 85, 50);',correct
'foxSpeed < -16',correct
'keyPressed && key ==   && creatureX - foxX < 180',correct
'quad(foxX - 183, foxY + 75, foxX - 211, foxY + 55, foxX - 240, foxY + 80, foxX - 210, foxY + 100)',correct
'creatureX + 30',correct
'{    foxX = width + 800;    foxY = height - 180;    foxSpeed = -6;    imgSpeed = 0;    imgX = width / 2 + 70;    imgY = height - 200;}',correct
'foxX - 100',correct
'{    stroke(bodyColor);    strokeWeight(1);    fill(bodyColor);    rect(creatureX, creatureY - 50, 75, 60);    rect(creatureX, creatureY - 17, 60, 5);    rect(creatureX, creatureY - 12, 50, 5);    rect(creatureX - 33, creatureY - 74, 25, 25);    rect(creatureX + 33, creatureY - 74, 25, 25);    stroke(219, 173, 138);    fill(219, 173, 138);    rect(creatureX, creatureY - 28, 42, 20);    stroke(0);    fill(0);    rect(creatureX, creatureY - 35, 18, 6);    rect(creatureX, creatureY - 29, 6, 6);    rect(creatureX - 18, creatureY - 64, 6, 6);    rect(creatureX + 18, creatureY - 64, 6, 6);    stroke(219, 173, 138);    fill(219, 173, 138);    rect(creatureX - 34, creatureY - 75, 13, 13);    rect(creatureX + 34, creatureY - 75, 13, 13);}',correct
'rect(creatureX, creatureY + 75, 95, 40);',correct
'triangle(creatureX - 83, creatureY - 122, creatureX - 93, creatureY - 122, creatureX - 87, creatureY - 133);',correct
'if (foxSpeed > 0) {    stroke(0);    strokeWeight(4);    line(foxX + 98, foxY - 115, foxX + 83, foxY - 80);    line(foxX + 100, foxY - 115, foxX + 119, foxY - 80);    stroke(0);    strokeWeight(1);    fill(229, 142, 55);    rect(foxX - 85, foxY + 80, 30, 90);    rect(foxX - 68, foxY + 80, 30, 90);    rect(foxX + 68, foxY + 80, 30, 90);    rect(foxX + 84, foxY + 80, 30, 90);    noStroke();    rect(foxX, foxY, 200, 85);    rect(foxX + 100, foxY - 55, 70, 70);    rect(foxX + 145, foxY - 32, 40, 25);    quad(foxX - 100, foxY, foxX - 100, foxY - 43, foxX - 240, foxY + 80, foxX - 210, foxY + 100);    triangle(foxX + 119, foxY - 75, foxX + 85, foxY - 75, foxX + 100, foxY - 113);    fill(255);    rect(foxX + 125, foxY - 60, 16, 32);    rect(foxX + 10, foxY + 22, 150, 35);    quad(foxX - 155, foxY + 50, foxX - 183, foxY + 30, foxX - 240, foxY + 80, foxX - 210, foxY + 100);    fill(0);    rect(foxX + 157, foxY - 32, 16, 25);    rect(foxX + 128, foxY - 53, 8, 16);    quad(foxX - 183, foxY + 75, foxX - 211, foxY + 55, foxX - 240, foxY + 80, foxX - 210, foxY + 100);    fill(226, 142, 200);    stroke(0);    strokeWeight(4);    triangle(foxX + 105, foxY - 80, foxX + 75, foxY - 80, foxX + 90, foxY - 110);} else {    stroke(0);    strokeWeight(4);    line(foxX - 98, foxY - 115, foxX - 83, foxY - 80);    line(foxX - 100, foxY - 115, foxX - 119, foxY - 80);    stroke(0);    strokeWeight(1);    fill(229, 142, 55);    rect(foxX + 85, foxY + 80, 30, 90);    rect(foxX + 68, foxY + 80, 30, 90);    rect(foxX - 68, foxY + 80, 30, 90);    rect(foxX - 84, foxY + 80, 30, 90);    noStroke();    rect(foxX, foxY, 200, 85);    rect(foxX - 100, foxY - 55, 70, 70);    rect(foxX - 145, foxY - 32, 40, 25);    quad(foxX + 100, foxY, foxX + 100, foxY - 43, foxX + 240, foxY + 80, foxX + 210, foxY + 100);    triangle(foxX - 119, foxY - 75, foxX - 85, foxY - 75, foxX - 100, foxY - 113);    fill(255);    rect(foxX - 125, foxY - 60, 16, 32);    rect(foxX - 10, foxY + 22, 150, 35);    quad(foxX + 155, foxY + 50, foxX + 183, foxY + 30, foxX + 240, foxY + 80, foxX + 210, foxY + 100);    fill(0);    rect(foxX - 157, foxY - 32, 16, 25);    rect(foxX - 128, foxY - 53, 8, 16);    quad(foxX + 183, foxY + 75, foxX + 211, foxY + 55, foxX + 240, foxY + 80, foxX + 210, foxY + 100);    fill(226, 142, 200);    stroke(0);    strokeWeight(4);    triangle(foxX - 105, foxY - 80, foxX - 75, foxY - 80, foxX - 90, foxY - 110);}',correct
'int bodyColor;',correct
'creatureX + 37',correct
'foxX - 105',correct
'triangle(creatureX + 15, creatureY - 34, creatureX + 10, creatureY - 34, creatureX + 12, creatureY - 28)',correct
'fill(255)',correct
'width / 2 - 93',correct
'foxLeft = new FoxA();',correct
'honey',correct
'rect(creatureX - 18, creatureY - 64, 8, 8)',correct
'fill(226, 142, 200);',correct
'creatureX + 47',correct
'bodyColor = color(119, 76, 44);',correct
'creatureX + 44',correct
'triangle(creatureX, creatureY - 34, creatureX - 5, creatureY - 34, creatureX - 3, creatureY - 28)',correct
'creatureX + 40',correct
'keyPressed && key ==',correct
'{    background(bg);    foxLeft.display();    foxLeft.move();    foxLeft.foxSpeed();    foxRight.display();    foxRight.move();    foxRight.foxSpeed();    // honey    image(honey, width / 2 + 70, height - 140, 70, 70);    image(honey, width / 2 - 130, height - 140, 70, 70);    image(honey, width / 2 - 63, height - 140, 70, 70);    image(honey, width / 2 + 3, height - 140, 70, 70);    image(honey, width / 2 - 93, height - 200, 70, 70);    image(honey, width / 2 - 26, height - 200, 70, 70);    image(honey, width / 2 + 41, height - 200, 70, 70);    image(honey, width / 2 + 12, height - 260, 70, 70);    image(honey, width / 2 - 51, height - 260, 70, 70);    if (keyPressed && key ==  ) {        stroke(bodyColor);        strokeWeight(1);        fill(bodyColor);        rect(creatureX, creatureY - 50, 75, 60);        rect(creatureX, creatureY - 17, 60, 5);        rect(creatureX, creatureY - 12, 50, 5);        rect(creatureX - 33, creatureY - 74, 25, 25);        rect(creatureX + 33, creatureY - 74, 25, 25);        stroke(219, 173, 138);        fill(219, 173, 138);        rect(creatureX, creatureY - 31, 42, 24);        rect(creatureX, creatureY - 26, 34, 24);        stroke(0);        fill(175, 26, 28);        rect(creatureX, creatureY - 26, 32, 16);        stroke(0);        fill(0);        rect(creatureX, creatureY - 40, 18, 6);        rect(creatureX, creatureY - 34, 6, 6);        rect(creatureX - 18, creatureY - 64, 8, 8);        rect(creatureX + 18, creatureY - 64, 8, 8);        stroke(219, 173, 138);        fill(219, 173, 138);        rect(creatureX - 34, creatureY - 75, 13, 13);        rect(creatureX + 34, creatureY - 75, 13, 13);        stroke(0);        fill(255);        triangle(creatureX - 10, creatureY - 34, creatureX - 15, creatureY - 34, creatureX - 13, creatureY - 28);        triangle(creatureX - 5, creatureY - 34, creatureX - 10, creatureY - 34, creatureX - 8, creatureY - 28);        triangle(creatureX, creatureY - 34, creatureX - 5, creatureY - 34, creatureX - 3, creatureY - 28);        triangle(creatureX + 5, creatureY - 34, creatureX, creatureY - 34, creatureX + 2, creatureY - 28);        triangle(creatureX + 10, creatureY - 34, creatureX + 5, creatureY - 34, creatureX + 7, creatureY - 28);        triangle(creatureX + 15, creatureY - 34, creatureX + 10, creatureY - 34, creatureX + 12, creatureY - 28);        triangle(creatureX - 10, creatureY - 18, creatureX - 15, creatureY - 18, creatureX - 13, creatureY - 24);        triangle(creatureX - 5, creatureY - 18, creatureX - 10, creatureY - 18, creatureX - 8, creatureY - 24);        triangle(creatureX, creatureY - 18, creatureX - 5, creatureY - 18, creatureX - 3, creatureY - 24);        triangle(creatureX + 5, creatureY - 18, creatureX, creatureY - 18, creatureX + 2, creatureY - 24);        triangle(creatureX + 10, creatureY - 18, creatureX + 5, creatureY - 18, creatureX + 7, creatureY - 24);        triangle(creatureX + 15, creatureY - 18, creatureX + 10, creatureY - 18, creatureX + 12, creatureY - 24);    } else {        stroke(bodyColor);        strokeWeight(1);        fill(bodyColor);        rect(creatureX, creatureY - 50, 75, 60);        rect(creatureX, creatureY - 17, 60, 5);        rect(creatureX, creatureY - 12, 50, 5);        rect(creatureX - 33, creatureY - 74, 25, 25);        rect(creatureX + 33, creatureY - 74, 25, 25);        stroke(219, 173, 138);        fill(219, 173, 138);        rect(creatureX, creatureY - 28, 42, 20);        stroke(0);        fill(0);        rect(creatureX, creatureY - 35, 18, 6);        rect(creatureX, creatureY - 29, 6, 6);        rect(creatureX - 18, creatureY - 64, 6, 6);        rect(creatureX + 18, creatureY - 64, 6, 6);        stroke(219, 173, 138);        fill(219, 173, 138);        rect(creatureX - 34, creatureY - 75, 13, 13);        rect(creatureX + 34, creatureY - 75, 13, 13);    }    // body    stroke(bodyColor);    fill(bodyColor);    rect(creatureX, creatureY + 65, 125, 110);    rect(creatureX, creatureY + 55, 110, 110);    rect(creatureX, creatureY + 45, 100, 110);    rect(creatureX, creatureY + 75, 135, 75);    rect(creatureX, creatureY + 88, 100, 75);    stroke(219, 173, 138);    fill(219, 173, 138);    rect(creatureX, creatureY + 75, 85, 50);    rect(creatureX, creatureY + 75, 60, 61);    rect(creatureX, creatureY + 75, 95, 40);    // legs    stroke(bodyColor);    fill(bodyColor);    rect(creatureX - 40, creatureY + 150, 45, 60);    rect(creatureX + 40, creatureY + 150, 45, 60);    stroke(bodyColor);    fill(219, 173, 138);    rect(creatureX - 40, creatureY + 170, 35, 20);    rect(creatureX + 40, creatureY + 170, 35, 20);    fill(0);    rect(creatureX + 51, creatureY + 174, 3, 12);    rect(creatureX + 44, creatureY + 174, 3, 12);    rect(creatureX + 37, creatureY + 174, 3, 12);    rect(creatureX + 30, creatureY + 174, 3, 12);    rect(creatureX - 51, creatureY + 174, 3, 12);    rect(creatureX - 44, creatureY + 174, 3, 12);    rect(creatureX - 37, creatureY + 174, 3, 12);    rect(creatureX - 30, creatureY + 174, 3, 12);    if (keyPressed && key ==  ) {        stroke(0);        strokeWeight(1);        fill(bodyColor);        quad(creatureX - 47, creatureY - 8, creatureX - 62, creatureY + 30, creatureX - 100, creatureY - 100, creatureX - 70, creatureY - 115);        quad(creatureX + 47, creatureY - 8, creatureX + 62, creatureY + 30, creatureX + 100, creatureY - 100, creatureX + 70, creatureY - 115);        stroke(bodyColor);        fill(bodyColor);        rect(creatureX - 83, creatureY - 108, 33, 33);        rect(creatureX + 84, creatureY - 108, 33, 33);        stroke(219, 173, 138);        fill(219, 173, 138);        rect(creatureX - 83, creatureY - 106, 20, 16);        rect(creatureX + 83, creatureY - 106, 20, 16);        stroke(0);        fill(255);        triangle(creatureX - 69, creatureY - 106, creatureX - 69, creatureY - 118, creatureX - 58, creatureY - 120);        triangle(creatureX - 70, creatureY - 122, creatureX - 80, creatureY - 122, creatureX - 74, creatureY - 133);        triangle(creatureX - 83, creatureY - 122, creatureX - 93, creatureY - 122, creatureX - 87, creatureY - 133);        triangle(creatureX - 93, creatureY - 120, creatureX - 100, creatureY - 115, creatureX - 103, creatureY - 131);        triangle(creatureX + 69, creatureY - 106, creatureX + 69, creatureY - 118, creatureX + 58, creatureY - 120);        triangle(creatureX + 70, creatureY - 122, creatureX + 80, creatureY - 122, creatureX + 74, creatureY - 133);        triangle(creatureX + 83, creatureY - 122, creatureX + 93, creatureY - 122, creatureX + 87, creatureY - 133);        triangle(creatureX + 93, creatureY - 120, creatureX + 100, creatureY - 115, creatureX + 103, creatureY - 131);    } else {        stroke(0);        fill(bodyColor);        strokeWeight(1);        quad(creatureX - 50, creatureY + 10, creatureX - 80, creatureY + 10, creatureX - 90, creatureY + 100, creatureX - 60, creatureY + 100);        quad(creatureX + 50, creatureY + 10, creatureX + 80, creatureY + 10, creatureX + 90, creatureY + 100, creatureX + 60, creatureY + 100);        rect(creatureX - 74, creatureY + 95, 33, 33);        rect(creatureX + 74, creatureY + 95, 33, 33);        stroke(219, 173, 138);        fill(219, 173, 138);        rect(creatureX + 64, creatureY + 103, 3, 12);        rect(creatureX + 74, creatureY + 103, 3, 12);        rect(creatureX + 84, creatureY + 103, 3, 12);        rect(creatureX - 64, creatureY + 103, 3, 12);        rect(creatureX - 74, creatureY + 103, 3, 12);        rect(creatureX - 84, creatureY + 103, 3, 12);    }}',LongMethodRule
'rect(foxX + 10, foxY + 22, 150, 35)',correct
'foxX - 119',correct
'quad(foxX + 183, foxY + 75, foxX + 211, foxY + 55, foxX + 240, foxY + 80, foxX + 210, foxY + 100);',correct
'triangle(foxX + 119, foxY - 75, foxX + 85, foxY - 75, foxX + 100, foxY - 113)',correct
'strokeWeight(4);',correct
'creatureX + 50',correct
'foxRight.move();',correct
'rect(foxX + 125, foxY - 60, 16, 32)',correct
'creatureX + 58',correct
'-foxSpeed',correct
'image(honey, width / 2 - 26, height - 200, 70, 70);',correct
'new FoxB()',correct
'imgY = height - 200;',correct
'foxX + 68',correct
'creatureX + 51',correct
'rect(creatureX, creatureY + 55, 110, 110);',correct
'triangle(creatureX - 10, creatureY - 34, creatureX - 15, creatureY - 34, creatureX - 13, creatureY - 28)',correct
'rect(creatureX, creatureY + 55, 110, 110)',correct
'float foxSpeed;',correct
'foxY - 60',correct
'rect(creatureX + 74, creatureY + 95, 33, 33)',correct
'rect(foxX - 85, foxY + 80, 30, 90);',correct
'foxX + 155',correct
'foxX + 157',correct
'creatureX - 84',correct
'creatureX - 83',correct
'-16',correct
'image(honey, width / 2 - 26, height - 200, 70, 70)',correct
'creatureX - 80',correct
'quad(foxX - 100, foxY, foxX - 100, foxY - 43, foxX - 240, foxY + 80, foxX - 210, foxY + 100)',correct
'foxX > width / 2 - 200',correct
'creatureX - 87',correct
'quad(foxX + 155, foxY + 50, foxX + 183, foxY + 30, foxX + 240, foxY + 80, foxX + 210, foxY + 100)',correct
'rect(creatureX - 83, creatureY - 106, 20, 16);',correct
'image(honey, width / 2 + 12, height - 260, 70, 70);',correct
'"honey.png"',correct
'rect(creatureX + 40, creatureY + 150, 45, 60)',correct
'quad(creatureX + 47, creatureY - 8, creatureX + 62, creatureY + 30, creatureX + 100, creatureY - 100, creatureX + 70, creatureY - 115)',correct
'keyCode == LEFT',correct
'{    foxSpeed = -foxSpeed / 3 * 1.1f;    if (foxSpeed < -16) {        foxSpeed = -5;    }}',correct
'imgX = imgX + 220;',correct
'foxY - 75',correct
'foxX + 145',correct
'file = new SoundFile(this, "Roar.mp3")',correct
'rect(foxX - 68, foxY + 80, 30, 90);',correct
'keyPressed && key ==   && creatureX - foxX < 180 && foxX - creatureX < 200 && foxSpeed < 0',correct
'creatureX - 93',correct
'rect(creatureX - 40, creatureY + 170, 35, 20);',correct
'if (foxX > width / 2 - 200) {    imgSpeed = foxSpeed;    imgX = imgX - 220;    imgY = imgY + 40;}',correct
'rect(creatureX - 51, creatureY + 174, 3, 12)',correct
'creatureX - 90',correct
'if (keyPressed && key ==   && creatureX - foxX < 180 && foxX - creatureX < 199 && foxSpeed > 0) {    foxSpeed = -foxSpeed * 3;}',DecentralizedEventHandlingRule
'height - 140',correct
'imgX = imgX + 220',correct
'-foxSpeed / 3 * 1.1f',correct
'height - 260',correct
'rect(creatureX - 40, creatureY + 150, 45, 60)',correct
'imgX + imgSpeed',correct
'width / 2 - 51',correct
'quad(creatureX - 50, creatureY + 10, creatureX - 80, creatureY + 10, creatureX - 90, creatureY + 100, creatureX - 60, creatureY + 100)',correct
'imgX = imgX - 220;',correct
'if (imgX < -200) {    imgX = -300;    imgSpeed = 0;    imgY = height - 200;}',correct
'rect(creatureX - 34, creatureY - 75, 13, 13);',correct
'foxY - 80',correct
'rect(creatureX, creatureY - 35, 18, 6)',correct
'creatureY - 8',correct
'rect(foxX - 128, foxY - 53, 8, 16)',correct
'triangle(creatureX + 15, creatureY - 18, creatureX + 10, creatureY - 18, creatureX + 12, creatureY - 24);',correct
'rect(creatureX, creatureY - 12, 50, 5)',correct
'rect(creatureX, creatureY + 75, 95, 40)',correct
'triangle(creatureX - 93, creatureY - 120, creatureX - 100, creatureY - 115, creatureX - 103, creatureY - 131)',correct
'triangle(creatureX - 10, creatureY - 34, creatureX - 15, creatureY - 34, creatureX - 13, creatureY - 28);',correct
'stroke(219, 173, 138)',correct
'creatureX = creatureX - 200',correct
'rect(creatureX + 34, creatureY - 75, 13, 13)',correct
'rect(foxX - 145, foxY - 32, 40, 25)',correct
'rect(foxX - 84, foxY + 80, 30, 90)',correct
'// bodystroke(bodyColor);',correct
'foxX + 10',correct
'rect(creatureX - 44, creatureY + 174, 3, 12)',correct
'// head',correct
'rect(foxX - 125, foxY - 60, 16, 32)',correct
'imgX = imgX + imgSpeed',correct
'keyCode == RIGHT',correct
'width / 2 - 63',correct
'rect(creatureX, creatureY + 88, 100, 75)',correct
'image(honey, width / 2 + 41, height - 200, 70, 70)',correct
'display',LongMethodRule
'rect(creatureX, creatureY - 29, 6, 6);',correct
'creatureX - foxX',correct
'rect(creatureX + 18, creatureY - 64, 6, 6);',correct
'keyPressed && keyCode == RIGHT',correct
'rect(creatureX - 74, creatureY + 95, 33, 33)',correct
'background(143, 238, 239);',correct
'triangle(creatureX + 5, creatureY - 34, creatureX, creatureY - 34, creatureX + 2, creatureY - 28);',correct
'width / 2 + 200',correct
'keyPressed && keyCode == LEFT',correct
'{    creatureX = creatureX + 200;}',correct
'rect(foxX + 128, foxY - 53, 8, 16);',correct
'file.play()',correct
'imgX = -300;',correct
'rect(creatureX + 84, creatureY - 108, 33, 33)',correct
'rect(creatureX, creatureY - 29, 6, 6)',correct
'triangle(foxX + 105, foxY - 80, foxX + 75, foxY - 80, foxX + 90, foxY - 110)',correct
'foxX + 119',correct
'{    imgX = imgX + imgSpeed;    foxX = foxX + foxSpeed;}',correct
'foxRight',correct
'rect(creatureX + 51, creatureY + 174, 3, 12)',correct
'rect(creatureX - 84, creatureY + 103, 3, 12)',correct
'foxY + 80',correct
'triangle(creatureX + 10, creatureY - 18, creatureX + 5, creatureY - 18, creatureX + 7, creatureY - 24)',correct
'fill(255);',correct
'creatureX - 40',correct
'foxY = height - 180',correct
'rect(creatureX - 64, creatureY + 103, 3, 12)',correct
'foxSpeed = -foxSpeed * 3',correct
'creatureX - 47',correct
'foxSpeed = -foxSpeed * 2',correct
'rect(foxX - 157, foxY - 32, 16, 25);',correct
'creatureX - 44',correct
'{    imgX = width + 200;    imgSpeed = 0;    imgY = height - 200;}',correct
'rect(creatureX - 40, creatureY + 170, 35, 20)',correct
'imgX - 90',correct
'fill(219, 173, 138)',correct
'foxY - 32',correct
'class FoxB {    float foxX;    float foxY;    float imgX;    float imgY;    float foxSpeed;    float imgSpeed;    FoxB() {        foxX = width + 800;        foxY = height - 180;        foxSpeed = -6;        imgSpeed = 0;        imgX = width / 2 + 70;        imgY = height - 200;    }    void display() {        // honey        image(honey, imgX - 90, imgY - 120, 70, 70);        if (foxX < width / 2 + 200) {            imgSpeed = foxSpeed;            imgX = imgX + 220;            imgY = imgY + 40;        }        if (imgX > width + 200) {            imgX = width + 200;            imgSpeed = 0;            imgY = height - 200;        }        // fox        if (foxSpeed > 0) {            stroke(0);            strokeWeight(4);            line(foxX + 98, foxY - 115, foxX + 83, foxY - 80);            line(foxX + 100, foxY - 115, foxX + 119, foxY - 80);            stroke(0);            strokeWeight(1);            fill(229, 142, 55);            rect(foxX - 85, foxY + 80, 30, 90);            rect(foxX - 68, foxY + 80, 30, 90);            rect(foxX + 68, foxY + 80, 30, 90);            rect(foxX + 84, foxY + 80, 30, 90);            noStroke();            rect(foxX, foxY, 200, 85);            rect(foxX + 100, foxY - 55, 70, 70);            rect(foxX + 145, foxY - 32, 40, 25);            quad(foxX - 100, foxY, foxX - 100, foxY - 43, foxX - 240, foxY + 80, foxX - 210, foxY + 100);            triangle(foxX + 119, foxY - 75, foxX + 85, foxY - 75, foxX + 100, foxY - 113);            fill(255);            rect(foxX + 125, foxY - 60, 16, 32);            rect(foxX + 10, foxY + 22, 150, 35);            quad(foxX - 155, foxY + 50, foxX - 183, foxY + 30, foxX - 240, foxY + 80, foxX - 210, foxY + 100);            fill(0);            rect(foxX + 157, foxY - 32, 16, 25);            rect(foxX + 128, foxY - 53, 8, 16);            quad(foxX - 183, foxY + 75, foxX - 211, foxY + 55, foxX - 240, foxY + 80, foxX - 210, foxY + 100);            fill(226, 142, 200);            stroke(0);            strokeWeight(4);            triangle(foxX + 105, foxY - 80, foxX + 75, foxY - 80, foxX + 90, foxY - 110);        } else {            stroke(0);            strokeWeight(4);            line(foxX - 98, foxY - 115, foxX - 83, foxY - 80);            line(foxX - 100, foxY - 115, foxX - 119, foxY - 80);            stroke(0);            strokeWeight(1);            fill(229, 142, 55);            rect(foxX + 85, foxY + 80, 30, 90);            rect(foxX + 68, foxY + 80, 30, 90);            rect(foxX - 68, foxY + 80, 30, 90);            rect(foxX - 84, foxY + 80, 30, 90);            noStroke();            rect(foxX, foxY, 200, 85);            rect(foxX - 100, foxY - 55, 70, 70);            rect(foxX - 145, foxY - 32, 40, 25);            quad(foxX + 100, foxY, foxX + 100, foxY - 43, foxX + 240, foxY + 80, foxX + 210, foxY + 100);            triangle(foxX - 119, foxY - 75, foxX - 85, foxY - 75, foxX - 100, foxY - 113);            fill(255);            rect(foxX - 125, foxY - 60, 16, 32);            rect(foxX - 10, foxY + 22, 150, 35);            quad(foxX + 155, foxY + 50, foxX + 183, foxY + 30, foxX + 240, foxY + 80, foxX + 210, foxY + 100);            fill(0);            rect(foxX - 157, foxY - 32, 16, 25);            rect(foxX - 128, foxY - 53, 8, 16);            quad(foxX + 183, foxY + 75, foxX + 211, foxY + 55, foxX + 240, foxY + 80, foxX + 210, foxY + 100);            fill(226, 142, 200);            stroke(0);            strokeWeight(4);            triangle(foxX - 105, foxY - 80, foxX - 75, foxY - 80, foxX - 90, foxY - 110);        }    }    void foxSpeed() {        if (keyPressed && key ==   && creatureX - foxX < 180 && foxX - creatureX < 200 && foxSpeed < 0) {            foxSpeed = -foxSpeed * 3;        }        if (foxX < width / 2 + 200) {            foxSpeed = -foxSpeed * 2;        }        if (foxX > width + 800 && foxSpeed > 0) {            foxSpeed = -foxSpeed / 3 * 1.1f;            if (foxSpeed < -16) {                foxSpeed = -5;            }        }    }    void move() {        imgX = imgX + imgSpeed;        foxX = foxX + foxSpeed;    }}',correct
'foxX + 105',correct
'rect(creatureX, creatureY - 28, 42, 20)',correct
'rect(creatureX - 44, creatureY + 174, 3, 12);',correct
'foxX + 100',correct
'creatureX - foxX < 180',correct
'imgSpeed',correct
'rect(foxX + 10, foxY + 22, 150, 35);',correct
'creatureX - 51',correct
'creatureX - 50',correct
'quad(foxX + 155, foxY + 50, foxX + 183, foxY + 30, foxX + 240, foxY + 80, foxX + 210, foxY + 100);',correct
'imgX - 220',correct
'int creatureY;',correct
'creatureX - 58',correct
'FoxA() {    foxX = -400;    foxY = height - 180;    imgX = width / 2 + 70;    imgY = height - 200;    foxSpeed = 4;    imgSpeed = 0;}',correct
'triangle(creatureX + 70, creatureY - 122, creatureX + 80, creatureY - 122, creatureX + 74, creatureY - 133)',correct
'if (key ==  ) {    file.play();}',correct
'width / 2 + 70',correct
'foxY - 43',correct
'bodyColor',correct
'foxLeft.display();',correct
'triangle(foxX - 105, foxY - 80, foxX - 75, foxY - 80, foxX - 90, foxY - 110);',correct
'bodyColor = color(119, 76, 44)',correct
'foxX - 183',correct
'foxY + 100',correct
'foxX = -400;',correct
'rect(foxX + 84, foxY + 80, 30, 90);',correct
'creatureX - 62',correct
'triangle(foxX - 119, foxY - 75, foxX - 85, foxY - 75, foxX - 100, foxY - 113)',correct
'creatureX - 60',correct
'foxX = foxX + foxSpeed',correct
'int creatureX;',correct
'bg = loadImage("bg.png");',correct
'-foxSpeed * 2',correct
'creatureX - 69',correct
'-foxSpeed * 3',correct
'creatureX - 64',correct
'foxX + 125',correct
'foxY - 55',correct
'foxX + 128',correct
'foxX + 240',correct
'foxY - 53',correct
'creatureX - 74',correct
'width / 2',correct
'color(119, 76, 44)',correct
'creatureX - 70',correct
'rect(foxX - 145, foxY - 32, 40, 25);',correct
'width / 2 - 26',correct
'height - 200',correct
'rect(creatureX - 18, creatureY - 64, 8, 8);',correct
'{    // honey    image(honey, imgX - 90, imgY - 120, 70, 70);    if (foxX > width / 2 - 200) {        imgSpeed = foxSpeed;        imgX = imgX - 220;        imgY = imgY + 40;    }    if (imgX < -200) {        imgX = -300;        imgSpeed = 0;        imgY = height - 200;    }    if (foxSpeed > 0) {        stroke(0);        strokeWeight(4);        line(foxX + 98, foxY - 115, foxX + 83, foxY - 80);        line(foxX + 100, foxY - 115, foxX + 119, foxY - 80);        stroke(0);        strokeWeight(1);        fill(229, 142, 55);        rect(foxX - 85, foxY + 80, 30, 90);        rect(foxX - 68, foxY + 80, 30, 90);        rect(foxX + 68, foxY + 80, 30, 90);        rect(foxX + 84, foxY + 80, 30, 90);        noStroke();        rect(foxX, foxY, 200, 85);        rect(foxX + 100, foxY - 55, 70, 70);        rect(foxX + 145, foxY - 32, 40, 25);        quad(foxX - 100, foxY, foxX - 100, foxY - 43, foxX - 240, foxY + 80, foxX - 210, foxY + 100);        triangle(foxX + 119, foxY - 75, foxX + 85, foxY - 75, foxX + 100, foxY - 113);        fill(255);        rect(foxX + 125, foxY - 60, 16, 32);        rect(foxX + 10, foxY + 22, 150, 35);        quad(foxX - 155, foxY + 50, foxX - 183, foxY + 30, foxX - 240, foxY + 80, foxX - 210, foxY + 100);        fill(0);        rect(foxX + 157, foxY - 32, 16, 25);        rect(foxX + 128, foxY - 53, 8, 16);        quad(foxX - 183, foxY + 75, foxX - 211, foxY + 55, foxX - 240, foxY + 80, foxX - 210, foxY + 100);        fill(226, 142, 200);        stroke(0);        strokeWeight(4);        triangle(foxX + 105, foxY - 80, foxX + 75, foxY - 80, foxX + 90, foxY - 110);    } else {        stroke(0);        strokeWeight(4);        line(foxX - 98, foxY - 115, foxX - 83, foxY - 80);        line(foxX - 100, foxY - 115, foxX - 119, foxY - 80);        stroke(0);        strokeWeight(1);        fill(229, 142, 55);        rect(foxX + 85, foxY + 80, 30, 90);        rect(foxX + 68, foxY + 80, 30, 90);        rect(foxX - 68, foxY + 80, 30, 90);        rect(foxX - 84, foxY + 80, 30, 90);        noStroke();        rect(foxX, foxY, 200, 85);        rect(foxX - 100, foxY - 55, 70, 70);        rect(foxX - 145, foxY - 32, 40, 25);        quad(foxX + 100, foxY, foxX + 100, foxY - 43, foxX + 240, foxY + 80, foxX + 210, foxY + 100);        triangle(foxX - 119, foxY - 75, foxX - 85, foxY - 75, foxX - 100, foxY - 113);        fill(255);        rect(foxX - 125, foxY - 60, 16, 32);        rect(foxX - 10, foxY + 22, 150, 35);        quad(foxX + 155, foxY + 50, foxX + 183, foxY + 30, foxX + 240, foxY + 80, foxX + 210, foxY + 100);        fill(0);        rect(foxX - 157, foxY - 32, 16, 25);        rect(foxX - 128, foxY - 53, 8, 16);        quad(foxX + 183, foxY + 75, foxX + 211, foxY + 55, foxX + 240, foxY + 80, foxX + 210, foxY + 100);        fill(226, 142, 200);        stroke(0);        strokeWeight(4);        triangle(foxX - 105, foxY - 80, foxX - 75, foxY - 80, foxX - 90, foxY - 110);    }}',LongMethodRule
'keyPressed && key ==   && creatureX - foxX < 180 && foxX - creatureX < 200',correct
'rect(creatureX + 64, creatureY + 103, 3, 12)',correct
'{    stroke(0);    strokeWeight(4);    line(foxX - 98, foxY - 115, foxX - 83, foxY - 80);    line(foxX - 100, foxY - 115, foxX - 119, foxY - 80);    stroke(0);    strokeWeight(1);    fill(229, 142, 55);    rect(foxX + 85, foxY + 80, 30, 90);    rect(foxX + 68, foxY + 80, 30, 90);    rect(foxX - 68, foxY + 80, 30, 90);    rect(foxX - 84, foxY + 80, 30, 90);    noStroke();    rect(foxX, foxY, 200, 85);    rect(foxX - 100, foxY - 55, 70, 70);    rect(foxX - 145, foxY - 32, 40, 25);    quad(foxX + 100, foxY, foxX + 100, foxY - 43, foxX + 240, foxY + 80, foxX + 210, foxY + 100);    triangle(foxX - 119, foxY - 75, foxX - 85, foxY - 75, foxX - 100, foxY - 113);    fill(255);    rect(foxX - 125, foxY - 60, 16, 32);    rect(foxX - 10, foxY + 22, 150, 35);    quad(foxX + 155, foxY + 50, foxX + 183, foxY + 30, foxX + 240, foxY + 80, foxX + 210, foxY + 100);    fill(0);    rect(foxX - 157, foxY - 32, 16, 25);    rect(foxX - 128, foxY - 53, 8, 16);    quad(foxX + 183, foxY + 75, foxX + 211, foxY + 55, foxX + 240, foxY + 80, foxX + 210, foxY + 100);    fill(226, 142, 200);    stroke(0);    strokeWeight(4);    triangle(foxX - 105, foxY - 80, foxX - 75, foxY - 80, foxX - 90, foxY - 110);}',correct
'bottleImg = loadImage("plasticBottle.png")',correct
'width / 10',correct
'tadHeadSize = 40',correct
'y < height - height / 3',correct
'// closing enterStreamvoid jumpBackToStart() {    if (x == 0) {        y = random(height / 3, height - height / 3);        x = width;        score = score + 1;    }    // closing if x == 0    if (rad == 0) {        y = random(height / 3, height - height / 3);        x = width;        if (x == width) {            rad = bottleSize;        }    // closing if x == width    }// closing if rad == 0}',correct
'keyPressed && y > height / 3',correct
'x = initX;',correct
'loadImage("plasticBottle.png")',correct
'y = y + 5;',correct
'ScoreBoard',correct
'// closing if pollyHelps// create plastic bottlebottle = new Bottle(width, random(height / 3, height - height / 3), bottleSize, bottleRange);',correct
'theItemRange + headSize',correct
'// closing if pollyHelps',correct
'// ItemSpawnerBottle bottle;',correct
'score',correct
'line(0, height - height / 4, width, height - height / 4);',correct
'x = width',correct
'rad',correct
'y = y - waveHeight * cos(x / waveLength);',correct
'fill(255, 20, 20)',correct
'float size;',correct
'stroke(0);',correct
'{    if (dist(theItemX, theItemY, x, y) <= theItemRange + headSize) {        theItemRad = 0;        bottle.rad = theItemRad;        fill(255, 20, 20);        noStroke();        ellipse(x + size, y + headSize / 2, 15, 10);        health = health - 1;    }// closing if dist}',AvoidReassigningParameters
'stroke(0)',correct
'score + 1',correct
'{    x = x - streamSpeed;    y = y - waveHeight * cos(x / waveLength);// if (y>height-height/2&&y<height-height/2-2||y<height-height/2&&y>height-height/2+2) {// streamSpeed *=-1;// waveHeight *=-1;}',correct
'pollyHelps = false',correct
'// closing if key = moveUp',correct
'waveLength = 15',correct
'ellipse(x + size, y + headSize / 2, 15, 10)',correct
'pushMatrix();',correct
'// close void display// move up and down using w and s keys.void moveUpDown(char moveUp, char moveDown) {    if (keyPressed && y > height / 3) {        if (key == moveUp) {            y = y - 5;        }    // closing if key = moveUp    }    // closing if keyPressed    if (mousePressed && mouseY < height / 2 && y > height / 3) {        y = y - 5;    }    // closing if mousePressed    if (keyPressed && y <= height - height / 3) {        if (key == moveDown) {            y = y + 5;        }    // closing if key = moveDown    }    // closing if keyPressed    if (mousePressed && mouseY > height / 2 && y < height - height / 3) {        y = y + 5;    }// closing if mousePressed}',correct
'mouseY > height / 2',correct
'// scoreboardScoreBoard scoreboard;',correct
'fill(textColorR, textColorG, textColorB);',correct
'{    polly = new Tadpole(width / 30, height / 2, tadBodySize, tadHeadSize);}',correct
'// display scoreboardscoreboard.display();',correct
'// closing displayvoid enterStream() {    x = x - streamSpeed;    y = y - waveHeight * cos(x / waveLength);// if (y>height-height/2&&y<height-height/2-2||y<height-height/2&&y>height-height/2+2) {// streamSpeed *=-1;// waveHeight *=-1;}',correct
'{    theItemRad = 0;    bottle.rad = theItemRad;    fill(255, 20, 20);    noStroke();    ellipse(x + size, y + headSize / 2, 15, 10);    health = health - 1;}',correct
'// streamSpeed *=-1;',correct
'size',correct
'ScoreBoard(float initX, float initY) {    x = initX;    y = initY;}',correct
'x == width',correct
'y <= height - height / 3',correct
'polly = new Tadpole(width / 30, height / 2, tadBodySize, tadHeadSize)',correct
'textSize(32)',correct
'textSize(20)',correct
'y = y - 5',correct
'new ScoreBoard(0.05f * width, 0.05f * height)',correct
'if (x == width) {    rad = bottleSize;}',correct
'y + 60',correct
'ellipse((size - headSize / 2) + headSize / 8, -headSize / 10, headSize / 5, headSize / 5)',correct
'bottle.rad = theItemRad;',correct
'bottle',correct
'text("Your score was" + score, 20, height / 4)',correct
'float initRad',correct
'void display() {    // set the position    // housekeeping the translation by storing it for the next Tadpole    pushMatrix();    translate(x, y);    // draw body    strokeWeight(2);    stroke(0);    line(0, 0, size, 0);    // draw head    fill(0);    stroke(255);    ellipse(size - headSize / 2, 0, headSize, headSize);    // draw a white eye, relative to the headSize    fill(255);    ellipse((size - headSize / 2) + headSize / 8, -headSize / 10, headSize / 5, headSize / 5);    // housekeeping the translation by restoring it for the next Tadpole    popMatrix();}',correct
'// close void display',correct
'float theItemRad',correct
'PImage',correct
'x = width;',correct
'x = initX',correct
'ellipse(x + size, y + headSize / 2, 15, 10);',correct
'{    y = initY;    x = initX;    rad = initRad;    range = initRange;}',correct
'scoreboard.display()',correct
'y - waveHeight * cos(x / waveLength)',correct
'// several bottles at the same timeif (frameCount == 1000) {    bottle = new Bottle(width, random(height / 3, height - height / 3), bottleSize, bottleRange);}',correct
'"Score "',correct
'float initSize',correct
'bottleRange = 10',correct
'range = initRange',correct
'y - 5',correct
'// closing constructorvoid display() {    PImage bottleImg = loadImage("plasticBottle.png");    imageMode(CENTER);    image(bottleImg, x, y, rad, rad);}',correct
'bottle = new Bottle(width, random(height / 3, height - height / 3), bottleSize, bottleRange)',correct
'x + 20',correct
'jumpBackToStart',correct
'0.05f * width',correct
'boolean pollyHelps = false;',correct
'popMatrix();',correct
'// Bottleint bottleRange = 10;',correct
'textColorB = 255',correct
'text("Health " + health, x + 20, y + 34);',correct
's',correct
'int textColorB = 255;',correct
'rad = initRad',correct
'w',correct
'x',correct
'// Interaction between taddy and the bottletaddy.TadpolefeelsItem(bottle.x, bottle.y, bottle.rad, bottle.range);',correct
'y',correct
'if (key == moveDown) {    y = y + 5;}',DecentralizedEventHandlingRule
'-headSize / 10',correct
'noStroke()',correct
'size = initSize',correct
'rect(x, y, 0.4f * width, 0.2f * height);',correct
'image(bottleImg, x, y, rad, rad);',correct
'// closing Constructorvoid display() {    fill(200);    stroke(0);    rectMode(CORNER);    rect(x, y, 0.4f * width, 0.2f * height);    textSize(32);    fill(textColorR, textColorG, textColorB);    text("Health " + health, x + 20, y + 34);    text("Score " + score, x + 20, y + 60);    if (health == 0) {        fill(0, 0, 0, 0.5f);        rect(0, 0, width, height);        textSize(20);        text("Your score was" + score, 20, height / 4);        text("You lost your health! Did you know already that fishes are dying from plastics in the oceans? Its a very big problem and thats the reason why I made this game. The special effects are showing how bad it is for fish.", 10, height / 2);    }// closing if health = 0;}',correct
'health == 0',correct
'{    fill(0, 0, 0, 0.5f);    rect(0, 0, width, height);    textSize(20);    text("Your score was" + score, 20, height / 4);    text("You lost your health! Did you know already that fishes are dying from plastics in the oceans? Its a very big problem and thats the reason why I made this game. The special effects are showing how bad it is for fish.", 10, height / 2);}',correct
'/*myName = Jarl Witt dateProgramWasBuilt = 03 10 2018*/// TadpolesTadpole taddy;',correct
'text("Score " + score, x + 20, y + 60);',correct
'// score and health Variablesint health = 1000;',correct
'// closing class Tadpole',correct
'{    if (key == moveUp) {        y = y - 5;    }// closing if key = moveUp}',DecentralizedEventHandlingRule
'if (key == moveUp) {    y = y - 5;}',DecentralizedEventHandlingRule
'0.2f * height',correct
'y = y - waveHeight * cos(x / waveLength)',correct
'dist(theItemX, theItemY, x, y) <= theItemRange + headSize',correct
'float headSize;',correct
'random(height / 3, height - height / 3)',correct
'// closing moveUpDownvoid TadpolefeelsItem(float theItemX, float theItemY, float theItemRad, float theItemRange) {    if (dist(theItemX, theItemY, x, y) <= theItemRange + headSize) {        theItemRad = 0;        bottle.rad = theItemRad;        fill(255, 20, 20);        noStroke();        ellipse(x + size, y + headSize / 2, 15, 10);        health = health - 1;    }// closing if dist}',correct
'-headSize',correct
'// housekeeping the translation by restoring it for the next TadpolepopMatrix();',correct
'// set the position',correct
'fill(0)',correct
'float theItemY',correct
'height / 2',correct
'height / 3',correct
'// Bottleint bottleSize = 70;',correct
'float theItemX',AvoidReassigningParameters
'height / 4',correct
'scoreboard = new ScoreBoard(0.05f * width, 0.05f * height)',correct
'tadBodySize = 70',correct
'bottle.rad = theItemRad',correct
'0.4f * width',correct
'theItemRad = 0',correct
'waveHeight * cos(x / waveLength)',correct
'new Tadpole(width / 30, height / 2, tadBodySize, tadHeadSize)',correct
'health = health - 1',correct
'score = score + 1',correct
'polly',correct
'rect(x, y, 0.4f * width, 0.2f * height)',correct
'streamSpeed = 5',correct
'{    y = y + 5;}',correct
'float x;',correct
'fill(255)',correct
'bottleSize = 70',correct
'y = y - 5;',correct
'Processing',correct
'image(bottleImg, x, y, rad, rad)',correct
'headSize / 2',correct
'"plasticBottle.png"',correct
'textSize(20);',correct
'if (pollyHelps) {    polly = new Tadpole(width / 30, height / 2, tadBodySize, tadHeadSize);}',correct
'Tadpole polly;',correct
'x + size',correct
'Tadpole(float initX, float initY, float initSize, float initHeadSize) {    x = initX;    y = initY;    size = initSize;    headSize = initHeadSize;}',correct
'"Health " + health',correct
'{    y = random(height / 3, height - height / 3);    x = width;    if (x == width) {        rad = bottleSize;    }// closing if x == width}',correct
'taddy.TadpolefeelsItem(bottle.x, bottle.y, bottle.rad, bottle.range)',correct
'pushMatrix()',correct
'headSize / 5',correct
'x / waveLength',correct
'// move taddy up and down with mouse click above or beneath middle-line or with w and staddy.moveUpDown(w, s);',correct
'headSize / 8',correct
'rad == 0',correct
'bottle.x',correct
'bottle.y',correct
'text("Your score was" + score, 20, height / 4);',correct
'0.2f',correct
'line(0, 0, size, 0);',correct
'"Your score was"',correct
'rectMode(CORNER);',correct
'// create scoreboardscoreboard = new ScoreBoard(0.05f * width, 0.05f * height);',correct
'float y;',correct
'false',correct
'// display taddytaddy.display();',correct
'imageMode(CENTER);',correct
'// draw backgroundbackground(68, 235, 214);',correct
'fill(200);',correct
'{    if (key == moveDown) {        y = y + 5;    }// closing if key = moveDown}',DecentralizedEventHandlingRule
'x = x - streamSpeed',correct
'void draw() {    // draw background    background(68, 235, 214);    pushMatrix();    stroke(255);    line(0, height / 4, width, height / 4);    line(0, height - height / 4, width, height - height / 4);    popMatrix();    // display scoreboard    scoreboard.display();    // display taddy    taddy.display();    // move taddy up and down with mouse click above or beneath middle-line or with w and s    taddy.moveUpDown(w, s);    // plastic bottle    // display bottle    bottle.display();    // bottleSpawnsInStream so it has entered stream already    bottle.enterStream();    // several bottles at the same time    if (frameCount == 1000) {        bottle = new Bottle(width, random(height / 3, height - height / 3), bottleSize, bottleRange);    }    // bottle jumps back to start when he is at x == 0    bottle.jumpBackToStart();    // Interaction between taddy and the bottle    taddy.TadpolefeelsItem(bottle.x, bottle.y, bottle.rad, bottle.range);}',correct
'float waveHeight = 0.5f;',correct
'stroke(255)',correct
'rad = bottleSize',correct
'0.05f',correct
'setup',correct
'rect(0, 0, width, height);',correct
'taddy',correct
'x == 0',correct
'// draw a white eye, relative to the headSizefill(255);',correct
'translate(x, y)',correct
'int score;',correct
'y = initY;',correct
'/*myName = Jarl Witt dateProgramWasBuilt = 03 10 2018*/',correct
'// closing if health = 0;',correct
'{    // draw background    background(68, 235, 214);    pushMatrix();    stroke(255);    line(0, height / 4, width, height / 4);    line(0, height - height / 4, width, height - height / 4);    popMatrix();    // display scoreboard    scoreboard.display();    // display taddy    taddy.display();    // move taddy up and down with mouse click above or beneath middle-line or with w and s    taddy.moveUpDown(w, s);    // plastic bottle    // display bottle    bottle.display();    // bottleSpawnsInStream so it has entered stream already    bottle.enterStream();    // several bottles at the same time    if (frameCount == 1000) {        bottle = new Bottle(width, random(height / 3, height - height / 3), bottleSize, bottleRange);    }    // bottle jumps back to start when he is at x == 0    bottle.jumpBackToStart();    // Interaction between taddy and the bottle    taddy.TadpolefeelsItem(bottle.x, bottle.y, bottle.rad, bottle.range);}',correct
'fill(255, 20, 20);',correct
'y + headSize / 2',correct
'float range;',correct
'y = initY',correct
'text("You lost your health! Did you know already that fishes are dying from plastics in the oceans? Its a very big problem and thats the reason why I made this game. The special effects are showing how bad it is for fish.", 10, height / 2)',correct
'Bottle',correct
'rad = initRad;',correct
'y = random(height / 3, height - height / 3);',correct
'enterStream',correct
'PImage bottleImg = loadImage("plasticBottle.png");',correct
'scoreboard',correct
'if (keyPressed && y > height / 3) {    if (key == moveUp) {        y = y - 5;    }// closing if key = moveUp}',correct
'char moveDown',correct
'{    x = initX;    y = initY;    size = initSize;    headSize = initHeadSize;}',correct
'// closing void jump back to start',correct
'mousePressed && mouseY < height / 2 && y > height / 3',DecentralizedEventHandlingRule
'0.4f',correct
'imageMode(CENTER)',correct
'size - headSize / 2',correct
'rectMode(CORNER)',correct
'fill(textColorR, textColorG, textColorB)',correct
'bottle.range',correct
'{    rad = bottleSize;}',correct
'textSize(32);',correct
'float waveLength = 15;',correct
'frameCount == 1000',correct
'noStroke();',correct
'health - 1',correct
'ellipse(size - headSize / 2, 0, headSize, headSize);',correct
'// standard sizes',correct
'if (dist(theItemX, theItemY, x, y) <= theItemRange + headSize) {    theItemRad = 0;    bottle.rad = theItemRad;    fill(255, 20, 20);    noStroke();    ellipse(x + size, y + headSize / 2, 15, 10);    health = health - 1;}',correct
'float theItemRange',correct
'// draw bodystrokeWeight(2);',correct
'{    y = y - 5;}',DecentralizedEventHandlingRule
'mouseY < height / 2',correct
'theItemRad = 0;',correct
'(size - headSize / 2) + headSize / 8',correct
'waveHeight = 0.5f',correct
'ellipse((size - headSize / 2) + headSize / 8, -headSize / 10, headSize / 5, headSize / 5);',correct
'range',correct
'text("Score " + score, x + 20, y + 60)',correct
'translate(x, y);',correct
'{    y = random(height / 3, height - height / 3);    x = width;    score = score + 1;}',correct
'"Health "',correct
'Bottle(float initX, float initY, float initRad, float initRange) {    y = initY;    x = initX;    rad = initRad;    range = initRange;}',correct
'// waveHeight *=-1;',correct
'taddy.display()',correct
'{    x = initX;    y = initY;}',correct
'TadpolefeelsItem',AvoidReassigningParameters
'score = score + 1;',DrawingStateChangeRule
'range = initRange;',correct
'0.5f',correct
'dist(theItemX, theItemY, x, y)',correct
'rect(0, 0, width, height)',correct
'PImage bottleImg = loadImage("plasticBottle.png")',correct
'y = random(height / 3, height - height / 3)',correct
'mousePressed && mouseY > height / 2 && y < height - height / 3',DecentralizedEventHandlingRule
'// closing Display',correct
'display',correct
'// create taddystaddy = new Tadpole(width / 10, height / 2, tadBodySize, tadHeadSize);',correct
'Tadpole',correct
'{    if (x == 0) {        y = random(height / 3, height - height / 3);        x = width;        score = score + 1;    }    // closing if x == 0    if (rad == 0) {        y = random(height / 3, height - height / 3);        x = width;        if (x == width) {            rad = bottleSize;        }    // closing if x == width    }// closing if rad == 0}',correct
'line(0, height - height / 4, width, height - height / 4)',correct
'draw',correct
'fill(200)',correct
'taddy = new Tadpole(width / 10, height / 2, tadBodySize, tadHeadSize)',correct
'"Score " + score',correct
'{    // set the position    // housekeeping the translation by storing it for the next Tadpole    pushMatrix();    translate(x, y);    // draw body    strokeWeight(2);    stroke(0);    line(0, 0, size, 0);    // draw head    fill(0);    stroke(255);    ellipse(size - headSize / 2, 0, headSize, headSize);    // draw a white eye, relative to the headSize    fill(255);    ellipse((size - headSize / 2) + headSize / 8, -headSize / 10, headSize / 5, headSize / 5);    // housekeeping the translation by restoring it for the next Tadpole    popMatrix();}',correct
'// closing if mousePressedif (keyPressed && y <= height - height / 3) {    if (key == moveDown) {        y = y + 5;    }// closing if key = moveDown}',correct
'keyPressed && y <= height - height / 3',DecentralizedEventHandlingRule
'int textColorR = 255;',correct
'line(0, 0, size, 0)',correct
'rad = bottleSize;',correct
'line(0, height / 4, width, height / 4)',correct
'// closing if x == 0if (rad == 0) {    y = random(height / 3, height - height / 3);    x = width;    if (x == width) {        rad = bottleSize;    }// closing if x == width}',correct
'polly = new Tadpole(width / 30, height / 2, tadBodySize, tadHeadSize);',correct
'key == moveUp',correct
'// closing if rad == 0',correct
'new Tadpole(width / 10, height / 2, tadBodySize, tadHeadSize)',correct
'headSize',correct
'// standard sizes// Tadint tadBodySize = 70;',correct
'taddy.moveUpDown(w, s)',correct
'height - height / 4',correct
'float initX',correct
'height - height / 3',correct
'float initY',correct
'// closing if dist',correct
'int textColorG = 255;',correct
'{    fill(200);    stroke(0);    rectMode(CORNER);    rect(x, y, 0.4f * width, 0.2f * height);    textSize(32);    fill(textColorR, textColorG, textColorB);    text("Health " + health, x + 20, y + 34);    text("Score " + score, x + 20, y + 60);    if (health == 0) {        fill(0, 0, 0, 0.5f);        rect(0, 0, width, height);        textSize(20);        text("Your score was" + score, 20, height / 4);        text("You lost your health! Did you know already that fishes are dying from plastics in the oceans? Its a very big problem and thats the reason why I made this game. The special effects are showing how bad it is for fish.", 10, height / 2);    }// closing if health = 0;}',correct
'// closing if keyPressedif (mousePressed && mouseY < height / 2 && y > height / 3) {    y = y - 5;}',correct
'health = 1000',correct
'// streamSpeed and waveHeightfloat streamSpeed = 5;',correct
'// closing if mousePressed',correct
'0.05f * height',correct
'x = x - streamSpeed;',correct
'textColorG = 255',correct
'new Bottle(width, random(height / 3, height - height / 3), bottleSize, bottleRange)',correct
'float initRange',correct
'cos(x / waveLength)',correct
'// draw headfill(0);',correct
'y = y + 5',correct
'void setup() {    // create taddys    taddy = new Tadpole(width / 10, height / 2, tadBodySize, tadHeadSize);    if (pollyHelps) {        polly = new Tadpole(width / 30, height / 2, tadBodySize, tadHeadSize);    }    // closing if pollyHelps    // create plastic bottle    bottle = new Bottle(width, random(height / 3, height - height / 3), bottleSize, bottleRange);    // create scoreboard    scoreboard = new ScoreBoard(0.05f * width, 0.05f * height);}',correct
'void',correct
'health = health - 1;',DrawingStateChangeRule
'size = initSize;',correct
'x - streamSpeed',correct
'bottle.jumpBackToStart()',correct
'// closing if x == width',correct
'// set the position// housekeeping the translation by storing it for the next TadpolepushMatrix();',correct
'bottle = new Bottle(width, random(height / 3, height - height / 3), bottleSize, bottleRange);',DrawingStateChangeRule
'strokeWeight(2)',correct
'class Bottle {    float x;    float y;    float rad;    float range;    Bottle(float initX, float initY, float initRad, float initRange) {        y = initY;        x = initX;        rad = initRad;        range = initRange;    }    // closing constructor    void display() {        PImage bottleImg = loadImage("plasticBottle.png");        imageMode(CENTER);        image(bottleImg, x, y, rad, rad);    }    // closing display    void enterStream() {        x = x - streamSpeed;        y = y - waveHeight * cos(x / waveLength);    // if (y>height-height/2&&y<height-height/2-2||y<height-height/2&&y>height-height/2+2) {    // streamSpeed *=-1;    // waveHeight *=-1;    }    // closing enterStream    void jumpBackToStart() {        if (x == 0) {            y = random(height / 3, height - height / 3);            x = width;            score = score + 1;        }        // closing if x == 0        if (rad == 0) {            y = random(height / 3, height - height / 3);            x = width;            if (x == width) {                rad = bottleSize;            }        // closing if x == width        }    // closing if rad == 0    }    // closing void jump back to start}',correct
'if (x == 0) {    y = random(height / 3, height - height / 3);    x = width;    score = score + 1;}',correct
'// bottleSpawnsInStream so it has entered stream alreadybottle.enterStream();',correct
'{    // create taddys    taddy = new Tadpole(width / 10, height / 2, tadBodySize, tadHeadSize);    if (pollyHelps) {        polly = new Tadpole(width / 30, height / 2, tadBodySize, tadHeadSize);    }    // closing if pollyHelps    // create plastic bottle    bottle = new Bottle(width, random(height / 3, height - height / 3), bottleSize, bottleRange);    // create scoreboard    scoreboard = new ScoreBoard(0.05f * width, 0.05f * height);}',correct
'text("Health " + health, x + 20, y + 34)',correct
'// bottle jumps back to start when he is at x == 0bottle.jumpBackToStart();',correct
'if (health == 0) {    fill(0, 0, 0, 0.5f);    rect(0, 0, width, height);    textSize(20);    text("Your score was" + score, 20, height / 4);    text("You lost your health! Did you know already that fishes are dying from plastics in the oceans? Its a very big problem and thats the reason why I made this game. The special effects are showing how bad it is for fish.", 10, height / 2);}',correct
'char moveUp',correct
'// plastic bottle',correct
'bottle.enterStream()',correct
'ellipse(size - headSize / 2, 0, headSize, headSize)',correct
'{    if (keyPressed && y > height / 3) {        if (key == moveUp) {            y = y - 5;        }    // closing if key = moveUp    }    // closing if keyPressed    if (mousePressed && mouseY < height / 2 && y > height / 3) {        y = y - 5;    }    // closing if mousePressed    if (keyPressed && y <= height - height / 3) {        if (key == moveDown) {            y = y + 5;        }    // closing if key = moveDown    }    // closing if keyPressed    if (mousePressed && mouseY > height / 2 && y < height - height / 3) {        y = y + 5;    }// closing if mousePressed}',correct
'popMatrix()',correct
'width / 30',correct
'// plastic bottle// display bottlebottle.display();',correct
'background(68, 235, 214)',correct
'stroke(255);',correct
'headSize = initHeadSize;',correct
'mousePressed && mouseY < height / 2',correct
'{    PImage bottleImg = loadImage("plasticBottle.png");    imageMode(CENTER);    image(bottleImg, x, y, rad, rad);}',correct
'class Tadpole {    float x;    float y;    float size;    float headSize;    Tadpole(float initX, float initY, float initSize, float initHeadSize) {        x = initX;        y = initY;        size = initSize;        headSize = initHeadSize;    }    void display() {        // set the position        // housekeeping the translation by storing it for the next Tadpole        pushMatrix();        translate(x, y);        // draw body        strokeWeight(2);        stroke(0);        line(0, 0, size, 0);        // draw head        fill(0);        stroke(255);        ellipse(size - headSize / 2, 0, headSize, headSize);        // draw a white eye, relative to the headSize        fill(255);        ellipse((size - headSize / 2) + headSize / 8, -headSize / 10, headSize / 5, headSize / 5);        // housekeeping the translation by restoring it for the next Tadpole        popMatrix();    }    // close void display    // move up and down using w and s keys.    void moveUpDown(char moveUp, char moveDown) {        if (keyPressed && y > height / 3) {            if (key == moveUp) {                y = y - 5;            }        // closing if key = moveUp        }        // closing if keyPressed        if (mousePressed && mouseY < height / 2 && y > height / 3) {            y = y - 5;        }        // closing if mousePressed        if (keyPressed && y <= height - height / 3) {            if (key == moveDown) {                y = y + 5;            }        // closing if key = moveDown        }        // closing if keyPressed        if (mousePressed && mouseY > height / 2 && y < height - height / 3) {            y = y + 5;        }    // closing if mousePressed    }    // closing moveUpDown    void TadpolefeelsItem(float theItemX, float theItemY, float theItemRad, float theItemRange) {        if (dist(theItemX, theItemY, x, y) <= theItemRange + headSize) {            theItemRad = 0;            bottle.rad = theItemRad;            fill(255, 20, 20);            noStroke();            ellipse(x + size, y + headSize / 2, 15, 10);            health = health - 1;        }    // closing if dist    }    // closing feelsItem}',correct
'// closing if key = moveDown',correct
'float initHeadSize',correct
'headSize = initHeadSize',correct
'float rad;',correct
'y + 5',correct
'"You lost your health! Did you know already that fishes are dying from plastics in the oceans? Its a very big problem and thats the reason why I made this game. The special effects are showing how bad it is for fish."',correct
'bottle.display()',correct
'mousePressed && mouseY > height / 2',correct
'moveUpDown',correct
'fill(0, 0, 0, 0.5f);',correct
'line(0, height / 4, width, height / 4);',correct
'{    bottle = new Bottle(width, random(height / 3, height - height / 3), bottleSize, bottleRange);}',correct
'fill(0, 0, 0, 0.5f)',correct
'// closing feelsItem',correct
'"Your score was" + score',correct
'y + 34',correct
'int tadHeadSize = 40;',correct
'// if (y>height-height/2&&y<height-height/2-2||y<height-height/2&&y>height-height/2+2) {',correct
'textColorR = 255',correct
'text("You lost your health! Did you know already that fishes are dying from plastics in the oceans? Its a very big problem and thats the reason why I made this game. The special effects are showing how bad it is for fish.", 10, height / 2);',correct
'key == moveDown',correct
'bottle.rad',correct
'class ScoreBoard {    float x;    float y;    int textColorR = 255;    int textColorG = 255;    int textColorB = 255;    ScoreBoard(float initX, float initY) {        x = initX;        y = initY;    }    // closing Constructor    void display() {        fill(200);        stroke(0);        rectMode(CORNER);        rect(x, y, 0.4f * width, 0.2f * height);        textSize(32);        fill(textColorR, textColorG, textColorB);        text("Health " + health, x + 20, y + 34);        text("Score " + score, x + 20, y + 60);        if (health == 0) {            fill(0, 0, 0, 0.5f);            rect(0, 0, width, height);            textSize(20);            text("Your score was" + score, 20, height / 4);            text("You lost your health! Did you know already that fishes are dying from plastics in the oceans? Its a very big problem and thats the reason why I made this game. The special effects are showing how bad it is for fish.", 10, height / 2);        }    // closing if health = 0;    }    // closing Display}',correct
'// closing if keyPressedif (mousePressed && mouseY > height / 2 && y < height - height / 3) {    y = y + 5;}',correct
'y > height / 3',correct
'// closing moveUpDown',correct
'xDirection = -1',correct
'void update() {    if (brake) {        lightColor = color(255, 0, 0);    } else {        lightColor = color(0, 255, 0);    }}',correct
'x - 90',correct
'ellipse(x + 60, y + 15, 30, 30)',correct
'y = carY;',correct
'arc(x - 90, y, 30, 30, PI, PI + HALF_PI)',correct
'car[i]',correct
'x = x + (xSpeed * xDirection)',correct
'background(255);',correct
'color(255, 0, 0)',correct
'arc(x - 60, y, 30, 30, PI, PI + HALF_PI);',correct
'TrafficLight trafficLight;',correct
'void mousePressed() {    for (int i = 0; i < cars; i++) {        car[i].isBrake();    }    trafficLight.isBrake();}',correct
'!brake',correct
'fill(rearLight);',correct
'{    xDirection = -1;}',correct
'quad(x + 15, y - 15, x + 15, y - 40, x + 30, y - 40, x + 45, y - 15);',correct
'y = trafficY;',correct
'ellipse(x + 30, y + 15, 30, 30)',correct
'// tiresfill(0);',correct
'fill(0);',correct
'trafficLight = new TrafficLight(0, 0)',correct
'// lightsfill(255, 255, 0);',correct
'quad(x - 60, y - 15, x - 30, y - 40, x + 15, y - 40, x + 15, y - 15);',correct
'xDirection = -1;',correct
'new Car((PApplet.parseInt(random(100, width - 100))), (PApplet.parseInt(random(100, height - 100))))',correct
'color(0, 255, 0)',correct
'{    lightColor = color(255, 0, 0);}',correct
'{    brake = true;}',correct
'{    trafficLight = new TrafficLight(0, 0);    for (int i = 0; i < cars; i++) {        car[i] = new Car((PApplet.parseInt(random(100, width - 100))), (PApplet.parseInt(random(100, height - 100))));    }}',correct
'if (x > width - 105) {    xDirection = -1;} else if (x < 105) {    xDirection = 1;}',correct
'fill(lightColor);',correct
'y - 15',correct
'i < cars',correct
'for (int i = 0; i < cars; i++) {    car[i].display();    car[i].update();}',correct
'trafficLight.update()',correct
'arc(x + 90, y, 30, 30, PI + HALF_PI, TWO_PI);',correct
'x',correct
'y',correct
'x = trafficX;',correct
'// bodyfill(180);',correct
'x + 15',correct
'x > width - 105',correct
'noStroke()',correct
'fill(100);',correct
'xDirection = 1;',correct
'rect(x - 60, y - 15, 150, 15);',correct
'{    if (mouseX <= 50 && mouseY <= 50 && !brake) {        brake = true;    } else if (mouseX <= 50 && mouseY <= 50) {        brake = false;    }    return brake;}',correct
'fill(100)',correct
'brake = false',correct
'Car(float carX, float carY) {    x = carX;    y = carY;}',correct
'{    ellipseMode(CENTER);    noStroke();    if (xDirection == 1) {        // body        fill(180);        rect(x - 75, y, 180, 15);        rect(x - 60, y - 15, 150, 15);        // tires        fill(0);        ellipse(x - 30, y + 15, 30, 30);        ellipse(x + 60, y + 15, 30, 30);        // lights        fill(255, 255, 0);        arc(x + 90, y, 30, 30, PI + HALF_PI, TWO_PI);        fill(rearLight);        arc(x - 60, y, 30, 30, PI, PI + HALF_PI);        // roof        fill(204, 247, 255);        quad(x - 15, y - 15, x - 15, y - 40, x + 30, y - 40, x + 60, y - 15);        fill(100);        quad(x - 45, y - 15, x - 30, y - 40, x - 15, y - 40, x - 15, y - 15);    } else {        // body        fill(180);        rect(x - 105, y, 180, 15);        rect(x - 90, y - 15, 150, 15);        // tires        fill(0);        ellipse(x - 60, y + 15, 30, 30);        ellipse(x + 30, y + 15, 30, 30);        // lights        fill(255, 255, 0);        arc(x - 90, y, 30, 30, PI, PI + HALF_PI);        fill(rearLight);        arc(x + 60, y, 30, 30, PI + HALF_PI, TWO_PI);        // roof        fill(204, 247, 255);        quad(x - 60, y - 15, x - 30, y - 40, x + 15, y - 40, x + 15, y - 15);        fill(100);        quad(x + 15, y - 15, x + 15, y - 40, x + 30, y - 40, x + 45, y - 15);    }}',LongMethodRule
'int cars = 5;',correct
'rearLight = color(brakeLight)',correct
'mouseX <= 50',correct
'rearLight = color(255, 0, 0)',correct
'int xDirection = 1;',correct
'PI + HALF_PI',correct
'class TrafficLight {    float x;    float y;    int lightColor;    boolean brake;    TrafficLight(float trafficX, float trafficY) {        x = trafficX;        y = trafficY;    }    void display() {        ellipseMode(CENTER);        fill(0);        rect(0, 0, 50, 50);        fill(lightColor);        ellipse(25, 25, 35, 35);    }    void update() {        if (brake) {            lightColor = color(255, 0, 0);        } else {            lightColor = color(0, 255, 0);        }    }    boolean isBrake() {        if (mouseX <= 50 && mouseY <= 50 && !brake) {            brake = true;        } else if (mouseX <= 50 && mouseY <= 50) {            brake = false;        }        return brake;    }}',correct
'int brakeLight = color(255, 100, 0);',correct
'x - 60',correct
'cars = 5',correct
'rect(x - 90, y - 15, 150, 15)',correct
'brakeLight = color(255, 100, 0)',correct
'y = carY',correct
'brake',correct
'fill(0)',correct
'arc(x - 90, y, 30, 30, PI, PI + HALF_PI);',correct
'{    xSpeed = 1;    rearLight = color(255, 0, 0);}',correct
'xDirection = 1',correct
'fill(180)',correct
'if (xDirection == 1) {    // body    fill(180);    rect(x - 75, y, 180, 15);    rect(x - 60, y - 15, 150, 15);    // tires    fill(0);    ellipse(x - 30, y + 15, 30, 30);    ellipse(x + 60, y + 15, 30, 30);    // lights    fill(255, 255, 0);    arc(x + 90, y, 30, 30, PI + HALF_PI, TWO_PI);    fill(rearLight);    arc(x - 60, y, 30, 30, PI, PI + HALF_PI);    // roof    fill(204, 247, 255);    quad(x - 15, y - 15, x - 15, y - 40, x + 30, y - 40, x + 60, y - 15);    fill(100);    quad(x - 45, y - 15, x - 30, y - 40, x - 15, y - 40, x - 15, y - 15);} else {    // body    fill(180);    rect(x - 105, y, 180, 15);    rect(x - 90, y - 15, 150, 15);    // tires    fill(0);    ellipse(x - 60, y + 15, 30, 30);    ellipse(x + 30, y + 15, 30, 30);    // lights    fill(255, 255, 0);    arc(x - 90, y, 30, 30, PI, PI + HALF_PI);    fill(rearLight);    arc(x + 60, y, 30, 30, PI + HALF_PI, TWO_PI);    // roof    fill(204, 247, 255);    quad(x - 60, y - 15, x - 30, y - 40, x + 15, y - 40, x + 15, y - 15);    fill(100);    quad(x + 15, y - 15, x + 15, y - 40, x + 30, y - 40, x + 45, y - 15);}',correct
'rect(x - 75, y, 180, 15);',correct
'car[i].display()',correct
'quad(x - 45, y - 15, x - 30, y - 40, x - 15, y - 40, x - 15, y - 15)',correct
'new TrafficLight(0, 0)',correct
'y - 40',correct
'x - 75',correct
'car[i].update();',correct
'float x;',correct
'x - 105',correct
'mouseY <= 50',correct
'background(255)',correct
'Processing',correct
'brake = true',correct
'fill(rearLight)',correct
'if (brake) {    lightColor = color(255, 0, 0);} else {    lightColor = color(0, 255, 0);}',correct
'{    // body    fill(180);    rect(x - 105, y, 180, 15);    rect(x - 90, y - 15, 150, 15);    // tires    fill(0);    ellipse(x - 60, y + 15, 30, 30);    ellipse(x + 30, y + 15, 30, 30);    // lights    fill(255, 255, 0);    arc(x - 90, y, 30, 30, PI, PI + HALF_PI);    fill(rearLight);    arc(x + 60, y, 30, 30, PI + HALF_PI, TWO_PI);    // roof    fill(204, 247, 255);    quad(x - 60, y - 15, x - 30, y - 40, x + 15, y - 40, x + 15, y - 15);    fill(100);    quad(x + 15, y - 15, x + 15, y - 40, x + 30, y - 40, x + 45, y - 15);}',correct
'trafficLight.isBrake()',correct
'arc(x + 90, y, 30, 30, PI + HALF_PI, TWO_PI)',correct
'{    if (brake) {        lightColor = color(255, 0, 0);    } else {        lightColor = color(0, 255, 0);    }}',correct
'float y;',correct
'false',correct
'{    lightColor = color(0, 255, 0);}',correct
'x = trafficX',correct
'{    for (int i = 0; i < cars; i++) {        car[i].isBrake();    }    trafficLight.isBrake();}',correct
'fill(204, 247, 255)',correct
'for (int i = 0; i < cars; i++) {    car[i] = new Car((PApplet.parseInt(random(100, width - 100))), (PApplet.parseInt(random(100, height - 100))));}',correct
'int i = 0',correct
'ellipseMode(CENTER);',correct
'for (int i = 0; i < cars; i++) {    car[i].isBrake();}',correct
'{    if (x > width - 105) {        xDirection = -1;    } else if (x < 105) {        xDirection = 1;    }    if (brake) {        xSpeed = 0;        rearLight = color(brakeLight);    } else {        xSpeed = 1;        rearLight = color(255, 0, 0);    }    x = x + (xSpeed * xDirection);}',correct
'{    car[i] = new Car((PApplet.parseInt(random(100, width - 100))), (PApplet.parseInt(random(100, height - 100))));}',correct
'int rearLight = color(255, 0, 0);',correct
'TrafficLight(float trafficX, float trafficY) {    x = trafficX;    y = trafficY;}',correct
'i = 0',correct
'x - 15',correct
'brake = true;',correct
'x + (xSpeed * xDirection)',correct
'lightColor = color(0, 255, 0);',correct
'color(brakeLight)',correct
'lightColor = color(0, 255, 0)',correct
'trafficLight.display()',correct
'ellipse(x - 30, y + 15, 30, 30);',correct
'arc(x + 60, y, 30, 30, PI + HALF_PI, TWO_PI)',correct
'{    ellipseMode(CENTER);    fill(0);    rect(0, 0, 50, 50);    fill(lightColor);    ellipse(25, 25, 35, 35);}',correct
'quad(x + 15, y - 15, x + 15, y - 40, x + 30, y - 40, x + 45, y - 15)',correct
'rect(x - 60, y - 15, 150, 15)',correct
'void update() {    if (x > width - 105) {        xDirection = -1;    } else if (x < 105) {        xDirection = 1;    }    if (brake) {        xSpeed = 0;        rearLight = color(brakeLight);    } else {        xSpeed = 1;        rearLight = color(255, 0, 0);    }    x = x + (xSpeed * xDirection);}',correct
'rect(x - 105, y, 180, 15);',correct
'boolean brake;',correct
'return brake;',correct
'{    car[i].display();    car[i].update();}',correct
'float trafficX',correct
'void draw() {    background(255);    trafficLight.display();    trafficLight.update();    for (int i = 0; i < cars; i++) {        car[i].display();        car[i].update();    }}',correct
'noStroke();',correct
'{    // body    fill(180);    rect(x - 75, y, 180, 15);    rect(x - 60, y - 15, 150, 15);    // tires    fill(0);    ellipse(x - 30, y + 15, 30, 30);    ellipse(x + 60, y + 15, 30, 30);    // lights    fill(255, 255, 0);    arc(x + 90, y, 30, 30, PI + HALF_PI, TWO_PI);    fill(rearLight);    arc(x - 60, y, 30, 30, PI, PI + HALF_PI);    // roof    fill(204, 247, 255);    quad(x - 15, y - 15, x - 15, y - 40, x + 30, y - 40, x + 60, y - 15);    fill(100);    quad(x - 45, y - 15, x - 30, y - 40, x - 15, y - 40, x - 15, y - 15);}',correct
'x = carX;',correct
'rect(x - 90, y - 15, 150, 15);',correct
'car[i].update()',correct
'x - 30',correct
'quad(x - 45, y - 15, x - 30, y - 40, x - 15, y - 40, x - 15, y - 15);',correct
'x + 90',correct
'xDirection == 1',correct
'[cars]',correct
'float trafficY',correct
'int lightColor;',correct
'{    xDirection = 1;}',correct
'{    background(255);    trafficLight.display();    trafficLight.update();    for (int i = 0; i < cars; i++) {        car[i].display();        car[i].update();    }}',correct
'if (mouseX <= 50 && mouseY <= 50 && !brake) {    brake = true;} else if (mouseX <= 50 && mouseY <= 50) {    brake = false;}',correct
'if (x < 105) {    xDirection = 1;}',correct
'new Car[cars]',correct
'rect(x - 105, y, 180, 15)',correct
'x - 45',correct
'display',LongMethodRule
'void display() {    ellipseMode(CENTER);    fill(0);    rect(0, 0, 50, 50);    fill(lightColor);    ellipse(25, 25, 35, 35);}',correct
'arc(x - 60, y, 30, 30, PI, PI + HALF_PI)',correct
'car = new Car[cars]',correct
'width - 105',correct
'{    xSpeed = 0;    rearLight = color(brakeLight);}',correct
'if (brake) {    xSpeed = 0;    rearLight = color(brakeLight);} else {    xSpeed = 1;    rearLight = color(255, 0, 0);}',correct
'{    brake = false;}',correct
'x + 30',correct
'i++',correct
'TrafficLight',correct
'x < 105',correct
'ellipseMode(CENTER)',correct
'fill(255, 255, 0)',correct
'rearLight = color(255, 0, 0);',correct
'car[i].display();',correct
'trafficLight = new TrafficLight(0, 0);',correct
'rect(0, 0, 50, 50)',correct
'lightColor = color(255, 0, 0)',correct
'xSpeed = 1;',correct
'trafficLight.update();',correct
'ellipse(25, 25, 35, 35)',correct
'x = x + (xSpeed * xDirection);',correct
'x + 45',correct
'void',correct
'car[i].isBrake()',correct
'-1',correct
'brake = false;',correct
'rect(x - 75, y, 180, 15)',correct
'color(255, 100, 0)',correct
'car[i] = new Car((PApplet.parseInt(random(100, width - 100))), (PApplet.parseInt(random(100, height - 100))));',correct
'float carX',correct
'ellipse(x - 30, y + 15, 30, 30)',correct
'quad(x - 15, y - 15, x - 15, y - 40, x + 30, y - 40, x + 60, y - 15);',correct
'float carY',correct
'void setup() {    trafficLight = new TrafficLight(0, 0);    for (int i = 0; i < cars; i++) {        car[i] = new Car((PApplet.parseInt(random(100, width - 100))), (PApplet.parseInt(random(100, height - 100))));    }}',correct
'class Car {    float x;    float y;    int xDirection = 1;    float xSpeed = 1;    boolean brake;    int rearLight = color(255, 0, 0);    int brakeLight = color(255, 100, 0);    Car(float carX, float carY) {        x = carX;        y = carY;    }    void display() {        ellipseMode(CENTER);        noStroke();        if (xDirection == 1) {            // body            fill(180);            rect(x - 75, y, 180, 15);            rect(x - 60, y - 15, 150, 15);            // tires            fill(0);            ellipse(x - 30, y + 15, 30, 30);            ellipse(x + 60, y + 15, 30, 30);            // lights            fill(255, 255, 0);            arc(x + 90, y, 30, 30, PI + HALF_PI, TWO_PI);            fill(rearLight);            arc(x - 60, y, 30, 30, PI, PI + HALF_PI);            // roof            fill(204, 247, 255);            quad(x - 15, y - 15, x - 15, y - 40, x + 30, y - 40, x + 60, y - 15);            fill(100);            quad(x - 45, y - 15, x - 30, y - 40, x - 15, y - 40, x - 15, y - 15);        } else {            // body            fill(180);            rect(x - 105, y, 180, 15);            rect(x - 90, y - 15, 150, 15);            // tires            fill(0);            ellipse(x - 60, y + 15, 30, 30);            ellipse(x + 30, y + 15, 30, 30);            // lights            fill(255, 255, 0);            arc(x - 90, y, 30, 30, PI, PI + HALF_PI);            fill(rearLight);            arc(x + 60, y, 30, 30, PI + HALF_PI, TWO_PI);            // roof            fill(204, 247, 255);            quad(x - 60, y - 15, x - 30, y - 40, x + 15, y - 40, x + 15, y - 15);            fill(100);            quad(x + 15, y - 15, x + 15, y - 40, x + 30, y - 40, x + 45, y - 15);        }    }    void update() {        if (x > width - 105) {            xDirection = -1;        } else if (x < 105) {            xDirection = 1;        }        if (brake) {            xSpeed = 0;            rearLight = color(brakeLight);        } else {            xSpeed = 1;            rearLight = color(255, 0, 0);        }        x = x + (xSpeed * xDirection);    }    boolean isBrake() {        if (mouseX <= 50 && mouseY <= 50 && !brake) {            brake = true;        } else if (mouseX <= 50 && mouseY <= 50) {            brake = false;        }        return brake;    }}',correct
'ellipse(x - 60, y + 15, 30, 30);',correct
'Car',correct
'true',correct
'// rooffill(204, 247, 255);',correct
'rect(0, 0, 50, 50);',PixelHardcodeIgnoranceRule
'quad(x - 15, y - 15, x - 15, y - 40, x + 30, y - 40, x + 60, y - 15)',correct
'xSpeed = 0;',correct
'Car[] car = new Car[cars];',correct
'{    x = carX;    y = carY;}',correct
'quad(x - 60, y - 15, x - 30, y - 40, x + 15, y - 40, x + 15, y - 15)',correct
'trafficLight.isBrake();',correct
'Car[]',correct
'void display() {    ellipseMode(CENTER);    noStroke();    if (xDirection == 1) {        // body        fill(180);        rect(x - 75, y, 180, 15);        rect(x - 60, y - 15, 150, 15);        // tires        fill(0);        ellipse(x - 30, y + 15, 30, 30);        ellipse(x + 60, y + 15, 30, 30);        // lights        fill(255, 255, 0);        arc(x + 90, y, 30, 30, PI + HALF_PI, TWO_PI);        fill(rearLight);        arc(x - 60, y, 30, 30, PI, PI + HALF_PI);        // roof        fill(204, 247, 255);        quad(x - 15, y - 15, x - 15, y - 40, x + 30, y - 40, x + 60, y - 15);        fill(100);        quad(x - 45, y - 15, x - 30, y - 40, x - 15, y - 40, x - 15, y - 15);    } else {        // body        fill(180);        rect(x - 105, y, 180, 15);        rect(x - 90, y - 15, 150, 15);        // tires        fill(0);        ellipse(x - 60, y + 15, 30, 30);        ellipse(x + 30, y + 15, 30, 30);        // lights        fill(255, 255, 0);        arc(x - 90, y, 30, 30, PI, PI + HALF_PI);        fill(rearLight);        arc(x + 60, y, 30, 30, PI + HALF_PI, TWO_PI);        // roof        fill(204, 247, 255);        quad(x - 60, y - 15, x - 30, y - 40, x + 15, y - 40, x + 15, y - 15);        fill(100);        quad(x + 15, y - 15, x + 15, y - 40, x + 30, y - 40, x + 45, y - 15);    }}',correct
'arc(x + 60, y, 30, 30, PI + HALF_PI, TWO_PI);',correct
'y + 15',correct
'if (mouseX <= 50 && mouseY <= 50) {    brake = false;}',correct
'ellipse(25, 25, 35, 35);',PixelHardcodeIgnoranceRule
'lightColor = color(255, 0, 0);',correct
'ellipse(x + 60, y + 15, 30, 30);',correct
'car[i].isBrake();',correct
'float xSpeed = 1;',correct
'ellipse(x - 60, y + 15, 30, 30)',correct
'lightColor',correct
'car[i] = new Car((PApplet.parseInt(random(100, width - 100))), (PApplet.parseInt(random(100, height - 100))))',correct
'x + 60',correct
'{    x = trafficX;    y = trafficY;}',correct
'ellipse(x + 30, y + 15, 30, 30);',correct
'x = carX',correct
'rearLight = color(brakeLight);',correct
'mouseX <= 50 && mouseY <= 50',correct
'boolean isBrake() {    if (mouseX <= 50 && mouseY <= 50 && !brake) {        brake = true;    } else if (mouseX <= 50 && mouseY <= 50) {        brake = false;    }    return brake;}',correct
'trafficLight.display();',correct
'y = trafficY',correct
'xSpeed = 0',correct
'{    car[i].isBrake();}',correct
'xSpeed = 1',correct
'fill(lightColor)',correct
'trafficLight',correct
'mouseX <= 50 && mouseY <= 50 && !brake',correct
'shaper.right_trigger = false',correct
'b > 255',correct
'cos(t / frequency) * 85',correct
'g++',correct
'orbit_weight_trigger = false',correct
'// CHANGE WEIGHT ORBIT SEGMENTS WHEN KEY IS PRESSED//orbit_lines_key_trigger = true;',correct
'// ellipse (0 , 0 , range2 , range2);',correct
'// noFill();',correct
'random(-width, width)',correct
'random(0, 255)',correct
'if (opacity > 0) {    opacity -= 0.1f;}',correct
'parametric.t = random(20, 100);',correct
'{    if (colorUpdate <= 255 && color_trigger == true) {        colorUpdate += colorChange * 30;        if (colorUpdate > 254) {            colorUpdate = 0;        }    } else {        if (colorUpdate > 0) {            colorUpdate -= colorChange;        }    }    if (color_trigger == true) {        vertexX = sin(parametric.t / 40) * 40;        vertexY = cos(parametric.t / 40) * 40;    }}',correct
'eyeX = x',correct
'stroke(238, 169, 144)',correct
'eyeOpacity = eyeOpacity - opacitySpeed;',correct
'println(opacity)',correct
'{    colorUpdate = 0;}',correct
'// ROTATING SEGMENTS BECOME MORE THIN WHEN MOUSE CLICKEDorbit_lines_mouse_trigger = true;',correct
'sin(parametric.t / (parametric.frequency / 2)) * expansion_width + 10 * i',correct
'-height',correct
'new EyeBall(60, 0)',correct
'(cos(parametric.n / 65) + 1) * 8',correct
'if (float_key_trigger == true) {    return sin(t / frequency) * 100;}',SimplifyBooleanExpressions
'parametric.x4(parametric.t)',correct
'vertexY = cos(parametric.t / 40) * 40',correct
'return sin(-n / frequency) * 20;',correct
'n1 / 24',correct
'guidePoints.display();',correct
'void color_update() {    if (colorUpdate <= 255 && color_trigger == true) {        colorUpdate += colorChange * 30;        if (colorUpdate > 254) {            colorUpdate = 0;        }    } else {        if (colorUpdate > 0) {            colorUpdate -= colorChange;        }    }    if (color_trigger == true) {        vertexX = sin(parametric.t / 40) * 40;        vertexY = cos(parametric.t / 40) * 40;    }}',MethodNamingConventions
'sin(parametric.t / 30) * 30',correct
'shakingFXrange_2',correct
'shakingFXrange_1',correct
'point(parametric.x4(parametric.t), parametric.y4(parametric.n))',correct
';',EmptyStatementNotInLoop
'update_sustain_ellipse()',correct
'stroke_weight <= 0',correct
'vertex(0, vertexY);',correct
'n = 0',correct
'shaper = new Shaper()',correct
'// MOVING CENTRAL SHAPEshaper.display();',correct
'stroke_weight = 1500',correct
'fill(0);',correct
'increment = 0.9f',correct
'cos(n / frequency)',correct
'N',correct
'{    // TRANSLATE EVERYTING TO CENTER.    translate(width / 2, height / 2);    if (trigger_background == true) {        // --------------R-E-G-U-L-A-R----M-O-D-E----W-I-T-H-----B-A-C-K-G-R-O-U-N-D------//        parametric.parametric_increment();        background(sin(parametric.t / 30) * 30 + 50, cos(parametric.t / 30) * 30 + 50, -sin(parametric.n / 30) * 30 + 50);        stroke(238, 169, 144);        for (int i = 0; i < 100; i++) {            space[i].display();            space[i].update();        }        display_externalFX();        update_externalFX();        // --------------------------E-X-P-A-N-D-I-N-G-------C-I-R-C-L-E-S--------------------//        display_internalFX();        update_internalFX();        draw_sustain_ellipse();        // CENTRAL FIXED ELLIPSE        update_sustain_ellipse();        shakingFXrange_1.display();        shakingFXrange_1.shake();        // MOVING CENTRAL SHAPE        shaper.display();        shaper.color_update();        shaper.color_fill();        shaper.expansion();        shaper.de_expansion();        shakingFXrange_2.display();        shakingFXrange_2.shake();        eye_1.display();        eye_1.update();        eye_2.display();        eye_2.update();        display_main_orbits();        display_orbit_lines();        display_central_orbit();        central_orbit_move();        central_orbit_weight_update();        guidePoints.display();        guidePoints.change_color();    } else {        // ------------A-C-T-I-V-A-T-E---D-R-E-A-M-----M-O-D-E---------------//        // ALL THE T AND N VALUES ARE INCREMENTING        parametric.parametric_increment();        for (int i = 0; i < 100; i++) {            space[i].display();            space[i].update();        }        // 50 OPACITY TO THE "FAKE" BACKGROUND TO CREATE THE ECHO EFFECT        fill(sin(parametric.t / 30) * 30, cos(parametric.t / 30) * 30, -sin(parametric.n / 30) * 30, 50);        noStroke();        rectMode(CENTER);        rect(0, 0, width, height);        shakingFXrange_1.display();        shakingFXrange_1.shake();        shakingFXrange_2.display();        shakingFXrange_2.shake();        eye_1.display();        eye_1.update();        eye_2.display();        eye_2.update();        display_main_orbits();        display_orbit_lines();        guidePoints.display();        guidePoints.change_color();    }    // IF MOUSE NOT DRAGGED, T AND N VALUES ARE SYNCHRONIZED, IF THE MOUSE IS DRAGGED, THE T VALUE IS ALTERED WHILE N KEEPS INCREASING. THIS    text(parametric.t, 600, 0);    // GENERATES THE RANDOM PATTERNS IF MOUSE IS DRAGGER. ONCE T REACHES 602, BOTH T AND N ARE RESETED TO THE SAME VALUE AGAIN.    text(parametric.n, 600, 200);}',LongMethodRule
'point(parametric.x2(parametric.t), parametric.y2(parametric.n))',correct
'colorChange = 0.5f',correct
'trigger_background = false',correct
'map(mouseX, 0, width, 0, 255)',correct
'8.5f',correct
'n1++;',DrawingStateChangeRule
'rectMode(CENTER)',correct
'b',correct
'opacity < 255',correct
'eye_2',correct
'eye_1',correct
'g',correct
'void expansion() {    // println("Expanding");    if (expansion_width < 200 && left_trigger == true) {        // println("Setting width");        expansion_width++;    }}',AtLeastOneConstructor
't1++',correct
'fill(238, 169, 144);',correct
'{    speed = 100;}',correct
'float weight_ = 4;',FieldDeclarationsShouldBeAtStartOfClass
'line(parametric.x1(parametric.t * i), parametric.y1(parametric.n * i), parametric.x2(parametric.t * i), parametric.y2(parametric.n * i));',correct
'vertexY = cos(parametric.t / (parametric.frequency / 2)) * expansion_width + 10 * i',correct
'orbit_weight += 0.5f',correct
'{    color_guide_points_X = 0;    color_guide_points_Y = 0;}',correct
'r',correct
'// DEACTIVATE FUNCTIONS ACTIVATED WITH PRESSING KEYorbit_lines_key_trigger = false;',correct
'strokeWeight(random(0, orbit_weight))',correct
'ellipseY = 0',correct
'x',correct
'arc(eyeX + 100, eyeY, 100, 200, radians(150), radians(60));',correct
'y',correct
'shakingFXrange_2.display()',correct
'shaper = new Shaper();',correct
'vertexX = sin(parametric.t / 40) * 40',correct
'eyeY = y',correct
'colorUpdate += colorChange * 30;',correct
'parametric.x3(parametric.t * i)',correct
'boolean trigger_background = true;',correct
'parametric.x3(parametric.t)',correct
'int b;',ShortVariable
'opacity += 0.5f',correct
'parametric.n * i',correct
'// PRESS THE CENTER BUTTON OF THE MOUSE TO ACTIVATE THE DREAM MODE. PRESS THE SAME BUTTON AGAIN TO TURN THE DREAM MODE OFF.',correct
'fill_g',correct
'opacity += 0.5f;',correct
'fill_b',correct
'x = random(-width, width)',correct
'{    return cos(n / frequency) * 100;}',correct
'expansion_width > 40 && right_trigger == true',correct
'{    if (mouseButton == RIGHT) {        // INCREASE SIZE CENTRAL SHAPE AND ACTIVATE COLOR PULSE        shaper.right_trigger = true;        shaper.color_trigger = true;    }    if (mouseButton == LEFT) {        // DECREASE SIZE CENTRAL SHAPE AND ACTIVATE COLOR PULSE        shaper.left_trigger = true;        shaper.color_trigger = true;    }    // ORBIDAL CIRCLES INCREASE THEIR STROKE WEIGHT    orbit_weight_trigger = true;    // ROTATING SEGMENTS BECOME MORE THIN WHEN MOUSE CLICKED    orbit_lines_mouse_trigger = true;    if (mouseButton == CENTER && trigger_background == true) {        // SWITCH FROM REGULAR MODE TO DEAM MODE AND VICEVERSA.        trigger_background = false;    } else if (mouseButton == CENTER && trigger_background == false) {        trigger_background = true;    }    // CALL X1 Y1 RETURNS (PATTERN 1)    parametric.float_mouse_trigger = true;    if (space[space.length - 1].opacity_trigger == false && mouseButton == CENTER) {        for (int i = 0; i < 100; i++) {            // ---------WHEN DREAM MODE IS ACTIVATED, SLOWLY INCREASE OPACITY OF SPACE STARS, WHEN DREAM MODE IS            space[i].opacity_trigger = true;        }    // ---------DEACTIVATED, SLOWLY DECREASE OPACITY    } else if (mouseButton == CENTER) {        for (int i = 0; i < 100; i++) {            space[i].opacity_trigger = false;        }    }}',correct
'fill_r',correct
'guidePoints = new GuidePoints();',correct
'{    t = t + increment;    n = n + increment;    if (t > 602.5f) {        t = 0;        n = 0;    }}',correct
'g > 255',correct
'void shake() {    range = PApplet.parseInt(random(random_1, random_2));}',correct
'eyeOpacity < 0 || eyeOpacity > 254',correct
'cos(t / frequency) * 20',correct
'orbit_weight_trigger = false;',correct
'float x;',correct
'if (mouseButton == LEFT) {    // DECREASE SIZE CENTRAL SHAPE AND ACTIVATE COLOR PULSE    shaper.left_trigger = true;    shaper.color_trigger = true;}',correct
'strokeWeight(15)',correct
'i < 5',correct
'guidePoints = new GuidePoints()',correct
'fill_b = random(100, 255)',correct
'random(0, 100)',correct
'i < 10',correct
'n = 0;',correct
'range_1 += 8.5f;',DrawingStateChangeRule
'right_trigger == true',correct
'sx * parametric_x',correct
'shakingFXrange_1.display();',correct
'float n(float n1) {    return cos(n1 / 24) * 350;}',ShortVariable
'for (int i = 0; i < 100; i++) {    space[i].display();    space[i].update();}',correct
'float y;',correct
'ellipse(0, 0, 600, 600)',correct
'{    if (colorUpdate > 0) {        colorUpdate -= colorChange;    }}',correct
'new ShakingFX(400, 500)',correct
'update_internalFX();',correct
'orbit_weight_trigger = true',correct
'{    speed = speed - 1;    if (speed < 1) {        speed = 100;    }    if (opacity_trigger == true && opacity < 255) {        opacity += 0.5f;    } else if (opacity_trigger == false) {        if (opacity > 0) {            opacity -= 0.1f;        }    }    println(opacity);}',correct
'{    opacitySpeed *= -1;}',correct
'void draw_sustain_ellipse() {    noFill();    ellipseMode(CENTER);    // SUSTAINING CENTRAL ELLIPSE    strokeWeight(weight_);    stroke(random(100, 170), random(120, 150), random(0, 255));    ellipse(0, 0, 398, 398);}',correct
'int numLines = 9;',FieldDeclarationsShouldBeAtStartOfClass
'strokeWeight(random(0, 2));',correct
'float fill_r, fill_g, fill_b;',correct
'sin(parametric.t / (parametric.frequency / 2))',correct
'// --------------R-E-G-U-L-A-R----M-O-D-E----W-I-T-H-----B-A-C-K-G-R-O-U-N-D------//parametric.parametric_increment();',correct
'fill(fill_r, fill_g, fill_b, opacity);',correct
'parametric.x2(parametric.t)',correct
'fill(varcol_2, varcol_2, 100, 100);',correct
'colorUpdate -= colorChange;',correct
'draw_sustain_ellipse',MethodNamingConventions
'{    for (int i = 1; i < numLines; i++) {        // strokeWeight(random( 1 , 100 ));        ix = (-sin(t1 * i / 100) * 100);        iy = (sin(n1 * i / 100) * 100);        noFill();        strokeWeight(random(0, orbit_weight));        ellipse((sin(parametric.t / 100) * (parametric.x2(parametric.t * i))), (cos(parametric.y2(parametric.n * i))), (ix / 6), (iy / 6));    }}',MethodNamingConventions
'float vertexY;',correct
'surface.setResizable(true);',correct
'fill_g = random(100, 200)',correct
'eye_2 = new EyeBall(-60, 0);',correct
'boolean opacity_trigger = false;',correct
'update_weight_orbit_lines_a()',correct
'eyeWidth_speed * -1',correct
'if (orbit_weight > 2) {    orbit_weight -= 0.5f;}',correct
'stroke_weight = 1500;',DrawingStateChangeRule
'602.5f',correct
'float vertexX;',AtLeastOneConstructor
'shaper.left_trigger = true',correct
'parametric.float_key_trigger',correct
'float y2(float t) {    if (float_key_trigger == true) {        return sin(t / frequency) * 100;    }    return -cos(-t / frequency) * 300;}',ShortVariable
'noStroke();',correct
'// SAME OF THE INTERNAL TWO POINTS MOLTIPLICATION, BUT THIS EXTERNAL POINTS ARE// ALL CONNECTED WITH A LINE, SO I HAVE MY ORBITAL SEGMENTS.update_weight_orbit_lines_a();',correct
'b = 0',correct
'g++;',correct
'orbit_weight > 2',correct
'space = new Space[100]',correct
'{    // SHAKING EFFECT PRODUCES BY WIDE RANDOM GENERATION OF RANGE VALUES.    strokeWeight(0);    stroke(255);    noFill();    ellipse(ellipseX, ellipseY, range, range);}',correct
'g = 0;',correct
'shakingFXrange_1 = new ShakingFX(25, 75);',correct
'float stroke_weight = 800;',FieldDeclarationsShouldBeAtStartOfClass
'float range_1 = 0;',FieldDeclarationsShouldBeAtStartOfClass
'vertexX = sin(parametric.t / 40) * 40;',correct
'eyeWidth_speed = 0.1f',correct
'shaper.right_trigger',correct
'update_externalFX();',correct
'float t1',correct
'boolean color_trigger = false;',correct
'orbit_lines_key_trigger == true',correct
'sin(parametric.t / 40)',correct
'sin(t1 / 48)',correct
'point(parametric.x4(parametric.t * i), parametric.y4(parametric.n * i));',correct
'{    ellipse(0, 0, 600, 600);}',correct
'right_trigger = false',correct
'eye_1 = new EyeBall(60, 0)',correct
'parametric.y4(parametric.n * i)',correct
'rect(0, 0, width, height)',correct
'{    fill(255, 255, 255);    // OPEN AND CLOSE THE EYES TROUGH CHANGING THE HEIGHT OF ELLIPSE    ellipse(eyeX, eyeY, 50, eyeWidth);    fill(0, 0, 0, eyeOpacity);    noStroke();    ellipse(eyeX, eyeY, 15, 15);    fill(255, 255, 255);    arc(eyeX + 100, eyeY, 100, 200, radians(150), radians(60));}',correct
'{    vertexX = sin(parametric.t / 40) * 40;    vertexY = cos(parametric.t / 40) * 40;}',correct
't + increment',correct
'stroke(abs(color_guide_points_X), abs(color_guide_points_Y), 0)',correct
'cos(parametric.t / (parametric.frequency / 2)) * expansion_width + 10 * i',correct
'EyeBall(float x, float y) {    eyeX = x;    eyeY = y;    eyeOpacity = eyeOpacity - opacitySpeed;}',correct
'strokeWeight(0)',correct
'strokeWeight(0.5f)',correct
'return -sin(-n / frequency) * 200;',correct
'Space[] space = new Space[100];',correct
'fill(sin(parametric.t / 30) * 30, cos(parametric.t / 30) * 30, -sin(parametric.n / 30) * 30, 50)',correct
'void display_orbit_lines() {    for (int i = 1; i < numLines; i++) {        stroke(PApplet.parseInt(random(100, 170)), PApplet.parseInt(random(120, 150)), PApplet.parseInt(random(0, 255)));        strokeWeight((sin(parametric.n / parametric.frequency) + 1) * 5);        if (orbit_lines_mouse_trigger == true) {            // SAME OF THE INTERNAL TWO POINTS MOLTIPLICATION, BUT THIS EXTERNAL POINTS ARE            // ALL CONNECTED WITH A LINE, SO I HAVE MY ORBITAL SEGMENTS.            update_weight_orbit_lines_a();        }        if (orbit_lines_key_trigger == true) {            update_weight_orbit_lines_b();        }        line(parametric.x1(parametric.t * i), parametric.y1(parametric.n * i), parametric.x2(parametric.t * i), parametric.y2(parametric.n * i));    }}',correct
'{    // ------------A-C-T-I-V-A-T-E---D-R-E-A-M-----M-O-D-E---------------//    // ALL THE T AND N VALUES ARE INCREMENTING    parametric.parametric_increment();    for (int i = 0; i < 100; i++) {        space[i].display();        space[i].update();    }    // 50 OPACITY TO THE "FAKE" BACKGROUND TO CREATE THE ECHO EFFECT    fill(sin(parametric.t / 30) * 30, cos(parametric.t / 30) * 30, -sin(parametric.n / 30) * 30, 50);    noStroke();    rectMode(CENTER);    rect(0, 0, width, height);    shakingFXrange_1.display();    shakingFXrange_1.shake();    shakingFXrange_2.display();    shakingFXrange_2.shake();    eye_1.display();    eye_1.update();    eye_2.display();    eye_2.update();    display_main_orbits();    display_orbit_lines();    guidePoints.display();    guidePoints.change_color();}',SimplifyBooleanExpressions
'int y',correct
'eye_1.display();',correct
'shakingFXrange_2.shake();',correct
'-t / frequency',correct
'int x',correct
'{    // DESIGN OF SHAPE WITH VARIABLE VERTEXES    stroke((i + colorUpdate), 0, 0);    beginShape();    vertex(vertexX, 0);    vertex(0, vertexY);    vertex(-vertexX, 0);    vertex(0, -vertexY);    endShape(CLOSE);    vertexX = sin(parametric.t / (parametric.frequency / 2)) * expansion_width + 10 * i;    vertexY = cos(parametric.t / (parametric.frequency / 2)) * expansion_width + 10 * i;}',correct
'float varcol_2 = 0;',FieldDeclarationsShouldBeAtStartOfClass
'Space[]',correct
'class GuidePoints {    float color_guide_points_X;    float color_guide_points_Y;    GuidePoints() {        color_guide_points_X = 0;        color_guide_points_Y = 0;    }    void display() {        fill(0);        // ABSOLUTE FUNCTION KEEPS NUMBERS POSITIVE.  :)        stroke(abs(color_guide_points_X), abs(color_guide_points_Y), 0);        strokeWeight(15);        // ball 4          /*------------- THE FOUR BALLS FOLLOW THE SAME PARAMETRIC EQUATION WITH 4 DIFFERENT SIN AND COS RANGES.        point(parametric.x2(parametric.t), parametric.y2(parametric.n));        strokeWeight(5);        // ball 1        point(parametric.x4(parametric.t), parametric.y4(parametric.n));        strokeWeight(7.5f);        // ball 2        point(parametric.x3(parametric.t), parametric.y3(parametric.n));        strokeWeight(7.5f);        // ball 3        point(parametric.x1(parametric.t), parametric.y1(parametric.t));    }    void change_color() {        // --------CREATE RATIO BETWEEN SCREEN RANGE AND COLOR RANGE--------//        color_guide_points_X = map(mouseX, 0, width, 0, 255);        color_guide_points_Y = map(mouseY, 0, height, 0, 255);    }}',correct
'{    t1 = 0;    n1 = 0;}',correct
'return cos(t / frequency) * 20;',correct
'guidePoints.display()',correct
'{    return cos(t / frequency) * 20;}',correct
'sin(t1 / 48) * 350',correct
'if (color_trigger == true) {    vertexX = sin(parametric.t / 40) * 40;    vertexY = cos(parametric.t / 40) * 40;}',SimplifyBooleanExpressions
'space[space.length - 1].opacity_trigger == false && mouseButton == CENTER',SimplifyBooleanExpressions
'-sin(-n / frequency)',correct
'parametric.t / 40',correct
'mousePressed',correct
'float parametric_x = sin(parametric.t / parametric.frequency);',correct
'ellipseMode(CENTER)',correct
'{    // NEGATIVE WIDTH AND HEIGHT BECAUSE OF THE TRANSLATION FUNCTION IN THE MAIN TAB. THE TRANSLATION MOVES THE O POINT OF CANVAS TO CENTER,    x = random(-width, width);    // BUT I STILL NEED TO HAVE MY RANDOM VALUES OF "STARS" DIRECTIONS FROM THE REAL ZERO POINT.    y = random(-height, height);    speed = random(100);    fill_r = random(200, 255);    fill_g = random(100, 200);    fill_b = random(100, 255);}',correct
'colorUpdate <= 255 && color_trigger == true',correct
'space[i] = new Space();',correct
'opacity_trigger == true',correct
'space[i].update()',correct
'orbit_lines_key_trigger = false',correct
'eye_2.update();',correct
'fill(255, 255, 255)',correct
'orbit_weight < 10',correct
'void',correct
'class Space {    float x;    float y;    float speed;    float fill_r, fill_g, fill_b;    float sx, sy;    float opacity = 0;    boolean opacity_trigger = false;    Space() {        // NEGATIVE WIDTH AND HEIGHT BECAUSE OF THE TRANSLATION FUNCTION IN THE MAIN TAB. THE TRANSLATION MOVES THE O POINT OF CANVAS TO CENTER,        x = random(-width, width);        // BUT I STILL NEED TO HAVE MY RANDOM VALUES OF "STARS" DIRECTIONS FROM THE REAL ZERO POINT.        y = random(-height, height);        speed = random(100);        fill_r = random(200, 255);        fill_g = random(100, 200);        fill_b = random(100, 255);    }    void display() {        fill(fill_r, fill_g, fill_b, opacity);        noStroke();        float parametric_x = sin(parametric.t / parametric.frequency);        float parametric_y = cos(parametric.n / parametric.frequency);        ellipse(sx * parametric_x, sy * parametric_y, sx / 60, sx / 60);        // ALL THE SPOTS ARE GENERATED IN RANDOM POSITIONS WITHIN THE CANVAS, BUT WHEN DEVIDED FOR INITIAL VALUE OF SPEED (100),        sx = x / speed;        // X AND Y POSITION BECOME SMALL, SO THEY STAY IN CENTER. WHILE THE SPEED VALUE DECREASES, X AND Y BECOME BIGGER, SO THEY EXPAND TO THEIR        sy = y / speed;    }    // RANDOM POSITIONS AND GO OVER THEM, OUTSIDE THE CANVAS.    void update() {        speed = speed - 1;        if (speed < 1) {            speed = 100;        }        if (opacity_trigger == true && opacity < 255) {            opacity += 0.5f;        } else if (opacity_trigger == false) {            if (opacity > 0) {                opacity -= 0.1f;            }        }        println(opacity);    }}',correct
'eye_1.update();',correct
'{    for (int i = 1; i < numLines; i++) {        stroke(PApplet.parseInt(random(100, 170)), PApplet.parseInt(random(120, 150)), PApplet.parseInt(random(0, 255)));        strokeWeight((sin(parametric.n / parametric.frequency) + 1) * 5);        if (orbit_lines_mouse_trigger == true) {            // SAME OF THE INTERNAL TWO POINTS MOLTIPLICATION, BUT THIS EXTERNAL POINTS ARE            // ALL CONNECTED WITH A LINE, SO I HAVE MY ORBITAL SEGMENTS.            update_weight_orbit_lines_a();        }        if (orbit_lines_key_trigger == true) {            update_weight_orbit_lines_b();        }        line(parametric.x1(parametric.t * i), parametric.y1(parametric.n * i), parametric.x2(parametric.t * i), parametric.y2(parametric.n * i));    }}',MethodNamingConventions
'void display_main_orbits() {    for (int i = 1; i < numLines; i++) {        strokeWeight((cos(parametric.n / 65) + 1) * 8);        stroke(random(100, 170), random(120, 150), random(0, 255));        point(parametric.x3(parametric.t * i), parametric.y3(parametric.n * i));        // -------MULTIPLY INTERNAL TWO POINTS, RANDOM COLOR, MOVEMENT BASED ON PARAMETRIC        // ----VALUES OF T AND N IN X4 Y4 AND X3 Y3        strokeWeight(((-sin(parametric.n)) * 4) + 4.5f);        stroke(random(100, 170), random(120, 150), random(0, 255));        point(parametric.x4(parametric.t * i), parametric.y4(parametric.n * i));        fill(238, 169, 144);    }}',correct
'new ShakingFX(25, 75)',correct
'// 50 OPACITY TO THE "FAKE" BACKGROUND TO CREATE THE ECHO EFFECTfill(sin(parametric.t / 30) * 30, cos(parametric.t / 30) * 30, -sin(parametric.n / 30) * 30, 50);',correct
'central_orbit_weight_update();',correct
'noFill();',correct
'fill(fill_r, fill_g, fill_b, opacity)',correct
'fill_r = random(200, 255)',correct
'void central_orbit_move() {    n1++;    t1++;    if (n1 > 602.5f) {        t1 = 0;        n1 = 0;    }}',MethodNamingConventions
'// CENTRAL FIXED ELLIPSEupdate_sustain_ellipse();',correct
'guidePoints',correct
'parametric.float_mouse_trigger = true',correct
'if (opacity_trigger == true && opacity < 255) {    opacity += 0.5f;} else if (opacity_trigger == false) {    if (opacity > 0) {        opacity -= 0.1f;    }}',SimplifyBooleanExpressions
'guidePoints.change_color();',correct
'{    t = 0;    n = 0;}',correct
'parametric.parametric_increment()',correct
'// DECREASING SPEED IS SYCHRONISED WITH INTERNAL FX EXPANSION FREQUENCYstroke_weight -= 15.25641f;',correct
'space[i].opacity_trigger = false;',correct
'beginShape();',correct
't1 / 48',correct
'eyeOpacity = 0',correct
'strokeWeight(5)',correct
'PApplet.parseInt(random(120, 150))',correct
'{    // SWITCH FROM REGULAR MODE TO DEAM MODE AND VICEVERSA.    trigger_background = false;}',SimplifyBooleanExpressions
'// CALL X2 AND Y2 RETURNS (PATTERN 2)parametric.float_key_trigger = true;',correct
'mouseButton == CENTER',correct
'float expansion_width = 40;',AtLeastOneConstructor
'parametric.t < 602',correct
'space[i] = new Space()',correct
'stroke(238, 169, 144);',correct
'opacity_trigger = false',correct
'space[i]',correct
'update_weight_orbit_lines_b();',correct
'parametric.t / 30',correct
'-vertexY',correct
'radians(60)',correct
'varcol_2 = random(0, 80)',correct
'ellipse(ellipseX, ellipseY, range, range)',correct
'ellipse(eyeX, eyeY, 15, 15);',correct
'-vertexX',correct
'orbit_weight_trigger == true',correct
'i < 100',correct
'if (b > 255) {    b = 0;}',correct
'parametric.t / (parametric.frequency / 2)',correct
'random_1 = x',correct
'stroke(varcol, 0, varcol + 100)',correct
'sin(parametric.t / (parametric.frequency / 2)) * expansion_width',correct
'float x2(float n) {    if (float_key_trigger == true) {        return cos(n / frequency) * 100;    }    return -sin(-n / frequency) * 300;}',AtLeastOneConstructor
'expansion_width--;',correct
'i < numLines',correct
'boolean orbit_lines_mouse_trigger = false;',FieldDeclarationsShouldBeAtStartOfClass
'float n1',correct
'{    b = 0;}',correct
'void display_externalFX() {    ;    stroke(varcol, 0, varcol + 100);    strokeWeight(stroke_weight);    noFill();    for (int i = 0; i < 5; i++) {        ellipse(0, 0, 600, 600);    }}',MethodNamingConventions
'sin(parametric.t / parametric.frequency)',correct
'{    // --------------R-E-G-U-L-A-R----M-O-D-E----W-I-T-H-----B-A-C-K-G-R-O-U-N-D------//    parametric.parametric_increment();    background(sin(parametric.t / 30) * 30 + 50, cos(parametric.t / 30) * 30 + 50, -sin(parametric.n / 30) * 30 + 50);    stroke(238, 169, 144);    for (int i = 0; i < 100; i++) {        space[i].display();        space[i].update();    }    display_externalFX();    update_externalFX();    // --------------------------E-X-P-A-N-D-I-N-G-------C-I-R-C-L-E-S--------------------//    display_internalFX();    update_internalFX();    draw_sustain_ellipse();    // CENTRAL FIXED ELLIPSE    update_sustain_ellipse();    shakingFXrange_1.display();    shakingFXrange_1.shake();    // MOVING CENTRAL SHAPE    shaper.display();    shaper.color_update();    shaper.color_fill();    shaper.expansion();    shaper.de_expansion();    shakingFXrange_2.display();    shakingFXrange_2.shake();    eye_1.display();    eye_1.update();    eye_2.display();    eye_2.update();    display_main_orbits();    display_orbit_lines();    display_central_orbit();    central_orbit_move();    central_orbit_weight_update();    guidePoints.display();    guidePoints.change_color();}',SimplifyBooleanExpressions
'{    // INCREASE SIZE CENTRAL SHAPE AND ACTIVATE COLOR PULSE    shaper.right_trigger = true;    shaper.color_trigger = true;}',correct
'-sin(-n / frequency) * 300',correct
'10 * i',correct
'PApplet.parseInt(random(0, 255))',correct
'central_orbit_move()',correct
'expansion_width = 40',correct
'fill_r = random(200, 255);',correct
'-width',correct
'map(mouseY, 0, height, 0, 255)',correct
'opacitySpeed *= -1;',correct
'eyeX + 100',correct
'strokeWeight(stroke_weight)',correct
'trigger_background == false',correct
'display_orbit_lines',MethodNamingConventions
'((-sin(parametric.n)) * 4) + 4.5f',correct
'float_key_trigger = false',correct
'// }',correct
'{    space[i] = new Space();}',correct
'-cos(-t / frequency) * 200',correct
'cos(n1 / 24) * 350',correct
'{    // parametric.parametric_increment();    strokeWeight(0.5f);    fill(colorUpdate, g, b, 5);    for (float i = 0; i < 10; i += 0.5f) {        // DESIGN OF SHAPE WITH VARIABLE VERTEXES        stroke((i + colorUpdate), 0, 0);        beginShape();        vertex(vertexX, 0);        vertex(0, vertexY);        vertex(-vertexX, 0);        vertex(0, -vertexY);        endShape(CLOSE);        vertexX = sin(parametric.t / (parametric.frequency / 2)) * expansion_width + 10 * i;        vertexY = cos(parametric.t / (parametric.frequency / 2)) * expansion_width + 10 * i;    }    text(colorUpdate, 600, 100);    text(vertexX, 600, 300);    text(vertexY, 600, 400);}',correct
'void update_weight_orbit_lines_b() {    strokeWeight((sin(parametric.n / parametric.frequency) + 1) * 2);}',MethodNamingConventions
'cos(parametric.t / 40)',correct
'new GuidePoints()',correct
'println(expansion_width)',correct
'{    eyeX = x;    eyeY = y;    eyeOpacity = eyeOpacity - opacitySpeed;}',correct
'random_2 = y',correct
'mouseReleased',correct
'i += 0.5f',correct
'update_internalFX()',correct
'orbit_weight += 0.5f;',DrawingStateChangeRule
'cos(-t / frequency)',correct
'cos(t / frequency)',correct
'shaper.color_update()',correct
'mouseButton == RIGHT',correct
'draw_sustain_ellipse();',correct
'float_mouse_trigger = false',correct
'color_guide_points_Y = map(mouseY, 0, height, 0, 255)',correct
'shaper.display()',correct
'update_externalFX()',correct
'ellipse(eyeX, eyeY, 50, eyeWidth)',correct
'float opacity = 0;',correct
'background(sin(parametric.t / 30) * 30 + 50, cos(parametric.t / 30) * 30 + 50, -sin(parametric.n / 30) * 30 + 50);',correct
'point(parametric.x4(parametric.t * i), parametric.y4(parametric.n * i))',correct
'void display() {    fill(fill_r, fill_g, fill_b, opacity);    noStroke();    float parametric_x = sin(parametric.t / parametric.frequency);    float parametric_y = cos(parametric.n / parametric.frequency);    ellipse(sx * parametric_x, sy * parametric_y, sx / 60, sx / 60);    // ALL THE SPOTS ARE GENERATED IN RANDOM POSITIONS WITHIN THE CANVAS, BUT WHEN DEVIDED FOR INITIAL VALUE OF SPEED (100),    sx = x / speed;    // X AND Y POSITION BECOME SMALL, SO THEY STAY IN CENTER. WHILE THE SPEED VALUE DECREASES, X AND Y BECOME BIGGER, SO THEY EXPAND TO THEIR    sy = y / speed;}',correct
'new ParametricVals()',correct
'shaper.right_trigger = true',correct
'float opacitySpeed = 0.90714f;',correct
'fill_b = random(100, 255);',correct
'vertexY = cos(parametric.t / (parametric.frequency / 2)) * expansion_width + 10 * i;',correct
'space[i].display()',correct
'ix = (-sin(t1 * i / 100) * 100)',correct
'// range2= int(random(400, 500));  //converting floats generated from random to integers',correct
'fill_g = random(100, 200);',correct
'Shaper',correct
'{    range = PApplet.parseInt(random(random_1, random_2));}',correct
'range = PApplet.parseInt(random(random_1, random_2))',correct
'float y4(float t) {    return cos(t / frequency) * 20;}',AtLeastOneConstructor
'{    noFill();    ellipseMode(CENTER);    // SUSTAINING CENTRAL ELLIPSE    strokeWeight(weight_);    stroke(random(100, 170), random(120, 150), random(0, 255));    ellipse(0, 0, 398, 398);}',MethodNamingConventions
'int r;',ShortVariable
'void display() {    fill(0);    // ABSOLUTE FUNCTION KEEPS NUMBERS POSITIVE.  :)    stroke(abs(color_guide_points_X), abs(color_guide_points_Y), 0);    strokeWeight(15);    // ball 4          /*------------- THE FOUR BALLS FOLLOW THE SAME PARAMETRIC EQUATION WITH 4 DIFFERENT SIN AND COS RANGES.    point(parametric.x2(parametric.t), parametric.y2(parametric.n));    strokeWeight(5);    // ball 1    point(parametric.x4(parametric.t), parametric.y4(parametric.n));    strokeWeight(7.5f);    // ball 2    point(parametric.x3(parametric.t), parametric.y3(parametric.n));    strokeWeight(7.5f);    // ball 3    point(parametric.x1(parametric.t), parametric.y1(parametric.t));}',correct
'eyeWidth += eyeWidth_speed',correct
'opacity -= 0.1f;',correct
'color_guide_points_X',correct
'// DECREASE SIZE CENTRAL SHAPE AND ACTIVATE COLOR PULSEshaper.left_trigger = true;',correct
'random(100)',correct
'opacitySpeed = 0.90714f',correct
'parametric.float_key_trigger = true',correct
'color_guide_points_Y',correct
'{    trigger_background = true;}',correct
'// void shakingCircle_2() {',correct
'space[i].opacity_trigger',correct
'parametric',correct
'abs(color_guide_points_X)',correct
'left_trigger == true',correct
'speed = speed - 1;',correct
'eyeOpacity - opacitySpeed',correct
'colorUpdate = 0;',correct
'ellipse(0, 0, 398, 398);',correct
'trigger_background == true',correct
'float eyeX;',correct
'float eyeY;',correct
'return cos(t / frequency) * 85;',correct
'noFill()',correct
'abs(color_guide_points_Y)',correct
'eyeWidth = 1',correct
'shaper.left_trigger',correct
'vertexX = sin(parametric.t / (parametric.frequency / 2)) * expansion_width + 10 * i',correct
'shakingFXrange_1 = new ShakingFX(25, 75)',correct
'vertex(-vertexX, 0);',correct
'int i = 1',correct
'int i = 0',correct
'n1 > 602.5f',correct
'new Shaper()',correct
'ellipse(0, 0, (range_1) + 100, range_1);',PixelHardcodeIgnoranceRule
'ellipse(0, 0, (range_1) + 100, range_1)',correct
'// SHAKING EFFECT PRODUCES BY WIDE RANDOM GENERATION OF RANGE VALUES.strokeWeight(0);',correct
'range_1 >= 390',correct
'Space() {    // NEGATIVE WIDTH AND HEIGHT BECAUSE OF THE TRANSLATION FUNCTION IN THE MAIN TAB. THE TRANSLATION MOVES THE O POINT OF CANVAS TO CENTER,    x = random(-width, width);    // BUT I STILL NEED TO HAVE MY RANDOM VALUES OF "STARS" DIRECTIONS FROM THE REAL ZERO POINT.    y = random(-height, height);    speed = random(100);    fill_r = random(200, 255);    fill_g = random(100, 200);    fill_b = random(100, 255);}',correct
'// PRESS ANY KEY TO SWITCH TO PATTERN N.3;',correct
'random_2 = y;',correct
'ellipseY',correct
'eye_1.display()',correct
'ellipseX',correct
'// ------------A-C-T-I-V-A-T-E---D-R-E-A-M-----M-O-D-E---------------//// ALL THE T AND N VALUES ARE INCREMENTINGparametric.parametric_increment();',correct
'// ALL THE SPOTS ARE GENERATED IN RANDOM POSITIONS WITHIN THE CANVAS, BUT WHEN DEVIDED FOR INITIAL VALUE OF SPEED (100),sx = x / speed;',correct
'ShakingFX(int x, int y) {    // X AND Y INSERED IN THE MAIN PAGE WILL BE THE TWO VALUES OF A RANDOM FUNCTION, WHICH WILL BE THE WIDTH AND HEIGHT OF THE CIRCLES.    random_1 = x;    random_2 = y;    ellipseX = 0;    ellipseY = 0;}',correct
'PApplet.parseInt(random(100, 170))',correct
'eyeOpacity += opacitySpeed',correct
'orbit_weight < 10 && orbit_weight_trigger == true',correct
'void display_central_orbit() {    for (int i = 1; i < numLines; i++) {        // strokeWeight(random( 1 , 100 ));        ix = (-sin(t1 * i / 100) * 100);        iy = (sin(n1 * i / 100) * 100);        noFill();        strokeWeight(random(0, orbit_weight));        ellipse((sin(parametric.t / 100) * (parametric.x2(parametric.t * i))), (cos(parametric.y2(parametric.n * i))), (ix / 6), (iy / 6));    }}',correct
'float eyeOpacity = 0;',correct
'speed = random(100);',correct
'b += 3',correct
'// ARE CALLED FOR MAINLY MOVING DOTS. THE INCREMENTS OF VALUE OF T AND N ARE USED FOR OTHER SINs AND COSes FUNCTIONS',correct
'fill(varcol_2, varcol_2, 100, 100)',correct
'{    if (float_key_trigger == true) {        return sin(t / frequency) * 100;    }    return -cos(-t / frequency) * 300;}',correct
'sin(parametric.t / 40) * 40',correct
'float orbit_weight = 2;',FieldDeclarationsShouldBeAtStartOfClass
'{    // ---------WHEN DREAM MODE IS ACTIVATED, SLOWLY INCREASE OPACITY OF SPACE STARS, WHEN DREAM MODE IS    space[i].opacity_trigger = true;}',correct
'sin(-n / frequency) * 85',correct
'fill(238, 169, 144)',correct
'colorUpdate -= colorChange',correct
'varcol_2 = random(0, 80);',DrawingStateChangeRule
'if (speed < 1) {    speed = 100;}',correct
'expansion_width < 200 && left_trigger == true',SimplifyBooleanExpressions
'if (parametric.t < 602) {    parametric.t = random(20, 100);}',correct
'expansion_width++',correct
'space.length - 1',correct
'n = n + increment;',correct
'// ORBIDAL CIRCLES INCREASE THEIR STROKE WEIGHTorbit_weight_trigger = true;',correct
'if (n1 > 602.5f) {    t1 = 0;    n1 = 0;}',correct
'strokeWeight(stroke_weight);',correct
'color_guide_points_Y = 0',correct
'varcol_2 = 0',correct
'stroke(random(100, 170), random(120, 150), random(0, 255));',correct
'space[i].opacity_trigger = true',correct
'// X AND Y INSERED IN THE MAIN PAGE WILL BE THE TWO VALUES OF A RANDOM FUNCTION, WHICH WILL BE THE WIDTH AND HEIGHT OF THE CIRCLES.',correct
'trigger_background = true;',correct
'{    expansion_width--;}',correct
'n + increment',correct
'// SUSTAINING CENTRAL ELLIPSEstrokeWeight(weight_);',correct
'ShakingFX',correct
'shaper.de_expansion()',correct
'parametric.float_key_trigger = false;',correct
'sin(-n / frequency)',correct
'arc(eyeX + 100, eyeY, 100, 200, radians(150), radians(60))',correct
'opacity > 0',correct
'float frequency = 96;',correct
'display_externalFX();',correct
'display',correct
'float speed;',correct
'background(0);',correct
'expansion_width--',correct
'strokeWeight(random(0, 2))',correct
'{    for (int i = 1; i < numLines; i++) {        strokeWeight((cos(parametric.n / 65) + 1) * 8);        stroke(random(100, 170), random(120, 150), random(0, 255));        point(parametric.x3(parametric.t * i), parametric.y3(parametric.n * i));        // -------MULTIPLY INTERNAL TWO POINTS, RANDOM COLOR, MOVEMENT BASED ON PARAMETRIC        // ----VALUES OF T AND N IN X4 Y4 AND X3 Y3        strokeWeight(((-sin(parametric.n)) * 4) + 4.5f);        stroke(random(100, 170), random(120, 150), random(0, 255));        point(parametric.x4(parametric.t * i), parametric.y4(parametric.n * i));        fill(238, 169, 144);    }}',MethodNamingConventions
'float N, T = 0;',AtLeastOneConstructor
'shakingFXrange_2 = new ShakingFX(400, 500)',correct
'// RANDOM POSITIONS AND GO OVER THEM, OUTSIDE THE CANVAS.void update() {    speed = speed - 1;    if (speed < 1) {        speed = 100;    }    if (opacity_trigger == true && opacity < 255) {        opacity += 0.5f;    } else if (opacity_trigger == false) {        if (opacity > 0) {            opacity -= 0.1f;        }    }    println(opacity);}',correct
'orbit_lines_mouse_trigger == true',SimplifyBooleanExpressions
'return -cos(-t / frequency) * 300;',correct
'random(100, 255)',correct
'for (int i = 1; i < numLines; i++) {    // strokeWeight(random( 1 , 100 ));    ix = (-sin(t1 * i / 100) * 100);    iy = (sin(n1 * i / 100) * 100);    noFill();    strokeWeight(random(0, orbit_weight));    ellipse((sin(parametric.t / 100) * (parametric.x2(parametric.t * i))), (cos(parametric.y2(parametric.n * i))), (ix / 6), (iy / 6));}',correct
'eyeY = y;',correct
'float ix, iy;',FieldDeclarationsShouldBeAtStartOfClass
'-sin(parametric.n / 30)',correct
'// --------------R-E-G-U-L-A-R----M-O-D-E----W-I-T-H-----B-A-C-K-G-R-O-U-N-D------//',correct
'// INSTRUCTIONS: //<>// //<>//',correct
'y / speed',correct
'if (g > 255) {    g = 0;}',correct
'-n / frequency',correct
'(sin(parametric.n / parametric.frequency) + 1) * 2',correct
'ellipse(sx * parametric_x, sy * parametric_y, sx / 60, sx / 60);',correct
'sin(parametric.t / 30) * 30 + 50',correct
'shakingFXrange_1.shake();',correct
'(sin(parametric.n / parametric.frequency) + 1) * 5',correct
'parametric.y2(parametric.n)',correct
'vertex(vertexX, 0)',correct
'speed - 1',correct
'color_guide_points_X = 0',correct
'mouseButton == CENTER && trigger_background == true',correct
'{    stroke_weight = 1500;    varcol = random(0, 100);}',correct
'vertex(0, vertexY)',correct
'if (mouseButton == CENTER) {    for (int i = 0; i < 100; i++) {        space[i].opacity_trigger = false;    }}',SimplifyBooleanExpressions
'boolean float_key_trigger = false;',AtLeastOneConstructor
'fill(colorUpdate, g, b, 5);',correct
'{    if (parametric.t < 602) {        parametric.t = random(20, 100);    }}',correct
'line(parametric.x1(parametric.t * i), parametric.y1(parametric.n * i), parametric.x2(parametric.t * i), parametric.y2(parametric.n * i))',correct
'float x4(float n) {    return sin(-n / frequency) * 20;}',ShortVariable
'parametric.t = random(20, 100)',correct
'ellipse(sx * parametric_x, sy * parametric_y, sx / 60, sx / 60)',correct
'vertexY = cos(parametric.t / 40) * 40;',correct
'shakingFXrange_2.shake()',correct
'{    g = 0;}',correct
'colorUpdate = 0',correct
'// PRESSING THE LEFT MOUSE BUTTON, THE CENTRAL SHAPE WILL BECOME BIGGER. PRESSING THE RIGHT MOUSE BUTTON WILL MAKE THE SHAPE SMALLER.',correct
'void parametric_increment() {    t = t + increment;    n = n + increment;    if (t > 602.5f) {        t = 0;        n = 0;    }}',MethodNamingConventions
'class EyeBall {    float eyeX;    float eyeY;    float eyeOpacity = 0;    float opacitySpeed = 0.90714f;    float eyeWidth = 1;    float eyeWidth_speed = 0.1f;    EyeBall(float x, float y) {        eyeX = x;        eyeY = y;        eyeOpacity = eyeOpacity - opacitySpeed;    }    void display() {        fill(255, 255, 255);        // OPEN AND CLOSE THE EYES TROUGH CHANGING THE HEIGHT OF ELLIPSE        ellipse(eyeX, eyeY, 50, eyeWidth);        fill(0, 0, 0, eyeOpacity);        noStroke();        ellipse(eyeX, eyeY, 15, 15);        fill(255, 255, 255);        arc(eyeX + 100, eyeY, 100, 200, radians(150), radians(60));    }    void update() {        eyeWidth += eyeWidth_speed;        if (eyeWidth < 0 || eyeWidth > 28) {            eyeWidth_speed = eyeWidth_speed * -1;        }        eyeOpacity += opacitySpeed;        if (eyeOpacity < 0 || eyeOpacity > 254) {            opacitySpeed *= -1;        }    }}',correct
'// -----------TURNS OFF THE TRIGGERS ACTIVATED IN MOUSE PRESSED--------//shaper.right_trigger = false;',correct
'float parametric_x = sin(parametric.t / parametric.frequency)',correct
'void de_expansion() {    if (expansion_width > 40 && right_trigger == true) {        expansion_width--;    }}',AtLeastOneConstructor
'// TRANSLATE EVERYTING TO CENTER.translate(width / 2, height / 2);',correct
'{    // DEACTIVATE FUNCTIONS ACTIVATED WITH PRESSING KEY    orbit_lines_key_trigger = false;    parametric.float_key_trigger = false;}',correct
'return sin(-n / frequency) * 85;',correct
'{    // DECREASE SIZE CENTRAL SHAPE AND ACTIVATE COLOR PULSE    shaper.left_trigger = true;    shaper.color_trigger = true;}',correct
'display_central_orbit();',correct
'eye_2.display()',correct
'// DESIGN OF SHAPE WITH VARIABLE VERTEXESstroke((i + colorUpdate), 0, 0);',correct
'void central_orbit_weight_update() {    if (orbit_weight < 10 && orbit_weight_trigger == true) {        orbit_weight += 0.5f;    } else if (orbit_weight > 2) {        orbit_weight -= 0.5f;    }}',MethodNamingConventions
'speed = 100;',correct
'text(vertexY, 600, 400);',correct
'ParametricVals parametric;',correct
'{    // -----------TURNS OFF THE TRIGGERS ACTIVATED IN MOUSE PRESSED--------//    shaper.right_trigger = false;    shaper.left_trigger = false;    shaper.color_trigger = false;    orbit_weight_trigger = false;    orbit_lines_mouse_trigger = false;    parametric.float_mouse_trigger = false;}',correct
'void update_weight_orbit_lines_a() {    strokeWeight(random(0, 2));}',MethodNamingConventions
'parametric.y4(parametric.n)',correct
'strokeWeight(0);',correct
'ellipse((sin(parametric.t / 100) * (parametric.x2(parametric.t * i))), (cos(parametric.y2(parametric.n * i))), (ix / 6), (iy / 6));',correct
'7.5f',correct
'void draw() {    // TRANSLATE EVERYTING TO CENTER.    translate(width / 2, height / 2);    if (trigger_background == true) {        // --------------R-E-G-U-L-A-R----M-O-D-E----W-I-T-H-----B-A-C-K-G-R-O-U-N-D------//        parametric.parametric_increment();        background(sin(parametric.t / 30) * 30 + 50, cos(parametric.t / 30) * 30 + 50, -sin(parametric.n / 30) * 30 + 50);        stroke(238, 169, 144);        for (int i = 0; i < 100; i++) {            space[i].display();            space[i].update();        }        display_externalFX();        update_externalFX();        // --------------------------E-X-P-A-N-D-I-N-G-------C-I-R-C-L-E-S--------------------//        display_internalFX();        update_internalFX();        draw_sustain_ellipse();        // CENTRAL FIXED ELLIPSE        update_sustain_ellipse();        shakingFXrange_1.display();        shakingFXrange_1.shake();        // MOVING CENTRAL SHAPE        shaper.display();        shaper.color_update();        shaper.color_fill();        shaper.expansion();        shaper.de_expansion();        shakingFXrange_2.display();        shakingFXrange_2.shake();        eye_1.display();        eye_1.update();        eye_2.display();        eye_2.update();        display_main_orbits();        display_orbit_lines();        display_central_orbit();        central_orbit_move();        central_orbit_weight_update();        guidePoints.display();        guidePoints.change_color();    } else {        // ------------A-C-T-I-V-A-T-E---D-R-E-A-M-----M-O-D-E---------------//        // ALL THE T AND N VALUES ARE INCREMENTING        parametric.parametric_increment();        for (int i = 0; i < 100; i++) {            space[i].display();            space[i].update();        }        // 50 OPACITY TO THE "FAKE" BACKGROUND TO CREATE THE ECHO EFFECT        fill(sin(parametric.t / 30) * 30, cos(parametric.t / 30) * 30, -sin(parametric.n / 30) * 30, 50);        noStroke();        rectMode(CENTER);        rect(0, 0, width, height);        shakingFXrange_1.display();        shakingFXrange_1.shake();        shakingFXrange_2.display();        shakingFXrange_2.shake();        eye_1.display();        eye_1.update();        eye_2.display();        eye_2.update();        display_main_orbits();        display_orbit_lines();        guidePoints.display();        guidePoints.change_color();    }    // IF MOUSE NOT DRAGGED, T AND N VALUES ARE SYNCHRONIZED, IF THE MOUSE IS DRAGGED, THE T VALUE IS ALTERED WHILE N KEEPS INCREASING. THIS    text(parametric.t, 600, 0);    // GENERATES THE RANDOM PATTERNS IF MOUSE IS DRAGGER. ONCE T REACHES 602, BOTH T AND N ARE RESETED TO THE SAME VALUE AGAIN.    text(parametric.n, 600, 200);}',correct
'speed < 1',correct
'int g;',ShortVariable
'{    // --------CREATE RATIO BETWEEN SCREEN RANGE AND COLOR RANGE--------//    color_guide_points_X = map(mouseX, 0, width, 0, 255);    color_guide_points_Y = map(mouseY, 0, height, 0, 255);}',MethodNamingConventions
'// SHAKING EFFECT PRODUCES BY WIDE RANDOM GENERATION OF RANGE VALUES.',correct
'surface.setResizable(true)',correct
'boolean orbit_weight_trigger = false;',FieldDeclarationsShouldBeAtStartOfClass
'parametric_x = sin(parametric.t / parametric.frequency)',correct
'return sin(t / frequency) * 100;',correct
'shakingFXrange_1.shake()',correct
'{    colorUpdate -= colorChange;}',correct
'display_central_orbit()',correct
'void keyReleased() {    // DEACTIVATE FUNCTIONS ACTIVATED WITH PRESSING KEY    orbit_lines_key_trigger = false;    parametric.float_key_trigger = false;}',correct
'color_guide_points_Y = 0;',correct
'// --------------------------E-X-P-A-N-D-I-N-G-------C-I-R-C-L-E-S--------------------//display_internalFX();',correct
'float n1, t1;',FieldDeclarationsShouldBeAtStartOfClass
'parametric = new ParametricVals();',correct
'float varcol = 0;',FieldDeclarationsShouldBeAtStartOfClass
'varcol + 100',correct
'space[i].display();',correct
'if (colorUpdate > 254) {    colorUpdate = 0;}',correct
'float color_guide_points_X;',correct
'change_color',MethodNamingConventions
'if (space[space.length - 1].opacity_trigger == false && mouseButton == CENTER) {    for (int i = 0; i < 100; i++) {        // ---------WHEN DREAM MODE IS ACTIVATED, SLOWLY INCREASE OPACITY OF SPACE STARS, WHEN DREAM MODE IS        space[i].opacity_trigger = true;    }// ---------DEACTIVATED, SLOWLY DECREASE OPACITY} else if (mouseButton == CENTER) {    for (int i = 0; i < 100; i++) {        space[i].opacity_trigger = false;    }}',correct
't1 = 0',correct
'Space',correct
'range_1 += 8.5f',correct
'point(parametric.x3(parametric.t), parametric.y3(parametric.n))',correct
'void change_color() {    // --------CREATE RATIO BETWEEN SCREEN RANGE AND COLOR RANGE--------//    color_guide_points_X = map(mouseX, 0, width, 0, 255);    color_guide_points_Y = map(mouseY, 0, height, 0, 255);}',correct
'{    // EACH FLOAT METHOD GIVES THE POSSIBILITY TO RETURN SIN AND COS VALUES FOR PARAMETRIC EQUATIONS: THIS RETURNS    if (float_mouse_trigger == true) {        // ALL AROUND THE PROGRAM TO CHANGE IN CYCLE MODE COLOR, STROKE WEIGHTS ETC..        return sin(-n / frequency) * 300;    }    return -sin(-n / frequency) * 200;}',ShortVariable
'text(vertexX, 600, 300)',correct
'opacity_trigger == true && opacity < 255',correct
'{    // println("Expanding");    if (expansion_width < 200 && left_trigger == true) {        // println("Setting width");        expansion_width++;    }}',correct
'(range_1) + 100',correct
't = t + increment',correct
'parametric.t * i',correct
'float color_guide_points_Y;',correct
'parametric = new ParametricVals()',correct
'{    opacity -= 0.1f;}',correct
'eye_2.display();',correct
'opacity -= 0.1f',correct
'display_central_orbit',MethodNamingConventions
'PApplet.parseInt(random(random_1, random_2))',correct
'sin(-n / frequency) * 20',correct
'sin(t / frequency) * 100',correct
'float y3(float t) {    return cos(t / frequency) * 85;}',ShortVariable
'float sx, sy;',correct
'int ellipseX, ellipseY;',correct
'shaper.color_fill();',correct
'boolean right_trigger = false;',correct
'eyeY',correct
'mouseButton == LEFT',correct
'eyeX',correct
'float parametric_y = cos(parametric.n / parametric.frequency);',correct
'speed = speed - 1',correct
'translate(width / 2, height / 2)',correct
'if (float_mouse_trigger == true) {    return cos(-t / frequency) * 300;}',SimplifyBooleanExpressions
't / frequency',correct
'g = 0',correct
'strokeWeight(7.5f);',correct
'GuidePoints',correct
'{    parametric.t = random(20, 100);}',correct
'weight_ = random(4, 8);',DrawingStateChangeRule
'ellipse(ellipseX, ellipseY, range, range);',correct
'rectMode(CENTER);',correct
'// -------MULTIPLY INTERNAL TWO POINTS, RANDOM COLOR, MOVEMENT BASED ON PARAMETRIC',correct
'n / frequency',correct
'// PRESS THE MOUSE TO SWITCH TO PATTERN N.2;',correct
'fill(0, 0, 0, eyeOpacity);',correct
'text(parametric.n, 600, 200)',correct
'orbit_weight -= 0.5f',correct
'// --------CREATE RATIO BETWEEN SCREEN RANGE AND COLOR RANGE--------//color_guide_points_X = map(mouseX, 0, width, 0, 255);',correct
'random(0, 80)',correct
'eye_1 = new EyeBall(60, 0);',correct
'display_main_orbits()',correct
'space[space.length - 1]',correct
'parametric.x4(parametric.t * i)',correct
'// ball 2point(parametric.x3(parametric.t), parametric.y3(parametric.n));',correct
'// X AND Y INSERED IN THE MAIN PAGE WILL BE THE TWO VALUES OF A RANDOM FUNCTION, WHICH WILL BE THE WIDTH AND HEIGHT OF THE CIRCLES.random_1 = x;',correct
'eyeWidth += eyeWidth_speed;',correct
'{    stroke(PApplet.parseInt(random(100, 170)), PApplet.parseInt(random(120, 150)), PApplet.parseInt(random(0, 255)));    strokeWeight((sin(parametric.n / parametric.frequency) + 1) * 5);    if (orbit_lines_mouse_trigger == true) {        // SAME OF THE INTERNAL TWO POINTS MOLTIPLICATION, BUT THIS EXTERNAL POINTS ARE        // ALL CONNECTED WITH A LINE, SO I HAVE MY ORBITAL SEGMENTS.        update_weight_orbit_lines_a();    }    if (orbit_lines_key_trigger == true) {        update_weight_orbit_lines_b();    }    line(parametric.x1(parametric.t * i), parametric.y1(parametric.n * i), parametric.x2(parametric.t * i), parametric.y2(parametric.n * i));}',correct
'{    // X AND Y INSERED IN THE MAIN PAGE WILL BE THE TWO VALUES OF A RANDOM FUNCTION, WHICH WILL BE THE WIDTH AND HEIGHT OF THE CIRCLES.    random_1 = x;    random_2 = y;    ellipseX = 0;    ellipseY = 0;}',correct
'eyeWidth_speed = eyeWidth_speed * -1;',correct
'{    if (float_mouse_trigger == true) {        return cos(-t / frequency) * 300;    }    return -cos(-t / frequency) * 200;}',correct
'class ParametricVals {    float N, T = 0;    float t = 0;    float n = 0;    float frequency = 96;    float increment = 0.9f;    boolean float_mouse_trigger = false;    boolean float_key_trigger = false;    void parametric_increment() {        t = t + increment;        n = n + increment;        if (t > 602.5f) {            t = 0;            n = 0;        }    }    float x1(float n) {        // EACH FLOAT METHOD GIVES THE POSSIBILITY TO RETURN SIN AND COS VALUES FOR PARAMETRIC EQUATIONS: THIS RETURNS        if (float_mouse_trigger == true) {            // ALL AROUND THE PROGRAM TO CHANGE IN CYCLE MODE COLOR, STROKE WEIGHTS ETC..            return sin(-n / frequency) * 300;        }        return -sin(-n / frequency) * 200;    }    float y1(float t) {        if (float_mouse_trigger == true) {            return cos(-t / frequency) * 300;        }        return -cos(-t / frequency) * 200;    }    float x2(float n) {        if (float_key_trigger == true) {            return cos(n / frequency) * 100;        }        return -sin(-n / frequency) * 300;    }    float y2(float t) {        if (float_key_trigger == true) {            return sin(t / frequency) * 100;        }        return -cos(-t / frequency) * 300;    }    float x3(float n) {        return sin(-n / frequency) * 85;    }    float y3(float t) {        return cos(t / frequency) * 85;    }    float x4(float n) {        return sin(-n / frequency) * 20;    }    float y4(float t) {        return cos(t / frequency) * 20;    }}',correct
'strokeWeight((sin(parametric.n / parametric.frequency) + 1) * 5);',correct
'shaper.color_update();',correct
'// BUT I STILL NEED TO HAVE MY RANDOM VALUES OF "STARS" DIRECTIONS FROM THE REAL ZERO POINT.y = random(-height, height);',correct
'{    opacity += 0.5f;}',correct
'if (mouseButton == CENTER && trigger_background == true) {    // SWITCH FROM REGULAR MODE TO DEAM MODE AND VICEVERSA.    trigger_background = false;} else if (mouseButton == CENTER && trigger_background == false) {    trigger_background = true;}',correct
'vertex(0, -vertexY);',correct
'parametric.y3(parametric.n * i)',correct
'float eyeWidth_speed = 0.1f;',correct
'// void shakingCircle_1() {',correct
'text(colorUpdate, 600, 100)',correct
'orbit_lines_mouse_trigger = false',correct
'random(100, 170)',correct
'// OPEN AND CLOSE THE EYES TROUGH CHANGING THE HEIGHT OF ELLIPSEellipse(eyeX, eyeY, 50, eyeWidth);',correct
'cos(n1 / 24)',correct
'strokeWeight((cos(parametric.n / 65) + 1) * 8);',correct
'0.1f',correct
'shaper.expansion();',correct
'draw_sustain_ellipse()',correct
'n = n + increment',correct
'Processing',correct
'void color_fill() {    r += 2;    g++;    b += 3;    if (g > 255) {        g = 0;    }    if (b > 255) {        b = 0;    }    println(expansion_width);}',MethodNamingConventions
'for (int i = 0; i < 100; i++) {    // ---------WHEN DREAM MODE IS ACTIVATED, SLOWLY INCREASE OPACITY OF SPACE STARS, WHEN DREAM MODE IS    space[i].opacity_trigger = true;}',correct
'b = 0;',correct
'void update_sustain_ellipse() {    weight_ = random(4, 8);}',MethodNamingConventions
'random(0, orbit_weight)',correct
'float t(float t1) {    return sin(t1 / 48) * 350;}',ShortVariable
'ellipse(0, 0, 398, 398)',correct
'eyeOpacity += opacitySpeed;',correct
'eye_1.update()',correct
'false',correct
'new EyeBall(-60, 0)',correct
'vertexX = sin(parametric.t / (parametric.frequency / 2)) * expansion_width + 10 * i;',correct
'float n = 0;',AtLeastOneConstructor
'ellipse(0, 0, 600, 600);',PixelHardcodeIgnoranceRule
'for (int i = 0; i < 100; i++) {    space[i].opacity_trigger = false;}',correct
'expansion_width < 200',correct
'cos(parametric.t / (parametric.frequency / 2)) * expansion_width',correct
'endShape(CLOSE);',correct
'// ---------DEACTIVATED, SLOWLY DECREASE OPACITY',correct
'eyeWidth < 0 || eyeWidth > 28',correct
'shaper.color_trigger = false;',correct
'if (stroke_weight <= 0) {    stroke_weight = 1500;    varcol = random(0, 100);}',correct
'numLines = 9',correct
'// parametric.parametric_increment();strokeWeight(0.5f);',correct
'i = 1',correct
'i = 0',correct
'float_mouse_trigger == true',correct
'range_1 = 0;',DrawingStateChangeRule
'EyeBall eye_1;',correct
't1++;',DrawingStateChangeRule
'return -sin(-n / frequency) * 300;',correct
'void mousePressed() {    if (mouseButton == RIGHT) {        // INCREASE SIZE CENTRAL SHAPE AND ACTIVATE COLOR PULSE        shaper.right_trigger = true;        shaper.color_trigger = true;    }    if (mouseButton == LEFT) {        // DECREASE SIZE CENTRAL SHAPE AND ACTIVATE COLOR PULSE        shaper.left_trigger = true;        shaper.color_trigger = true;    }    // ORBIDAL CIRCLES INCREASE THEIR STROKE WEIGHT    orbit_weight_trigger = true;    // ROTATING SEGMENTS BECOME MORE THIN WHEN MOUSE CLICKED    orbit_lines_mouse_trigger = true;    if (mouseButton == CENTER && trigger_background == true) {        // SWITCH FROM REGULAR MODE TO DEAM MODE AND VICEVERSA.        trigger_background = false;    } else if (mouseButton == CENTER && trigger_background == false) {        trigger_background = true;    }    // CALL X1 Y1 RETURNS (PATTERN 1)    parametric.float_mouse_trigger = true;    if (space[space.length - 1].opacity_trigger == false && mouseButton == CENTER) {        for (int i = 0; i < 100; i++) {            // ---------WHEN DREAM MODE IS ACTIVATED, SLOWLY INCREASE OPACITY OF SPACE STARS, WHEN DREAM MODE IS            space[i].opacity_trigger = true;        }    // ---------DEACTIVATED, SLOWLY DECREASE OPACITY    } else if (mouseButton == CENTER) {        for (int i = 0; i < 100; i++) {            space[i].opacity_trigger = false;        }    }}',correct
'y = random(-height, height)',correct
'strokeWeight(((-sin(parametric.n)) * 4) + 4.5f)',correct
'15.25641f',correct
'float range;',correct
'if (mouseButton == RIGHT) {    // INCREASE SIZE CENTRAL SHAPE AND ACTIVATE COLOR PULSE    shaper.right_trigger = true;    shaper.color_trigger = true;}',correct
'r += 2;',correct
't = 0',correct
'color_guide_points_X = 0;',correct
'sin(parametric.t / 30)',correct
'fill(255, 255, 255);',correct
'colorChange * 30',correct
'// ball 1point(parametric.x4(parametric.t), parametric.y4(parametric.n));',correct
'{    ;    stroke(varcol, 0, varcol + 100);    strokeWeight(stroke_weight);    noFill();    for (int i = 0; i < 5; i++) {        ellipse(0, 0, 600, 600);    }}',correct
'cos(parametric.n / parametric.frequency)',correct
't1 = 0;',DrawingStateChangeRule
'random(4, 8)',correct
'shaper.color_trigger',correct
'{    // println("Setting width");    expansion_width++;}',SimplifyBooleanExpressions
'n1 = 0;',DrawingStateChangeRule
't = t + increment;',correct
'sin(-n / frequency) * 300',correct
'space[space.length - 1].opacity_trigger == false',correct
'strokeWeight(5);',correct
'ix',correct
'iy',correct
'-sin(parametric.n / 30) * 30',correct
'float colorUpdate = 0;',AtLeastOneConstructor
'{    colorUpdate += colorChange * 30;    if (colorUpdate > 254) {        colorUpdate = 0;    }}',correct
'// parametric.parametric_increment();',correct
'beginShape()',correct
'// GENERATES THE RANDOM PATTERNS IF MOUSE IS DRAGGER. ONCE T REACHES 602, BOTH T AND N ARE RESETED TO THE SAME VALUE AGAIN.text(parametric.n, 600, 200);',correct
'trigger_background = true',correct
'range_1 = 0',correct
'fill(0, 0, 0, eyeOpacity)',correct
'// ball 4          /*------------- THE FOUR BALLS FOLLOW THE SAME PARAMETRIC EQUATION WITH 4 DIFFERENT SIN AND COS RANGES.point(parametric.x2(parametric.t), parametric.y2(parametric.n));',correct
'varcol = random(0, 100)',correct
'parametric.float_mouse_trigger = false',correct
'iy = (sin(n1 * i / 100) * 100);',DrawingStateChangeRule
'frequency = 96',correct
'{    eyeWidth += eyeWidth_speed;    if (eyeWidth < 0 || eyeWidth > 28) {        eyeWidth_speed = eyeWidth_speed * -1;    }    eyeOpacity += opacitySpeed;    if (eyeOpacity < 0 || eyeOpacity > 254) {        opacitySpeed *= -1;    }}',correct
'0.5f',correct
'random_1',correct
'random_2',correct
'eyeWidth_speed = eyeWidth_speed * -1',correct
'float eyeWidth = 1;',correct
'ellipse(eyeX, eyeY, 15, 15)',correct
'eye_2 = new EyeBall(-60, 0)',correct
'shaper.de_expansion();',correct
'{    for (int i = 0; i < 100; i++) {        // ---------WHEN DREAM MODE IS ACTIVATED, SLOWLY INCREASE OPACITY OF SPACE STARS, WHEN DREAM MODE IS        space[i].opacity_trigger = true;    }// ---------DEACTIVATED, SLOWLY DECREASE OPACITY}',SimplifyBooleanExpressions
'draw',LongMethodRule
'{    space[i].opacity_trigger = false;}',correct
'shaper.color_trigger = false',correct
'stroke(PApplet.parseInt(random(100, 170)), PApplet.parseInt(random(120, 150)), PApplet.parseInt(random(0, 255)));',correct
'void mouseReleased() {    // -----------TURNS OFF THE TRIGGERS ACTIVATED IN MOUSE PRESSED--------//    shaper.right_trigger = false;    shaper.left_trigger = false;    shaper.color_trigger = false;    orbit_weight_trigger = false;    orbit_lines_mouse_trigger = false;    parametric.float_mouse_trigger = false;}',correct
'{    weight_ = random(4, 8);}',correct
'orbit_weight = 2',correct
'opacitySpeed *= -1',correct
'sx = x / speed',correct
'strokeWeight(7.5f)',correct
'{    if (float_key_trigger == true) {        return cos(n / frequency) * 100;    }    return -sin(-n / frequency) * 300;}',correct
'n1',correct
'EyeBall',correct
'cos(parametric.t / 30)',correct
'{    // DECREASING SPEED IS SYCHRONISED WITH INTERNAL FX EXPANSION FREQUENCY    stroke_weight -= 15.25641f;    if (stroke_weight <= 0) {        stroke_weight = 1500;        varcol = random(0, 100);    }}',MethodNamingConventions
'ShakingFX shakingFXrange_1;',correct
'eyeOpacity < 0',correct
'for (int i = 0; i < 100; i++) {    space[i] = new Space();}',correct
'colorUpdate <= 255',correct
'{    // ALL AROUND THE PROGRAM TO CHANGE IN CYCLE MODE COLOR, STROKE WEIGHTS ETC..    return sin(-n / frequency) * 300;}',SimplifyBooleanExpressions
'text(parametric.t, 600, 0)',correct
'-1',correct
'{    return sin(-n / frequency) * 20;}',correct
'{    if (orbit_weight < 10 && orbit_weight_trigger == true) {        orbit_weight += 0.5f;    } else if (orbit_weight > 2) {        orbit_weight -= 0.5f;    }}',correct
'if (t > 602.5f) {    t = 0;    n = 0;}',correct
'ShakingFX shakingFXrange_2;',correct
'expansion',correct
'if (opacity_trigger == false) {    if (opacity > 0) {        opacity -= 0.1f;    }}',SimplifyBooleanExpressions
'// ellipse (0, 0, range, range);',correct
'true',correct
'0.90714f',correct
'color_trigger = false',correct
'vertex(0, -vertexY)',correct
'colorUpdate > 254',correct
'{    return cos(t / frequency) * 85;}',correct
'shakingFXrange_2 = new ShakingFX(400, 500);',correct
'orbit_weight -= 0.5f;',DrawingStateChangeRule
'// ------------A-C-T-I-V-A-T-E---D-R-E-A-M-----M-O-D-E---------------//',correct
'sy = y / speed',correct
'shakingFXrange_1.display()',correct
'central_orbit_move();',correct
'// ALL AROUND THE PROGRAM TO CHANGE IN CYCLE MODE COLOR, STROKE WEIGHTS ETC..return sin(-n / frequency) * 300;',correct
'if (expansion_width > 40 && right_trigger == true) {    expansion_width--;}',SimplifyBooleanExpressions
'void update() {    eyeWidth += eyeWidth_speed;    if (eyeWidth < 0 || eyeWidth > 28) {        eyeWidth_speed = eyeWidth_speed * -1;    }    eyeOpacity += opacitySpeed;    if (eyeOpacity < 0 || eyeOpacity > 254) {        opacitySpeed *= -1;    }}',correct
'// NEGATIVE WIDTH AND HEIGHT BECAUSE OF THE TRANSLATION FUNCTION IN THE MAIN TAB. THE TRANSLATION MOVES THE O POINT OF CANVAS TO CENTER,x = random(-width, width);',correct
'// INCREASE SIZE CENTRAL SHAPE AND ACTIVATE COLOR PULSEshaper.right_trigger = true;',correct
'mouseButton == CENTER && trigger_background == false',correct
'cos(parametric.t / 30) * 30',correct
'0.9f',correct
'update_weight_orbit_lines_b()',correct
'float t',correct
'-n',correct
'boolean float_mouse_trigger = false;',correct
'{    return sin(-n / frequency) * 85;}',correct
'float x',correct
'float y',correct
'color_trigger == true',correct
'-t',correct
'if (trigger_background == true) {    // --------------R-E-G-U-L-A-R----M-O-D-E----W-I-T-H-----B-A-C-K-G-R-O-U-N-D------//    parametric.parametric_increment();    background(sin(parametric.t / 30) * 30 + 50, cos(parametric.t / 30) * 30 + 50, -sin(parametric.n / 30) * 30 + 50);    stroke(238, 169, 144);    for (int i = 0; i < 100; i++) {        space[i].display();        space[i].update();    }    display_externalFX();    update_externalFX();    // --------------------------E-X-P-A-N-D-I-N-G-------C-I-R-C-L-E-S--------------------//    display_internalFX();    update_internalFX();    draw_sustain_ellipse();    // CENTRAL FIXED ELLIPSE    update_sustain_ellipse();    shakingFXrange_1.display();    shakingFXrange_1.shake();    // MOVING CENTRAL SHAPE    shaper.display();    shaper.color_update();    shaper.color_fill();    shaper.expansion();    shaper.de_expansion();    shakingFXrange_2.display();    shakingFXrange_2.shake();    eye_1.display();    eye_1.update();    eye_2.display();    eye_2.update();    display_main_orbits();    display_orbit_lines();    display_central_orbit();    central_orbit_move();    central_orbit_weight_update();    guidePoints.display();    guidePoints.change_color();} else {    // ------------A-C-T-I-V-A-T-E---D-R-E-A-M-----M-O-D-E---------------//    // ALL THE T AND N VALUES ARE INCREMENTING    parametric.parametric_increment();    for (int i = 0; i < 100; i++) {        space[i].display();        space[i].update();    }    // 50 OPACITY TO THE "FAKE" BACKGROUND TO CREATE THE ECHO EFFECT    fill(sin(parametric.t / 30) * 30, cos(parametric.t / 30) * 30, -sin(parametric.n / 30) * 30, 50);    noStroke();    rectMode(CENTER);    rect(0, 0, width, height);    shakingFXrange_1.display();    shakingFXrange_1.shake();    shakingFXrange_2.display();    shakingFXrange_2.shake();    eye_1.display();    eye_1.update();    eye_2.display();    eye_2.update();    display_main_orbits();    display_orbit_lines();    guidePoints.display();    guidePoints.change_color();}',correct
'shakingFXrange_2.display();',correct
'EyeBall eye_2;',correct
'weight_ = 4',correct
'colorUpdate += colorChange * 30',correct
'strokeWeight((cos(parametric.n / 65) + 1) * 8)',correct
'float x1(float n) {    // EACH FLOAT METHOD GIVES THE POSSIBILITY TO RETURN SIN AND COS VALUES FOR PARAMETRIC EQUATIONS: THIS RETURNS    if (float_mouse_trigger == true) {        // ALL AROUND THE PROGRAM TO CHANGE IN CYCLE MODE COLOR, STROKE WEIGHTS ETC..        return sin(-n / frequency) * 300;    }    return -sin(-n / frequency) * 200;}',AtLeastOneConstructor
'for (int i = 0; i < 5; i++) {    ellipse(0, 0, 600, 600);}',correct
'float n',ShortVariable
'color_guide_points_X = map(mouseX, 0, width, 0, 255)',correct
'cos(n / frequency) * 100',correct
'-cos(-t / frequency) * 300',correct
'return cos(n / frequency) * 100;',correct
'point(parametric.x1(parametric.t), parametric.y1(parametric.t))',correct
'boolean orbit_lines_key_trigger = false;',FieldDeclarationsShouldBeAtStartOfClass
'if (eyeWidth < 0 || eyeWidth > 28) {    eyeWidth_speed = eyeWidth_speed * -1;}',correct
'weight_ = random(4, 8)',correct
'shaper.color_trigger = true;',correct
'n1++',correct
'eyeOpacity = eyeOpacity - opacitySpeed',correct
'// SAME OF THE INTERNAL TWO POINTS MOLTIPLICATION, BUT THIS EXTERNAL POINTS ARE',correct
't > 602.5f',correct
'strokeWeight(weight_)',correct
'text(vertexX, 600, 300);',correct
'for (float i = 0; i < 10; i += 0.5f) {    // DESIGN OF SHAPE WITH VARIABLE VERTEXES    stroke((i + colorUpdate), 0, 0);    beginShape();    vertex(vertexX, 0);    vertex(0, vertexY);    vertex(-vertexX, 0);    vertex(0, -vertexY);    endShape(CLOSE);    vertexX = sin(parametric.t / (parametric.frequency / 2)) * expansion_width + 10 * i;    vertexY = cos(parametric.t / (parametric.frequency / 2)) * expansion_width + 10 * i;}',correct
'void display() {    // parametric.parametric_increment();    strokeWeight(0.5f);    fill(colorUpdate, g, b, 5);    for (float i = 0; i < 10; i += 0.5f) {        // DESIGN OF SHAPE WITH VARIABLE VERTEXES        stroke((i + colorUpdate), 0, 0);        beginShape();        vertex(vertexX, 0);        vertex(0, vertexY);        vertex(-vertexX, 0);        vertex(0, -vertexY);        endShape(CLOSE);        vertexX = sin(parametric.t / (parametric.frequency / 2)) * expansion_width + 10 * i;        vertexY = cos(parametric.t / (parametric.frequency / 2)) * expansion_width + 10 * i;    }    text(colorUpdate, 600, 100);    text(vertexX, 600, 300);    text(vertexY, 600, 400);}',AtLeastOneConstructor
'if (mouseButton == CENTER && trigger_background == false) {    trigger_background = true;}',SimplifyBooleanExpressions
'stroke((i + colorUpdate), 0, 0)',correct
'float colorChange = 0.5f;',AtLeastOneConstructor
'point(parametric.x3(parametric.t * i), parametric.y3(parametric.n * i));',correct
't1',correct
'cos(parametric.t / 40) * 40',correct
'return sin(t1 / 48) * 350;',correct
'{    if (opacity > 0) {        opacity -= 0.1f;    }}',correct
'{    return sin(t1 / 48) * 350;}',correct
'parametric.t / parametric.frequency',correct
'GuidePoints() {    color_guide_points_X = 0;    color_guide_points_Y = 0;}',correct
'{    update_weight_orbit_lines_b();}',correct
'// strokeWeight (0);',correct
'{    range_1 = 0;    varcol_2 = random(0, 80);}',correct
'{    for (int i = 0; i < 100; i++) {        space[i].opacity_trigger = false;    }}',correct
'parametric.float_mouse_trigger = false;',correct
'void display_internalFX() {    fill(varcol_2, varcol_2, 100, 100);    strokeWeight(0);    ellipse(0, 0, (range_1) + 100, range_1);}',MethodNamingConventions
'return cos(n1 / 24) * 350;',correct
'if (orbit_lines_mouse_trigger == true) {    // SAME OF THE INTERNAL TWO POINTS MOLTIPLICATION, BUT THIS EXTERNAL POINTS ARE    // ALL CONNECTED WITH A LINE, SO I HAVE MY ORBITAL SEGMENTS.    update_weight_orbit_lines_a();}',correct
'radians(150)',correct
'GuidePoints guidePoints;',correct
'{    strokeWeight((sin(parametric.n / parametric.frequency) + 1) * 2);}',correct
'sx',correct
'stroke_weight -= 15.25641f',correct
'sy',correct
'// CLICK&DRAG THE MOUSE TO CREATE A RANDOM PATTERN, WHICH WILL RESET ITSELF AFTER COMPLETING THE CYCLE;',correct
'stroke_weight = 800',correct
'{    range_1 += 8.5f;    if (range_1 >= 390) {        range_1 = 0;        varcol_2 = random(0, 80);    }}',correct
'{    orbit_weight -= 0.5f;}',correct
'-cos(-t / frequency)',correct
'ellipseY = 0;',correct
'void update_externalFX() {    // DECREASING SPEED IS SYCHRONISED WITH INTERNAL FX EXPANSION FREQUENCY    stroke_weight -= 15.25641f;    if (stroke_weight <= 0) {        stroke_weight = 1500;        varcol = random(0, 100);    }}',correct
'{    return cos(-t / frequency) * 300;}',correct
'{    fill(fill_r, fill_g, fill_b, opacity);    noStroke();    float parametric_x = sin(parametric.t / parametric.frequency);    float parametric_y = cos(parametric.n / parametric.frequency);    ellipse(sx * parametric_x, sy * parametric_y, sx / 60, sx / 60);    // ALL THE SPOTS ARE GENERATED IN RANDOM POSITIONS WITHIN THE CANVAS, BUT WHEN DEVIDED FOR INITIAL VALUE OF SPEED (100),    sx = x / speed;    // X AND Y POSITION BECOME SMALL, SO THEY STAY IN CENTER. WHILE THE SPEED VALUE DECREASES, X AND Y BECOME BIGGER, SO THEY EXPAND TO THEIR    sy = y / speed;}',correct
'-sin(parametric.n / 30) * 30 + 50',correct
'[100]',correct
'println(opacity);',correct
'strokeWeight((sin(parametric.n / parametric.frequency) + 1) * 2)',correct
'noStroke()',correct
'sin(t / frequency)',correct
'// EACH FLOAT METHOD GIVES THE POSSIBILITY TO RETURN SIN AND COS VALUES FOR PARAMETRIC EQUATIONS: THIS RETURNSif (float_mouse_trigger == true) {    // ALL AROUND THE PROGRAM TO CHANGE IN CYCLE MODE COLOR, STROKE WEIGHTS ETC..    return sin(-n / frequency) * 300;}',correct
'n1 = 0',correct
'display_externalFX()',correct
'shaper.color_trigger = true',correct
'float t = 0;',ShortVariable
'// range=random(-25, 25)+50;',correct
'opacity_trigger == false',correct
'stroke(random(100, 170), random(120, 150), random(0, 255))',correct
'display_internalFX()',correct
'display_main_orbits();',correct
'space.length',correct
'display_orbit_lines()',correct
'// strokeWeight(random( 1 , 100 ));ix = (-sin(t1 * i / 100) * 100);',correct
'strokeWeight(random(0, orbit_weight));',correct
'eyeWidth < 0',correct
'{    orbit_weight += 0.5f;}',correct
'void display() {    fill(255, 255, 255);    // OPEN AND CLOSE THE EYES TROUGH CHANGING THE HEIGHT OF ELLIPSE    ellipse(eyeX, eyeY, 50, eyeWidth);    fill(0, 0, 0, eyeOpacity);    noStroke();    ellipse(eyeX, eyeY, 15, 15);    fill(255, 255, 255);    arc(eyeX + 100, eyeY, 100, 200, radians(150), radians(60));}',correct
'void setup() {    surface.setResizable(true);    background(0);    eye_1 = new EyeBall(60, 0);    eye_2 = new EyeBall(-60, 0);    guidePoints = new GuidePoints();    shaper = new Shaper();    shakingFXrange_2 = new ShakingFX(400, 500);    shakingFXrange_1 = new ShakingFX(25, 75);    parametric = new ParametricVals();    for (int i = 0; i < 100; i++) {        space[i] = new Space();    }}',correct
'parametric.n',correct
'fill(0)',correct
'height / 2',correct
'parametric.t',correct
'x1',ShortVariable
'ellipseX = 0;',correct
'text(vertexY, 600, 400)',correct
'float y1(float t) {    if (float_mouse_trigger == true) {        return cos(-t / frequency) * 300;    }    return -cos(-t / frequency) * 200;}',AtLeastOneConstructor
'// IF MOUSE NOT DRAGGED, T AND N VALUES ARE SYNCHRONIZED, IF THE MOUSE IS DRAGGED, THE T VALUE IS ALTERED WHILE N KEEPS INCREASING. THIStext(parametric.t, 600, 0);',correct
'float parametric_y = cos(parametric.n / parametric.frequency)',correct
'update',correct
'// ABSOLUTE FUNCTION KEEPS NUMBERS POSITIVE.  :)stroke(abs(color_guide_points_X), abs(color_guide_points_Y), 0);',correct
'float i = 0',correct
'x / speed',correct
'speed',correct
'// CALL X1 Y1 RETURNS (PATTERN 1)parametric.float_mouse_trigger = true;',correct
'speed = random(100)',correct
'4.5f',correct
'strokeWeight((sin(parametric.n / parametric.frequency) + 1) * 5)',correct
'shaper',correct
'random(100, 200)',correct
'// ball 3point(parametric.x1(parametric.t), parametric.y1(parametric.t));',correct
'stroke(varcol, 0, varcol + 100);',correct
'// INSTRUCTIONS: //<>// //<>//// PRESS THE MOUSE TO SWITCH TO PATTERN N.2;// PRESS ANY KEY TO SWITCH TO PATTERN N.3;// CLICK&DRAG THE MOUSE TO CREATE A RANDOM PATTERN, WHICH WILL RESET ITSELF AFTER COMPLETING THE CYCLE;// CHANGE THE COLOR OF THE 4 MAIN DOTS MOVING THE CURSOR ACROSS THE SCREEN.// PRESS THE CENTER BUTTON OF THE MOUSE TO ACTIVATE THE DREAM MODE. PRESS THE SAME BUTTON AGAIN TO TURN THE DREAM MODE OFF.// PRESSING THE LEFT MOUSE BUTTON, THE CENTRAL SHAPE WILL BECOME BIGGER. PRESSING THE RIGHT MOUSE BUTTON WILL MAKE THE SHAPE SMALLER.Shaper shaper;',correct
'iy = (sin(n1 * i / 100) * 100)',correct
'{    surface.setResizable(true);    background(0);    eye_1 = new EyeBall(60, 0);    eye_2 = new EyeBall(-60, 0);    guidePoints = new GuidePoints();    shaper = new Shaper();    shakingFXrange_2 = new ShakingFX(400, 500);    shakingFXrange_1 = new ShakingFX(25, 75);    parametric = new ParametricVals();    for (int i = 0; i < 100; i++) {        space[i] = new Space();    }}',correct
'text(colorUpdate, 600, 100);',correct
'parametric.x1(parametric.t)',correct
'-sin(-n / frequency) * 200',correct
'{    strokeWeight(random(0, 2));}',correct
'stroke(PApplet.parseInt(random(100, 170)), PApplet.parseInt(random(120, 150)), PApplet.parseInt(random(0, 255)))',correct
'if (colorUpdate > 0) {    colorUpdate -= colorChange;}',correct
'orbit_lines_mouse_trigger = false;',correct
'strokeWeight(15);',correct
'ellipseMode(CENTER);',correct
'eyeX = x;',correct
'shaper.left_trigger = false',correct
'parametric.frequency',correct
'orbit_lines_key_trigger = true',correct
'endShape(CLOSE)',correct
'stroke(255)',correct
'random(120, 150)',correct
'rect(0, 0, width, height);',correct
'{    strokeWeight((cos(parametric.n / 65) + 1) * 8);    stroke(random(100, 170), random(120, 150), random(0, 255));    point(parametric.x3(parametric.t * i), parametric.y3(parametric.n * i));    // -------MULTIPLY INTERNAL TWO POINTS, RANDOM COLOR, MOVEMENT BASED ON PARAMETRIC    // ----VALUES OF T AND N IN X4 Y4 AND X3 Y3    strokeWeight(((-sin(parametric.n)) * 4) + 4.5f);    stroke(random(100, 170), random(120, 150), random(0, 255));    point(parametric.x4(parametric.t * i), parametric.y4(parametric.n * i));    fill(238, 169, 144);}',correct
'display_main_orbits',MethodNamingConventions
'if (float_key_trigger == true) {    return cos(n / frequency) * 100;}',SimplifyBooleanExpressions
'float increment = 0.9f;',correct
'void display() {    // SHAKING EFFECT PRODUCES BY WIDE RANDOM GENERATION OF RANGE VALUES.    strokeWeight(0);    stroke(255);    noFill();    ellipse(ellipseX, ellipseY, range, range);}',correct
'parametric.y3(parametric.n)',correct
'display_orbit_lines();',correct
'parametric.y1(parametric.t)',correct
'{    if (expansion_width > 40 && right_trigger == true) {        expansion_width--;    }}',correct
'background(0)',correct
'return -cos(-t / frequency) * 200;',correct
'ParametricVals',AtLeastOneConstructor
'eyeWidth > 28',correct
'int random_1, random_2;',correct
'parametric.float_key_trigger = false',correct
'fill(colorUpdate, g, b, 5)',correct
'opacity = 0',correct
'left_trigger = false',correct
'void update_internalFX() {    range_1 += 8.5f;    if (range_1 >= 390) {        range_1 = 0;        varcol_2 = random(0, 80);    }}',MethodNamingConventions
'{    // strokeWeight(random( 1 , 100 ));    ix = (-sin(t1 * i / 100) * 100);    iy = (sin(n1 * i / 100) * 100);    noFill();    strokeWeight(random(0, orbit_weight));    ellipse((sin(parametric.t / 100) * (parametric.x2(parametric.t * i))), (cos(parametric.y2(parametric.n * i))), (ix / 6), (iy / 6));}',correct
'vertex(-vertexX, 0)',correct
'update_externalFX',MethodNamingConventions
'shaper.expansion()',correct
'sy * parametric_y',correct
't = 0;',correct
'float x3(float n) {    return sin(-n / frequency) * 85;}',ShortVariable
'if (colorUpdate <= 255 && color_trigger == true) {    colorUpdate += colorChange * 30;    if (colorUpdate > 254) {        colorUpdate = 0;    }} else {    if (colorUpdate > 0) {        colorUpdate -= colorChange;    }}',SimplifyBooleanExpressions
'sx / 60',correct
'space[i].update();',correct
'{    n1++;    t1++;    if (n1 > 602.5f) {        t1 = 0;        n1 = 0;    }}',correct
'random(-height, height)',correct
'// CHANGE THE COLOR OF THE 4 MAIN DOTS MOVING THE CURSOR ACROSS THE SCREEN.',correct
'class ShakingFX {    float range;    int ellipseX, ellipseY;    int random_1, random_2;    ShakingFX(int x, int y) {        // X AND Y INSERED IN THE MAIN PAGE WILL BE THE TWO VALUES OF A RANDOM FUNCTION, WHICH WILL BE THE WIDTH AND HEIGHT OF THE CIRCLES.        random_1 = x;        random_2 = y;        ellipseX = 0;        ellipseY = 0;    }    void display() {        // SHAKING EFFECT PRODUCES BY WIDE RANDOM GENERATION OF RANGE VALUES.        strokeWeight(0);        stroke(255);        noFill();        ellipse(ellipseX, ellipseY, range, range);    }    void shake() {        range = PApplet.parseInt(random(random_1, random_2));    }}',correct
'if (orbit_weight < 10 && orbit_weight_trigger == true) {    orbit_weight += 0.5f;} else if (orbit_weight > 2) {    orbit_weight -= 0.5f;}',SimplifyBooleanExpressions
'point(parametric.x3(parametric.t * i), parametric.y3(parametric.n * i))',correct
'cos(-t / frequency) * 300',correct
'parametric.x1(parametric.t * i)',correct
'eye_2.update()',correct
'sin(parametric.n / 30)',correct
'range',correct
'range = PApplet.parseInt(random(random_1, random_2));',correct
'{    r += 2;    g++;    b += 3;    if (g > 255) {        g = 0;    }    if (b > 255) {        b = 0;    }    println(expansion_width);}',correct
'keyReleased',correct
'{    // CHANGE WEIGHT ORBIT SEGMENTS WHEN KEY IS PRESSED//    orbit_lines_key_trigger = true;    // CALL X2 AND Y2 RETURNS (PATTERN 2)    parametric.float_key_trigger = true;}',correct
'background(sin(parametric.t / 30) * 30 + 50, cos(parametric.t / 30) * 30 + 50, -sin(parametric.n / 30) * 30 + 50)',correct
'{    eyeWidth_speed = eyeWidth_speed * -1;}',correct
'strokeWeight((sin(parametric.n / parametric.frequency) + 1) * 2);',correct
'{    fill(varcol_2, varcol_2, 100, 100);    strokeWeight(0);    ellipse(0, 0, (range_1) + 100, range_1);}',correct
'void keyPressed() {    // CHANGE WEIGHT ORBIT SEGMENTS WHEN KEY IS PRESSED//    orbit_lines_key_trigger = true;    // CALL X2 AND Y2 RETURNS (PATTERN 2)    parametric.float_key_trigger = true;}',correct
'new Space[100]',correct
'random(random_1, random_2)',correct
'// X AND Y POSITION BECOME SMALL, SO THEY STAY IN CENTER. WHILE THE SPEED VALUE DECREASES, X AND Y BECOME BIGGER, SO THEY EXPAND TO THEIRsy = y / speed;',correct
'if (orbit_lines_key_trigger == true) {    update_weight_orbit_lines_b();}',correct
'ellipse((sin(parametric.t / 100) * (parametric.x2(parametric.t * i))), (cos(parametric.y2(parametric.n * i))), (ix / 6), (iy / 6))',correct
'cos(parametric.t / (parametric.frequency / 2))',correct
'colorUpdate > 0',correct
'random(0, 2)',correct
'i++',correct
'// -------MULTIPLY INTERNAL TWO POINTS, RANDOM COLOR, MOVEMENT BASED ON PARAMETRIC// ----VALUES OF T AND N IN X4 Y4 AND X3 Y3strokeWeight(((-sin(parametric.n)) * 4) + 4.5f);',correct
'float',ShortVariable
'space[i].opacity_trigger = false',correct
'parametric_y = cos(parametric.n / parametric.frequency)',correct
'eyeOpacity > 254',correct
'cos(parametric.t / 30) * 30 + 50',correct
'parametric.n / parametric.frequency',correct
'new Space()',correct
'parametric.y1(parametric.n * i)',correct
'void mouseDragged() {    if (parametric.t < 602) {        parametric.t = random(20, 100);    }}',correct
'// stroke (255) ;',correct
'{    fill(0);    // ABSOLUTE FUNCTION KEEPS NUMBERS POSITIVE.  :)    stroke(abs(color_guide_points_X), abs(color_guide_points_Y), 0);    strokeWeight(15);    // ball 4          /*------------- THE FOUR BALLS FOLLOW THE SAME PARAMETRIC EQUATION WITH 4 DIFFERENT SIN AND COS RANGES.    point(parametric.x2(parametric.t), parametric.y2(parametric.n));    strokeWeight(5);    // ball 1    point(parametric.x4(parametric.t), parametric.y4(parametric.n));    strokeWeight(7.5f);    // ball 2    point(parametric.x3(parametric.t), parametric.y3(parametric.n));    strokeWeight(7.5f);    // ball 3    point(parametric.x1(parametric.t), parametric.y1(parametric.t));}',correct
'return cos(-t / frequency) * 300;',correct
'keyPressed',correct
'parametric.x2(parametric.t * i)',correct
'{    return sin(t / frequency) * 100;}',correct
'-60',correct
'if (range_1 >= 390) {    range_1 = 0;    varcol_2 = random(0, 80);}',correct
'parametric.y2(parametric.n * i)',correct
'r += 2',correct
'vertex(vertexX, 0);',correct
'b += 3;',correct
'{    return cos(n1 / 24) * 350;}',correct
'println(expansion_width);',correct
'random(200, 255)',correct
'vertexY',correct
'vertexX',correct
'parametric.float_mouse_trigger',correct
'stroke(255);',correct
'expansion_width > 40',correct
'central_orbit_weight_update()',correct
'class Shaper {    float vertexX;    float vertexY;    int r;    int g;    int b;    float colorUpdate = 0;    float colorChange = 0.5f;    float expansion_width = 40;    boolean right_trigger = false;    boolean left_trigger = false;    boolean color_trigger = false;    void display() {        // parametric.parametric_increment();        strokeWeight(0.5f);        fill(colorUpdate, g, b, 5);        for (float i = 0; i < 10; i += 0.5f) {            // DESIGN OF SHAPE WITH VARIABLE VERTEXES            stroke((i + colorUpdate), 0, 0);            beginShape();            vertex(vertexX, 0);            vertex(0, vertexY);            vertex(-vertexX, 0);            vertex(0, -vertexY);            endShape(CLOSE);            vertexX = sin(parametric.t / (parametric.frequency / 2)) * expansion_width + 10 * i;            vertexY = cos(parametric.t / (parametric.frequency / 2)) * expansion_width + 10 * i;        }        text(colorUpdate, 600, 100);        text(vertexX, 600, 300);        text(vertexY, 600, 400);    }    void color_fill() {        r += 2;        g++;        b += 3;        if (g > 255) {            g = 0;        }        if (b > 255) {            b = 0;        }        println(expansion_width);    }    void color_update() {        if (colorUpdate <= 255 && color_trigger == true) {            colorUpdate += colorChange * 30;            if (colorUpdate > 254) {                colorUpdate = 0;            }        } else {            if (colorUpdate > 0) {                colorUpdate -= colorChange;            }        }        if (color_trigger == true) {            vertexX = sin(parametric.t / 40) * 40;            vertexY = cos(parametric.t / 40) * 40;        }    }    void expansion() {        // println("Expanding");        if (expansion_width < 200 && left_trigger == true) {            // println("Setting width");            expansion_width++;        }    }    void de_expansion() {        if (expansion_width > 40 && right_trigger == true) {            expansion_width--;        }    }}',correct
'varcol = random(0, 100);',DrawingStateChangeRule
'color_guide_points_Y = map(mouseY, 0, height, 0, 255);',correct
'orbit_lines_mouse_trigger = true',correct
'speed = 100',correct
'parametric.n / 30',correct
'shaper.color_fill()',correct
'varcol = 0',correct
'random(20, 100)',correct
'{    space[i].display();    space[i].update();}',correct
'guidePoints.change_color()',correct
'T = 0',correct
'float_key_trigger == true',correct
'width / 2',correct
'shaper.left_trigger = false;',correct
'ellipseX = 0',correct
'{    // SAME OF THE INTERNAL TWO POINTS MOLTIPLICATION, BUT THIS EXTERNAL POINTS ARE    // ALL CONNECTED WITH A LINE, SO I HAVE MY ORBITAL SEGMENTS.    update_weight_orbit_lines_a();}',SimplifyBooleanExpressions
'space[space.length - 1].opacity_trigger',correct
'if (eyeOpacity < 0 || eyeOpacity > 254) {    opacitySpeed *= -1;}',correct
'boolean left_trigger = false;',correct
'random(width)',correct
'yspeed = random(2, 5)',correct
'if (y > height / 2) {    speed = speed * -0.95f;    y = height / 2;}',correct
'// bodyfill(bodyColor);',correct
'snowflakes[i].display();',correct
'rotate(radians(45))',correct
'// penguinpenguin01.display();',correct
'{    penguin01 = new Penguin(200, 200);    for (int i = 0; i < snowflakes.length; i++) {        snowflakes[i] = new Snow();    }}',correct
'x = xInit;',correct
'translate(x - 22, y + 145)',correct
'y = yInit',correct
'stroke(0);',correct
'stroke(0)',correct
'triangle(x - 20, y + 10, x - 36, y + 10, x - 28, y - 12)',correct
'penguin01 = new Penguin(200, 200)',correct
'new Snow[150]',correct
'y + 93',correct
'pushMatrix();',correct
'ellipse(x + 29, y, 20, 30);',correct
'ellipse(x - 25, y, 5, 5);',correct
'x = xInit',correct
'// blushing',correct
'float y = random(-500, -50);',correct
';',EmptyStatementNotInLoop
'y = y + speed',correct
'ellipse(x, y + 102, 70, 70);',correct
'translate(armX2, armY);',correct
'x + 10',correct
'stroke(bodyColor)',correct
'void display() {    fill(255);    noStroke();    ellipse(x, y, 3, 3);    ;}',correct
'fill(0);',correct
'{    armY = y + 40;    armX1 = x + 50;    armX2 = x - 50;}',DecentralizedEventHandlingRule
'ellipse(0, 0, 25, 75);',correct
'float x = random(width);',correct
'angle = (angle + angularSpeed) % 90',correct
'ellipse(x, y, 100, 110)',correct
'arc(x, y, 100, 110, QUARTER_PI, 3 * QUARTER_PI);',correct
'// beakfill(255, 200, 0);',correct
'random(2, 5)',correct
'ellipse(x, y, 100, 110);',correct
'// feetfill(255, 200, 0);',correct
'y = yInit;',correct
'speed = speed * -0.95f',correct
'ellipse(x + 29, y, 20, 30)',correct
'ellipse(x, y + 93, 112, 100);',correct
'snowflakes.length',correct
'ellipse(x + 29, y + 21, 18, 13)',correct
'x + 22',correct
'armX2 = -armX2;',correct
'dist(mouseX, mouseY, x, y) <= 100',DecentralizedEventHandlingRule
'{    speed = speed * -0.95f;    y = height / 2;}',correct
'x + 20',correct
'y - 12',correct
'dx = 1;',correct
'rotate(radians(angle));',correct
'y + 75',correct
'popMatrix();',correct
'y - 14',correct
'-200',correct
'// blushing// babypinkfill(255, 200, 200);',correct
'stroke(255, 200, 0);',correct
'float bodyColor;',correct
'x',correct
'x + 18',correct
'ellipse(x - 29, y, 20, 30)',correct
'y',correct
'background(0, 200, 255)',correct
'-0.95f',correct
'ellipse(x + 34, y, 5, 5)',correct
'-armX1',correct
'-armX2',correct
'noStroke()',correct
'armY = y + 75;',correct
'speed + gravity',correct
'new Snow()',correct
'3 * height / 4',correct
'speed = speed + gravity;',correct
'x - 50',correct
'bodyColor = 190;',correct
'-angle',correct
'dx',correct
'ellipse(x + 34, y, 5, 5);',correct
'armX2 = x + 50;',correct
'ellipse(x + 29, y + 5, 20, 20)',correct
'triangle(x - 10, y + 10, x + 10, y + 10, x, y + 30);',correct
'new Penguin(200, 200)',correct
'armY = y + 40;',correct
'rotate(radians(45));',correct
'snowflakes[i].fall()',correct
'translate(x + 22, y + 145);',correct
'fill(bodyColor)',correct
'rect(0, 3 * height / 4, width, height / 4)',correct
'arc(x, y, 100, 110, QUARTER_PI, 3 * QUARTER_PI)',correct
'ellipse(x, y, 3, 3)',correct
'y = random(-200, -100);',correct
'translate(x - 22, y + 145);',correct
'rotate(radians(-angle))',correct
'-100',correct
'fill(0)',correct
'height / 2',correct
'0.95f',correct
'height / 4',correct
'snowflakes[i] = new Snow()',correct
'fill(bodyColor);',correct
'snowflakes[i].display()',correct
'penguin01 = new Penguin(200, 200);',correct
'dist(mouseX, mouseY, x, y)',correct
'0.1f',correct
'float x;',correct
'armX1 = x + 50;',correct
'fill(255)',correct
'for (int i = 0; i < snowflakes.length; i++) {    snowflakes[i] = new Snow();}',correct
'dx = 1',correct
'y = height / 2',correct
'Processing',correct
'{    x = xInit;    y = yInit;    dx = 1;    bodyColor = 190;    angularSpeed = 1;}',correct
'float armX2;',correct
'armX2 = x + 50',correct
'y = height / 2;',correct
'y = y + yspeed',correct
'pushMatrix()',correct
'snowflakes = new Snow[150]',correct
'rotate(radians(-angle));',correct
'x = random(width)',correct
'y > height',correct
'int dx;',correct
'angle = (angle + angularSpeed) % 90;',correct
'// left armfill(bodyColor);',correct
'{    y = random(-200, -100);    yspeed = random(2, 5);}',correct
'random(-200, -100)',correct
'ellipse(x - 29, y + 5, 20, 20);',correct
'float y;',correct
'int i = 0',correct
'{    fill(255);    stroke(0);    ellipse(x - 29, y, 20, 30);    ellipse(x + 29, y, 20, 30);    fill(0);    stroke(0);    ellipse(x - 29, y + 5, 20, 20);    ellipse(x + 29, y + 5, 20, 20);    fill(255);    stroke(255);    ellipse(x - 25, y, 5, 5);    ellipse(x + 34, y, 5, 5);}',correct
'class Snow {    float x = random(width);    float y = random(-500, -50);    float yspeed = random(2, 5);    void fall() {        y = y + yspeed;        yspeed = yspeed + 0.05f;        if (y > height) {            y = random(-200, -100);            yspeed = random(2, 5);        }    }    void display() {        fill(255);        noStroke();        ellipse(x, y, 3, 3);        ;    }}',AtLeastOneConstructor
'0.05f',correct
'speed = speed + gravity',correct
'stroke(255)',correct
'// headnoStroke();',correct
'stroke(bodyColor);',correct
'triangle(x - 20, y + 10, x - 36, y + 10, x - 28, y - 12);',correct
'Penguin penguin01;',correct
'// gravityy = y + speed;',correct
'i = 0',correct
'// armsif (dist(mouseX, mouseY, x, y) <= 100) {    armY = y + 40;    armX1 = x + 50;    armX2 = x - 50;} else {    armY = y + 75;    armX1 = x - 50;    armX2 = x + 50;}',correct
'rotate(radians(-45))',correct
'x - 10',correct
'float armY;',correct
'radians(45)',correct
'3 * height',correct
'ellipse(0, 0, 30, 14);',correct
'ellipse(x - 29, y + 5, 20, 20)',correct
'Snow[] snowflakes = new Snow[150];',correct
'penguin01.update();',correct
'void fall() {    y = y + yspeed;    yspeed = yspeed + 0.05f;    if (y > height) {        y = random(-200, -100);        yspeed = random(2, 5);    }}',correct
'class Penguin {    float x;    float y;    int dx;    float armX1;    float armX2;    float armY;    float bodyColor;    float angularSpeed;    float angle;    float speed = 0;    float gravity = 0.1f;    Penguin(float xInit, float yInit) {        x = xInit;        y = yInit;        dx = 1;        bodyColor = 190;        angularSpeed = 1;    }    void display() {        // gravity        y = y + speed;        speed = speed + gravity;        if (y > height / 2) {            speed = speed * -0.95f;            y = height / 2;        }        // body        fill(bodyColor);        stroke(bodyColor);        ellipse(x, y + 93, 112, 100);        fill(255);        ellipse(x, y + 102, 70, 70);        // head        noStroke();        fill(bodyColor);        ellipse(x, y, 100, 110);        fill(255);        stroke(255);        arc(x, y, 100, 110, QUARTER_PI, 3 * QUARTER_PI);        // beak        fill(255, 200, 0);        stroke(255, 200, 0);        triangle(x - 10, y + 10, x + 10, y + 10, x, y + 30);        // eyes        if (dist(mouseX, mouseY, x, y) <= 100) {            fill(0);            noStroke();            triangle(x - 18, y + 10, x - 38, y + 10, x - 28, y - 14);            triangle(x + 18, y + 10, x + 38, y + 10, x + 28, y - 14);            fill(bodyColor);            triangle(x - 20, y + 10, x - 36, y + 10, x - 28, y - 12);            triangle(x + 20, y + 10, x + 36, y + 10, x + 28, y - 12);            // blushing            // babypink            fill(255, 200, 200);            noStroke();            ellipse(x - 29, y + 21, 18, 13);            ellipse(x + 29, y + 21, 18, 13);        } else {            fill(255);            stroke(0);            ellipse(x - 29, y, 20, 30);            ellipse(x + 29, y, 20, 30);            fill(0);            stroke(0);            ellipse(x - 29, y + 5, 20, 20);            ellipse(x + 29, y + 5, 20, 20);            fill(255);            stroke(255);            ellipse(x - 25, y, 5, 5);            ellipse(x + 34, y, 5, 5);        }        // arms        if (dist(mouseX, mouseY, x, y) <= 100) {            armY = y + 40;            armX1 = x + 50;            armX2 = x - 50;        } else {            armY = y + 75;            armX1 = x - 50;            armX2 = x + 50;        }        // left arm        fill(bodyColor);        noStroke();        pushMatrix();        translate(armX1, armY);        rotate(radians(45));        ellipse(0, 0, 25, 75);        popMatrix();        // right arm        pushMatrix();        translate(armX2, armY);        rotate(radians(-45));        ellipse(0, 0, 25, 75);        popMatrix();        // feet        fill(255, 200, 0);        noStroke();        pushMatrix();        translate(x - 22, y + 145);        rotate(radians(angle));        ellipse(0, 0, 30, 14);        popMatrix();        pushMatrix();        translate(x + 22, y + 145);        rotate(radians(-angle));        ellipse(0, 0, 30, 14);        popMatrix();    }    void update() {        angle = (angle + angularSpeed) % 90;    }    void mouseClick() {        if (dist(mouseX, mouseY, x, y) <= 100) {            armX1 = -armX1;            armX2 = -armX2;        }    }}',correct
'triangle(x - 18, y + 10, x - 38, y + 10, x - 28, y - 14)',correct
'snowflakes[i].fall();',correct
'float xInit',correct
'yspeed + 0.05f',correct
'x - 25',correct
'x - 20',correct
'triangle(x + 18, y + 10, x + 38, y + 10, x + 28, y - 14)',correct
'y + speed',correct
'x - 22',correct
'random(-500, -50)',correct
'y + 10',correct
'y + yspeed',correct
'{    if (dist(mouseX, mouseY, x, y) <= 100) {        armX1 = -armX1;        armX2 = -armX2;    }}',correct
'triangle(x + 18, y + 10, x + 38, y + 10, x + 28, y - 14);',correct
'float armX1;',correct
'penguin01',correct
'ellipse(x + 29, y + 5, 20, 20);',correct
'[150]',correct
'noStroke();',correct
'armY = y + 75',correct
'radians(-45)',correct
'triangle(x + 20, y + 10, x + 36, y + 10, x + 28, y - 12);',correct
'y = random(-500, -50)',correct
'translate(armX2, armY)',correct
'x - 18',correct
'fill(255, 200, 0)',correct
'x - 36',correct
'rect(0, 3 * height / 4, width, height / 4);',correct
'{    snowflakes[i] = new Snow();}',correct
'radians(-angle)',correct
'ellipse(x - 29, y + 21, 18, 13);',correct
'y + 145',correct
'float angularSpeed;',correct
'armY',correct
'if (y > height) {    y = random(-200, -100);    yspeed = random(2, 5);}',correct
'background(0, 200, 255);',correct
'armX2 = -armX2',correct
'angle',correct
'x - 28',correct
'void setup() {    penguin01 = new Penguin(200, 200);    for (int i = 0; i < snowflakes.length; i++) {        snowflakes[i] = new Snow();    }}',correct
'x - 29',correct
'snowflake',correct
'Snow snowflake;',correct
'float gravity = 0.1f;',correct
'penguin01.update()',correct
'display',LongMethodRule
'triangle(x - 18, y + 10, x - 38, y + 10, x - 28, y - 14);',correct
'{    y = y + yspeed;    yspeed = yspeed + 0.05f;    if (y > height) {        y = random(-200, -100);        yspeed = random(2, 5);    }}',correct
'draw',correct
'ellipse(x + 29, y + 21, 18, 13);',correct
'armX1 = x + 50',correct
'-45',correct
'// right armpushMatrix();',correct
'angularSpeed',correct
'yspeed = yspeed + 0.05f',correct
'3 * QUARTER_PI',correct
'{    fill(0);    noStroke();    triangle(x - 18, y + 10, x - 38, y + 10, x - 28, y - 14);    triangle(x + 18, y + 10, x + 38, y + 10, x + 28, y - 14);    fill(bodyColor);    triangle(x - 20, y + 10, x - 36, y + 10, x - 28, y - 12);    triangle(x + 20, y + 10, x + 36, y + 10, x + 28, y - 12);    // blushing    // babypink    fill(255, 200, 200);    noStroke();    ellipse(x - 29, y + 21, 18, 13);    ellipse(x + 29, y + 21, 18, 13);}',DecentralizedEventHandlingRule
'x - 38',correct
'gravity = 0.1f',correct
'translate(armX1, armY);',correct
'x + 34',correct
'Snow',correct
'Penguin',correct
'fill(255, 200, 200)',correct
'// snow fallingfor (int i = 0; i < snowflakes.length; i++) {    snowflakes[i].fall();    snowflakes[i].display();}',correct
'armX2 = x - 50;',correct
'-50',correct
'i++',correct
'y + 40',correct
'{    fill(255);    noStroke();    ellipse(x, y, 3, 3);    ;}',correct
'ellipse(x, y, 3, 3);',EmptyStatementNotInLoop
'fill(255);',correct
'float angle;',correct
'{    angle = (angle + angularSpeed) % 90;}',correct
'armX2 = x - 50',correct
'i < snowflakes.length',correct
'radians(angle)',correct
'rotate(radians(-45));',correct
'angularSpeed = 1',correct
'x + 29',correct
'// eyesif (dist(mouseX, mouseY, x, y) <= 100) {    fill(0);    noStroke();    triangle(x - 18, y + 10, x - 38, y + 10, x - 28, y - 14);    triangle(x + 18, y + 10, x + 38, y + 10, x + 28, y - 14);    fill(bodyColor);    triangle(x - 20, y + 10, x - 36, y + 10, x - 28, y - 12);    triangle(x + 20, y + 10, x + 36, y + 10, x + 28, y - 12);    // blushing    // babypink    fill(255, 200, 200);    noStroke();    ellipse(x - 29, y + 21, 18, 13);    ellipse(x + 29, y + 21, 18, 13);} else {    fill(255);    stroke(0);    ellipse(x - 29, y, 20, 30);    ellipse(x + 29, y, 20, 30);    fill(0);    stroke(0);    ellipse(x - 29, y + 5, 20, 20);    ellipse(x + 29, y + 5, 20, 20);    fill(255);    stroke(255);    ellipse(x - 25, y, 5, 5);    ellipse(x + 34, y, 5, 5);}',correct
'translate(x + 22, y + 145)',correct
'penguin01.display()',correct
'x + 28',correct
'Snow[]',correct
'void',correct
'void mouseClick() {    if (dist(mouseX, mouseY, x, y) <= 100) {        armX1 = -armX1;        armX2 = -armX2;    }}',correct
'armX1 = -armX1;',correct
'angularSpeed = 1;',correct
'armX1 = x - 50',correct
'bodyColor = 190',correct
'// snow on the groundfill(255);',correct
'armY = y + 40',correct
'(angle + angularSpeed) % 90',correct
'{    snowflakes[i].fall();    snowflakes[i].display();}',correct
'speed * -0.95f',correct
'ellipse(x - 29, y + 21, 18, 13)',correct
'speed = 0',correct
'float yInit',correct
'ellipse(x, y + 93, 112, 100)',correct
'armX1',correct
'armX2',correct
'x + 36',correct
'-500',correct
'x + 38',correct
'float yspeed = random(2, 5);',correct
'ellipse(0, 0, 25, 75)',correct
'bodyColor',correct
'triangle(x - 10, y + 10, x + 10, y + 10, x, y + 30)',correct
'popMatrix()',correct
'x + 50',correct
'y = random(-200, -100)',correct
'triangle(x + 20, y + 10, x + 36, y + 10, x + 28, y - 12)',correct
'y = y + yspeed;',correct
'{    armX1 = -armX1;    armX2 = -armX2;}',correct
'{    armY = y + 75;    armX1 = x - 50;    armX2 = x + 50;}',DecentralizedEventHandlingRule
'stroke(255);',correct
'y + 21',correct
'Penguin(float xInit, float yInit) {    x = xInit;    y = yInit;    dx = 1;    bodyColor = 190;    angularSpeed = 1;}',correct
'ellipse(x - 25, y, 5, 5)',correct
'y + 102',correct
'speed = speed * -0.95f;',correct
'void display() {    // gravity    y = y + speed;    speed = speed + gravity;    if (y > height / 2) {        speed = speed * -0.95f;        y = height / 2;    }    // body    fill(bodyColor);    stroke(bodyColor);    ellipse(x, y + 93, 112, 100);    fill(255);    ellipse(x, y + 102, 70, 70);    // head    noStroke();    fill(bodyColor);    ellipse(x, y, 100, 110);    fill(255);    stroke(255);    arc(x, y, 100, 110, QUARTER_PI, 3 * QUARTER_PI);    // beak    fill(255, 200, 0);    stroke(255, 200, 0);    triangle(x - 10, y + 10, x + 10, y + 10, x, y + 30);    // eyes    if (dist(mouseX, mouseY, x, y) <= 100) {        fill(0);        noStroke();        triangle(x - 18, y + 10, x - 38, y + 10, x - 28, y - 14);        triangle(x + 18, y + 10, x + 38, y + 10, x + 28, y - 14);        fill(bodyColor);        triangle(x - 20, y + 10, x - 36, y + 10, x - 28, y - 12);        triangle(x + 20, y + 10, x + 36, y + 10, x + 28, y - 12);        // blushing        // babypink        fill(255, 200, 200);        noStroke();        ellipse(x - 29, y + 21, 18, 13);        ellipse(x + 29, y + 21, 18, 13);    } else {        fill(255);        stroke(0);        ellipse(x - 29, y, 20, 30);        ellipse(x + 29, y, 20, 30);        fill(0);        stroke(0);        ellipse(x - 29, y + 5, 20, 20);        ellipse(x + 29, y + 5, 20, 20);        fill(255);        stroke(255);        ellipse(x - 25, y, 5, 5);        ellipse(x + 34, y, 5, 5);    }    // arms    if (dist(mouseX, mouseY, x, y) <= 100) {        armY = y + 40;        armX1 = x + 50;        armX2 = x - 50;    } else {        armY = y + 75;        armX1 = x - 50;        armX2 = x + 50;    }    // left arm    fill(bodyColor);    noStroke();    pushMatrix();    translate(armX1, armY);    rotate(radians(45));    ellipse(0, 0, 25, 75);    popMatrix();    // right arm    pushMatrix();    translate(armX2, armY);    rotate(radians(-45));    ellipse(0, 0, 25, 75);    popMatrix();    // feet    fill(255, 200, 0);    noStroke();    pushMatrix();    translate(x - 22, y + 145);    rotate(radians(angle));    ellipse(0, 0, 30, 14);    popMatrix();    pushMatrix();    translate(x + 22, y + 145);    rotate(radians(-angle));    ellipse(0, 0, 30, 14);    popMatrix();}',correct
'yspeed = yspeed + 0.05f;',correct
'rotate(radians(angle))',correct
'y + 5',correct
'{    // gravity    y = y + speed;    speed = speed + gravity;    if (y > height / 2) {        speed = speed * -0.95f;        y = height / 2;    }    // body    fill(bodyColor);    stroke(bodyColor);    ellipse(x, y + 93, 112, 100);    fill(255);    ellipse(x, y + 102, 70, 70);    // head    noStroke();    fill(bodyColor);    ellipse(x, y, 100, 110);    fill(255);    stroke(255);    arc(x, y, 100, 110, QUARTER_PI, 3 * QUARTER_PI);    // beak    fill(255, 200, 0);    stroke(255, 200, 0);    triangle(x - 10, y + 10, x + 10, y + 10, x, y + 30);    // eyes    if (dist(mouseX, mouseY, x, y) <= 100) {        fill(0);        noStroke();        triangle(x - 18, y + 10, x - 38, y + 10, x - 28, y - 14);        triangle(x + 18, y + 10, x + 38, y + 10, x + 28, y - 14);        fill(bodyColor);        triangle(x - 20, y + 10, x - 36, y + 10, x - 28, y - 12);        triangle(x + 20, y + 10, x + 36, y + 10, x + 28, y - 12);        // blushing        // babypink        fill(255, 200, 200);        noStroke();        ellipse(x - 29, y + 21, 18, 13);        ellipse(x + 29, y + 21, 18, 13);    } else {        fill(255);        stroke(0);        ellipse(x - 29, y, 20, 30);        ellipse(x + 29, y, 20, 30);        fill(0);        stroke(0);        ellipse(x - 29, y + 5, 20, 20);        ellipse(x + 29, y + 5, 20, 20);        fill(255);        stroke(255);        ellipse(x - 25, y, 5, 5);        ellipse(x + 34, y, 5, 5);    }    // arms    if (dist(mouseX, mouseY, x, y) <= 100) {        armY = y + 40;        armX1 = x + 50;        armX2 = x - 50;    } else {        armY = y + 75;        armX1 = x - 50;        armX2 = x + 50;    }    // left arm    fill(bodyColor);    noStroke();    pushMatrix();    translate(armX1, armY);    rotate(radians(45));    ellipse(0, 0, 25, 75);    popMatrix();    // right arm    pushMatrix();    translate(armX2, armY);    rotate(radians(-45));    ellipse(0, 0, 25, 75);    popMatrix();    // feet    fill(255, 200, 0);    noStroke();    pushMatrix();    translate(x - 22, y + 145);    rotate(radians(angle));    ellipse(0, 0, 30, 14);    popMatrix();    pushMatrix();    translate(x + 22, y + 145);    rotate(radians(-angle));    ellipse(0, 0, 30, 14);    popMatrix();}',LongMethodRule
'{    background(0, 200, 255);    // snow on the ground    fill(255);    rect(0, 3 * height / 4, width, height / 4);    // snow falling    for (int i = 0; i < snowflakes.length; i++) {        snowflakes[i].fall();        snowflakes[i].display();    }    // penguin    penguin01.display();    penguin01.update();}',correct
'y + 30',correct
'void update() {    angle = (angle + angularSpeed) % 90;}',correct
'if (dist(mouseX, mouseY, x, y) <= 100) {    armX1 = -armX1;    armX2 = -armX2;}',DecentralizedEventHandlingRule
'ellipse(0, 0, 30, 14)',correct
'armX1 = x - 50;',correct
'snowflakes[i] = new Snow();',correct
'stroke(255, 200, 0)',correct
'armX1 = -armX1',correct
'ellipse(x - 29, y, 20, 30);',correct
'snowflakes[i]',correct
'yspeed = random(2, 5);',correct
'float speed = 0;',correct
'ellipse(x, y + 102, 70, 70)',correct
'void draw() {    background(0, 200, 255);    // snow on the ground    fill(255);    rect(0, 3 * height / 4, width, height / 4);    // snow falling    for (int i = 0; i < snowflakes.length; i++) {        snowflakes[i].fall();        snowflakes[i].display();    }    // penguin    penguin01.display();    penguin01.update();}',correct
'translate(armX1, armY)',correct
'y > height / 2',correct
'y = y + speedModY',correct
'creaX = PApplet.parseInt(random(46, width - 31))',correct
'PApplet.parseFloat(nfc(speedModY, 1))',correct
'[12]',correct
'speedModX - 0.4f',correct
'-0.2f',correct
'Pikachu',correct
'// Making a proper collision model x-axis',correct
'fill(blush)',correct
'speedModY > -0.2f',correct
'// Eyesfill(eyes);',correct
'// |       S2169479           |',correct
'x <= 45',correct
'new Pikachu(creaX, creaY, 1, 1)',correct
'triangle(x + 1, y - 42, x + 12, y - 72, x + 13, y - 40)',correct
'background(backgr);',correct
'arc(x, y + 2, 90, 90, PI / 2, 3 * PI / 2, OPEN)',correct
'bodyColor = color(26, 37, 213)',correct
'backgr = color(30);',correct
'mouth = color(255);',correct
'// Move the creature to the position you clicked.x = mouseX;',correct
'if (speedModX > -0.2f) {    // Make sure they dont mess around and move in straight line    speedModX = speedModX + 0.4f;} else if (speedModX < -0.2f) {    // Same goes for over here    speedModX = speedModX - 0.4f;}',correct
'speedModY = speedInitY;',correct
'creatureX',correct
'creatureY',correct
'eyes',correct
'pikas = new Pikachu[12]',correct
'y = y + speedModY;',correct
'R',correct
'{    // generate a random number for the position    int creaX, creaY;    creaX = PApplet.parseInt(random(46, width - 31));    creaY = PApplet.parseInt(random(63, height - 70));    // Print the location ofthe pikachus    println("Pika ", i, ": ", creaX, ", ", creaY);    // Give m their data    pikas[i] = new Pikachu(creaX, creaY, 1, 1);}',correct
'y = mouseY',correct
'Pikachu[]',correct
'background(backgr)',correct
'void move() {    // Move the creature to the position you clicked.    x = mouseX;    y = mouseY;}',correct
'y = yInit = creatureY',correct
'mouseButton == LEFT',correct
'speedModY',correct
'speedModY = -speedModY',correct
'speedModX',correct
'{    speedModY = speedModY - 0.4f;}',correct
'{    // Just invert the colours    bodyColor = color(26, 37, 213);    earTips = color(255);    eyes = color(255);    mouth = color(255);    blush = color(1, 125, 115);    backgr = color(20);}',correct
'x + speedModX',correct
'// Body// upper circleellipse(x, y + 17, 60, 60);',correct
'r',correct
'// Ears// Lefttriangle(x - 38, y - 62, x - 30, y - 32, x - 18, y - 39);',correct
'y + speedModY',correct
'backgr = color(235)',correct
'speedModY = speedInitY = speedY;',correct
'x = xInit = creatureX;',correct
'x',correct
'y',correct
'y >= (height - 69) | y <= 62',correct
'pikas[i].speedDown();',correct
'x = mouseX',correct
'pikas[i].reset();',correct
'{    if (key == CODED) {        if (keyCode == UP) {            // ACCELERATE THE PIKAS IF YOU CLICK THE UP ARROW            for (int i = 0; i < pikas.length; i++) {                pikas[i].speedUp();            }        } else if (keyCode == DOWN) {            // SLOW THOSE PIKAS DOWN IF YOU CLICK THE DOWN ARROW            for (int i = 0; i < pikas.length; i++) {                pikas[i].speedDown();            }        }    } else if (key == r | key == R) {        for (int i = 0; i < pikas.length; i++) {            pikas[i].reset();        }    }}',correct
'width - 31',correct
'ellipse(x, y + 17, 60, 60)',correct
'{    // Move the creature to the position you clicked.    x = mouseX;    y = mouseY;}',correct
'// THIS ONLY WORKS WITH A SINGLE PIKA BOY',correct
'y >= (height - 69)',correct
'// Making a proper collision model for the y-axis',correct
'blush',correct
'fill(bodyColor)',correct
'3 * PI / 2',correct
'speedModY < -0.2f',correct
'key == r | key == R',correct
'pikas[i].update()',correct
'void reset() {    // reset the creatures back to their initial positions    x = (x - (x - xInit));    y = (y - (y - yInit));    speedModX = speedInitX;    speedModY = speedInitY;}',correct
'fill(bodyColor);',correct
'// Rightellipse(x + 7, y - 20, 5, 5);',correct
'for (int i = 0; i < pikas.length; i++) {    pikas[i].invertColour();}',correct
'// Tail',correct
'void normalColour() {    // Put m back to what they used to be    bodyColor = color(229, 218, 42);    earTips = color(0);    eyes = color(0);    mouth = color(0);    blush = color(254, 130, 140);    backgr = color(235);}',correct
'void invertColour() {    // Just invert the colours    bodyColor = color(26, 37, 213);    earTips = color(255);    eyes = color(255);    mouth = color(255);    blush = color(1, 125, 115);    backgr = color(20);}',correct
'x >= (width - 30)',correct
'// Speed the pikas up',correct
'Processing',correct
'backgr',correct
'eyes = color(255);',correct
'speedModX = -speedModX',correct
'triangle(x - 38, y - 62, x - 30, y - 32, x - 18, y - 39)',correct
'// reset the creatures back to their initial positionsx = (x - (x - xInit));',correct
'0.2f',correct
'pikas[i].invertColour()',correct
'void mousePressed() {    if (mouseButton == LEFT) {        // Teleport a random pikachu to selected location        pikas[PApplet.parseInt(random(0, pikas.length))].move();    } else if (mouseButton == RIGHT) {        // invert the colours of the pikachus and the background        if (bodyColor == (color(229, 218, 42))) {            for (int i = 0; i < pikas.length; i++) {                pikas[i].invertColour();            }            backgr = color(30);        } else {            for (int i = 0; i < pikas.length; i++) {                pikas[i].normalColour();            }            backgr = color(235);        }    }}',correct
'{    for (int i = 0; i < pikas.length; i++) {        pikas[i].invertColour();    }    backgr = color(30);}',correct
'fill(earTips)',correct
'{    // Make sure they dont mess around and move in straight line    speedModX = speedModX + 0.4f;}',correct
'setup',correct
'pikas = new Pikachu[12];',correct
'// Just invert the coloursbodyColor = color(26, 37, 213);',correct
'creaX = PApplet.parseInt(random(46, width - 31));',correct
'normalColour',correct
'i = 0',correct
'"Pika "',correct
'PApplet.parseInt(random(0, pikas.length))',correct
'speedUp',correct
'speedModY - 0.4f',correct
'{    // ACCELERATE THE PIKAS IF YOU CLICK THE UP ARROW    for (int i = 0; i < pikas.length; i++) {        pikas[i].speedUp();    }}',correct
'{    x = xInit = creatureX;    y = yInit = creatureY;    speedModX = speedInitX = speedX;    speedModY = speedInitY = speedY;}',correct
'{    // SLOW THOSE PIKAS DOWN IF YOU CLICK THE DOWN ARROW    for (int i = 0; i < pikas.length; i++) {        pikas[i].speedDown();    }}',correct
'ellipse(x + 2, y - 28, 6, 8)',correct
'{    // invert the colours of the pikachus and the background    if (bodyColor == (color(229, 218, 42))) {        for (int i = 0; i < pikas.length; i++) {            pikas[i].invertColour();        }        backgr = color(30);    } else {        for (int i = 0; i < pikas.length; i++) {            pikas[i].normalColour();        }        backgr = color(235);    }}',correct
'color(1, 125, 115)',correct
'// ---------------------------',correct
'quad(x - 18, y + 53, x - 15, y + 61, x - 23, y + 77, x - 28, y + 69)',correct
'{    if (mouseButton == LEFT) {        // Teleport a random pikachu to selected location        pikas[PApplet.parseInt(random(0, pikas.length))].move();    } else if (mouseButton == RIGHT) {        // invert the colours of the pikachus and the background        if (bodyColor == (color(229, 218, 42))) {            for (int i = 0; i < pikas.length; i++) {                pikas[i].invertColour();            }            backgr = color(30);        } else {            for (int i = 0; i < pikas.length; i++) {                pikas[i].normalColour();            }            backgr = color(235);        }    }}',correct
'PApplet.parseFloat(nfc(speedModX, 1))',correct
'earTips = color(255)',correct
'0.4f',correct
'// Lower quadquad(x - 18, y + 53, x - 15, y + 61, x - 23, y + 77, x - 28, y + 69);',correct
'backgr = color(random(255), random(255), random(255));',DrawingStateChangeRule
'speedModX = speedModX + 0.4f',correct
'speedInitY',correct
'noStroke();',correct
'speedInitX',correct
'ellipse(x - 15, y - 27, 6, 8)',correct
'if (speedModX < -0.2f) {    // Same goes for over here    speedModX = speedModX - 0.4f;}',correct
'void speedDown() {    if (PApplet.parseFloat(nfc(speedModX, 1)) != 0) {        // If its not 0, slow m down.        if (PApplet.parseFloat(nfc(speedModX, 1)) > 0) {            // Round it off to one decimal place and then compare it            speedModX = speedModX - 0.4f;        } else {            speedModX = speedModX + 0.4f;        }    } else {        // If speedModX is roughly 0, make sure it is proper 0 now. You dont want those 5.651651561E-7 values.        speedModX = 0;    }    if (PApplet.parseFloat(nfc(speedModY, 1)) != 0) {        // Yeah this is the same as above, but just for the Y position using a different variable.        if (PApplet.parseFloat(nfc(speedModY, 1)) > 0) {            speedModY = speedModY - 0.4f;        } else {            speedModY = speedModY + 0.4f;        }    } else {        speedModY = 0;    }}',correct
'PI / 2',correct
'y = mouseY;',correct
'color(26, 37, 213)',correct
'mouth = color(0);',correct
'keyCode == UP',correct
'pikas[i].invertColour();',correct
'// Slow the pikas down',correct
'pikas[PApplet.parseInt(random(0, pikas.length))].move()',correct
'{    pikas[i].normalColour();}',correct
'void display() {    noStroke();    fill(bodyColor);    // Body    // upper circle    ellipse(x, y + 17, 60, 60);    // lower circle    ellipse(x, y - 18, 50, 50);    // Connecting arc    arc(x, y + 2, 90, 90, PI / 2, 3 * PI / 2, OPEN);    // Ears    // Left    triangle(x - 38, y - 62, x - 30, y - 32, x - 18, y - 39);    // Right    triangle(x + 1, y - 42, x + 12, y - 72, x + 13, y - 40);    // Tail    // Upper quad    quad(x - 19, y + 42, x - 10, y + 44, x - 23, y + 61, x - 23, y + 50);    // Lower quad    quad(x - 18, y + 53, x - 15, y + 61, x - 23, y + 77, x - 28, y + 69);    // Black tips ears    fill(earTips);    // Left    triangle(x - 35, y - 52, x - 38, y - 62, x - 31, y - 55);    // Right    triangle(x + 12, y - 72, x + 8, y - 62, x + 13, y - 60);    // Eyes    fill(eyes);    // Left    ellipse(x - 15, y - 27, 6, 8);    // Right    ellipse(x + 2, y - 28, 6, 8);    // Blush pink    fill(blush);    // Left    ellipse(x - 21, y - 19, 5, 5);    // Right    ellipse(x + 7, y - 20, 5, 5);    // Mouth    stroke(mouth);    line(x - 7, y - 22, x - 10, y - 18);    line(x - 7, y - 22, x - 3, y - 19);}',correct
'earTips',correct
'void keyPressed() {    if (key == CODED) {        if (keyCode == UP) {            // ACCELERATE THE PIKAS IF YOU CLICK THE UP ARROW            for (int i = 0; i < pikas.length; i++) {                pikas[i].speedUp();            }        } else if (keyCode == DOWN) {            // SLOW THOSE PIKAS DOWN IF YOU CLICK THE DOWN ARROW            for (int i = 0; i < pikas.length; i++) {                pikas[i].speedDown();            }        }    } else if (key == r | key == R) {        for (int i = 0; i < pikas.length; i++) {            pikas[i].reset();        }    }}',correct
'draw',correct
'{    // If its not 0, slow m down.    if (PApplet.parseFloat(nfc(speedModX, 1)) > 0) {        // Round it off to one decimal place and then compare it        speedModX = speedModX - 0.4f;    } else {        speedModX = speedModX + 0.4f;    }}',correct
'speedModX < -0.2f',correct
'// Leftellipse(x - 21, y - 19, 5, 5);',correct
'triangle(x - 35, y - 52, x - 38, y - 62, x - 31, y - 55)',correct
'{    // If speedModX is roughly 0, make sure it is proper 0 now. You dont want those 5.651651561E-7 values.    speedModX = 0;}',correct
'bodyColor == (color(229, 218, 42))',correct
'// println("x = ", round(x), "    |    y = ", round(y), "    |    speedModX = ", speedModX, "    |    speedModY = ", speedModY);',correct
'float x, y, xInit, yInit, speedModX, speedModY, speedInitX, speedInitY;',correct
'// DEBUG STATS',correct
'y + 42',correct
'pikas[i].speedUp()',correct
'PApplet.parseInt(random(63, height - 70))',correct
'y + 44',correct
'mousePressed',correct
'void draw() {    background(backgr);    for (int i = 0; i < pikas.length; i++) {        // DRAW THEM        pikas[i].display();        // UPDATE THEM        pikas[i].update();    }}',correct
'pikas[i].reset()',correct
'{    speedModY = speedModY + 0.4f;}',correct
'3 * PI',correct
'void',correct
'println("Pika ", i, ": ", creaX, ", ", creaY)',correct
'earTips = eyes = mouth = color(0);',correct
'y + 50',correct
'y + 53',correct
'PApplet.parseFloat(nfc(speedModY, 1)) != 0',correct
'{    pikas[i].reset();}',correct
'pikas[i].display()',correct
'// Print the location ofthe pikachusprintln("Pika ", i, ": ", creaX, ", ", creaY);',correct
'// Righttriangle(x + 1, y - 42, x + 12, y - 72, x + 13, y - 40);',correct
'{    // Same goes for over here    speedModX = speedModX - 0.4f;}',correct
'for (int i = 0; i < pikas.length; i++) {    pikas[i].reset();}',correct
'// --------------------------- //<>//',correct
'mouth = color(255)',correct
'creaX',correct
'if (speedModY < -0.2f) {    speedModY = speedModY - 0.4f;}',correct
'creaY',correct
'speedModX = speedInitX = speedX',correct
'{    // Yeah this is the same as above, but just for the Y position using a different variable.    if (PApplet.parseFloat(nfc(speedModY, 1)) > 0) {        speedModY = speedModY - 0.4f;    } else {        speedModY = speedModY + 0.4f;    }}',correct
'eyes = color(0)',correct
'y + 17',correct
'line(x - 7, y - 22, x - 10, y - 18)',correct
'quad(x - 19, y + 42, x - 10, y + 44, x - 23, y + 61, x - 23, y + 50)',correct
'ellipse(x + 7, y - 20, 5, 5)',correct
'speedModX > -0.2f',correct
'height - 70',correct
'", "',correct
'// Black tips earsfill(earTips);',correct
'speedModX = speedModX - 0.4f',correct
'{    for (int i = 0; i < pikas.length; i++) {        pikas[i].reset();    }}',correct
'// Lefttriangle(x - 35, y - 52, x - 38, y - 62, x - 31, y - 55);',correct
'if (y >= (height - 69) | y <= 62) {    // Making a proper collision model for the y-axis    // Make Pikachu turn around    speedModY = -speedModY;    backgr = color(random(255), random(255), random(255));}',correct
'{    // Round it off to one decimal place and then compare it    speedModX = speedModX - 0.4f;}',correct
'y = (y - (y - yInit))',correct
'y - 22',correct
'blush = color(254, 130, 140);',correct
'// Rightellipse(x + 2, y - 28, 6, 8);',correct
'y - 20',correct
'earTips = color(0)',correct
'y - 27',correct
'-speedModY',correct
'-speedModX',correct
'y - 19',correct
'y - 18',correct
'blush = color(1, 125, 115)',correct
'{    if (PApplet.parseFloat(nfc(speedModX, 1)) != 0) {        // If its not 0, slow m down.        if (PApplet.parseFloat(nfc(speedModX, 1)) > 0) {            // Round it off to one decimal place and then compare it            speedModX = speedModX - 0.4f;        } else {            speedModX = speedModX + 0.4f;        }    } else {        // If speedModX is roughly 0, make sure it is proper 0 now. You dont want those 5.651651561E-7 values.        speedModX = 0;    }    if (PApplet.parseFloat(nfc(speedModY, 1)) != 0) {        // Yeah this is the same as above, but just for the Y position using a different variable.        if (PApplet.parseFloat(nfc(speedModY, 1)) > 0) {            speedModY = speedModY - 0.4f;        } else {            speedModY = speedModY + 0.4f;        }    } else {        speedModY = 0;    }}',correct
'for (int i = 0; i < pikas.length; i++) {    // DRAW THEM    pikas[i].display();    // UPDATE THEM    pikas[i].update();}',correct
'earTips = eyes = mouth = color(0)',correct
'{    speedModX = speedModX + 0.4f;}',correct
'y - 32',correct
'{    pikas[i].speedDown();}',correct
'y - 28',correct
'xInit = creatureX',correct
'// Connecting arcarc(x, y + 2, 90, 90, PI / 2, 3 * PI / 2, OPEN);',correct
'speedModY = speedModY - 0.4f;',correct
'// |       WOUTER KONING      |',correct
'creaY = PApplet.parseInt(random(63, height - 70))',correct
'if (x >= (width - 30) | x <= 45) {    // Making a proper collision model x-axis    // Make Pikachu turn around    speedModX = -speedModX;    backgr = color(random(255), random(255), random(255));} else if (y >= (height - 69) | y <= 62) {    // Making a proper collision model for the y-axis    // Make Pikachu turn around    speedModY = -speedModY;    backgr = color(random(255), random(255), random(255));}',correct
'backgr = color(30)',correct
'// UPDATE THEMpikas[i].update();',correct
'x + 12',correct
'x + 13',correct
'for (int i = 0; i < pikas.length; i++) {    // generate a random number for the position    int creaX, creaY;    creaX = PApplet.parseInt(random(46, width - 31));    creaY = PApplet.parseInt(random(63, height - 70));    // Print the location ofthe pikachus    println("Pika ", i, ": ", creaX, ", ", creaY);    // Give m their data    pikas[i] = new Pikachu(creaX, creaY, 1, 1);}',correct
'y + 61',correct
'color(random(255), random(255), random(255))',correct
'": "',correct
'speedInitX = speedX',correct
'y + 69',correct
'x >= (width - 30) | x <= 45',correct
'ellipse(x, y - 18, 50, 50)',correct
'eyes = color(255)',correct
'{    if (keyCode == UP) {        // ACCELERATE THE PIKAS IF YOU CLICK THE UP ARROW        for (int i = 0; i < pikas.length; i++) {            pikas[i].speedUp();        }    } else if (keyCode == DOWN) {        // SLOW THOSE PIKAS DOWN IF YOU CLICK THE DOWN ARROW        for (int i = 0; i < pikas.length; i++) {            pikas[i].speedDown();        }    }}',correct
'pikas[i].normalColour();',correct
'{    if (speedModX > -0.2f) {        // Make sure they dont mess around and move in straight line        speedModX = speedModX + 0.4f;    } else if (speedModX < -0.2f) {        // Same goes for over here        speedModX = speedModX - 0.4f;    }    if (speedModY > -0.2f) {        // Yeah this is the same code as above, but with different variables. Sorry.        speedModY = speedModY + 0.4f;    } else if (speedModY < -0.2f) {        speedModY = speedModY - 0.4f;    }}',correct
'mouseButton == RIGHT',correct
'// Ears',correct
'line(x - 7, y - 22, x - 3, y - 19)',correct
'{    pikas[i].invertColour();}',correct
'y + 77',correct
'random(0, pikas.length)',correct
'speedModX = 0',correct
'if (key == r | key == R) {    for (int i = 0; i < pikas.length; i++) {        pikas[i].reset();    }}',correct
'random(255)',correct
'noStroke()',correct
'color(229, 218, 42)',correct
'PApplet.parseFloat(nfc(speedModX, 1)) != 0',correct
'color(235)',correct
'y - 62',correct
'y - 60',correct
'{    // DRAW THEM    pikas[i].display();    // UPDATE THEM    pikas[i].update();}',correct
'y = (y - (y - yInit));',correct
'{    background(backgr);    for (int i = 0; i < pikas.length; i++) {        // DRAW THEM        pikas[i].display();        // UPDATE THEM        pikas[i].update();    }}',correct
'pikas[i] = new Pikachu(creaX, creaY, 1, 1)',correct
'speedModY = speedModY + 0.4f;',correct
'for (int i = 0; i < pikas.length; i++) {    pikas[i].normalColour();}',correct
'class Pikachu {    float x, y, xInit, yInit, speedModX, speedModY, speedInitX, speedInitY;    Pikachu(float creatureX, float creatureY, float speedX, float speedY) {        x = xInit = creatureX;        y = yInit = creatureY;        speedModX = speedInitX = speedX;        speedModY = speedInitY = speedY;    }    void display() {        noStroke();        fill(bodyColor);        // Body        // upper circle        ellipse(x, y + 17, 60, 60);        // lower circle        ellipse(x, y - 18, 50, 50);        // Connecting arc        arc(x, y + 2, 90, 90, PI / 2, 3 * PI / 2, OPEN);        // Ears        // Left        triangle(x - 38, y - 62, x - 30, y - 32, x - 18, y - 39);        // Right        triangle(x + 1, y - 42, x + 12, y - 72, x + 13, y - 40);        // Tail        // Upper quad        quad(x - 19, y + 42, x - 10, y + 44, x - 23, y + 61, x - 23, y + 50);        // Lower quad        quad(x - 18, y + 53, x - 15, y + 61, x - 23, y + 77, x - 28, y + 69);        // Black tips ears        fill(earTips);        // Left        triangle(x - 35, y - 52, x - 38, y - 62, x - 31, y - 55);        // Right        triangle(x + 12, y - 72, x + 8, y - 62, x + 13, y - 60);        // Eyes        fill(eyes);        // Left        ellipse(x - 15, y - 27, 6, 8);        // Right        ellipse(x + 2, y - 28, 6, 8);        // Blush pink        fill(blush);        // Left        ellipse(x - 21, y - 19, 5, 5);        // Right        ellipse(x + 7, y - 20, 5, 5);        // Mouth        stroke(mouth);        line(x - 7, y - 22, x - 10, y - 18);        line(x - 7, y - 22, x - 3, y - 19);    }    void update() {        // DEBUG STATS        // THIS ONLY WORKS WITH A SINGLE PIKA BOY        // println("x = ", round(x), "    |    y = ", round(y), "    |    speedModX = ", speedModX, "    |    speedModY = ", speedModY);        // Update the x and y position of every pikachu        x = x + speedModX;        y = y + speedModY;        if (x >= (width - 30) | x <= 45) {            // Making a proper collision model x-axis            // Make Pikachu turn around            speedModX = -speedModX;            backgr = color(random(255), random(255), random(255));        } else if (y >= (height - 69) | y <= 62) {            // Making a proper collision model for the y-axis            // Make Pikachu turn around            speedModY = -speedModY;            backgr = color(random(255), random(255), random(255));        }    }    void move() {        // Move the creature to the position you clicked.        x = mouseX;        y = mouseY;    }    void invertColour() {        // Just invert the colours        bodyColor = color(26, 37, 213);        earTips = color(255);        eyes = color(255);        mouth = color(255);        blush = color(1, 125, 115);        backgr = color(20);    }    void normalColour() {        // Put m back to what they used to be        bodyColor = color(229, 218, 42);        earTips = color(0);        eyes = color(0);        mouth = color(0);        blush = color(254, 130, 140);        backgr = color(235);    }    void speedUp() {        if (speedModX > -0.2f) {            // Make sure they dont mess around and move in straight line            speedModX = speedModX + 0.4f;        } else if (speedModX < -0.2f) {            // Same goes for over here            speedModX = speedModX - 0.4f;        }        if (speedModY > -0.2f) {            // Yeah this is the same code as above, but with different variables. Sorry.            speedModY = speedModY + 0.4f;        } else if (speedModY < -0.2f) {            speedModY = speedModY - 0.4f;        }    }    void speedDown() {        if (PApplet.parseFloat(nfc(speedModX, 1)) != 0) {            // If its not 0, slow m down.            if (PApplet.parseFloat(nfc(speedModX, 1)) > 0) {                // Round it off to one decimal place and then compare it                speedModX = speedModX - 0.4f;            } else {                speedModX = speedModX + 0.4f;            }        } else {            // If speedModX is roughly 0, make sure it is proper 0 now. You dont want those 5.651651561E-7 values.            speedModX = 0;        }        if (PApplet.parseFloat(nfc(speedModY, 1)) != 0) {            // Yeah this is the same as above, but just for the Y position using a different variable.            if (PApplet.parseFloat(nfc(speedModY, 1)) > 0) {                speedModY = speedModY - 0.4f;            } else {                speedModY = speedModY + 0.4f;            }        } else {            speedModY = 0;        }    }    void reset() {        // reset the creatures back to their initial positions        x = (x - (x - xInit));        y = (y - (y - yInit));        speedModX = speedInitX;        speedModY = speedInitY;    }}',correct
'i < pikas.length',correct
'void speedUp() {    if (speedModX > -0.2f) {        // Make sure they dont mess around and move in straight line        speedModX = speedModX + 0.4f;    } else if (speedModX < -0.2f) {        // Same goes for over here        speedModX = speedModX - 0.4f;    }    if (speedModY > -0.2f) {        // Yeah this is the same code as above, but with different variables. Sorry.        speedModY = speedModY + 0.4f;    } else if (speedModY < -0.2f) {        speedModY = speedModY - 0.4f;    }}',correct
'earTips = color(255);',correct
'{    // Making a proper collision model x-axis    // Make Pikachu turn around    speedModX = -speedModX;    backgr = color(random(255), random(255), random(255));}',correct
'PApplet.parseFloat(nfc(speedModX, 1)) > 0',correct
'y - 72',correct
'key == CODED',correct
'speedModY = speedModY - 0.4f',correct
'{    pikas = new Pikachu[12];    // pikachu yellow    bodyColor = color(229, 218, 42);    earTips = eyes = mouth = color(0);    backgr = color(235);    blush = color(254, 130, 140);    for (int i = 0; i < pikas.length; i++) {        // generate a random number for the position        int creaX, creaY;        creaX = PApplet.parseInt(random(46, width - 31));        creaY = PApplet.parseInt(random(63, height - 70));        // Print the location ofthe pikachus        println("Pika ", i, ": ", creaX, ", ", creaY);        // Give m their data        pikas[i] = new Pikachu(creaX, creaY, 1, 1);    }}',correct
'key == R',correct
'y - 40',correct
'{    // reset the creatures back to their initial positions    x = (x - (x - xInit));    y = (y - (y - yInit));    speedModX = speedInitX;    speedModY = speedInitY;}',correct
'speedModY = 0',correct
'{    // Making a proper collision model for the y-axis    // Make Pikachu turn around    speedModY = -speedModY;    backgr = color(random(255), random(255), random(255));}',correct
'line(x - 7, y - 22, x - 10, y - 18);',correct
'update',correct
'y - 42',correct
'// pikachu yellowbodyColor = color(229, 218, 42);',correct
'random(63, height - 70)',correct
'if (speedModY > -0.2f) {    // Yeah this is the same code as above, but with different variables. Sorry.    speedModY = speedModY + 0.4f;} else if (speedModY < -0.2f) {    speedModY = speedModY - 0.4f;}',correct
'y - 39',correct
'speedModY = speedInitY = speedY',correct
'speedModX = speedInitX',correct
'bodyColor = color(229, 218, 42)',correct
'void update() {    // DEBUG STATS    // THIS ONLY WORKS WITH A SINGLE PIKA BOY    // println("x = ", round(x), "    |    y = ", round(y), "    |    speedModX = ", speedModX, "    |    speedModY = ", speedModY);    // Update the x and y position of every pikachu    x = x + speedModX;    y = y + speedModY;    if (x >= (width - 30) | x <= 45) {        // Making a proper collision model x-axis        // Make Pikachu turn around        speedModX = -speedModX;        backgr = color(random(255), random(255), random(255));    } else if (y >= (height - 69) | y <= 62) {        // Making a proper collision model for the y-axis        // Make Pikachu turn around        speedModY = -speedModY;        backgr = color(random(255), random(255), random(255));    }}',correct
'{    // Teleport a random pikachu to selected location    pikas[PApplet.parseInt(random(0, pikas.length))].move();}',correct
'y - 52',correct
'y - 55',correct
'// DRAW THEMpikas[i].display();',correct
'Pikachu[] pikas;',correct
'int i = 0',correct
'mouth',correct
'if (keyCode == DOWN) {    // SLOW THOSE PIKAS DOWN IF YOU CLICK THE DOWN ARROW    for (int i = 0; i < pikas.length; i++) {        pikas[i].speedDown();    }}',correct
'stroke(mouth)',correct
'// Leftellipse(x - 15, y - 27, 6, 8);',correct
'x = x + speedModX',correct
'{    // Yeah this is the same code as above, but with different variables. Sorry.    speedModY = speedModY + 0.4f;}',correct
'x - 15',correct
'nfc(speedModY, 1)',correct
'Pikachu(float creatureX, float creatureY, float speedX, float speedY) {    x = xInit = creatureX;    y = yInit = creatureY;    speedModX = speedInitX = speedX;    speedModY = speedInitY = speedY;}',correct
'color(255)',correct
'x - 10',correct
'if (PApplet.parseFloat(nfc(speedModY, 1)) != 0) {    // Yeah this is the same as above, but just for the Y position using a different variable.    if (PApplet.parseFloat(nfc(speedModY, 1)) > 0) {        speedModY = speedModY - 0.4f;    } else {        speedModY = speedModY + 0.4f;    }} else {    speedModY = 0;}',correct
'// Put m back to what they used to bebodyColor = color(229, 218, 42);',correct
'// Tail// Upper quadquad(x - 19, y + 42, x - 10, y + 44, x - 23, y + 61, x - 23, y + 50);',correct
'// Making a proper collision model x-axis// Make Pikachu turn aroundspeedModX = -speedModX;',correct
'mouth = color(0)',correct
'xInit',correct
'{    pikas[i].speedUp();}',correct
'speedModX = speedInitX = speedX;',correct
'pikas',correct
'// --------------------------- //<>//// |       WOUTER KONING      |// |       S2169479           |// ---------------------------int creatureX, creatureY;',correct
'x - 23',correct
'backgr = color(random(255), random(255), random(255))',correct
'speedModY + 0.4f',correct
'x - 21',correct
'// Righttriangle(x + 12, y - 72, x + 8, y - 62, x + 13, y - 60);',correct
'eyes = mouth = color(0)',correct
'void setup() {    pikas = new Pikachu[12];    // pikachu yellow    bodyColor = color(229, 218, 42);    earTips = eyes = mouth = color(0);    backgr = color(235);    blush = color(254, 130, 140);    for (int i = 0; i < pikas.length; i++) {        // generate a random number for the position        int creaX, creaY;        creaX = PApplet.parseInt(random(46, width - 31));        creaY = PApplet.parseInt(random(63, height - 70));        // Print the location ofthe pikachus        println("Pika ", i, ": ", creaX, ", ", creaY);        // Give m their data        pikas[i] = new Pikachu(creaX, creaY, 1, 1);    }}',correct
'pikas[i].speedUp();',correct
'reset',correct
'int bodyColor, earTips, eyes, mouth, blush, backgr;',correct
'x - 19',correct
'x - 18',correct
'speedModX = speedInitX;',correct
'x - 35',correct
'eyes = color(0);',correct
'x - 31',correct
'float speedX',correct
'x - 30',correct
'float speedY',correct
'blush = color(254, 130, 140)',correct
'earTips = color(0);',correct
'random(46, width - 31)',correct
'int creaX, creaY',correct
'color(0)',correct
'blush = color(1, 125, 115);',correct
'x - 28',correct
'fill(eyes)',correct
'key == r',correct
'if (mouseButton == RIGHT) {    // invert the colours of the pikachus and the background    if (bodyColor == (color(229, 218, 42))) {        for (int i = 0; i < pikas.length; i++) {            pikas[i].invertColour();        }        backgr = color(30);    } else {        for (int i = 0; i < pikas.length; i++) {            pikas[i].normalColour();        }        backgr = color(235);    }}',correct
'ellipse(x - 21, y - 19, 5, 5)',correct
'display',correct
'pikas.length',correct
'x + 7',correct
'x + 8',correct
'y = yInit = creatureY;',correct
'yInit = creatureY',correct
'invertColour',correct
'x - 38',correct
'x + 1',correct
'x + 2',correct
'y <= 62',correct
'// generate a random number for the positionint creaX, creaY;',correct
'// Body',correct
'{    noStroke();    fill(bodyColor);    // Body    // upper circle    ellipse(x, y + 17, 60, 60);    // lower circle    ellipse(x, y - 18, 50, 50);    // Connecting arc    arc(x, y + 2, 90, 90, PI / 2, 3 * PI / 2, OPEN);    // Ears    // Left    triangle(x - 38, y - 62, x - 30, y - 32, x - 18, y - 39);    // Right    triangle(x + 1, y - 42, x + 12, y - 72, x + 13, y - 40);    // Tail    // Upper quad    quad(x - 19, y + 42, x - 10, y + 44, x - 23, y + 61, x - 23, y + 50);    // Lower quad    quad(x - 18, y + 53, x - 15, y + 61, x - 23, y + 77, x - 28, y + 69);    // Black tips ears    fill(earTips);    // Left    triangle(x - 35, y - 52, x - 38, y - 62, x - 31, y - 55);    // Right    triangle(x + 12, y - 72, x + 8, y - 62, x + 13, y - 60);    // Eyes    fill(eyes);    // Left    ellipse(x - 15, y - 27, 6, 8);    // Right    ellipse(x + 2, y - 28, 6, 8);    // Blush pink    fill(blush);    // Left    ellipse(x - 21, y - 19, 5, 5);    // Right    ellipse(x + 7, y - 20, 5, 5);    // Mouth    stroke(mouth);    line(x - 7, y - 22, x - 10, y - 18);    line(x - 7, y - 22, x - 3, y - 19);}',correct
'i++',correct
'nfc(speedModX, 1)',correct
'speedModY = speedInitY',correct
'keyCode == DOWN',correct
'speedDown',correct
'color(20)',correct
'speedInitY = speedY',correct
'x = (x - (x - xInit))',correct
'backgr = color(20);',correct
'// Making a proper collision model for the y-axis// Make Pikachu turn aroundspeedModY = -speedModY;',correct
'keyPressed',correct
'float creatureX',correct
'// DEBUG STATS// THIS ONLY WORKS WITH A SINGLE PIKA BOY// println("x = ", round(x), "    |    y = ", round(y), "    |    speedModX = ", speedModX, "    |    speedModY = ", speedModY);// Update the x and y position of every pikachux = x + speedModX;',correct
'if (PApplet.parseFloat(nfc(speedModX, 1)) != 0) {    // If its not 0, slow m down.    if (PApplet.parseFloat(nfc(speedModX, 1)) > 0) {        // Round it off to one decimal place and then compare it        speedModX = speedModX - 0.4f;    } else {        speedModX = speedModX + 0.4f;    }} else {    // If speedModX is roughly 0, make sure it is proper 0 now. You dont want those 5.651651561E-7 values.    speedModX = 0;}',correct
'float creatureY',correct
'backgr = color(235);',correct
'pikas[PApplet.parseInt(random(0, pikas.length))]',correct
'x = xInit = creatureX',correct
'pikas[i].normalColour()',correct
'bodyColor',correct
'new Pikachu[12]',correct
'PApplet.parseInt(random(46, width - 31))',correct
'creaY = PApplet.parseInt(random(63, height - 70));',correct
'PApplet.parseFloat(nfc(speedModY, 1)) > 0',correct
'pikas[i].speedDown()',correct
'// Give m their datapikas[i] = new Pikachu(creaX, creaY, 1, 1);',correct
'{    speedModY = 0;}',correct
'{    for (int i = 0; i < pikas.length; i++) {        pikas[i].normalColour();    }    backgr = color(235);}',correct
'{    // Put m back to what they used to be    bodyColor = color(229, 218, 42);    earTips = color(0);    eyes = color(0);    mouth = color(0);    blush = color(254, 130, 140);    backgr = color(235);}',correct
'// lower circleellipse(x, y - 18, 50, 50);',correct
'color(30)',correct
'// Blush pinkfill(blush);',correct
'yInit',correct
'move',correct
'triangle(x + 12, y - 72, x + 8, y - 62, x + 13, y - 60)',correct
'color(254, 130, 140)',correct
'line(x - 7, y - 22, x - 3, y - 19);',correct
'speedModX + 0.4f',correct
'speedModY = 0;',correct
'{    // DEBUG STATS    // THIS ONLY WORKS WITH A SINGLE PIKA BOY    // println("x = ", round(x), "    |    y = ", round(y), "    |    speedModX = ", speedModX, "    |    speedModY = ", speedModY);    // Update the x and y position of every pikachu    x = x + speedModX;    y = y + speedModY;    if (x >= (width - 30) | x <= 45) {        // Making a proper collision model x-axis        // Make Pikachu turn around        speedModX = -speedModX;        backgr = color(random(255), random(255), random(255));    } else if (y >= (height - 69) | y <= 62) {        // Making a proper collision model for the y-axis        // Make Pikachu turn around        speedModY = -speedModY;        backgr = color(random(255), random(255), random(255));    }}',correct
'y + 2',correct
'speedModY = speedModY + 0.4f',correct
'x - 3',correct
'speedModX = speedModX + 0.4f;',correct
'// Mouthstroke(mouth);',correct
'x - 7',correct
'backgr = color(20)',correct
'pikas[i]',correct
'// if the mouse is pressed on the eye Plankton will be upset/in painif ((mouseX < body1.x + 30 && mouseX > body1.x - 30) && (mouseY < body1.y + 5 && mouseY > body1.y - 65)) {    body1.upset();}',correct
'moveSpeed = diameter * 0.025f',correct
'eyeClosed = false;',correct
'eye1',correct
'bubbleX',correct
'bubbleY',correct
'random(height - 250, height + 90)',correct
'mouth1',correct
'index < bubbles.length',correct
'stroke(0);',correct
'stroke(0)',correct
'diameter = random(10, 60);',correct
'random(10, 60)',correct
'{    // this makes the bubbles float upwards    moveSpeed = diameter * 0.025f;    bubbleY = bubbleY - moveSpeed;}',correct
'fill(0, 0, 0)',correct
'mouthOpen = false;',correct
'// Planktons eyeellipse(x, y - 30, 60, 70);',correct
'bubble.liftUpdate();',correct
'int iconY',correct
'int iconX',correct
'x = iconX;',correct
'bubbles',correct
'{    boolean bubbleClick = false;    // this will check if the mouse is on a bubble    if (dist(initX, initY, bubbleX, bubbleY) < diameter / 2) {        bubbleClick = true;    }    return bubbleClick;}',correct
'height + 150',correct
'eye1 = new Eye(width / 2, height / 2);',correct
'ellipse(x + 20, y + 20, 5, 5)',correct
'bezier(x + 45, y, x + 85, y + 70, x + 85, y + 70, x + 45, y + 15)',correct
'Mouth(int iconX, int iconY) {    x = iconX;    y = iconY;}',correct
'bubbleY = random(height - 250, height + 90)',correct
'arms1 = new Arms(width / 2, height / 2);',correct
'{    noFill();    strokeWeight(3);    // mouth    bezier(x - 30, y, x - 25, y + 35, x + 10, y + 35, x + 20, y + 20);    fill(0, 0, 0);    strokeWeight(1);    // mouth ends    ellipse(x - 30, y, 5, 5);    ellipse(x + 20, y + 20, 5, 5);}',SimplifyBooleanExpressions
'new Bubble[5]',correct
'height + 90',correct
'bubble.move()',correct
'{    strokeWeight(1);    // yellow-ish, color of his iris    fill(irisColor);    // Planktons eye    ellipse(x, y - 30, 60, 70);    // red, color of his pupil    fill(pupilColor);    // Planktons pupil    ellipse(x, y - 30, 30, 35);    // white    fill(255, 255, 255);    noStroke();    // shimmer in the eye    ellipse(x - 5, y - 35, 8, 8);    noFill();    stroke(0);    strokeWeight(10);    // eyebrow    bezier(x - 20, y - 65, x - 10, y - 60, x + 10, y - 60, x + 20, y - 75);}',SimplifyBooleanExpressions
'[5]',correct
'random(height)',correct
'// red, color of his pupilfill(pupilColor);',correct
'body1.upset();',correct
'fill(pupilColor)',correct
'// redint pupilColor = color(255, 69, 0);',correct
'(mouseX < body1.x + 30 && mouseX > body1.x - 30) && (mouseY < body1.y + 5 && mouseY > body1.y - 65)',correct
'mouthOpen == true',correct
'x',correct
'y',correct
'{    body1 = new Body(width / 2, height / 2);    for (int index = 0; index < bubbles.length; index++) {        bubbles[index] = new Bubble(random(width), random(height), random(10, 60));    }}',correct
'bezier(x - 30, y, x - 25, y + 35, x + 10, y + 35, x + 20, y + 20)',correct
'mouth1.closeMouth()',correct
'fill(irisColor)',correct
'bezier(x - 20, y - 65, x - 10, y - 60, x + 10, y - 60, x + 20, y - 75)',correct
'boolean checkLocation() {    boolean bubbleLift = false;    // this will check if a bubble is off screen    if (bubbleY < 0 - diameter / 2) {        bubbleLift = true;    }    return bubbleLift;}',correct
'{    mouthOpen = true;}',correct
'bubble.clickUpdate()',correct
'boolean bubbleClick = false',correct
'mouthOpen = true',correct
'// green-ishint bodyColor = color(58, 201, 183);',correct
'diameter = iconDiameter',correct
'ellipse(x, y - 30, 30, 35)',correct
'fill(bodyColor)',correct
'armsDown = false',correct
'class Arms {    int x;    int y;    boolean armsDown = false;    // green-ish    int bodyColor = color(58, 201, 183);    Arms(int iconX, int iconY) {        x = iconX;        y = iconY;    }    void display() {        fill(bodyColor);        strokeWeight(1);        if (armsDown == true) {            // right arm down            bezier(x + 45, y, x + 85, y + 70, x + 85, y + 70, x + 45, y + 15);            // left arm down            bezier(x - 45, y, x - 85, y + 70, x - 85, y + 70, x - 45, y + 15);        } else {            // right arm up            bezier(x + 45, y, x + 85, y - 70, x + 85, y - 70, x + 45, y + 15);            // left arm up            bezier(x - 45, y, x - 85, y - 70, x - 85, y - 70, x - 45, y + 15);        }    }    void downArms() {        armsDown = true;    }    void upArms() {        armsDown = false;    }}',correct
'bubbles.length',correct
'{    stroke(255);    fill(0, 0, 0, 0);    // bubble    ellipse(bubbleX, bubbleY, diameter, diameter);    fill(255, 255, 255);    // shimmer of the bubble    ellipse(bubbleX - diameter / 5, bubbleY - diameter / 5, diameter / 4, diameter / 4);}',correct
'bubble.clickLocation(mouseX, mouseY)',correct
'mouth1.closeMouth();',correct
'// shimmer of the bubbleellipse(bubbleX - diameter / 5, bubbleY - diameter / 5, diameter / 4, diameter / 4);',correct
'fill(bodyColor);',correct
'arms1.downArms();',correct
'body1.normal()',correct
'float iconY',correct
'bubble.liftUpdate()',correct
'void openEye() {    eyeClosed = false;}',correct
'float iconX',correct
'bubbleY = bubbleY - moveSpeed;',correct
'new Arms(width / 2, height / 2)',correct
'bubbleClick = true',correct
'bezier(x - 15, y - 8, x - 7, y - 3, x + 7, y - 3, x + 15, y - 8)',correct
'Processing',correct
'bubbleY = iconY',correct
'{    bubbleClick = true;}',correct
'Mouth',correct
'return bubbleClick;',correct
'void mouseReleased() {    body1.normal();}',correct
'ellipse(x - 30, y, 5, 5)',correct
'bubbleLift = false',correct
'x - 85',correct
'false',correct
'dist(initX, initY, bubbleX, bubbleY)',correct
'// SJOERD VAN VEEN - CreaTe     s2136090// PlanktonBody body1;',correct
'ellipse(bubbleX - diameter / 5, bubbleY - diameter / 5, diameter / 4, diameter / 4)',correct
'arms1',correct
'mouth1 = new Mouth(width / 2, height / 2)',correct
'armsDown == true',correct
'bubbleClick = false',correct
'{    bubble.move();    bubble.display();    // if the bubble is off screen it will relocate    if (bubble.checkLocation()) {        bubble.liftUpdate();    }}',correct
'// right arm downbezier(x + 45, y, x + 85, y + 70, x + 85, y + 70, x + 45, y + 15);',correct
'fill(255, 255, 255);',correct
'boolean bubbleLift = false',correct
'{    bubbleX = random(width);    bubbleY = random(height - 250, height + 90);    diameter = random(10, 60);}',correct
'bubbleX - diameter / 5',correct
'eyeClosed = true;',correct
'mouth1.openMouth();',correct
'color(45, 146, 133)',correct
'mouthOpen = false',correct
'random(height, height + 150)',correct
'void setup() {    body1 = new Body(width / 2, height / 2);    for (int index = 0; index < bubbles.length; index++) {        bubbles[index] = new Bubble(random(width), random(height), random(10, 60));    }}',correct
'diameter = random(10, 60)',correct
'noStroke();',correct
'fill(200, 80, 112);',correct
'if (bubble.clickLocation(mouseX, mouseY)) {    bubble.clickUpdate();}',correct
'// left arm downbezier(x - 45, y, x - 85, y + 70, x - 85, y + 70, x - 45, y + 15);',correct
'strokeWeight(1)',correct
'// mouth endsellipse(x - 30, y, 5, 5);',correct
'{    // right arm down    bezier(x + 45, y, x + 85, y + 70, x + 85, y + 70, x + 45, y + 15);    // left arm down    bezier(x - 45, y, x - 85, y + 70, x - 85, y + 70, x - 45, y + 15);}',SimplifyBooleanExpressions
'ellipse(x, y, 90, 200)',correct
'mouthOpen = true;',correct
'new Bubble(random(width), random(height), random(10, 60))',correct
'bubble',correct
'{    mouthOpen = false;}',correct
'void openMouth() {    mouthOpen = true;}',correct
'mouth1 = new Mouth(width / 2, height / 2);',correct
'{    bubbleLift = true;}',correct
'bubbleX = random(width)',correct
'draw',correct
'{    // right arm up    bezier(x + 45, y, x + 85, y - 70, x + 85, y - 70, x + 45, y + 15);    // left arm up    bezier(x - 45, y, x - 85, y - 70, x - 85, y - 70, x - 45, y + 15);}',SimplifyBooleanExpressions
'void display() {    stroke(255);    fill(0, 0, 0, 0);    // bubble    ellipse(bubbleX, bubbleY, diameter, diameter);    fill(255, 255, 255);    // shimmer of the bubble    ellipse(bubbleX - diameter / 5, bubbleY - diameter / 5, diameter / 4, diameter / 4);}',correct
'diameter = iconDiameter;',correct
'diameter / 2',correct
'// this will check if the mouse is on a bubbleif (dist(initX, initY, bubbleX, bubbleY) < diameter / 2) {    bubbleClick = true;}',correct
'diameter / 5',correct
'diameter / 4',correct
'// mouthellipse(x, y + 25, 35, 25);',correct
'bubble.display();',correct
'bezier(x - 45, y, x - 85, y + 70, x - 85, y + 70, x - 45, y + 15)',correct
'void display() {    stroke(0);    strokeWeight(1);    fill(bodyColor);    // Planktons body    ellipse(x, y, 90, 200);    // left leg    bezier(x - 20, y + 88, x - 30, y + 135, x - 25, y + 135, x - 5, y + 95);    // right leg    bezier(x + 20, y + 88, x + 30, y + 135, x + 25, y + 135, x + 5, y + 95);    eye1.display();    mouth1.display();    arms1.display();}',correct
'{    eye1 = new Eye(width / 2, height / 2);    mouth1 = new Mouth(width / 2, height / 2);    arms1 = new Arms(width / 2, height / 2);    x = iconX;    y = iconY;}',correct
'bubble.checkLocation()',correct
'class Mouth {    int x;    int y;    boolean mouthOpen = false;    Mouth(int iconX, int iconY) {        x = iconX;        y = iconY;    }    void display() {        if (mouthOpen == true) {            fill(200, 80, 112);            strokeWeight(2);            // mouth            ellipse(x, y + 25, 35, 25);        } else {            noFill();            strokeWeight(3);            // mouth            bezier(x - 30, y, x - 25, y + 35, x + 10, y + 35, x + 20, y + 20);            fill(0, 0, 0);            strokeWeight(1);            // mouth ends            ellipse(x - 30, y, 5, 5);            ellipse(x + 20, y + 20, 5, 5);        }    }    void openMouth() {        mouthOpen = true;    }    void closeMouth() {        mouthOpen = false;    }}',correct
'return bubbleLift;',correct
'void display() {    fill(bodyColor);    strokeWeight(1);    if (armsDown == true) {        // right arm down        bezier(x + 45, y, x + 85, y + 70, x + 85, y + 70, x + 45, y + 15);        // left arm down        bezier(x - 45, y, x - 85, y + 70, x - 85, y + 70, x - 45, y + 15);    } else {        // right arm up        bezier(x + 45, y, x + 85, y - 70, x + 85, y - 70, x + 45, y + 15);        // left arm up        bezier(x - 45, y, x - 85, y - 70, x - 85, y - 70, x - 45, y + 15);    }}',correct
'eyeClosed == true',SimplifyBooleanExpressions
'mousePressed',correct
'{    fill(bodyColor);    strokeWeight(1);    if (armsDown == true) {        // right arm down        bezier(x + 45, y, x + 85, y + 70, x + 85, y + 70, x + 45, y + 15);        // left arm down        bezier(x - 45, y, x - 85, y + 70, x - 85, y + 70, x - 45, y + 15);    } else {        // right arm up        bezier(x + 45, y, x + 85, y - 70, x + 85, y - 70, x + 45, y + 15);        // left arm up        bezier(x - 45, y, x - 85, y - 70, x - 85, y - 70, x - 45, y + 15);    }}',correct
'strokeWeight(3)',correct
'ellipse(x + 20, y + 20, 5, 5);',correct
'fill(255, 255, 255)',correct
'void',correct
'Arms',correct
'strokeWeight(10);',correct
'body1.upset()',correct
'{    eyeClosed = true;}',correct
'strokeWeight(2)',correct
'true',correct
'noFill();',correct
'eye1.closeEye();',correct
'class Eye {    int x;    int y;    // yellow-ish    int irisColor = color(240, 230, 140);    // red    int pupilColor = color(255, 69, 0);    // dark green-ish    int eyelidColor = color(45, 146, 133);    boolean eyeClosed = false;    Eye(int iconX, int iconY) {        x = iconX;        y = iconY;    }    void display() {        if (eyeClosed == true) {            strokeWeight(2);            fill(eyelidColor);            // his eyelid            ellipse(x, y - 30, 60, 70);            strokeWeight(3);            // wrinkle            bezier(x - 17, y - 10, x - 7, y, x + 7, y, x + 17, y - 10);            bezier(x - 15, y - 8, x - 7, y - 3, x + 7, y - 3, x + 15, y - 8);            strokeWeight(10);            // eyebrow            bezier(x - 20, y - 65, x - 10, y - 60, x + 10, y - 60, x + 20, y - 65);        } else {            strokeWeight(1);            // yellow-ish, color of his iris            fill(irisColor);            // Planktons eye            ellipse(x, y - 30, 60, 70);            // red, color of his pupil            fill(pupilColor);            // Planktons pupil            ellipse(x, y - 30, 30, 35);            // white            fill(255, 255, 255);            noStroke();            // shimmer in the eye            ellipse(x - 5, y - 35, 8, 8);            noFill();            stroke(0);            strokeWeight(10);            // eyebrow            bezier(x - 20, y - 65, x - 10, y - 60, x + 10, y - 60, x + 20, y - 75);        }    }    void closeEye() {        eyeClosed = true;    }    void openEye() {        eyeClosed = false;    }}',correct
'{    bubbleX = iconX;    bubbleY = iconY;    diameter = iconDiameter;}',correct
'int y;',correct
'{    body1.upset();}',correct
'eye1.display()',correct
'y + 20',correct
'bubbles[index] = new Bubble(random(width), random(height), random(10, 60))',correct
'y + 25',correct
'y + 15',correct
'// this will check if a bubble is off screenif (bubbleY < 0 - diameter / 2) {    bubbleLift = true;}',correct
'color(240, 230, 140)',correct
'Body',correct
'bubbles = new Bubble[5]',correct
'checkLocation',correct
'int x;',correct
'eyeClosed = false',correct
'new Mouth(width / 2, height / 2)',correct
'ellipse(x, y - 30, 60, 70)',correct
'// right legbezier(x + 20, y + 88, x + 30, y + 135, x + 25, y + 135, x + 5, y + 95);',correct
'Eye(int iconX, int iconY) {    x = iconX;    y = iconY;}',correct
'bubbleY - diameter / 5',correct
'y + 35',correct
'boolean armsDown = false;',correct
'moveSpeed',correct
'// Planktons pupilellipse(x, y - 30, 30, 35);',correct
'body1.display();',correct
'dist(initX, initY, bubbleX, bubbleY) < diameter / 2',correct
'{    eyeClosed = false;}',correct
'Mouth mouth1;',correct
'// mouthbezier(x - 30, y, x - 25, y + 35, x + 10, y + 35, x + 20, y + 20);',correct
'random(width)',correct
'{    armsDown = true;}',correct
'bubbleLift = true',correct
'bezier(x - 17, y - 10, x - 7, y, x + 7, y, x + 17, y - 10)',correct
'{    armsDown = false;}',correct
'y + 88',correct
'Eye',correct
'x = iconX',correct
'for (int index = 0; index < bubbles.length; index++) {    bubbles[index] = new Bubble(random(width), random(height), random(10, 60));}',correct
'Bubble[] bubbles = new Bubble[5];',correct
'// this makes the bubbles float upwardsmoveSpeed = diameter * 0.025f;',correct
'fill(0, 0, 0, 0)',correct
'y - 30',correct
'void display() {    if (eyeClosed == true) {        strokeWeight(2);        fill(eyelidColor);        // his eyelid        ellipse(x, y - 30, 60, 70);        strokeWeight(3);        // wrinkle        bezier(x - 17, y - 10, x - 7, y, x + 7, y, x + 17, y - 10);        bezier(x - 15, y - 8, x - 7, y - 3, x + 7, y - 3, x + 15, y - 8);        strokeWeight(10);        // eyebrow        bezier(x - 20, y - 65, x - 10, y - 60, x + 10, y - 60, x + 20, y - 65);    } else {        strokeWeight(1);        // yellow-ish, color of his iris        fill(irisColor);        // Planktons eye        ellipse(x, y - 30, 60, 70);        // red, color of his pupil        fill(pupilColor);        // Planktons pupil        ellipse(x, y - 30, 30, 35);        // white        fill(255, 255, 255);        noStroke();        // shimmer in the eye        ellipse(x - 5, y - 35, 8, 8);        noFill();        stroke(0);        strokeWeight(10);        // eyebrow        bezier(x - 20, y - 65, x - 10, y - 60, x + 10, y - 60, x + 20, y - 75);    }}',correct
'y + 95',correct
'strokeWeight(1);',correct
'void display() {    if (mouthOpen == true) {        fill(200, 80, 112);        strokeWeight(2);        // mouth        ellipse(x, y + 25, 35, 25);    } else {        noFill();        strokeWeight(3);        // mouth        bezier(x - 30, y, x - 25, y + 35, x + 10, y + 35, x + 20, y + 20);        fill(0, 0, 0);        strokeWeight(1);        // mouth ends        ellipse(x - 30, y, 5, 5);        ellipse(x + 20, y + 20, 5, 5);    }}',correct
'bubbleY = random(height, height + 150);',correct
'eyelidColor = color(45, 146, 133)',correct
'y - 35',correct
'// yellow-ishint irisColor = color(240, 230, 140);',correct
'class Body {    Eye eye1;    Mouth mouth1;    Arms arms1;    int x;    int y;    // green-ish    int bodyColor = color(58, 201, 183);    Body(int iconX, int iconY) {        eye1 = new Eye(width / 2, height / 2);        mouth1 = new Mouth(width / 2, height / 2);        arms1 = new Arms(width / 2, height / 2);        x = iconX;        y = iconY;    }    void display() {        stroke(0);        strokeWeight(1);        fill(bodyColor);        // Planktons body        ellipse(x, y, 90, 200);        // left leg        bezier(x - 20, y + 88, x - 30, y + 135, x - 25, y + 135, x - 5, y + 95);        // right leg        bezier(x + 20, y + 88, x + 30, y + 135, x + 25, y + 135, x + 5, y + 95);        eye1.display();        mouth1.display();        arms1.display();    }    void upset() {        eye1.closeEye();        mouth1.openMouth();        arms1.downArms();    }    void normal() {        eye1.openEye();        mouth1.closeMouth();        arms1.upArms();    }}',correct
'// whitefill(255, 255, 255);',correct
'// yellow-ish, color of his irisfill(irisColor);',correct
'x + 10',correct
'bubbleY = iconY;',correct
'body1 = new Body(width / 2, height / 2)',correct
'{    if (bubble.clickLocation(mouseX, mouseY)) {        bubble.clickUpdate();    }}',correct
'{    bubbles[index] = new Bubble(random(width), random(height), random(10, 60));}',correct
'void liftUpdate() {    bubbleX = random(width);    bubbleY = random(height - 250, height + 90);    diameter = random(10, 60);}',correct
'color(58, 201, 183)',correct
'Eye eye1;',correct
'mouth1.display();',correct
'fill(200, 80, 112)',correct
'// eyebrowbezier(x - 20, y - 65, x - 10, y - 60, x + 10, y - 60, x + 20, y - 65);',correct
'Arms arms1;',correct
'y - 3',correct
'bubble.move();',correct
'bubble.clickUpdate();',correct
'int initY',correct
'arms1.upArms()',correct
'y + 70',correct
'bezier(x - 20, y + 88, x - 30, y + 135, x - 25, y + 135, x - 5, y + 95)',correct
'y - 8',correct
'index++',correct
'x + 20',correct
'new Eye(width / 2, height / 2)',correct
'float moveSpeed;',correct
'y - 10',correct
'int initX',correct
'strokeWeight(2);',correct
'background(0, 188, 255)',correct
'Bubble bubble',correct
'body1 = new Body(width / 2, height / 2);',correct
'{    // if the mouse is pressed on the eye Plankton will be upset/in pain    if ((mouseX < body1.x + 30 && mouseX > body1.x - 30) && (mouseY < body1.y + 5 && mouseY > body1.y - 65)) {        body1.upset();    }    // if the mouse is pressed on a bubble it will relocate    for (Bubble bubble : bubbles) {        if (bubble.clickLocation(mouseX, mouseY)) {            bubble.clickUpdate();        }    }}',correct
'x + 15',correct
'noStroke()',correct
'mouth1.display()',correct
'x + 17',correct
'pupilColor = color(255, 69, 0)',correct
'armsDown = false;',correct
'y - 60',correct
'boolean mouthOpen = false;',correct
'{    body1.normal();}',correct
'eye1.closeEye()',correct
'y - 65',correct
'bubbleY = random(height - 250, height + 90);',correct
'float diameter;',correct
'bubbleY = bubbleY - moveSpeed',correct
'bubbleX = random(width);',correct
'diameter',correct
'diameter * 0.025f',correct
'color(255, 69, 0)',correct
'{    boolean bubbleLift = false;    // this will check if a bubble is off screen    if (bubbleY < 0 - diameter / 2) {        bubbleLift = true;    }    return bubbleLift;}',correct
'y - 70',correct
'arms1.upArms();',correct
'{    if (eyeClosed == true) {        strokeWeight(2);        fill(eyelidColor);        // his eyelid        ellipse(x, y - 30, 60, 70);        strokeWeight(3);        // wrinkle        bezier(x - 17, y - 10, x - 7, y, x + 7, y, x + 17, y - 10);        bezier(x - 15, y - 8, x - 7, y - 3, x + 7, y - 3, x + 15, y - 8);        strokeWeight(10);        // eyebrow        bezier(x - 20, y - 65, x - 10, y - 60, x + 10, y - 60, x + 20, y - 65);    } else {        strokeWeight(1);        // yellow-ish, color of his iris        fill(irisColor);        // Planktons eye        ellipse(x, y - 30, 60, 70);        // red, color of his pupil        fill(pupilColor);        // Planktons pupil        ellipse(x, y - 30, 30, 35);        // white        fill(255, 255, 255);        noStroke();        // shimmer in the eye        ellipse(x - 5, y - 35, 8, 8);        noFill();        stroke(0);        strokeWeight(10);        // eyebrow        bezier(x - 20, y - 65, x - 10, y - 60, x + 10, y - 60, x + 20, y - 75);    }}',correct
'y - 75',correct
'strokeWeight(3);',correct
'height / 2',correct
'void closeMouth() {    mouthOpen = false;}',correct
'ellipse(x - 5, y - 35, 8, 8)',correct
'// eyebrowbezier(x - 20, y - 65, x - 10, y - 60, x + 10, y - 60, x + 20, y - 75);',correct
'void downArms() {    armsDown = true;}',correct
'boolean eyeClosed = false;',correct
'boolean clickLocation(int initX, int initY) {    boolean bubbleClick = false;    // this will check if the mouse is on a bubble    if (dist(initX, initY, bubbleX, bubbleY) < diameter / 2) {        bubbleClick = true;    }    return bubbleClick;}',correct
'bezier(x + 20, y + 88, x + 30, y + 135, x + 25, y + 135, x + 5, y + 95)',correct
'class Bubble {    float bubbleX;    float bubbleY;    float diameter;    float moveSpeed;    Bubble(float iconX, float iconY, float iconDiameter) {        bubbleX = iconX;        bubbleY = iconY;        diameter = iconDiameter;    }    void display() {        stroke(255);        fill(0, 0, 0, 0);        // bubble        ellipse(bubbleX, bubbleY, diameter, diameter);        fill(255, 255, 255);        // shimmer of the bubble        ellipse(bubbleX - diameter / 5, bubbleY - diameter / 5, diameter / 4, diameter / 4);    }    void liftUpdate() {        bubbleX = random(width);        bubbleY = random(height - 250, height + 90);        diameter = random(10, 60);    }    void clickUpdate() {        bubbleX = random(width);        bubbleY = random(height, height + 150);        diameter = random(10, 60);    }    void move() {        // this makes the bubbles float upwards        moveSpeed = diameter * 0.025f;        bubbleY = bubbleY - moveSpeed;    }    boolean clickLocation(int initX, int initY) {        boolean bubbleClick = false;        // this will check if the mouse is on a bubble        if (dist(initX, initY, bubbleX, bubbleY) < diameter / 2) {            bubbleClick = true;        }        return bubbleClick;    }    boolean checkLocation() {        boolean bubbleLift = false;        // this will check if a bubble is off screen        if (bubbleY < 0 - diameter / 2) {            bubbleLift = true;        }        return bubbleLift;    }}',correct
'clickLocation',correct
'arms1 = new Arms(width / 2, height / 2)',correct
'void move() {    // this makes the bubbles float upwards    moveSpeed = diameter * 0.025f;    bubbleY = bubbleY - moveSpeed;}',correct
'body1.normal();',correct
'{    bubble.liftUpdate();}',correct
'eye1 = new Eye(width / 2, height / 2)',correct
'new Body(width / 2, height / 2)',correct
'armsDown = true;',correct
'eyeClosed = true',correct
'noFill()',correct
'mouth1.openMouth()',correct
'arms1.display()',correct
'bezier(x - 15, y - 8, x - 7, y - 3, x + 7, y - 3, x + 15, y - 8);',correct
'bubbleLift = true;',correct
'stroke(255)',correct
'bubbleY = random(height, height + 150)',correct
'x - 15',correct
'// bubbleellipse(bubbleX, bubbleY, diameter, diameter);',correct
'// left legbezier(x - 20, y + 88, x - 30, y + 135, x - 25, y + 135, x - 5, y + 95);',correct
'x - 10',correct
'{    background(0, 188, 255);    body1.display();    for (Bubble bubble : bubbles) {        bubble.move();        bubble.display();        // if the bubble is off screen it will relocate        if (bubble.checkLocation()) {            bubble.liftUpdate();        }    }}',correct
'// wrinklebezier(x - 17, y - 10, x - 7, y, x + 7, y, x + 17, y - 10);',correct
'bubbleClick = true;',correct
'fill(eyelidColor)',correct
'ellipse(bubbleX, bubbleY, diameter, diameter)',correct
'Bubble[]',correct
'if (armsDown == true) {    // right arm down    bezier(x + 45, y, x + 85, y + 70, x + 85, y + 70, x + 45, y + 15);    // left arm down    bezier(x - 45, y, x - 85, y + 70, x - 85, y + 70, x - 45, y + 15);} else {    // right arm up    bezier(x + 45, y, x + 85, y - 70, x + 85, y - 70, x + 45, y + 15);    // left arm up    bezier(x - 45, y, x - 85, y - 70, x - 85, y - 70, x - 45, y + 15);}',correct
'// if the mouse is pressed on a bubble it will relocatefor (Bubble bubble : bubbles) {    if (bubble.clickLocation(mouseX, mouseY)) {        bubble.clickUpdate();    }}',correct
'{    stroke(0);    strokeWeight(1);    fill(bodyColor);    // Planktons body    ellipse(x, y, 90, 200);    // left leg    bezier(x - 20, y + 88, x - 30, y + 135, x - 25, y + 135, x - 5, y + 95);    // right leg    bezier(x + 20, y + 88, x + 30, y + 135, x + 25, y + 135, x + 5, y + 95);    eye1.display();    mouth1.display();    arms1.display();}',correct
'fill(eyelidColor);',correct
'// SJOERD VAN VEEN - CreaTe     s2136090',correct
'void normal() {    eye1.openEye();    mouth1.closeMouth();    arms1.upArms();}',correct
'void closeEye() {    eyeClosed = true;}',correct
'// shimmer in the eyeellipse(x - 5, y - 35, 8, 8);',correct
'x - 25',correct
'x - 20',correct
'bubbles[index]',correct
'x + 85',correct
'{    eye1.openEye();    mouth1.closeMouth();    arms1.upArms();}',correct
'bubble.display()',correct
'// left arm upbezier(x - 45, y, x - 85, y - 70, x - 85, y - 70, x - 45, y + 15);',correct
'void upset() {    eye1.closeEye();    mouth1.openMouth();    arms1.downArms();}',correct
'x - 17',correct
'bezier(x - 20, y - 65, x - 10, y - 60, x + 10, y - 60, x + 20, y - 65)',correct
'// his eyelidellipse(x, y - 30, 60, 70);',correct
'x - 30',correct
'eye1.openEye()',correct
'bubbleY < 0 - diameter / 2',correct
'{    x = iconX;    y = iconY;}',correct
'eye1.display();',correct
'ellipse(x, y + 25, 35, 25)',correct
'bubbles[index] = new Bubble(random(width), random(height), random(10, 60));',correct
'irisColor = color(240, 230, 140)',correct
'eye1.openEye();',correct
'0 - diameter / 2',correct
'body1',correct
'y = iconY',correct
'height - 250',correct
'x - 45',correct
'void draw() {    background(0, 188, 255);    body1.display();    for (Bubble bubble : bubbles) {        bubble.move();        bubble.display();        // if the bubble is off screen it will relocate        if (bubble.checkLocation()) {            bubble.liftUpdate();        }    }}',correct
'display',correct
'// Planktons bodyellipse(x, y, 90, 200);',correct
'int index = 0',correct
'x + 7',correct
'x + 5',correct
'strokeWeight(10)',correct
'for (Bubble bubble : bubbles) {    bubble.move();    bubble.display();    // if the bubble is off screen it will relocate    if (bubble.checkLocation()) {        bubble.liftUpdate();    }}',correct
'// dark green-ishint eyelidColor = color(45, 146, 133);',correct
'index = 0',correct
'// if the bubble is off screen it will relocateif (bubble.checkLocation()) {    bubble.liftUpdate();}',correct
'x + 30',correct
'Body(int iconX, int iconY) {    eye1 = new Eye(width / 2, height / 2);    mouth1 = new Mouth(width / 2, height / 2);    arms1 = new Arms(width / 2, height / 2);    x = iconX;    y = iconY;}',correct
'bubbleY - moveSpeed',correct
'boolean bubbleClick = false;',correct
'Bubble',correct
'arms1.display();',correct
'Bubble(float iconX, float iconY, float iconDiameter) {    bubbleX = iconX;    bubbleY = iconY;    diameter = iconDiameter;}',correct
'bubbleX = iconX',correct
'x + 25',correct
'x + 45',correct
'Arms(int iconX, int iconY) {    x = iconX;    y = iconY;}',correct
'y + 135',correct
'boolean bubbleLift = false;',correct
'{    strokeWeight(2);    fill(eyelidColor);    // his eyelid    ellipse(x, y - 30, 60, 70);    strokeWeight(3);    // wrinkle    bezier(x - 17, y - 10, x - 7, y, x + 7, y, x + 17, y - 10);    bezier(x - 15, y - 8, x - 7, y - 3, x + 7, y - 3, x + 15, y - 8);    strokeWeight(10);    // eyebrow    bezier(x - 20, y - 65, x - 10, y - 60, x + 10, y - 60, x + 20, y - 65);}',SimplifyBooleanExpressions
'bodyColor = color(58, 201, 183)',correct
'float bubbleY;',correct
'arms1.downArms()',correct
'y = iconY;',correct
'armsDown = true',correct
'bezier(x + 45, y, x + 85, y - 70, x + 85, y - 70, x + 45, y + 15)',correct
'stroke(255);',correct
'fill(0, 0, 0);',correct
'{    eye1.closeEye();    mouth1.openMouth();    arms1.downArms();}',correct
'// right arm upbezier(x + 45, y, x + 85, y - 70, x + 85, y - 70, x + 45, y + 15);',correct
'void clickUpdate() {    bubbleX = random(width);    bubbleY = random(height, height + 150);    diameter = random(10, 60);}',correct
'float bubbleX;',correct
'0.025f',correct
'bubbleX = iconX;',correct
'background(0, 188, 255);',correct
'void mousePressed() {    // if the mouse is pressed on the eye Plankton will be upset/in pain    if ((mouseX < body1.x + 30 && mouseX > body1.x - 30) && (mouseY < body1.y + 5 && mouseY > body1.y - 65)) {        body1.upset();    }    // if the mouse is pressed on a bubble it will relocate    for (Bubble bubble : bubbles) {        if (bubble.clickLocation(mouseX, mouseY)) {            bubble.clickUpdate();        }    }}',correct
'fill(0, 0, 0, 0);',correct
'{    bubble.clickUpdate();}',correct
'move',correct
'float iconDiameter',correct
'void upArms() {    armsDown = false;}',correct
'{    bubbleX = random(width);    bubbleY = random(height, height + 150);    diameter = random(10, 60);}',correct
'{    fill(200, 80, 112);    strokeWeight(2);    // mouth    ellipse(x, y + 25, 35, 25);}',SimplifyBooleanExpressions
'body1.display()',correct
'// Plankton',correct
'bezier(x - 45, y, x - 85, y - 70, x - 85, y - 70, x - 45, y + 15)',correct
'{    if (mouthOpen == true) {        fill(200, 80, 112);        strokeWeight(2);        // mouth        ellipse(x, y + 25, 35, 25);    } else {        noFill();        strokeWeight(3);        // mouth        bezier(x - 30, y, x - 25, y + 35, x + 10, y + 35, x + 20, y + 20);        fill(0, 0, 0);        strokeWeight(1);        // mouth ends        ellipse(x - 30, y, 5, 5);        ellipse(x + 20, y + 20, 5, 5);    }}',correct
'x - 5',correct
'width / 2',correct
'boolean',correct
'x - 7',correct
'img = loadImage("Kafe.jpg");',correct
'x = initX;',correct
'helmet_2.setFill(0xff4b5320)',correct
'if (Body1[i].mouseOver(mouseX, mouseY)) {    Body1[i].colorActive = true;}',correct
'helmet_2 = createShape(RECT, x, y - 15, 60, 30);',correct
'{    for (int i = 0; i < Body1.length; i++) {        if (Body1[i].mouseOver(mouseX, mouseY)) {            Body1[i].moveActive = true;        }    }}',correct
'y - 17',correct
'{    s = createShape(GROUP);    // body    body = createShape(RECT, x, y + 15, 45, 30);    body.setFill(BodyColor);    // helmet    helmet_1 = createShape(ARC, x, y - 28, 50, 50, PI, 2 * PI);    helmet_1.setFill(0xff4b5320);    helmet_2 = createShape(RECT, x, y - 15, 60, 30);    helmet_2.setFill(0xff4b5320);    // eye guard    eye_guard = createShape(RECT, x, y - 17, 40, 3);    eye_guard.setFill(color(0));    // left leg    left_leg = createShape(RECT, x - 10, y + 40, 5, 20);    left_leg.setFill(0xff4b5320);    // right leg    right_leg = createShape(RECT, x + 10, y + 40, 5, 20);    right_leg.setFill(0xff4b5320);    // left arm    pushMatrix();    left_arm = createShape(RECT, 1, 1, 20, 5);    left_arm.setFill(0xff4b5320);    left_arm.translate(x - 25, y + 15);    left_arm.rotate(PI / 1.5f);    popMatrix();    // right arm    pushMatrix();    right_arm = createShape(RECT, 1, 1, 20, 5);    right_arm.setFill(0xff4b5320);    right_arm.translate(x + 25, y + 15);    right_arm.rotate(PI / 3.5f);    popMatrix();    // group together    s.addChild(helmet_1);    s.addChild(helmet_2);    s.addChild(eye_guard);    s.addChild(body);    s.addChild(left_arm);    s.addChild(right_arm);    s.addChild(right_leg);    s.addChild(left_leg);}',LongMethodRule
'helmet_1',correct
'y = Ymouse;',correct
's.addChild(eye_guard)',correct
'float mx',ShortVariable
'PImage img;',correct
'void keyPressed() {    if (key == c) {        for (int i = 0; i < Body1.length; i++) {            if (Body1[i].mouseOver(mouseX, mouseY)) {                Body1[i].colorActive = true;            }            Body1[i].changeColor();        }    }/*if(key ==r){   for (int i=0; i<Body1.length; i++) {   if(Body1[i].mouseOver(mouseX,mouseY)){     Body1[i].rotateActive = true;   }   Body1[i].charRotate();   }  }*/}',correct
'createShape(RECT, x, y - 17, 40, 3)',correct
'Body1[i].resetKeyPress();',correct
'helmet_2',correct
'void setup() {    rectMode(CENTER);    imageMode(CENTER);    img = loadImage("Kafe.jpg");    for (int i = 0; i < Body1.length; i++) {        Body1[i] = new Body(i * 70, 0);    }}',correct
'// change colorvoid changeColor() {    if (colorActive) {        int redValue = PApplet.parseInt(random(0, 256));        int blueValue = PApplet.parseInt(random(0, 256));        int greenValue = PApplet.parseInt(random(0, 256));        BodyColor = color(redValue, greenValue, blueValue);    }}',correct
'int Xmouse',correct
'random(0, 256)',correct
'if (moveActive) {    x = Xmouse;    y = Ymouse;}',correct
'my >= y',correct
'int x, y;',correct
'y = Ymouse',correct
'y - 28',correct
'createShape(RECT, x - 10, y + 40, 5, 20)',correct
'Body(int initX, int initY) {    x = initX;    y = initY;    int redValue = PApplet.parseInt(random(0, 256));    int blueValue = PApplet.parseInt(random(0, 256));    int greenValue = PApplet.parseInt(random(0, 256));    BodyColor = color(redValue, greenValue, blueValue);}',correct
'body.setFill(BodyColor)',correct
'helmet_1 = createShape(ARC, x, y - 28, 50, 50, PI, 2 * PI)',correct
'float my',correct
'Body1[i].resetKeyPress()',correct
'greenValue = PApplet.parseInt(random(0, 256))',correct
's.addChild(helmet_2);',correct
'x + 10',correct
's.addChild(left_leg)',correct
'Body1[i].mouseOver(mouseX, mouseY)',correct
'right_arm.setFill(0xff4b5320);',correct
'changeColor',correct
'Body1[i].display();',correct
'x = Xmouse;',correct
'Body[]',correct
'PImage',correct
'x = initX',correct
'return false;',correct
'BodyColor',correct
'left_arm',correct
'eye_guard',correct
'rectMode(CENTER)',correct
'x + 22',correct
'PApplet.parseInt(random(0, 256))',correct
'mx >= x - 22 && mx <= x + 22 && my >= y && my <= y + 30',correct
'int initY',correct
'c',correct
'background(img);',correct
'{    x = Xmouse;    y = Ymouse;}',correct
'left_arm.translate(x - 25, y + 15)',correct
'Body1[i].charMove(mouseX, mouseY)',correct
'Body1[i] = new Body(i * 70, 0)',correct
'PI / 1.5f',correct
'popMatrix();',correct
'int initX',correct
'y - 15',correct
'{    if (moveActive) {        x = Xmouse;        y = Ymouse;    }}',correct
'Body1[i].moveActive = true',correct
'my <= y + 30',correct
's',correct
'left_arm.setFill(0xff4b5320)',correct
'PShape',correct
'Body1[i].charMove(mouseX, mouseY);',DecentralizedEventHandlingRule
'x',correct
'y',correct
'rectMode(CENTER);',correct
'3.5f',correct
's.addChild(left_leg);',correct
'Body1.length',correct
'{    Body1[i].resetKeyPress();}',correct
'for (int i = 0; i < Body1.length; i++) {    Body1[i] = new Body(i * 70, 0);}',correct
'{    shape(s, 0, 0);}',correct
'createShape(RECT, x + 10, y + 40, 5, 20)',correct
'left_arm.rotate(PI / 1.5f)',correct
's.addChild(eye_guard);',correct
'createShape(RECT, 1, 1, 20, 5)',correct
'a1 = 0',correct
'resetMousePress',correct
'resetKeyPress',correct
'BodyColor = color(redValue, greenValue, blueValue);',correct
'// display charactervoid display() {    shape(s, 0, 0);}',correct
'mx >= x - 22',correct
'loadChar',LongMethodRule
'{    Body1[i].colorActive = true;}',correct
'PI / 3.5f',correct
'{    if (mx >= x - 22 && mx <= x + 22 && my >= y && my <= y + 30) {        return true;    }    return false;}',correct
'// rotateActive = false;',correct
'color(redValue, greenValue, blueValue)',correct
'if (Body1[i].mouseOver(mouseX, mouseY)) {    Body1[i].moveActive = true;}',correct
'Body[] Body1 = new Body[10];',correct
'{    for (int i = 0; i < Body1.length; i++) {        Body1[i].resetMousePress();    }}',correct
'Body1 = new Body[10]',correct
'void keyReleased() {    for (int i = 0; i < Body1.length; i++) {        Body1[i].resetKeyPress();    }}',correct
'boolean colorActive = false;',correct
'helmet_2.setFill(0xff4b5320);',correct
'right_arm.rotate(PI / 3.5f)',correct
'int blueValue = PApplet.parseInt(random(0, 256))',correct
'Processing',correct
'moveActive = false;',correct
'redValue = PApplet.parseInt(random(0, 256))',correct
'{    int redValue = PApplet.parseInt(random(0, 256));    int blueValue = PApplet.parseInt(random(0, 256));    int greenValue = PApplet.parseInt(random(0, 256));    BodyColor = color(redValue, greenValue, blueValue);}',correct
'pushMatrix()',correct
's.addChild(right_leg)',correct
'Body1[i].colorActive',correct
'{    background(img);    for (int i = 0; i < Body1.length; i++) {        Body1[i].loadChar();        Body1[i].display();        Body1[i].charMove(mouseX, mouseY);    }}',correct
'// right leg',correct
'int redValue = PApplet.parseInt(random(0, 256))',correct
'Body1[i].changeColor();',correct
'colorActive = false',correct
'i * 70',correct
'Body1[i]',correct
'false',correct
'createShape(RECT, x, y - 15, 60, 30)',correct
'boolean moveActive = false;',correct
'Body1[i].colorActive = true;',correct
'imageMode(CENTER);',correct
'int i = 0',correct
'// left legleft_leg = createShape(RECT, x - 10, y + 40, 5, 20);',correct
's.addChild(body);',correct
'"Kafe.jpg"',correct
'loadImage("Kafe.jpg")',correct
'int blueValue = PApplet.parseInt(random(0, 256));',correct
'// group togethers.addChild(helmet_1);',correct
'for (int i = 0; i < Body1.length; i++) {    if (Body1[i].mouseOver(mouseX, mouseY)) {        Body1[i].colorActive = true;    }    Body1[i].changeColor();}',correct
'i = 0',correct
's.addChild(right_arm);',correct
'// stop color and rotatevoid resetKeyPress() {    colorActive = false;// rotateActive = false;}',correct
'y = initY;',correct
'{    rectMode(CENTER);    imageMode(CENTER);    img = loadImage("Kafe.jpg");    for (int i = 0; i < Body1.length; i++) {        Body1[i] = new Body(i * 70, 0);    }}',correct
'x - 10',correct
'shape(s, 0, 0);',correct
'img = loadImage("Kafe.jpg")',correct
'{    if (Body1[i].mouseOver(mouseX, mouseY)) {        Body1[i].moveActive = true;    }}',correct
'Body1[i].colorActive = true',correct
'int BodyColor;',VariableNamingConventions
'y = initY',correct
'right_leg',correct
'{    if (key == c) {        for (int i = 0; i < Body1.length; i++) {            if (Body1[i].mouseOver(mouseX, mouseY)) {                Body1[i].colorActive = true;            }            Body1[i].changeColor();        }    }/*if(key ==r){   for (int i=0; i<Body1.length; i++) {   if(Body1[i].mouseOver(mouseX,mouseY)){     Body1[i].rotateActive = true;   }   Body1[i].charRotate();   }  }*/}',correct
'/* //rotate character    void charRotate(){    if(rotateActive){      a1+=0.05;    }  }*/// stop movevoid resetMousePress() {    moveActive = false;}',correct
'right_arm = createShape(RECT, 1, 1, 20, 5);',correct
'int greenValue = PApplet.parseInt(random(0, 256))',correct
'left_leg = createShape(RECT, x - 10, y + 40, 5, 20)',correct
'i < Body1.length',correct
'/* //rotate character    void charRotate(){    if(rotateActive){      a1+=0.05;    }  }*/',correct
'x - 25',correct
'for (int i = 0; i < Body1.length; i++) {    Body1[i].loadChar();    Body1[i].display();    Body1[i].charMove(mouseX, mouseY);}',correct
'x - 22',correct
'left_arm = createShape(RECT, 1, 1, 20, 5);',correct
'{    colorActive = false;// rotateActive = false;}',correct
'void mouseDragged() {    for (int i = 0; i < Body1.length; i++) {        if (Body1[i].mouseOver(mouseX, mouseY)) {            Body1[i].moveActive = true;        }    }}',correct
'imageMode(CENTER)',correct
'// bodybody = createShape(RECT, x, y + 15, 45, 30);',correct
's.addChild(body)',correct
'{    if (Body1[i].mouseOver(mouseX, mouseY)) {        Body1[i].colorActive = true;    }    Body1[i].changeColor();}',correct
'helmet_1.setFill(0xff4b5320)',correct
'return true;',correct
'{    Body1[i].loadChar();    Body1[i].display();    Body1[i].charMove(mouseX, mouseY);}',correct
'/*if(key ==r){   for (int i=0; i<Body1.length; i++) {   if(Body1[i].mouseOver(mouseX,mouseY)){     Body1[i].rotateActive = true;   }   Body1[i].charRotate();   }  }*/',correct
'rotateActive = false',correct
'Body1[i].moveActive = true;',correct
'float a1 = 0;',ShortVariable
'for (int i = 0; i < Body1.length; i++) {    Body1[i].resetKeyPress();}',correct
's.addChild(right_arm)',correct
'key == c',correct
'right_leg = createShape(RECT, x + 10, y + 40, 5, 20)',correct
's.addChild(left_arm)',correct
'void mouseReleased() {    for (int i = 0; i < Body1.length; i++) {        Body1[i].resetMousePress();    }}',correct
'{    Body1[i].resetMousePress();}',correct
'class Body {    int x, y;    int BodyColor;    PShape s, helmet_1, helmet_2, eye_guard, body, left_arm, right_arm, left_leg, right_leg;    boolean moveActive = false;    boolean rotateActive = false;    boolean colorActive = false;    Body(int initX, int initY) {        x = initX;        y = initY;        int redValue = PApplet.parseInt(random(0, 256));        int blueValue = PApplet.parseInt(random(0, 256));        int greenValue = PApplet.parseInt(random(0, 256));        BodyColor = color(redValue, greenValue, blueValue);    }    // load character    void loadChar() {        s = createShape(GROUP);        // body        body = createShape(RECT, x, y + 15, 45, 30);        body.setFill(BodyColor);        // helmet        helmet_1 = createShape(ARC, x, y - 28, 50, 50, PI, 2 * PI);        helmet_1.setFill(0xff4b5320);        helmet_2 = createShape(RECT, x, y - 15, 60, 30);        helmet_2.setFill(0xff4b5320);        // eye guard        eye_guard = createShape(RECT, x, y - 17, 40, 3);        eye_guard.setFill(color(0));        // left leg        left_leg = createShape(RECT, x - 10, y + 40, 5, 20);        left_leg.setFill(0xff4b5320);        // right leg        right_leg = createShape(RECT, x + 10, y + 40, 5, 20);        right_leg.setFill(0xff4b5320);        // left arm        pushMatrix();        left_arm = createShape(RECT, 1, 1, 20, 5);        left_arm.setFill(0xff4b5320);        left_arm.translate(x - 25, y + 15);        left_arm.rotate(PI / 1.5f);        popMatrix();        // right arm        pushMatrix();        right_arm = createShape(RECT, 1, 1, 20, 5);        right_arm.setFill(0xff4b5320);        right_arm.translate(x + 25, y + 15);        right_arm.rotate(PI / 3.5f);        popMatrix();        // group together        s.addChild(helmet_1);        s.addChild(helmet_2);        s.addChild(eye_guard);        s.addChild(body);        s.addChild(left_arm);        s.addChild(right_arm);        s.addChild(right_leg);        s.addChild(left_leg);    }    // display character    void display() {        shape(s, 0, 0);    }    // check if in middle of character    boolean mouseOver(float mx, float my) {        if (mx >= x - 22 && mx <= x + 22 && my >= y && my <= y + 30) {            return true;        }        return false;    }    // change color    void changeColor() {        if (colorActive) {            int redValue = PApplet.parseInt(random(0, 256));            int blueValue = PApplet.parseInt(random(0, 256));            int greenValue = PApplet.parseInt(random(0, 256));            BodyColor = color(redValue, greenValue, blueValue);        }    }    // move character    void charMove(int Xmouse, int Ymouse) {        if (moveActive) {            x = Xmouse;            y = Ymouse;        }    }    /* //rotate character    void charRotate(){    if(rotateActive){      a1+=0.05;    }  }*/    // stop move    void resetMousePress() {        moveActive = false;    }    // stop color and rotate    void resetKeyPress() {        colorActive = false;    // rotateActive = false;    }}',correct
'{    for (int i = 0; i < Body1.length; i++) {        Body1[i].resetKeyPress();    }}',correct
'eye_guard.setFill(color(0))',correct
'mx >= x - 22 && mx <= x + 22',correct
'{    Body1[i] = new Body(i * 70, 0);}',correct
'int Ymouse',VariableNamingConventions
'color(0)',correct
'Body1[i].resetMousePress()',correct
'for (int i = 0; i < Body1.length; i++) {    Body1[i].resetMousePress();}',correct
'for (int i = 0; i < Body1.length; i++) {    if (Body1[i].mouseOver(mouseX, mouseY)) {        Body1[i].moveActive = true;    }}',correct
'mx <= x + 22',correct
'createShape(RECT, x, y + 15, 45, 30)',correct
'left_arm = createShape(RECT, 1, 1, 20, 5)',correct
'right_leg.setFill(0xff4b5320)',correct
'display',correct
'right_arm.translate(x + 25, y + 15);',correct
'eye_guard.setFill(color(0));',correct
'right_leg.setFill(0xff4b5320);',correct
'void draw() {    background(img);    for (int i = 0; i < Body1.length; i++) {        Body1[i].loadChar();        Body1[i].display();        Body1[i].charMove(mouseX, mouseY);    }}',correct
'boolean rotateActive = false;',correct
'// right armpushMatrix();',correct
'new Body(i * 70, 0)',correct
'// eye guardeye_guard = createShape(RECT, x, y - 17, 40, 3);',correct
'if (colorActive) {    int redValue = PApplet.parseInt(random(0, 256));    int blueValue = PApplet.parseInt(random(0, 256));    int greenValue = PApplet.parseInt(random(0, 256));    BodyColor = color(redValue, greenValue, blueValue);}',correct
'Body1[i].changeColor()',correct
'{    return true;}',correct
'i++',correct
'y + 40',correct
'body',correct
'moveActive = false',correct
'shape(s, 0, 0)',correct
'// load charactervoid loadChar() {    s = createShape(GROUP);    // body    body = createShape(RECT, x, y + 15, 45, 30);    body.setFill(BodyColor);    // helmet    helmet_1 = createShape(ARC, x, y - 28, 50, 50, PI, 2 * PI);    helmet_1.setFill(0xff4b5320);    helmet_2 = createShape(RECT, x, y - 15, 60, 30);    helmet_2.setFill(0xff4b5320);    // eye guard    eye_guard = createShape(RECT, x, y - 17, 40, 3);    eye_guard.setFill(color(0));    // left leg    left_leg = createShape(RECT, x - 10, y + 40, 5, 20);    left_leg.setFill(0xff4b5320);    // right leg    right_leg = createShape(RECT, x + 10, y + 40, 5, 20);    right_leg.setFill(0xff4b5320);    // left arm    pushMatrix();    left_arm = createShape(RECT, 1, 1, 20, 5);    left_arm.setFill(0xff4b5320);    left_arm.translate(x - 25, y + 15);    left_arm.rotate(PI / 1.5f);    popMatrix();    // right arm    pushMatrix();    right_arm = createShape(RECT, 1, 1, 20, 5);    right_arm.setFill(0xff4b5320);    right_arm.translate(x + 25, y + 15);    right_arm.rotate(PI / 3.5f);    popMatrix();    // group together    s.addChild(helmet_1);    s.addChild(helmet_2);    s.addChild(eye_guard);    s.addChild(body);    s.addChild(left_arm);    s.addChild(right_arm);    s.addChild(right_leg);    s.addChild(left_leg);}',correct
'Body1[i].moveActive',correct
'blueValue = PApplet.parseInt(random(0, 256))',correct
'left_leg.setFill(0xff4b5320);',correct
'{    for (int i = 0; i < Body1.length; i++) {        if (Body1[i].mouseOver(mouseX, mouseY)) {            Body1[i].colorActive = true;        }        Body1[i].changeColor();    }}',correct
'Body1[i].display()',correct
'{    x = initX;    y = initY;    int redValue = PApplet.parseInt(random(0, 256));    int blueValue = PApplet.parseInt(random(0, 256));    int greenValue = PApplet.parseInt(random(0, 256));    BodyColor = color(redValue, greenValue, blueValue);}',correct
'int greenValue = PApplet.parseInt(random(0, 256));',correct
's = createShape(GROUP)',correct
'x + 25',correct
'// right legright_leg = createShape(RECT, x + 10, y + 40, 5, 20);',correct
'void',correct
'PShape s, helmet_1, helmet_2, eye_guard, body, left_arm, right_arm, left_leg, right_leg;',ShortVariable
'helmet_2 = createShape(RECT, x, y - 15, 60, 30)',correct
'left_leg',correct
'right_arm.rotate(PI / 3.5f);',correct
'helmet_1.setFill(0xff4b5320);',correct
'{    if (colorActive) {        int redValue = PApplet.parseInt(random(0, 256));        int blueValue = PApplet.parseInt(random(0, 256));        int greenValue = PApplet.parseInt(random(0, 256));        BodyColor = color(redValue, greenValue, blueValue);    }}',correct
'left_arm.translate(x - 25, y + 15);',correct
's.addChild(left_arm);',correct
'Body1[i] = new Body(i * 70, 0);',correct
'if (key == c) {    for (int i = 0; i < Body1.length; i++) {        if (Body1[i].mouseOver(mouseX, mouseY)) {            Body1[i].colorActive = true;        }        Body1[i].changeColor();    }}',correct
'left_arm.setFill(0xff4b5320);',correct
'BodyColor = color(redValue, greenValue, blueValue)',correct
'background(img)',correct
'true',correct
'1.5f',correct
'new Body[10]',correct
'int redValue = PApplet.parseInt(random(0, 256));',correct
'Body1[i].loadChar()',correct
'img',correct
'right_arm.translate(x + 25, y + 15)',correct
'left_leg.setFill(0xff4b5320)',correct
'{    moveActive = false;}',correct
'right_arm',correct
'popMatrix()',correct
'mx >= x - 22 && mx <= x + 22 && my >= y',correct
'right_arm = createShape(RECT, 1, 1, 20, 5)',correct
'body.setFill(BodyColor);',correct
'left_arm.rotate(PI / 1.5f);',correct
'[10]',correct
's.addChild(helmet_2)',correct
'charMove',VariableNamingConventions
'Body1[i].resetMousePress();',correct
'// check if in middle of characterboolean mouseOver(float mx, float my) {    if (mx >= x - 22 && mx <= x + 22 && my >= y && my <= y + 30) {        return true;    }    return false;}',correct
'createShape(ARC, x, y - 28, 50, 50, PI, 2 * PI)',correct
'{    Body1[i].moveActive = true;}',correct
'y + 15',correct
'// helmethelmet_1 = createShape(ARC, x, y - 28, 50, 50, PI, 2 * PI);',correct
'Body',correct
'eye_guard = createShape(RECT, x, y - 17, 40, 3)',correct
's.addChild(helmet_1)',correct
's.addChild(right_leg);',correct
'y + 30',correct
'body = createShape(RECT, x, y + 15, 45, 30)',correct
'mouseOver',ShortVariable
'right_arm.setFill(0xff4b5320)',correct
'x = Xmouse',correct
'// move charactervoid charMove(int Xmouse, int Ymouse) {    if (moveActive) {        x = Xmouse;        y = Ymouse;    }}',correct
'Body1[i].loadChar();',correct
'if (mx >= x - 22 && mx <= x + 22 && my >= y && my <= y + 30) {    return true;}',correct
'boolean',ShortVariable
'2 * PI',correct
's = createShape(GROUP);',correct
'// left armpushMatrix();',correct
'createShape(GROUP)',correct
'colorActive = false;',correct
'konijnX = konijnX + xspeed',correct
'void display() {    if (konijnX < width / 2) {        // head        stroke(0);        fill(255, 183, 234);        // left ear        ellipse(konijnX - 25, konijnY - 60, 30, 70);        fill(255, 127, 217);        ellipse(konijnX - 25, konijnY - 60, 15, 40);        fill(255, 183, 234);        // right ear        ellipse(konijnX + 25, konijnY - 60, 30, 70);        fill(255, 127, 217);        ellipse(konijnX + 25, konijnY - 60, 15, 40);        fill(255, 183, 234);        // head        ellipse(konijnX - 0, konijnY + 0, 100, 100);        fill(255);        // left eye        ellipse(konijnX - 14, konijnY - 18, 25, 25);        // right eye        ellipse(konijnX + 14, konijnY - 18, 25, 25);        fill(0);        // left iris        ellipse(konijnX - 14, konijnY - 18, 16, 16);        // right iris        ellipse(konijnX + 14, konijnY - 18, 16, 16);        fill(255);        // left glitter        ellipse(konijnX - 17, konijnY - 21, 7, 7);        // right glitter        ellipse(konijnX + 11, konijnY - 21, 7, 7);        // left little glitter        ellipse(konijnX - 16, konijnY - 16, 4, 4);        // right little glitter        ellipse(konijnX + 13, konijnY - 16, 4, 4);        fill(255, 127, 217);        // nose        triangle(konijnX - 8, konijnY + 8, konijnX + 8, konijnY + 8, konijnX + 0, konijnY - 4);        noFill();        // mouth        arc(konijnX - 12, konijnY + 8, 25, 35, 0, PI);        arc(konijnX + 12, konijnY + 8, 25, 35, 0, PI);    } else {        stroke(0);        fill(230, 168, 220);        // left ear        ellipse(konijnX - 25, konijnY - 60, 30, 70);        fill(203, 104, 174);        ellipse(konijnX - 25, konijnY - 60, 15, 40);        fill(230, 168, 220);        // right ear        ellipse(konijnX + 25, konijnY - 60, 30, 70);        fill(203, 104, 174);        ellipse(konijnX + 25, konijnY - 60, 15, 40);        fill(230, 168, 220);        // head        ellipse(konijnX - 0, konijnY + 0, 100, 100);        // eyes shut        arc(konijnX - 16, konijnY - 25, 20, 25, TWO_PI, TWO_PI + PI);        arc(konijnX + 16, konijnY - 25, 20, 25, TWO_PI, TWO_PI + PI);        fill(203, 104, 174);        // nose        triangle(konijnX - 8, konijnY + 8, konijnX + 8, konijnY + 8, konijnX + 0, konijnY - 4);        noFill();        // mouth        arc(konijnX - 12, konijnY + 8, 25, 35, 0, PI);        arc(konijnX + 12, konijnY + 8, 25, 35, 0, PI);    }}',correct
'void display() {    noStroke();    fill(243, 243, 4);    arc(zonX + 0, zonY + 0, 120, 120, HALF_PI, HALF_PI + PI, OPEN);    stroke(243, 243, 4);    strokeWeight(5);    pushMatrix();    translate(width / 2, height / 2);    rotate(radians(45));    for (int i = 0; i <= 6; i++) {        line(60, 60, 100, 100);        rotate(radians(30));    }    popMatrix();    strokeWeight(1);}',correct
'new Konijn[10]',correct
'// eyes shutarc(konijnX - 16, konijnY - 25, 20, 25, TWO_PI, TWO_PI + PI);',correct
'konijnY - 25',correct
'Maan mijnMaan;',correct
'fill(255, 183, 234);',correct
'mijnMaan.display()',correct
'ellipse(konijnX + 14, konijnY - 18, 25, 25)',correct
'rotate(radians(45))',correct
'random(50, width - 50)',correct
'height - 50',correct
'frameRate(80);',correct
'arc(konijnX + 16, konijnY - 25, 20, 25, TWO_PI, TWO_PI + PI)',correct
'ellipse(konijnX - 25, konijnY - 60, 15, 40);',correct
'Konijn[]',correct
'// co\u00f6rdinate x-axis konijnfloat konijnX;',correct
'stroke(0);',correct
'stroke(0)',correct
'{    line(60, 60, 100, 100);    rotate(radians(30));}',correct
'// left earellipse(konijnX - 25, konijnY - 60, 30, 70);',correct
'// headellipse(konijnX - 0, konijnY + 0, 100, 100);',correct
'mijnMaan = new Maan()',correct
'{    // making 10 bunnys at random places    mijnKonijn[i] = new Konijn(random(50, width - 50), random(95, height - 50));    frameRate(80);}',correct
'background(58, 52, 112);',correct
'pushMatrix();',correct
'konijnY - 16',correct
'strokeWeight(1);',correct
'ellipse(maanX + 9, maanY + 0, 12, 12);',correct
'konijnY - 18',correct
'{    if (konijnX < width / 2) {        // head        stroke(0);        fill(255, 183, 234);        // left ear        ellipse(konijnX - 25, konijnY - 60, 30, 70);        fill(255, 127, 217);        ellipse(konijnX - 25, konijnY - 60, 15, 40);        fill(255, 183, 234);        // right ear        ellipse(konijnX + 25, konijnY - 60, 30, 70);        fill(255, 127, 217);        ellipse(konijnX + 25, konijnY - 60, 15, 40);        fill(255, 183, 234);        // head        ellipse(konijnX - 0, konijnY + 0, 100, 100);        fill(255);        // left eye        ellipse(konijnX - 14, konijnY - 18, 25, 25);        // right eye        ellipse(konijnX + 14, konijnY - 18, 25, 25);        fill(0);        // left iris        ellipse(konijnX - 14, konijnY - 18, 16, 16);        // right iris        ellipse(konijnX + 14, konijnY - 18, 16, 16);        fill(255);        // left glitter        ellipse(konijnX - 17, konijnY - 21, 7, 7);        // right glitter        ellipse(konijnX + 11, konijnY - 21, 7, 7);        // left little glitter        ellipse(konijnX - 16, konijnY - 16, 4, 4);        // right little glitter        ellipse(konijnX + 13, konijnY - 16, 4, 4);        fill(255, 127, 217);        // nose        triangle(konijnX - 8, konijnY + 8, konijnX + 8, konijnY + 8, konijnX + 0, konijnY - 4);        noFill();        // mouth        arc(konijnX - 12, konijnY + 8, 25, 35, 0, PI);        arc(konijnX + 12, konijnY + 8, 25, 35, 0, PI);    } else {        stroke(0);        fill(230, 168, 220);        // left ear        ellipse(konijnX - 25, konijnY - 60, 30, 70);        fill(203, 104, 174);        ellipse(konijnX - 25, konijnY - 60, 15, 40);        fill(230, 168, 220);        // right ear        ellipse(konijnX + 25, konijnY - 60, 30, 70);        fill(203, 104, 174);        ellipse(konijnX + 25, konijnY - 60, 15, 40);        fill(230, 168, 220);        // head        ellipse(konijnX - 0, konijnY + 0, 100, 100);        // eyes shut        arc(konijnX - 16, konijnY - 25, 20, 25, TWO_PI, TWO_PI + PI);        arc(konijnX + 16, konijnY - 25, 20, 25, TWO_PI, TWO_PI + PI);        fill(203, 104, 174);        // nose        triangle(konijnX - 8, konijnY + 8, konijnX + 8, konijnY + 8, konijnX + 0, konijnY - 4);        noFill();        // mouth        arc(konijnX - 12, konijnY + 8, 25, 35, 0, PI);        arc(konijnX + 12, konijnY + 8, 25, 35, 0, PI);    }}',LongMethodRule
'fill(158, 236, 255);',correct
'arc(konijnX - 16, konijnY - 25, 20, 25, TWO_PI, TWO_PI + PI)',correct
'ellipse(konijnX - 25, konijnY - 60, 15, 40)',correct
'konijnY - 21',correct
'stroke(243, 243, 4);',correct
'// initialize zon object by calling constructormijnZon = new Zon();',correct
'xspeed = -xspeed',correct
'maanY = height / 2;',correct
'{    zonX = width / 2;    zonY = height / 2;}',correct
'mijnKonijn[i].display();',correct
'width - 50',correct
'arc(zonX + 0, zonY + 0, 120, 120, HALF_PI, HALF_PI + PI, OPEN)',correct
'arc(konijnX + 12, konijnY + 8, 25, 35, 0, PI);',correct
'fill(0);',correct
'maanY + 0',correct
'konijnX + 16',correct
'if (konijnY <= 95 || konijnY >= height - 50) {    yspeed = -yspeed;}',correct
'maanY - 22',correct
'fill(230, 168, 220)',correct
'konijnX + 12',correct
'float yspeed = random(1, 3);',correct
'konijnX + 11',correct
'konijnX + 14',correct
'konijnX + 13',correct
'class Zon {    int zonX;    int zonY;    Zon() {        zonX = width / 2;        zonY = height / 2;    }    void display() {        noStroke();        fill(243, 243, 4);        arc(zonX + 0, zonY + 0, 120, 120, HALF_PI, HALF_PI + PI, OPEN);        stroke(243, 243, 4);        strokeWeight(5);        pushMatrix();        translate(width / 2, height / 2);        rotate(radians(45));        for (int i = 0; i <= 6; i++) {            line(60, 60, 100, 100);            rotate(radians(30));        }        popMatrix();        strokeWeight(1);    }}',correct
'// pixels of screenfor (int i = 0; i <= 9; i++) {    // making 10 bunnys at random places    mijnKonijn[i] = new Konijn(random(50, width - 50), random(95, height - 50));    frameRate(80);}',correct
'mijnMaan.display();',correct
'fill(203, 104, 174);',correct
'ellipse(maanX + 30, maanY - 22, 22, 22);',correct
'for (int i = 0; i <= 6; i++) {    line(60, 60, 100, 100);    rotate(radians(30));}',correct
'void move() {    // giving speed    konijnX = konijnX + xspeed;    konijnY = konijnY + yspeed;    if (konijnX <= 50 || konijnX >= width - 50) {        // bouncing off walls        xspeed = -xspeed;    }    if (konijnY <= 95 || konijnY >= height - 50) {        yspeed = -yspeed;    }}',correct
'// moutharc(konijnX - 12, konijnY + 8, 25, 35, 0, PI);',correct
'{    // head    stroke(0);    fill(255, 183, 234);    // left ear    ellipse(konijnX - 25, konijnY - 60, 30, 70);    fill(255, 127, 217);    ellipse(konijnX - 25, konijnY - 60, 15, 40);    fill(255, 183, 234);    // right ear    ellipse(konijnX + 25, konijnY - 60, 30, 70);    fill(255, 127, 217);    ellipse(konijnX + 25, konijnY - 60, 15, 40);    fill(255, 183, 234);    // head    ellipse(konijnX - 0, konijnY + 0, 100, 100);    fill(255);    // left eye    ellipse(konijnX - 14, konijnY - 18, 25, 25);    // right eye    ellipse(konijnX + 14, konijnY - 18, 25, 25);    fill(0);    // left iris    ellipse(konijnX - 14, konijnY - 18, 16, 16);    // right iris    ellipse(konijnX + 14, konijnY - 18, 16, 16);    fill(255);    // left glitter    ellipse(konijnX - 17, konijnY - 21, 7, 7);    // right glitter    ellipse(konijnX + 11, konijnY - 21, 7, 7);    // left little glitter    ellipse(konijnX - 16, konijnY - 16, 4, 4);    // right little glitter    ellipse(konijnX + 13, konijnY - 16, 4, 4);    fill(255, 127, 217);    // nose    triangle(konijnX - 8, konijnY + 8, konijnX + 8, konijnY + 8, konijnX + 0, konijnY - 4);    noFill();    // mouth    arc(konijnX - 12, konijnY + 8, 25, 35, 0, PI);    arc(konijnX + 12, konijnY + 8, 25, 35, 0, PI);}',correct
'random(1, 3)',correct
'konijnY <= 95 || konijnY >= height - 50',correct
'rect(0, 0, width / 2, height);',PixelHardcodeIgnoranceRule
'translate(width / 2, height / 2)',correct
'popMatrix();',correct
'ellipse(maanX + 15, maanY - 50, 18, 12);',correct
'fill(255, 127, 217);',correct
'// right irisellipse(konijnX + 14, konijnY - 18, 16, 16);',correct
'mijnKonijn[i].display()',correct
'zonY = height / 2;',correct
'fill(243, 243, 4)',correct
'noStroke()',correct
'rect(0, 0, width / 2, height)',correct
'konijnY = konijnY + yspeed',correct
'fill(255, 183, 234)',correct
'{    stroke(0);    fill(230, 168, 220);    // left ear    ellipse(konijnX - 25, konijnY - 60, 30, 70);    fill(203, 104, 174);    ellipse(konijnX - 25, konijnY - 60, 15, 40);    fill(230, 168, 220);    // right ear    ellipse(konijnX + 25, konijnY - 60, 30, 70);    fill(203, 104, 174);    ellipse(konijnX + 25, konijnY - 60, 15, 40);    fill(230, 168, 220);    // head    ellipse(konijnX - 0, konijnY + 0, 100, 100);    // eyes shut    arc(konijnX - 16, konijnY - 25, 20, 25, TWO_PI, TWO_PI + PI);    arc(konijnX + 16, konijnY - 25, 20, 25, TWO_PI, TWO_PI + PI);    fill(203, 104, 174);    // nose    triangle(konijnX - 8, konijnY + 8, konijnX + 8, konijnY + 8, konijnX + 0, konijnY - 4);    noFill();    // mouth    arc(konijnX - 12, konijnY + 8, 25, 35, 0, PI);    arc(konijnX + 12, konijnY + 8, 25, 35, 0, PI);}',correct
'mijnMaan = new Maan();',correct
'mijnKonijn[i]',correct
'// right little glitterellipse(konijnX + 13, konijnY - 16, 4, 4);',correct
'if (konijnX <= 50 || konijnX >= width - 50) {    // bouncing off walls    xspeed = -xspeed;}',correct
'rotate(radians(45));',correct
'-yspeed',correct
'konijnX + xspeed',correct
'mijnMaan',correct
'radians(30)',correct
'xspeed = random(1, 3)',correct
'mijnKonijn[i] = new Konijn(random(50, width - 50), random(95, height - 50))',correct
'fill(0)',correct
'height / 2',correct
'yspeed = random(1, 3)',correct
'konijnX + 25',correct
'zonX = width / 2',correct
'// nosetriangle(konijnX - 8, konijnY + 8, konijnX + 8, konijnY + 8, konijnX + 0, konijnY - 4);',correct
'HALF_PI + PI',correct
'line(60, 60, 100, 100)',correct
'konijnY <= 95',correct
'zonX + 0',correct
'Maan',correct
'konijnY - 4',correct
'fill(255)',correct
'TWO_PI + PI',correct
'// arrayKonijn[] mijnKonijn = new Konijn[10];',correct
'Processing',correct
'float xspeed = random(1, 3);',correct
'ellipse(konijnX + 25, konijnY - 60, 30, 70)',correct
'maanX + 9',correct
'zonY = height / 2',correct
'pushMatrix()',correct
'ellipse(maanX + 9, maanY + 0, 12, 12)',correct
'maanX + 0',correct
'maanX = width / 2;',correct
'{    // giving speed    konijnX = konijnX + xspeed;    konijnY = konijnY + yspeed;    if (konijnX <= 50 || konijnX >= width - 50) {        // bouncing off walls        xspeed = -xspeed;    }    if (konijnY <= 95 || konijnY >= height - 50) {        yspeed = -yspeed;    }}',correct
'mijnZon',correct
'noFill()',correct
'{    // pixels of screen    for (int i = 0; i <= 9; i++) {        // making 10 bunnys at random places        mijnKonijn[i] = new Konijn(random(50, width - 50), random(95, height - 50));        frameRate(80);    }    // initialize zon object by calling constructor    mijnZon = new Zon();    mijnMaan = new Maan();}',correct
'{    // bouncing off walls    xspeed = -xspeed;}',correct
'{    background(58, 52, 112);    fill(158, 236, 255);    rect(0, 0, width / 2, height);    // display zon    mijnZon.display();    mijnMaan.display();    for (int i = 0; i <= 9; i++) {        mijnKonijn[i].display();        mijnKonijn[i].move();    }}',correct
'mijnZon.display()',correct
'konijnX',correct
'rotate(radians(30))',correct
'for (int i = 0; i <= 9; i++) {    mijnKonijn[i].display();    mijnKonijn[i].move();}',correct
'int i = 0',correct
'konijnY',correct
'mijnZon = new Zon()',correct
'ellipse(maanX + 30, maanY - 22, 22, 22)',correct
'setup',correct
'-xspeed',correct
'{    konijnX = x;    konijnY = y;    // center of ellipse is in center of ellipse    ellipseMode(CENTER);}',correct
'maanY - 50',correct
'yspeed = -yspeed',correct
'i = 0',correct
'ellipse(konijnX + 14, konijnY - 18, 16, 16)',correct
'Zon() {    zonX = width / 2;    zonY = height / 2;}',correct
'ellipse(konijnX + 11, konijnY - 21, 7, 7)',correct
'radians(45)',correct
'mijnKonijn[i].move()',correct
'int maanY;',correct
'konijnX - 17',correct
'konijnX <= 50 || konijnX >= width - 50',correct
'konijnX - 16',correct
'ellipse(konijnX + 25, konijnY - 60, 15, 40)',correct
'konijnX - 14',correct
'maanY = height / 2',correct
'arc(konijnX + 16, konijnY - 25, 20, 25, TWO_PI, TWO_PI + PI);',correct
'// right glitterellipse(konijnX + 11, konijnY - 21, 7, 7);',correct
'konijnY >= height - 50',correct
'// display zonmijnZon.display();',correct
'// right earellipse(konijnX + 25, konijnY - 60, 30, 70);',correct
'konijnX - 12',correct
'strokeWeight(5);',correct
'yspeed = -yspeed;',correct
'// right eyeellipse(konijnX + 14, konijnY - 18, 25, 25);',correct
'zonY + 0',correct
'maanX + 37',correct
'noStroke();',correct
'random(95, height - 50)',correct
'ellipse(konijnX - 25, konijnY - 60, 30, 70)',correct
'translate(width / 2, height / 2);',correct
'ellipse(konijnX + 25, konijnY - 60, 15, 40);',correct
'fill(220, 220, 156);',correct
'rotate(radians(30));',correct
'konijnY + 0',correct
'ellipse(konijnX - 17, konijnY - 21, 7, 7)',correct
'class Maan {    int maanX;    int maanY;    Maan() {        maanX = width / 2;        maanY = height / 2;    }    void display() {        noStroke();        fill(247, 247, 175);        arc(maanX + 0, maanY + 0, 120, 120, HALF_PI + PI, TWO_PI + HALF_PI, OPEN);        fill(220, 220, 156);        ellipse(maanX + 30, maanY - 22, 22, 22);        ellipse(maanX + 9, maanY + 0, 12, 12);        ellipse(maanX + 15, maanY - 50, 18, 12);        ellipse(maanX + 37, maanY + 22, 30, 30);        ellipse(maanX + 15, maanY + 45, 18, 15);    }}',correct
'strokeWeight(1)',correct
'zonX = width / 2;',correct
'triangle(konijnX - 8, konijnY + 8, konijnX + 8, konijnY + 8, konijnX + 0, konijnY - 4)',correct
'konijnY + 8',correct
'maanX + 30',correct
'line(60, 60, 100, 100);',correct
'konijnX - 0',correct
'fill(247, 247, 175)',correct
'mijnKonijn[i].move();',correct
'arc(maanX + 0, maanY + 0, 120, 120, HALF_PI + PI, TWO_PI + HALF_PI, OPEN);',correct
'fill(243, 243, 4);',correct
'frameRate(80)',correct
'konijnX - 8',correct
'TWO_PI + HALF_PI',correct
'ellipse(konijnX - 16, konijnY - 16, 4, 4)',correct
'fill(255, 127, 217)',correct
'Konijn(float x, float y) {    konijnX = x;    konijnY = y;    // center of ellipse is in center of ellipse    ellipseMode(CENTER);}',correct
'// left little glitterellipse(konijnX - 16, konijnY - 16, 4, 4);',correct
'konijnY + yspeed',correct
'display',LongMethodRule
'draw',correct
'ellipse(konijnX - 0, konijnY + 0, 100, 100)',correct
'int maanX;',correct
'// giving speedkonijnX = konijnX + xspeed;',correct
'// declare objectZon mijnZon;',correct
'void display() {    noStroke();    fill(247, 247, 175);    arc(maanX + 0, maanY + 0, 120, 120, HALF_PI + PI, TWO_PI + HALF_PI, OPEN);    fill(220, 220, 156);    ellipse(maanX + 30, maanY - 22, 22, 22);    ellipse(maanX + 9, maanY + 0, 12, 12);    ellipse(maanX + 15, maanY - 50, 18, 12);    ellipse(maanX + 37, maanY + 22, 30, 30);    ellipse(maanX + 15, maanY + 45, 18, 15);}',correct
'// co\u00f6rdinate y-axis konijnfloat konijnY;',correct
'konijnY = konijnY + yspeed;',correct
'// headstroke(0);',correct
'{    noStroke();    fill(243, 243, 4);    arc(zonX + 0, zonY + 0, 120, 120, HALF_PI, HALF_PI + PI, OPEN);    stroke(243, 243, 4);    strokeWeight(5);    pushMatrix();    translate(width / 2, height / 2);    rotate(radians(45));    for (int i = 0; i <= 6; i++) {        line(60, 60, 100, 100);        rotate(radians(30));    }    popMatrix();    strokeWeight(1);}',correct
'arc(konijnX - 12, konijnY + 8, 25, 35, 0, PI)',correct
'maanX + 15',correct
'konijnX - 25',correct
'konijnY = y',correct
'konijnX >= width - 50',correct
'ellipse(konijnX - 14, konijnY - 18, 25, 25)',correct
'int zonY;',correct
'i++',correct
'Konijn',correct
'{    mijnKonijn[i].display();    mijnKonijn[i].move();}',correct
'konijnX = x;',correct
'new Konijn(random(50, width - 50), random(95, height - 50))',correct
'fill(255);',correct
'ellipseMode(CENTER)',correct
'// left irisellipse(konijnX - 14, konijnY - 18, 16, 16);',correct
'background(58, 52, 112)',correct
'maanY + 22',correct
'maanY',correct
'zonY',correct
'void setup() {    // pixels of screen    for (int i = 0; i <= 9; i++) {        // making 10 bunnys at random places        mijnKonijn[i] = new Konijn(random(50, width - 50), random(95, height - 50));        frameRate(80);    }    // initialize zon object by calling constructor    mijnZon = new Zon();    mijnMaan = new Maan();}',correct
'maanX',correct
'konijnY = y;',correct
'konijnX <= 50',correct
'void',correct
'fill(230, 168, 220);',correct
'i <= 6',correct
'zonX',correct
'arc(konijnX + 12, konijnY + 8, 25, 35, 0, PI)',correct
'int zonX;',correct
'// center of ellipse is in center of ellipseellipseMode(CENTER);',correct
'arc(zonX + 0, zonY + 0, 120, 120, HALF_PI, HALF_PI + PI, OPEN);',correct
'noFill();',correct
'Zon',correct
'// making 10 bunnys at random placesmijnKonijn[i] = new Konijn(random(50, width - 50), random(95, height - 50));',correct
'class Konijn {    // co\u00f6rdinate x-axis konijn    float konijnX;    // co\u00f6rdinate y-axis konijn    float konijnY;    float yspeed = random(1, 3);    float xspeed = random(1, 3);    Konijn(float x, float y) {        konijnX = x;        konijnY = y;        // center of ellipse is in center of ellipse        ellipseMode(CENTER);    }    void display() {        if (konijnX < width / 2) {            // head            stroke(0);            fill(255, 183, 234);            // left ear            ellipse(konijnX - 25, konijnY - 60, 30, 70);            fill(255, 127, 217);            ellipse(konijnX - 25, konijnY - 60, 15, 40);            fill(255, 183, 234);            // right ear            ellipse(konijnX + 25, konijnY - 60, 30, 70);            fill(255, 127, 217);            ellipse(konijnX + 25, konijnY - 60, 15, 40);            fill(255, 183, 234);            // head            ellipse(konijnX - 0, konijnY + 0, 100, 100);            fill(255);            // left eye            ellipse(konijnX - 14, konijnY - 18, 25, 25);            // right eye            ellipse(konijnX + 14, konijnY - 18, 25, 25);            fill(0);            // left iris            ellipse(konijnX - 14, konijnY - 18, 16, 16);            // right iris            ellipse(konijnX + 14, konijnY - 18, 16, 16);            fill(255);            // left glitter            ellipse(konijnX - 17, konijnY - 21, 7, 7);            // right glitter            ellipse(konijnX + 11, konijnY - 21, 7, 7);            // left little glitter            ellipse(konijnX - 16, konijnY - 16, 4, 4);            // right little glitter            ellipse(konijnX + 13, konijnY - 16, 4, 4);            fill(255, 127, 217);            // nose            triangle(konijnX - 8, konijnY + 8, konijnX + 8, konijnY + 8, konijnX + 0, konijnY - 4);            noFill();            // mouth            arc(konijnX - 12, konijnY + 8, 25, 35, 0, PI);            arc(konijnX + 12, konijnY + 8, 25, 35, 0, PI);        } else {            stroke(0);            fill(230, 168, 220);            // left ear            ellipse(konijnX - 25, konijnY - 60, 30, 70);            fill(203, 104, 174);            ellipse(konijnX - 25, konijnY - 60, 15, 40);            fill(230, 168, 220);            // right ear            ellipse(konijnX + 25, konijnY - 60, 30, 70);            fill(203, 104, 174);            ellipse(konijnX + 25, konijnY - 60, 15, 40);            fill(230, 168, 220);            // head            ellipse(konijnX - 0, konijnY + 0, 100, 100);            // eyes shut            arc(konijnX - 16, konijnY - 25, 20, 25, TWO_PI, TWO_PI + PI);            arc(konijnX + 16, konijnY - 25, 20, 25, TWO_PI, TWO_PI + PI);            fill(203, 104, 174);            // nose            triangle(konijnX - 8, konijnY + 8, konijnX + 8, konijnY + 8, konijnX + 0, konijnY - 4);            noFill();            // mouth            arc(konijnX - 12, konijnY + 8, 25, 35, 0, PI);            arc(konijnX + 12, konijnY + 8, 25, 35, 0, PI);        }    }    void move() {        // giving speed        konijnX = konijnX + xspeed;        konijnY = konijnY + yspeed;        if (konijnX <= 50 || konijnX >= width - 50) {            // bouncing off walls            xspeed = -xspeed;        }        if (konijnY <= 95 || konijnY >= height - 50) {            yspeed = -yspeed;        }    }}',correct
'i <= 9',correct
'ellipse(maanX + 15, maanY + 45, 18, 15)',correct
'fill(203, 104, 174)',correct
'konijnY - 60',correct
'{    noStroke();    fill(247, 247, 175);    arc(maanX + 0, maanY + 0, 120, 120, HALF_PI + PI, TWO_PI + HALF_PI, OPEN);    fill(220, 220, 156);    ellipse(maanX + 30, maanY - 22, 22, 22);    ellipse(maanX + 9, maanY + 0, 12, 12);    ellipse(maanX + 15, maanY - 50, 18, 12);    ellipse(maanX + 37, maanY + 22, 30, 30);    ellipse(maanX + 15, maanY + 45, 18, 15);}',correct
'ellipse(maanX + 15, maanY + 45, 18, 15);',correct
'popMatrix()',correct
'fill(158, 236, 255)',correct
'fill(220, 220, 156)',correct
'new Maan()',correct
'[10]',correct
'arc(maanX + 0, maanY + 0, 120, 120, HALF_PI + PI, TWO_PI + HALF_PI, OPEN)',correct
'ellipse(konijnX + 13, konijnY - 16, 4, 4)',correct
'konijnX + 0',correct
'maanX = width / 2',correct
'strokeWeight(5)',correct
'// left eyeellipse(konijnX - 14, konijnY - 18, 25, 25);',correct
'maanY + 45',correct
'ellipse(maanX + 37, maanY + 22, 30, 30);',correct
'konijnX + 8',correct
'{    yspeed = -yspeed;}',correct
'Maan() {    maanX = width / 2;    maanY = height / 2;}',correct
'fill(247, 247, 175);',correct
'ellipse(konijnX - 14, konijnY - 18, 16, 16)',correct
'move',correct
'float x',correct
'float y',correct
'{    maanX = width / 2;    maanY = height / 2;}',correct
'konijnX = x',correct
'// left glitterellipse(konijnX - 17, konijnY - 21, 7, 7);',correct
'width / 2',correct
'konijnX < width / 2',correct
'void draw() {    background(58, 52, 112);    fill(158, 236, 255);    rect(0, 0, width / 2, height);    // display zon    mijnZon.display();    mijnMaan.display();    for (int i = 0; i <= 9; i++) {        mijnKonijn[i].display();        mijnKonijn[i].move();    }}',correct
'ellipse(maanX + 37, maanY + 22, 30, 30)',correct
'stroke(243, 243, 4)',correct
'ellipse(maanX + 15, maanY - 50, 18, 12)',correct
'new Zon()',correct
'mijnKonijn = new Konijn[10]',correct
'x > width - bodyX - 50',correct
'color(0xff000000)',correct
'mouseY < y + bodyY',correct
'if (!keyPressed) {    value = false;    kleurStrik = color(random(255), random(255), random(255), random(255));}',DecentralizedEventHandlingRule
'(int) random(1, 5)',correct
'// peng08 = new BodyPenguin (random(100,500),random(100,500));',correct
'// x direction of the snowflakes',correct
'// Quirine Vafi',correct
'x + stepSize',correct
'peng01',correct
'int randomX = (int) random(width);',correct
'peng03',correct
'"key pressed"',correct
'posX - 9',correct
'peng02',correct
'posX - 8',correct
'snowflakes[i].display();',correct
'// peng07.move();',correct
'float posX;',TooManyFields
'posX = mouseX',correct
'posX - 5',correct
'x = PApplet.parseInt(random(width))',correct
'{}',correct
'fill(0xffffffff)',correct
'-height',correct
'random(-height)',correct
'float bodyY = 80;',correct
'mouthPeng = color(0xffFFAD29);',correct
'/*snelheid naar rechts)*/',correct
'int ydirection = 1;',correct
'// BodyPenguin peng09;',correct
'size',correct
'mouseX > x && mouseX < x && mouseY > y - bodyY',correct
'if (y > height + size) {    // start outside screen on top (0 minus size of snowball)    y = 0 - size;    // start random on screen    x = PApplet.parseInt(random(width));}',correct
'BodyPenguin(float initX, float initY) {    x = initX;    y = initY;    bodyPeng = color(0xff000000);    bellyPeng = color(0xffFFFFFF);    feetPeng = color(0xffFFC248);    mouthPeng = color(0xffFFAD29);}',TooManyFields
'triangle(posX, posY - 30, posX + 15, posY - 38, posX + 15, posY + -22);',correct
'ellipse(posX, posY + 8, bodyX - 8, bodyY - 20)',correct
'peng01 = new BodyPenguin(random(50, 500), random(50, 500))',correct
'y = tempY',correct
'ellipse(posX - 8, posY - 57, bodyX - 65, bodyY - 75)',correct
'y = y + speed',correct
'{    x = initX;    y = initY;    bodyPeng = color(0xff000000);    bellyPeng = color(0xffFFFFFF);    feetPeng = color(0xffFFC248);    mouthPeng = color(0xffFFAD29);}',correct
'// println("k pressed" + key);',correct
'// peng09.strik();',correct
'void strik() {    if (keyPressed) {        if (key == k || key == K) {            value = true;            kleurStrik = color(random(255), random(255), random(255), random(255));        }        if (!keyPressed) {            value = false;            kleurStrik = color(random(255), random(255), random(255), random(255));        }    }    println("value" + value);    println("key pressed" + keyPressed);// println("keypressed" + keyPressed);// println("k pressed" + key);}',TooManyFields
'peng01.display();',correct
'mouseX > x',correct
'fill(bellyPeng);',correct
'// x direction of the snowflakesy = y + speed;',correct
'posY - 38',correct
'println("value" + value)',correct
'posY = mouseY;',DecentralizedEventHandlingRule
'{    snowflakes[i].display();    if (i % 2 == 0) {        // richting        snowflakes[i].move(mouseX);    } else {        // de helft van de balletjes reageren op x en de andere op y        snowflakes[i].move(mouseX);    }}',correct
'// BodyPenguin peng08;',correct
'K',correct
'// peng04.display();',correct
'height + size',correct
'posX + 10',correct
'speed = tempSpeed',correct
'x = initX',correct
'ellipse(posX, posY - 55, bodyX - 20, bodyY - 40);',correct
'feetPeng',correct
'posX + 15',correct
'y = mouseY',correct
'// peng05.move();',correct
'triangle(posX, posY - 30, posX - 15, posY - 38, posX - 15, posY + -22)',correct
'posY - 30',correct
'triangle(posX - 10, posY + 25, posX - 10, posY + 40, posX - 35, posY + 40)',correct
'snowflakes.length',correct
'stroke(1);',correct
'k',correct
'// peng04.strik();',correct
'fill(feetPeng)',correct
'{    float bodyX = 60;    float bodyY = 80;    float posX = x;    float posY = y;    // ice platform    stroke(2);    fill(0xffffffff);    ellipse(posX, posY + 40, bodyX + 45, bodyY - 30);    // feet    fill(feetPeng);    stroke(1);    triangle(posX - 10, posY + 25, posX - 10, posY + 40, posX - 35, posY + 40);    triangle(posX + 10, posY + 25, posX + 35, posY + 40, posX + 10, posY + 40);    // arms    fill(bodyPeng);    arc(posX + 32, posY - 20, 35, 30, 0, PI + QUARTER_PI, CHORD);    arc(posX - 32, posY - 20, 35, 30, -PI / 4, PI, CHORD);    // body    fill(bodyPeng);    ellipse(posX, posY, bodyX, bodyY);    fill(bellyPeng);    ellipse(posX, posY + 8, bodyX - 8, bodyY - 20);    // strikje    fill(kleurStrik);    triangle(posX, posY - 30, posX - 15, posY - 38, posX - 15, posY + -22);    triangle(posX, posY - 30, posX + 15, posY - 38, posX + 15, posY + -22);    // head    fill(bodyPeng);    ellipse(posX, posY - 55, bodyX - 20, bodyY - 40);    // face    fill(bellyPeng);    noStroke();    ellipse(posX - 9, posY - 55, bodyX - 43, bodyY - 55);    ellipse(posX + 9, posY - 55, bodyX - 43, bodyY - 55);    ellipse(posX, posY - 47, bodyX - 30, bodyY - 61);    // mouth    fill(mouthPeng);    stroke(1);    triangle(posX - 5, posY - 50, posX + 5, posY - 50, posX, posY - 38);    // eyes    fill(bodyPeng);    ellipse(posX - 8, posY - 57, bodyX - 65, bodyY - 75);    ellipse(posX + 8, posY - 57, bodyX - 65, bodyY - 75);}',LongMethodRule
'int ballAmount = 100;',correct
'x',correct
'y',correct
'ellipse(posX, posY - 47, bodyX - 30, bodyY - 61)',correct
'posY - 20',correct
'height - bodyY - 60',correct
'Snowflakes[] snowflakes;',correct
'float yspeed = (random(1, 5));',TooManyFields
'BodyPenguin peng03;',correct
'x = 0 - size',correct
'x = mouseX',correct
'(int) map(tempDirX, 2, width, -5, /*(snelheid naar links)*/5)',correct
'fill(0xffffffff);',correct
'bodyX - 30',correct
'locked == true',correct
'Snowflakes',correct
'random(5, 15)',correct
'posX + 32',correct
'peng02.display()',correct
'posX + 35',correct
'posX + 9',correct
'posX + 8',correct
'// peng07.strik();',correct
'{    if (keyPressed) {        if (key == k || key == K) {            value = true;            kleurStrik = color(random(255), random(255), random(255), random(255));        }        if (!keyPressed) {            value = false;            kleurStrik = color(random(255), random(255), random(255), random(255));        }    }    println("value" + value);    println("key pressed" + keyPressed);// println("keypressed" + keyPressed);// println("k pressed" + key);}',correct
'peng03.display();',correct
'posX + 5',correct
'peng03 = new BodyPenguin(random(50, 500), random(50, 500))',correct
'{    value = true;    kleurStrik = color(random(255), random(255), random(255), random(255));}',correct
'posY + 25',correct
'size = tempSize;',correct
'// peng10.move();',correct
'{    x = mouseX;    y = mouseY;}',correct
'randomSize = (int) random(5, 15)',correct
'peng01.move()',correct
'if (i % 2 == 0) {    // richting    snowflakes[i].move(mouseX);} else {    // de helft van de balletjes reageren op x en de andere op y    snowflakes[i].move(mouseX);}',correct
'locked = false',correct
'int bodyPeng;',TooManyFields
'x = width + size',correct
'int size;',correct
'bodyX - 43',correct
'posX',correct
'posY = y',correct
'posY',correct
'peng03 = new BodyPenguin(random(50, 500), random(50, 500));',correct
'int xdirection = 1;',TooManyFields
'ellipse(posX + 8, posY - 57, bodyX - 65, bodyY - 75)',correct
'int randomSpeed = (int) random(1, 5)',correct
'int ballColor;',correct
'ellipse(posX + 9, posY - 55, bodyX - 43, bodyY - 55);',correct
'triangle(posX + 10, posY + 25, posX + 35, posY + 40, posX + 10, posY + 40)',correct
'posX = x',correct
'float x;',TooManyFields
'{    // x direction of the snowflakes    y = y + speed;    if (y > height + size) {        // start outside screen on top (0 minus size of snowball)        y = 0 - size;        // start random on screen        x = PApplet.parseInt(random(width));    }    int stepSize = (int) map(tempDirX, 2, width, -5, /*(snelheid naar links)*/    5);    x = x + stepSize;    if (x > width + size) {        x = 0 - size;    } else if (x < -size) {        x = width + size;    }}',correct
'ellipse(posX - 9, posY - 55, bodyX - 43, bodyY - 55);',correct
'Processing',correct
'if (locked == true) {    x = mouseX;    y = mouseY;}',SimplifyBooleanExpressions
'x = x + stepSize;',correct
'int feetPeng;',TooManyFields
'// peng04 = new BodyPenguin (random(100,500),random(100,500));// peng05 = new BodyPenguin (random(100,500),random(100,500));// peng06 = new BodyPenguin (random(100,500),random(100,500));// peng07 = new BodyPenguin (random(100,500),random(100,500));// peng08 = new BodyPenguin (random(100,500),random(100,500));// peng09 = new BodyPenguin (random(100,500),random(100,500));// peng10 = new BodyPenguin (random(100,500),random(100,500));snowflakes = new Snowflakes[ballAmount];',correct
'posY + 8',correct
'ballColor = color(0xffFFFFFF);',correct
'peng03.move();',correct
'BodyPenguin peng02;',correct
'// println("keypressed" + keyPressed);',correct
'{    background(0xff3AB8FA);    println(overPeng);    peng01.display();    peng02.display();    peng03.display();    // peng04.display();    // peng05.display();    // peng06.display();    // peng07.display();    // peng08.display();    // peng09.display();    // peng10.display();    peng01.move();    peng02.move();    peng03.move();    // peng04.move();    // peng05.move();    // peng06.move();    // peng07.move();    // peng08.move();    // peng09.move();    // peng10.move();    peng01.strik();    peng02.strik();    peng03.strik();    for (int i = 0; i < snowflakes.length; i++) {        snowflakes[i].display();        if (i % 2 == 0) {            // richting            snowflakes[i].move(mouseX);        } else {            // de helft van de balletjes reageren op x en de andere op y            snowflakes[i].move(mouseX);        }    }}',correct
'y > height + size',correct
'false',correct
'float y;',TooManyFields
'// peng09.move();',correct
'new Snowflakes(randomX, randomY, randomSize, randomSpeed)',correct
'bellyPeng = color(0xffFFFFFF)',correct
'// BodyPenguin peng07;',correct
'value = true;',correct
'bodyX - 65',correct
'int stepSize = (int) map(tempDirX, 2, width, -5, /*(snelheid naar links)*/5);',correct
'float posY;',TooManyFields
'posY + 40',correct
'value = false',correct
'setup',correct
'ellipse(posX - 8, posY - 57, bodyX - 65, bodyY - 75);',correct
'i = 0',correct
'mousePressed == true',correct
'println(overPeng)',correct
'{    locked = true;    posX = mouseX;    posY = mouseY;}',correct
'{    int randomX = (int) random(width);    // -height omdat de balletjes anders al in het scherm beginnen    int randomY = (int) random(-height);    int randomSize = (int) random(5, 15);    int randomSpeed = (int) random(1, 5);    snowflakes[i] = new Snowflakes(randomX, randomY, randomSize, randomSpeed);}',correct
'bodyY = 80',correct
'// Quirine Vafi// 2204207BodyPenguin peng01;',correct
'int randomSpeed = (int) random(1, 5);',correct
'y = initY',correct
'posX - 10',correct
'"key pressed" + keyPressed',correct
'posX - 15',correct
'float bodyX;',TooManyFields
'// peng10.display();',correct
'ellipse(posX, posY + 8, bodyX - 8, bodyY - 20);',correct
'// start random on screenx = PApplet.parseInt(random(width));',correct
'bellyPeng',correct
'new BodyPenguin(random(50, 500), random(50, 500))',correct
'int kleurStrik = color(random(255), random(255), random(255));',TooManyFields
'"value" + value',correct
'{    locked = false;}',correct
'{    value = false;    kleurStrik = color(random(255), random(255), random(255), random(255));}',correct
'noStroke();',correct
'float posY = y;',correct
'float bodyY;',TooManyFields
'locked = false;',correct
'color(random(255), random(255), random(255), random(255))',correct
'ellipse(posX + 9, posY - 55, bodyX - 43, bodyY - 55)',correct
'kleurStrik = color(random(255), random(255), random(255))',correct
'int mouthPeng;',TooManyFields
'y + bodyY',correct
'x > width - bodyX - 50 || x < bodyX + 40',correct
'// armsfill(bodyPeng);',correct
'posX - 32',correct
'y = mouseY;',DecentralizedEventHandlingRule
'x = mouseX;',DecentralizedEventHandlingRule
'posX - 35',correct
'y > height - bodyY - 60',correct
'-PI / 4',correct
'// peng08.display();',correct
'{    // de helft van de balletjes reageren op x en de andere op y    snowflakes[i].move(mouseX);}',correct
'kleurStrik = color(random(255), random(255), random(255), random(255))',correct
'int randomX = (int) random(width)',correct
'{    // fullScreen();    peng01 = new BodyPenguin(random(50, 500), random(50, 500));    peng02 = new BodyPenguin(random(50, 500), random(50, 500));    peng03 = new BodyPenguin(random(50, 500), random(50, 500));    // peng04 = new BodyPenguin (random(100,500),random(100,500));    // peng05 = new BodyPenguin (random(100,500),random(100,500));    // peng06 = new BodyPenguin (random(100,500),random(100,500));    // peng07 = new BodyPenguin (random(100,500),random(100,500));    // peng08 = new BodyPenguin (random(100,500),random(100,500));    // peng09 = new BodyPenguin (random(100,500),random(100,500));    // peng10 = new BodyPenguin (random(100,500),random(100,500));    snowflakes = new Snowflakes[ballAmount];    for (int i = 0; i < snowflakes.length; i++) {        int randomX = (int) random(width);        // -height omdat de balletjes anders al in het scherm beginnen        int randomY = (int) random(-height);        int randomSize = (int) random(5, 15);        int randomSpeed = (int) random(1, 5);        snowflakes[i] = new Snowflakes(randomX, randomY, randomSize, randomSpeed);    }}',correct
'// strikjefill(kleurStrik);',correct
'boolean locked = false;',TooManyFields
'draw',correct
'float bodyY = 80',correct
'// peng06.strik();',correct
'int tempDirX',correct
'x = x + (xspeed * xdirection);',correct
'// Attributes : xpos, ypos, speed, size, colourint x;',correct
'triangle(posX - 5, posY - 50, posX + 5, posY - 50, posX, posY - 38);',correct
'ydirection *= -1',correct
'overPeng = true',correct
'xspeed = (random(1, 5))',correct
'int bellyPeng;',TooManyFields
'width - bodyX - 50',correct
'peng03.strik()',correct
'mouseY > y - bodyY',correct
'y < bodyY + 70',correct
'Snowflakes(int tempX, int tempY, int tempSize, int tempSpeed) {    ballColor = color(0xffFFFFFF);    size = tempSize;    speed = tempSpeed;    x = tempX;    y = tempY;}',correct
'strik',correct
'// mouthfill(mouthPeng);',correct
'println(overPeng);',correct
'// peng09.display();',correct
'PI + QUARTER_PI',correct
'void',correct
'-1',correct
'-5',correct
'{    ydirection *= -1;}',correct
'if (!locked) {}',EmptyIfStmt
'y - bodyY',correct
'true',correct
'println("value" + value);',correct
'x = tempX;',correct
'// eyesfill(bodyPeng);',correct
'stroke(1)',correct
'int y;',correct
'ellipse(posX - 9, posY - 55, bodyX - 43, bodyY - 55)',correct
'// BodyPenguin peng10;',correct
'peng03.strik();',correct
'ellipse(posX, posY + 40, bodyX + 45, bodyY - 30);',correct
'// facefill(bellyPeng);',correct
'{    overPeng = false;}',correct
'ballAmount = 100',correct
'xdirection *= -1',correct
'y + (yspeed * ydirection)',correct
'int stepSize = (int) map(tempDirX, 2, width, -5, /*(snelheid naar links)*/5)',correct
'arc(posX + 32, posY - 20, 35, 30, 0, PI + QUARTER_PI, CHORD);',correct
'peng02.move()',correct
'// headfill(bodyPeng);',correct
'yspeed = (random(1, 5))',correct
'color(0xffFFFFFF)',correct
'stroke(2)',correct
'peng02 = new BodyPenguin(random(50, 500), random(50, 500));',correct
'snowflakes[i]',correct
'(int) random(-height)',correct
'x = tempX',correct
'map(tempDirX, 2, width, -5, /*(snelheid naar links)*/5)',correct
'peng02 = new BodyPenguin(random(50, 500), random(50, 500))',correct
'boolean value = false;',correct
'random(width)',correct
'{    x = 0 - size;}',correct
'speed = tempSpeed;',correct
'x = initX;',correct
'"value"',correct
'if (mouseX > x && mouseX < x && mouseY > y - bodyY && mouseY < y + bodyY) {    overPeng = true;    if (!locked) {    }} else {    overPeng = false;}',DecentralizedEventHandlingRule
'mouseX > x && mouseX < x',correct
'height - bodyY',correct
'locked = true;',correct
'int tempSize',correct
'peng02.move();',correct
'randomSpeed = (int) random(1, 5)',correct
'feetPeng = color(0xffFFC248)',correct
'!locked',correct
'snowflakes[i].move(mouseX)',correct
'float posX = x;',correct
'// peng10 = new BodyPenguin (random(100,500),random(100,500));',correct
'peng02.display();',correct
'bodyY + 70',correct
'stepSize = (int) map(tempDirX, 2, width, -5, /*(snelheid naar links)*/5)',correct
'posX = mouseX;',DecentralizedEventHandlingRule
'// fullScreen();peng01 = new BodyPenguin(random(50, 500), random(50, 500));',correct
'{    overPeng = true;    if (!locked) {    }}',correct
'y > height - bodyY - 60 || y < bodyY + 70',correct
'float bodyX = 60;',correct
'int tempSpeed',correct
'color(random(255), random(255), random(255))',correct
'bodyPeng',correct
'// peng08.move();',correct
'// peng08.strik();',correct
'// feetfill(feetPeng);',correct
'println("key pressed" + keyPressed)',correct
'feetPeng = color(0xffFFC248);',correct
'Snowflakes[]',correct
'(int) random(5, 15)',correct
'color(0xffFFC248)',correct
'x < -size',correct
'value = true',correct
'randomX = (int) random(width)',correct
'randomY = (int) random(-height)',correct
'// -height omdat de balletjes anders al in het scherm beginnenint randomY = (int) random(-height);',correct
'arc(posX + 32, posY - 20, 35, 30, 0, PI + QUARTER_PI, CHORD)',correct
'// ice platformstroke(2);',correct
'fill(ballColor);',correct
'// peng04.move();// peng05.move();// peng06.move();// peng07.move();// peng08.move();// peng09.move();// peng10.move();peng01.strik();',correct
'random(255)',correct
'ballColor = color(0xffFFFFFF)',correct
'x = x + stepSize',correct
'arc(posX - 32, posY - 20, 35, 30, -PI / 4, PI, CHORD);',correct
'noStroke()',correct
'x = width + size;',correct
'if (mousePressed == true) {    locked = true;    posX = mouseX;    posY = mouseY;} else {    locked = false;}',DecentralizedEventHandlingRule
'fill(kleurStrik)',correct
'snowflakes[i] = new Snowflakes(randomX, randomY, randomSize, randomSpeed);',correct
'BodyPenguin',TooManyFields
'y = tempY;',correct
'x + (xspeed * xdirection)',correct
'bodyY - 40',correct
'ellipse(x, y, size, size);',correct
'color(0xffFFAD29)',correct
'y = y + (yspeed * ydirection);',correct
'int randomSize = (int) random(5, 15);',correct
'key == K',correct
'// peng04.move();',correct
'kleurStrik = color(random(255), random(255), random(255), random(255));',correct
'if (x > width + size) {    x = 0 - size;} else if (x < -size) {    x = width + size;}',correct
'// peng07 = new BodyPenguin (random(100,500),random(100,500));',correct
'{    ballColor = color(0xffFFFFFF);    size = tempSize;    speed = tempSpeed;    x = tempX;    y = tempY;}',correct
'peng03.move()',correct
'bodyY - 55',correct
'snowflakes[i].display()',correct
'overPeng = false',correct
'void draw() {    background(0xff3AB8FA);    println(overPeng);    peng01.display();    peng02.display();    peng03.display();    // peng04.display();    // peng05.display();    // peng06.display();    // peng07.display();    // peng08.display();    // peng09.display();    // peng10.display();    peng01.move();    peng02.move();    peng03.move();    // peng04.move();    // peng05.move();    // peng06.move();    // peng07.move();    // peng08.move();    // peng09.move();    // peng10.move();    peng01.strik();    peng02.strik();    peng03.strik();    for (int i = 0; i < snowflakes.length; i++) {        snowflakes[i].display();        if (i % 2 == 0) {            // richting            snowflakes[i].move(mouseX);        } else {            // de helft van de balletjes reageren op x en de andere op y            snowflakes[i].move(mouseX);        }    }}',correct
'peng03.display()',correct
'int speed;',correct
'triangle(posX, posY - 30, posX - 15, posY - 38, posX - 15, posY + -22);',correct
'// BodyPenguin peng04;// BodyPenguin peng05;// BodyPenguin peng06;// BodyPenguin peng07;// BodyPenguin peng08;// BodyPenguin peng09;// BodyPenguin peng10;boolean overPeng;',correct
'speed',correct
'background(0xff3AB8FA);',correct
'xdirection *= -1;',correct
'// peng09 = new BodyPenguin (random(100,500),random(100,500));',correct
'bodyY - 20',correct
'if (key == k || key == K) {    value = true;    kleurStrik = color(random(255), random(255), random(255), random(255));}',DecentralizedEventHandlingRule
'{    if (key == k || key == K) {        value = true;        kleurStrik = color(random(255), random(255), random(255), random(255));    }    if (!keyPressed) {        value = false;        kleurStrik = color(random(255), random(255), random(255), random(255));    }}',correct
'peng02.strik()',correct
'for (int i = 0; i < snowflakes.length; i++) {    int randomX = (int) random(width);    // -height omdat de balletjes anders al in het scherm beginnen    int randomY = (int) random(-height);    int randomSize = (int) random(5, 15);    int randomSpeed = (int) random(1, 5);    snowflakes[i] = new Snowflakes(randomX, randomY, randomSize, randomSpeed);}',correct
'ellipse(posX, posY + 40, bodyX + 45, bodyY - 30)',correct
'// peng04.display();// peng05.display();// peng06.display();// peng07.display();// peng08.display();// peng09.display();// peng10.display();peng01.move();',correct
'// fullScreen();',correct
'width + size',correct
'overPeng',correct
'if (keyPressed) {    if (key == k || key == K) {        value = true;        kleurStrik = color(random(255), random(255), random(255), random(255));    }    if (!keyPressed) {        value = false;        kleurStrik = color(random(255), random(255), random(255), random(255));    }}',correct
'-PI',correct
'bodyPeng = color(0xff000000);',correct
'[ballAmount]',correct
'PApplet.parseInt(random(width))',correct
'width - bodyX',correct
'snowflakes[i] = new Snowflakes(randomX, randomY, randomSize, randomSpeed)',correct
'fill(ballColor)',correct
'class BodyPenguin {    float x;    float y;    float xspeed = (random(1, 5));    float yspeed = (random(1, 5));    float bodyX;    float bodyY;    float posX;    float posY;    int xdirection = 1;    int ydirection = 1;    int bodyPeng;    int bellyPeng;    int feetPeng;    int mouthPeng;    int kleurStrik = color(random(255), random(255), random(255));    boolean locked = false;    boolean value = false;    BodyPenguin(float initX, float initY) {        x = initX;        y = initY;        bodyPeng = color(0xff000000);        bellyPeng = color(0xffFFFFFF);        feetPeng = color(0xffFFC248);        mouthPeng = color(0xffFFAD29);    }    void display() {        float bodyX = 60;        float bodyY = 80;        float posX = x;        float posY = y;        // ice platform        stroke(2);        fill(0xffffffff);        ellipse(posX, posY + 40, bodyX + 45, bodyY - 30);        // feet        fill(feetPeng);        stroke(1);        triangle(posX - 10, posY + 25, posX - 10, posY + 40, posX - 35, posY + 40);        triangle(posX + 10, posY + 25, posX + 35, posY + 40, posX + 10, posY + 40);        // arms        fill(bodyPeng);        arc(posX + 32, posY - 20, 35, 30, 0, PI + QUARTER_PI, CHORD);        arc(posX - 32, posY - 20, 35, 30, -PI / 4, PI, CHORD);        // body        fill(bodyPeng);        ellipse(posX, posY, bodyX, bodyY);        fill(bellyPeng);        ellipse(posX, posY + 8, bodyX - 8, bodyY - 20);        // strikje        fill(kleurStrik);        triangle(posX, posY - 30, posX - 15, posY - 38, posX - 15, posY + -22);        triangle(posX, posY - 30, posX + 15, posY - 38, posX + 15, posY + -22);        // head        fill(bodyPeng);        ellipse(posX, posY - 55, bodyX - 20, bodyY - 40);        // face        fill(bellyPeng);        noStroke();        ellipse(posX - 9, posY - 55, bodyX - 43, bodyY - 55);        ellipse(posX + 9, posY - 55, bodyX - 43, bodyY - 55);        ellipse(posX, posY - 47, bodyX - 30, bodyY - 61);        // mouth        fill(mouthPeng);        stroke(1);        triangle(posX - 5, posY - 50, posX + 5, posY - 50, posX, posY - 38);        // eyes        fill(bodyPeng);        ellipse(posX - 8, posY - 57, bodyX - 65, bodyY - 75);        ellipse(posX + 8, posY - 57, bodyX - 65, bodyY - 75);    }    void move() {        if (mousePressed == true) {            locked = true;            posX = mouseX;            posY = mouseY;        } else {            locked = false;        }        x = x + (xspeed * xdirection);        y = y + (yspeed * ydirection);        if (x > width - bodyX - 50 || x < bodyX + 40) {            xdirection *= -1;        }        if (y > height - bodyY - 60 || y < bodyY + 70) {            ydirection *= -1;        }        if (mouseX > x && mouseX < x && mouseY > y - bodyY && mouseY < y + bodyY) {            overPeng = true;            if (!locked) {            }        } else {            overPeng = false;        }        if (locked == true) {            x = mouseX;            y = mouseY;        }    }    void strik() {        if (keyPressed) {            if (key == k || key == K) {                value = true;                kleurStrik = color(random(255), random(255), random(255), random(255));            }            if (!keyPressed) {                value = false;                kleurStrik = color(random(255), random(255), random(255), random(255));            }        }        println("value" + value);        println("key pressed" + keyPressed);    // println("keypressed" + keyPressed);    // println("k pressed" + key);    }}',correct
'bodyY - 30',correct
'int i = 0',correct
'{    // start outside screen on top (0 minus size of snowball)    y = 0 - size;    // start random on screen    x = PApplet.parseInt(random(width));}',correct
'bodyX = 60',correct
'ellipse(posX + 8, posY - 57, bodyX - 65, bodyY - 75);',correct
'y = y + (yspeed * ydirection)',correct
'bodyX - 8',correct
'void setup() {    // fullScreen();    peng01 = new BodyPenguin(random(50, 500), random(50, 500));    peng02 = new BodyPenguin(random(50, 500), random(50, 500));    peng03 = new BodyPenguin(random(50, 500), random(50, 500));    // peng04 = new BodyPenguin (random(100,500),random(100,500));    // peng05 = new BodyPenguin (random(100,500),random(100,500));    // peng06 = new BodyPenguin (random(100,500),random(100,500));    // peng07 = new BodyPenguin (random(100,500),random(100,500));    // peng08 = new BodyPenguin (random(100,500),random(100,500));    // peng09 = new BodyPenguin (random(100,500),random(100,500));    // peng10 = new BodyPenguin (random(100,500),random(100,500));    snowflakes = new Snowflakes[ballAmount];    for (int i = 0; i < snowflakes.length; i++) {        int randomX = (int) random(width);        // -height omdat de balletjes anders al in het scherm beginnen        int randomY = (int) random(-height);        int randomSize = (int) random(5, 15);        int randomSpeed = (int) random(1, 5);        snowflakes[i] = new Snowflakes(randomX, randomY, randomSize, randomSpeed);    }}',correct
'y = initY;',correct
'mouthPeng',correct
'// BodyPenguin peng06;',correct
'triangle(posX, posY - 30, posX + 15, posY - 38, posX + 15, posY + -22)',correct
'x = 0 - size;',correct
'int randomSize = (int) random(5, 15)',correct
'bodyX + 45',correct
'size = tempSize',correct
'i % 2',correct
'// peng07.display();',correct
'void display() {    float bodyX = 60;    float bodyY = 80;    float posX = x;    float posY = y;    // ice platform    stroke(2);    fill(0xffffffff);    ellipse(posX, posY + 40, bodyX + 45, bodyY - 30);    // feet    fill(feetPeng);    stroke(1);    triangle(posX - 10, posY + 25, posX - 10, posY + 40, posX - 35, posY + 40);    triangle(posX + 10, posY + 25, posX + 35, posY + 40, posX + 10, posY + 40);    // arms    fill(bodyPeng);    arc(posX + 32, posY - 20, 35, 30, 0, PI + QUARTER_PI, CHORD);    arc(posX - 32, posY - 20, 35, 30, -PI / 4, PI, CHORD);    // body    fill(bodyPeng);    ellipse(posX, posY, bodyX, bodyY);    fill(bellyPeng);    ellipse(posX, posY + 8, bodyX - 8, bodyY - 20);    // strikje    fill(kleurStrik);    triangle(posX, posY - 30, posX - 15, posY - 38, posX - 15, posY + -22);    triangle(posX, posY - 30, posX + 15, posY - 38, posX + 15, posY + -22);    // head    fill(bodyPeng);    ellipse(posX, posY - 55, bodyX - 20, bodyY - 40);    // face    fill(bellyPeng);    noStroke();    ellipse(posX - 9, posY - 55, bodyX - 43, bodyY - 55);    ellipse(posX + 9, posY - 55, bodyX - 43, bodyY - 55);    ellipse(posX, posY - 47, bodyX - 30, bodyY - 61);    // mouth    fill(mouthPeng);    stroke(1);    triangle(posX - 5, posY - 50, posX + 5, posY - 50, posX, posY - 38);    // eyes    fill(bodyPeng);    ellipse(posX - 8, posY - 57, bodyX - 65, bodyY - 75);    ellipse(posX + 8, posY - 57, bodyX - 65, bodyY - 75);}',TooManyFields
'if (x < -size) {    x = width + size;}',correct
'ellipse(posX, posY - 55, bodyX - 20, bodyY - 40)',correct
'-size',correct
'overPeng = false;',DrawingStateChangeRule
'i % 2 == 0',correct
'random(50, 500)',correct
'if (x > width - bodyX - 50 || x < bodyX + 40) {    xdirection *= -1;}',correct
'y + speed',correct
'{    if (mousePressed == true) {        locked = true;        posX = mouseX;        posY = mouseY;    } else {        locked = false;    }    x = x + (xspeed * xdirection);    y = y + (yspeed * ydirection);    if (x > width - bodyX - 50 || x < bodyX + 40) {        xdirection *= -1;    }    if (y > height - bodyY - 60 || y < bodyY + 70) {        ydirection *= -1;    }    if (mouseX > x && mouseX < x && mouseY > y - bodyY && mouseY < y + bodyY) {        overPeng = true;        if (!locked) {        }    } else {        overPeng = false;    }    if (locked == true) {        x = mouseX;        y = mouseY;    }}',correct
'x > width + size',correct
'bodyPeng = color(0xff000000)',correct
'fill(mouthPeng)',correct
'// peng10.strik();',correct
'-22',correct
'{    // richting    snowflakes[i].move(mouseX);}',correct
'ydirection = 1',correct
'ellipse(posX, posY - 47, bodyX - 30, bodyY - 61);',correct
'mouseX > x && mouseX < x && mouseY > y - bodyY && mouseY < y + bodyY',correct
'if (y > height - bodyY - 60 || y < bodyY + 70) {    ydirection *= -1;}',correct
'void display() {    fill(ballColor);    noStroke();    ellipse(x, y, size, size);}',correct
'posY = mouseY',correct
'{    fill(ballColor);    noStroke();    ellipse(x, y, size, size);}',correct
'xdirection = 1',correct
'key == k',correct
'// peng05.strik();',correct
'ellipse(posX, posY, bodyX, bodyY)',correct
'ellipse(x, y, size, size)',correct
'overPeng = true;',DrawingStateChangeRule
'fill(bodyPeng)',correct
'new Snowflakes[ballAmount]',correct
'// peng06.display();',correct
'(int) random(width)',correct
'locked = true',correct
'float posX = x',correct
'posY + -22',correct
'snowflakes',correct
'snowflakes = new Snowflakes[ballAmount]',correct
'// peng06 = new BodyPenguin (random(100,500),random(100,500));',correct
'int randomY = (int) random(-height)',correct
'bodyY - 61',correct
'peng02.strik();',correct
'for (int i = 0; i < snowflakes.length; i++) {    snowflakes[i].display();    if (i % 2 == 0) {        // richting        snowflakes[i].move(mouseX);    } else {        // de helft van de balletjes reageren op x en de andere op y        snowflakes[i].move(mouseX);    }}',correct
'class Snowflakes {    // Attributes : xpos, ypos, speed, size, colour    int x;    int y;    int speed;    int size;    int ballColor;    Snowflakes(int tempX, int tempY, int tempSize, int tempSpeed) {        ballColor = color(0xffFFFFFF);        size = tempSize;        speed = tempSpeed;        x = tempX;        y = tempY;    }    void display() {        fill(ballColor);        noStroke();        ellipse(x, y, size, size);    }    void move(int tempDirX) {        // x direction of the snowflakes        y = y + speed;        if (y > height + size) {            // start outside screen on top (0 minus size of snowball)            y = 0 - size;            // start random on screen            x = PApplet.parseInt(random(width));        }        int stepSize = (int) map(tempDirX, 2, width, -5, /*(snelheid naar links)*/        5);        x = x + stepSize;        if (x > width + size) {            x = 0 - size;        } else if (x < -size) {            x = width + size;        }    }}',correct
'display',LongMethodRule
'peng01.strik()',correct
'bodyX - 20',correct
'// start outside screen on top (0 minus size of snowball)y = 0 - size;',correct
'peng01.display()',correct
'value = false;',correct
'// peng04 = new BodyPenguin (random(100,500),random(100,500));',correct
'bodyX',correct
'bodyY',correct
'ballColor',correct
'bodyY - 75',correct
'ydirection *= -1;',correct
'// peng05 = new BodyPenguin (random(100,500),random(100,500));',correct
'void move() {    if (mousePressed == true) {        locked = true;        posX = mouseX;        posY = mouseY;    } else {        locked = false;    }    x = x + (xspeed * xdirection);    y = y + (yspeed * ydirection);    if (x > width - bodyX - 50 || x < bodyX + 40) {        xdirection *= -1;    }    if (y > height - bodyY - 60 || y < bodyY + 70) {        ydirection *= -1;    }    if (mouseX > x && mouseX < x && mouseY > y - bodyY && mouseY < y + bodyY) {        overPeng = true;        if (!locked) {        }    } else {        overPeng = false;    }    if (locked == true) {        x = mouseX;        y = mouseY;    }}',TooManyFields
'{    x = width + size;}',correct
'!keyPressed',correct
'ellipse(posX, posY, bodyX, bodyY);',correct
'key == k || key == K',correct
'float bodyX = 60',correct
'void move(int tempDirX) {    // x direction of the snowflakes    y = y + speed;    if (y > height + size) {        // start outside screen on top (0 minus size of snowball)        y = 0 - size;        // start random on screen        x = PApplet.parseInt(random(width));    }    int stepSize = (int) map(tempDirX, 2, width, -5, /*(snelheid naar links)*/    5);    x = x + stepSize;    if (x > width + size) {        x = 0 - size;    } else if (x < -size) {        x = width + size;    }}',correct
'posY - 57',correct
'float initX',correct
'float initY',correct
'i++',correct
'// peng05.display();',correct
'// bodyfill(bodyPeng);',correct
'i < snowflakes.length',correct
'posY - 55',correct
'posY - 50',correct
'bellyPeng = color(0xffFFFFFF);',correct
'x = x + (xspeed * xdirection)',correct
'float xspeed = (random(1, 5));',TooManyFields
'x < bodyX + 40',correct
'posY - 47',correct
'{    xdirection *= -1;}',correct
'// BodyPenguin peng05;',correct
'random(1, 5)',correct
'arc(posX - 32, posY - 20, 35, 30, -PI / 4, PI, CHORD)',correct
'fill(bellyPeng)',correct
'int tempX',correct
'0 - size',correct
'int tempY',correct
'float posY = y',correct
'// 2204207',correct
'println("key pressed" + keyPressed);',correct
'mouseX < x',correct
'y = 0 - size',correct
'mouthPeng = color(0xffFFAD29)',correct
'// BodyPenguin peng04;',correct
'move',correct
'bodyX + 40',correct
'triangle(posX - 5, posY - 50, posX + 5, posY - 50, posX, posY - 38)',correct
'background(0xff3AB8FA)',correct
'triangle(posX - 10, posY + 25, posX - 10, posY + 40, posX - 35, posY + 40);',correct
'// peng06.move();',correct
'triangle(posX + 10, posY + 25, posX + 35, posY + 40, posX + 10, posY + 40);',correct
'1.33f',correct
'yP = yP + 3;',correct
'arc(xP, yP, 15, 15, 1.66f * PI, 2 * PI);',correct
'Terrain = new Terrain();',correct
'x = initX;',correct
'Terrain Terrain;',correct
'Sun.drawSun();',correct
'y - 20',correct
'new Sun()',correct
'ellipse(xP, yP, 15, 15);',correct
'y - 25',correct
'ellipse(x + 55, y - 1, 3, 45);',correct
'class Terrain {    void drawTerrain() {        // terrain        stroke(0);        fill(0);        ellipse(400, 1100, 1600, 800);    }}',correct
'ellipse(400, 1100, 1600, 800);',PixelHardcodeIgnoranceRule
'arc(xP, yP, 15, 15, PI, 1.33f * PI);',correct
'ellipse(xP, yP, 3, 3);',correct
'quad(xP + 15, yP - 20, xP + 12, yP - 20, xP + 7, yP - 10, xP + 10, yP - 10);',correct
'x = -50;',correct
'planeColor',correct
'{}',EmptyIfStmt
'Sun.drawSun()',correct
'// plane transitionif (x > 920) {    x = -50;}',correct
'quad(x + 27, y - 35, x + 31, y - 35, x + 4, y, x, y)',correct
'stroke(0)',correct
'triangle(x - 118, y - 30, x - 70, y, x - 120, y);',correct
'yP + 3',correct
'class Plane {    float x;    float y;    int planeColor;    Plane(float initX, float initY) {        planeColor = color(0);        x = initX;        y = initY;    }    void drawPlane() {        fill(planeColor);        // body        quad(x - 120, y - 10, x - 5, y - 16, x - 5, y + 20, x - 120, y + 5);        quad(x - 5, y - 20, x + 50, y - 12, x + 50, y + 10, x - 5, y + 20);        // tail        ellipse(x - 120, y - 12.5f, 20, 35);        triangle(x - 118, y - 30, x - 70, y, x - 120, y);        // propellor        ellipse(x + 50, y - 1, 20, 10);        ellipse(x + 55, y - 1, 3, 45);        // gear        quad(x, y, x + 10, y, x + 20, y + 30, x + 15, y + 30);        ellipse(x + 17.5f, y + 30, 20, 20);        // tailskid        quad(x - 118, y + 5, x - 108, y + 5, x - 120, y + 15, x - 122, y + 15);        // wings        ellipse(x + 5, y - 25, 80, 5);        ellipse(x + 10, y - 35, 80, 5);        quad(x - 14, y - 35, x - 10, y - 35, x - 27, y, x - 31, y);        quad(x + 27, y - 35, x + 31, y - 35, x + 4, y, x, y);        // auto movement        x = x + 3;        // plane transition        if (x > 920) {            x = -50;        }    }    // plane controlls    void move() {        if (keyPressed == true) {            if (keyCode == UP) {                y = y - 4;            }            if (keyCode == DOWN) {                y = y + 4;            } else {            }        }    }}',correct
'y - 30',correct
'ellipse(550, 750, 400, 400)',correct
'0.33f * PI',correct
'yP = initY;',correct
'Sun',correct
'y - 35',correct
'Terrain = new Terrain()',correct
'Package Package;',correct
'xP + 12',correct
'// tailellipse(x - 120, y - 12.5f, 20, 35);',correct
'xP + 10',correct
'// parachute deploymentif (Package.yP > 600) {    quad(xP - 15, yP - 20, xP - 12, yP - 20, xP - 7, yP - 10, xP - 10, yP - 10);    quad(xP + 15, yP - 20, xP + 12, yP - 20, xP + 7, yP - 10, xP + 10, yP - 10);    arc(xP, yP - 19, 30, 25, PI, 2 * PI);    xP = xP - 0.5f;    yP = yP - 1.5f;}',correct
'PackageColor = color(255);',correct
'y = y - 4',correct
'{    if (keyPressed == true) {        if (keyCode == UP) {            y = y - 4;        }        if (keyCode == DOWN) {            y = y + 4;        } else {        }    }}',correct
'x + 10',correct
'ellipse(x + 10, y - 35, 80, 5)',correct
'Plane.move()',correct
'ellipse(x + 5, y - 25, 80, 5)',correct
'fill(0);',correct
'// plane controllsvoid move() {    if (keyPressed == true) {        if (keyCode == UP) {            y = y - 4;        }        if (keyCode == DOWN) {            y = y + 4;        } else {        }    }}',correct
'{    rectMode(CENTER);    ellipseMode(CENTER);    Plane = new Plane(-50, 200);    Sun = new Sun();    Terrain = new Terrain();    Package = new Package(-50, 200);}',correct
'ellipse(x + 17.5f, y + 30, 20, 20);',correct
'// sunnoStroke();',correct
'// auto movementx = x + 3;',correct
'x = initX',correct
'0.66f',correct
'x > 920',correct
'xP = Plane.x;',correct
'{    if (keyCode == RIGHT) {        yP = yP + 3;        xP = xP + 1;    } else {        xP = Plane.x;        yP = Plane.y;    }    if (yP > 920) {        keyCode /= RIGHT;    }    if (xP > 920) {        keyCode /= RIGHT;    }}',correct
'ellipse(x + 10, y - 35, 80, 5);',correct
'ellipse(xP, yP, 15, 15)',correct
'quad(x - 118, y + 5, x - 108, y + 5, x - 120, y + 15, x - 122, y + 15)',correct
'Terrain.drawTerrain();',correct
'rectMode(CENTER)',correct
'y - 4',correct
'x + 20',correct
'background(140, 200, 255)',correct
'y - 12',correct
'y - 10',correct
'y - 16',correct
'drawSun',correct
'int PackageColor;',VariableNamingConventions
'float yP;',ShortVariable
'y - 1',correct
'rect(xP, yP, 20, 20, 5)',correct
'if (keyCode == DOWN) {    y = y + 4;} else {}',DecentralizedEventHandlingRule
'if (yP > 920) {    xP = Plane.x;    yP = Plane.y;}',correct
'ellipse(x + 50, y - 1, 20, 10)',correct
'xP - 0.5f',correct
'yP = Plane.y;',correct
'x',correct
'y',correct
'rectMode(CENTER);',correct
'Plane = new Plane(-50, 200)',correct
'{    if (keyCode == UP) {        y = y - 4;    }    if (keyCode == DOWN) {        y = y + 4;    } else {    }}',correct
'Package.yP > 600',correct
'x + 15',correct
'Package.drawPackage()',correct
'noStroke()',correct
'xP - 7',correct
'PackageColor',correct
'if (keyCode == RIGHT) {    yP = yP + 3;    xP = xP + 1;} else {    xP = Plane.x;    yP = Plane.y;}',DecentralizedEventHandlingRule
'x = -50',correct
'Plane.x',correct
'Plane.y',correct
'float xP;',ShortVariable
'drawPlane',correct
'fill(planeColor)',correct
'arc(xP, yP, 15, 15, PI, 1.33f * PI)',correct
'ellipse(x + 55, y - 1, 3, 45)',correct
'xP = xP - 0.5f',correct
'1.66f',correct
'// terrainstroke(0);',correct
'drawPackage',correct
'Plane',correct
'y = y - 4;',correct
'Plane.drawPlane();',correct
'fill(0)',correct
'// bodyrect(xP, yP, 20, 20, 5);',correct
'drop',correct
'new Plane(-50, 200)',correct
'xP + 15',correct
'class Package {    float xP;    float yP;    int PackageColor;    Package(float initX, float initY) {        PackageColor = color(255);        xP = initX;        yP = initY;    }    void drawPackage() {        fill(PackageColor);        // body        rect(xP, yP, 20, 20, 5);        // nuke symbol        fill(0);        ellipse(xP, yP, 15, 15);        fill(252, 240, 74);        arc(xP, yP, 15, 15, 0.33f * PI, 0.66f * PI);        arc(xP, yP, 15, 15, PI, 1.33f * PI);        arc(xP, yP, 15, 15, 1.66f * PI, 2 * PI);        ellipse(xP, yP, 3, 3);        fill(PackageColor);        // parachute deployment        if (Package.yP > 600) {            quad(xP - 15, yP - 20, xP - 12, yP - 20, xP - 7, yP - 10, xP - 10, yP - 10);            quad(xP + 15, yP - 20, xP + 12, yP - 20, xP + 7, yP - 10, xP + 10, yP - 10);            arc(xP, yP - 19, 30, 25, PI, 2 * PI);            xP = xP - 0.5f;            yP = yP - 1.5f;        }        // transition        if (xP > 920) {            xP = Plane.x;            yP = Plane.y;        }        if (yP > 920) {            xP = Plane.x;            yP = Plane.y;        }    }    // package drop    void drop() {        if (keyCode == RIGHT) {            yP = yP + 3;            xP = xP + 1;        } else {            xP = Plane.x;            yP = Plane.y;        }        if (yP > 920) {            keyCode /= RIGHT;        }        if (xP > 920) {            keyCode /= RIGHT;        }    }}',correct
'x - 70',correct
'float x;',correct
'yP = initY',correct
'quad(x - 14, y - 35, x - 10, y - 35, x - 27, y, x - 31, y);',correct
'x - 108',correct
'Processing',correct
'x = x + 3',correct
'yP = yP - 1.5f;',correct
'xP',correct
'yP = yP + 3',correct
'quad(xP - 15, yP - 20, xP - 12, yP - 20, xP - 7, yP - 10, xP - 10, yP - 10)',correct
'Plane.drawPlane()',correct
'{    fill(planeColor);    // body    quad(x - 120, y - 10, x - 5, y - 16, x - 5, y + 20, x - 120, y + 5);    quad(x - 5, y - 20, x + 50, y - 12, x + 50, y + 10, x - 5, y + 20);    // tail    ellipse(x - 120, y - 12.5f, 20, 35);    triangle(x - 118, y - 30, x - 70, y, x - 120, y);    // propellor    ellipse(x + 50, y - 1, 20, 10);    ellipse(x + 55, y - 1, 3, 45);    // gear    quad(x, y, x + 10, y, x + 20, y + 30, x + 15, y + 30);    ellipse(x + 17.5f, y + 30, 20, 20);    // tailskid    quad(x - 118, y + 5, x - 108, y + 5, x - 120, y + 15, x - 122, y + 15);    // wings    ellipse(x + 5, y - 25, 80, 5);    ellipse(x + 10, y - 35, 80, 5);    quad(x - 14, y - 35, x - 10, y - 35, x - 27, y, x - 31, y);    quad(x + 27, y - 35, x + 31, y - 35, x + 4, y, x, y);    // auto movement    x = x + 3;    // plane transition    if (x > 920) {        x = -50;    }}',correct
'xP = xP + 1',correct
'{    planeColor = color(0);    x = initX;    y = initY;}',correct
'Plane = new Plane(-50, 200);',correct
'{    // sun    noStroke();    fill(255, 255, 0);    ellipse(550, 750, 400, 400);}',correct
'float y;',correct
'class Gunfire {}',correct
'ellipse(x + 17.5f, y + 30, 20, 20)',correct
'void drawTerrain() {    // terrain    stroke(0);    fill(0);    ellipse(400, 1100, 1600, 800);}',AtLeastOneConstructor
'x - 118',correct
'xP = initX;',correct
'// nuke symbolfill(0);',correct
'ellipseMode(CENTER);',correct
'keyPressed == true',correct
'yP',correct
'ellipse(400, 1100, 1600, 800)',correct
'xP = xP + 1;',correct
'quad(x - 120, y - 10, x - 5, y - 16, x - 5, y + 20, x - 120, y + 5)',correct
'quad(x + 27, y - 35, x + 31, y - 35, x + 4, y, x, y);',correct
'arc(xP, yP, 15, 15, 1.66f * PI, 2 * PI)',correct
'keyCode /= RIGHT;',DecentralizedEventHandlingRule
'keyCode /= RIGHT',correct
'if (yP > 920) {    keyCode /= RIGHT;}',correct
'x - 14',correct
'y = initY;',correct
'x - 120',correct
'color(255)',correct
'x - 122',correct
'planeColor = color(0);',correct
'xP + 7',correct
'x - 10',correct
'xP + 1',correct
'y = initY',correct
'int planeColor;',correct
'quad(xP - 15, yP - 20, xP - 12, yP - 20, xP - 7, yP - 10, xP - 10, yP - 10);',correct
'Sun = new Sun();',correct
'{    background(140, 200, 255);    Sun.drawSun();    Terrain.drawTerrain();    Package.drawPackage();    Package.drop();    Plane.drawPlane();    Plane.move();}',correct
'Package.drop()',correct
'// bodyquad(x - 120, y - 10, x - 5, y - 16, x - 5, y + 20, x - 120, y + 5);',correct
'y + 10',correct
'yP - 1.5f',correct
'Package.yP',correct
'triangle(x - 118, y - 30, x - 70, y, x - 120, y)',correct
'quad(x, y, x + 10, y, x + 20, y + 30, x + 15, y + 30)',correct
'xP = initX',correct
'Package',correct
'xP = Plane.x',correct
'y - 12.5f',correct
'arc(xP, yP - 19, 30, 25, PI, 2 * PI)',correct
'{    PackageColor = color(255);    xP = initX;    yP = initY;}',correct
'background(140, 200, 255);',correct
'// transitionif (xP > 920) {    xP = Plane.x;    yP = Plane.y;}',correct
'x - 31',correct
'1.66f * PI',correct
'Package = new Package(-50, 200);',correct
'fill(252, 240, 74)',correct
'{    yP = yP + 3;    xP = xP + 1;}',correct
'keyCode == UP',correct
'ellipse(x - 120, y - 12.5f, 20, 35)',correct
'17.5f',correct
'drawTerrain',correct
'arc(xP, yP, 15, 15, 0.33f * PI, 0.66f * PI);',correct
'yP - 10',correct
'0.5f',correct
'color(0)',correct
'quad(x - 14, y - 35, x - 10, y - 35, x - 27, y, x - 31, y)',correct
'x - 27',correct
'{    y = y + 4;}',correct
'1.33f * PI',correct
'keyCode == RIGHT',correct
'fill(PackageColor);',correct
'if (keyCode == UP) {    y = y - 4;}',DecentralizedEventHandlingRule
'fill(planeColor);',correct
'// gearquad(x, y, x + 10, y, x + 20, y + 30, x + 15, y + 30);',correct
'x + 5',correct
'// tailskidquad(x - 118, y + 5, x - 108, y + 5, x - 120, y + 15, x - 122, y + 15);',correct
'Terrain',correct
'12.5f',correct
'xP - 15',correct
'if (keyPressed == true) {    if (keyCode == UP) {        y = y - 4;    }    if (keyCode == DOWN) {        y = y + 4;    } else {    }}',DecentralizedEventHandlingRule
'// wingsellipse(x + 5, y - 25, 80, 5);',correct
'xP - 12',correct
'x + 3',correct
'xP - 10',correct
'x + 4',correct
'void drawPlane() {    fill(planeColor);    // body    quad(x - 120, y - 10, x - 5, y - 16, x - 5, y + 20, x - 120, y + 5);    quad(x - 5, y - 20, x + 50, y - 12, x + 50, y + 10, x - 5, y + 20);    // tail    ellipse(x - 120, y - 12.5f, 20, 35);    triangle(x - 118, y - 30, x - 70, y, x - 120, y);    // propellor    ellipse(x + 50, y - 1, 20, 10);    ellipse(x + 55, y - 1, 3, 45);    // gear    quad(x, y, x + 10, y, x + 20, y + 30, x + 15, y + 30);    ellipse(x + 17.5f, y + 30, 20, 20);    // tailskid    quad(x - 118, y + 5, x - 108, y + 5, x - 120, y + 15, x - 122, y + 15);    // wings    ellipse(x + 5, y - 25, 80, 5);    ellipse(x + 10, y - 35, 80, 5);    quad(x - 14, y - 35, x - 10, y - 35, x - 27, y, x - 31, y);    quad(x + 27, y - 35, x + 31, y - 35, x + 4, y, x, y);    // auto movement    x = x + 3;    // plane transition    if (x > 920) {        x = -50;    }}',correct
'ellipse(xP, yP, 3, 3)',correct
'float initX',correct
'arc(xP, yP, 15, 15, 0.33f * PI, 0.66f * PI)',correct
'float initY',correct
'x + 31',correct
'-50',correct
'{    y = y - 4;}',correct
'ellipseMode(CENTER)',correct
'fill(255, 255, 0)',correct
'void draw() {    background(140, 200, 255);    Sun.drawSun();    Terrain.drawTerrain();    Package.drawPackage();    Package.drop();    Plane.drawPlane();    Plane.move();}',correct
'new Terrain()',correct
'keyCode == DOWN',correct
'yP > 920',correct
'Plane.move();',correct
'void drawPackage() {    fill(PackageColor);    // body    rect(xP, yP, 20, 20, 5);    // nuke symbol    fill(0);    ellipse(xP, yP, 15, 15);    fill(252, 240, 74);    arc(xP, yP, 15, 15, 0.33f * PI, 0.66f * PI);    arc(xP, yP, 15, 15, PI, 1.33f * PI);    arc(xP, yP, 15, 15, 1.66f * PI, 2 * PI);    ellipse(xP, yP, 3, 3);    fill(PackageColor);    // parachute deployment    if (Package.yP > 600) {        quad(xP - 15, yP - 20, xP - 12, yP - 20, xP - 7, yP - 10, xP - 10, yP - 10);        quad(xP + 15, yP - 20, xP + 12, yP - 20, xP + 7, yP - 10, xP + 10, yP - 10);        arc(xP, yP - 19, 30, 25, PI, 2 * PI);        xP = xP - 0.5f;        yP = yP - 1.5f;    }    // transition    if (xP > 920) {        xP = Plane.x;        yP = Plane.y;    }    if (yP > 920) {        xP = Plane.x;        yP = Plane.y;    }}',correct
'xP > 920',correct
'fill(252, 240, 74);',correct
'x + 27',correct
'Plane Plane;',correct
'yP = Plane.y',correct
'void',correct
'y = y + 4',correct
'{    quad(xP - 15, yP - 20, xP - 12, yP - 20, xP - 7, yP - 10, xP - 10, yP - 10);    quad(xP + 15, yP - 20, xP + 12, yP - 20, xP + 7, yP - 10, xP + 10, yP - 10);    arc(xP, yP - 19, 30, 25, PI, 2 * PI);    xP = xP - 0.5f;    yP = yP - 1.5f;}',correct
'void drawSun() {    // sun    noStroke();    fill(255, 255, 0);    ellipse(550, 750, 400, 400);}',AtLeastOneConstructor
'// package dropvoid drop() {    if (keyCode == RIGHT) {        yP = yP + 3;        xP = xP + 1;    } else {        xP = Plane.x;        yP = Plane.y;    }    if (yP > 920) {        keyCode /= RIGHT;    }    if (xP > 920) {        keyCode /= RIGHT;    }}',correct
'yP - 19',correct
'quad(x - 5, y - 20, x + 50, y - 12, x + 50, y + 10, x - 5, y + 20);',correct
'{    keyCode /= RIGHT;}',correct
'{    x = -50;}',correct
'Package(float initX, float initY) {    PackageColor = color(255);    xP = initX;    yP = initY;}',correct
'quad(xP + 15, yP - 20, xP + 12, yP - 20, xP + 7, yP - 10, xP + 10, yP - 10)',correct
'Package.drop();',correct
'PackageColor = color(255)',correct
'yP - 20',correct
'1.5f',correct
'true',correct
'fill(255, 255, 0);',correct
'arc(xP, yP - 19, 30, 25, PI, 2 * PI);',correct
'Sun = new Sun()',correct
'x + 55',correct
'x + 50',correct
'void setup() {    rectMode(CENTER);    ellipseMode(CENTER);    Plane = new Plane(-50, 200);    Sun = new Sun();    Terrain = new Terrain();    Package = new Package(-50, 200);}',correct
'Package = new Package(-50, 200)',correct
'y + 20',correct
'{    // terrain    stroke(0);    fill(0);    ellipse(400, 1100, 1600, 800);}',correct
'new Package(-50, 200)',correct
'Package.drawPackage();',correct
'quad(x - 5, y - 20, x + 50, y - 12, x + 50, y + 10, x - 5, y + 20)',correct
'y + 15',correct
'class Sun {    void drawSun() {        // sun        noStroke();        fill(255, 255, 0);        ellipse(550, 750, 400, 400);    }}',correct
'Terrain.drawTerrain()',correct
'planeColor = color(0)',correct
'Sun Sun;',correct
'// propellorellipse(x + 50, y - 1, 20, 10);',correct
'y + 4',correct
'y + 5',correct
'0.66f * PI',correct
'move',correct
'{    fill(PackageColor);    // body    rect(xP, yP, 20, 20, 5);    // nuke symbol    fill(0);    ellipse(xP, yP, 15, 15);    fill(252, 240, 74);    arc(xP, yP, 15, 15, 0.33f * PI, 0.66f * PI);    arc(xP, yP, 15, 15, PI, 1.33f * PI);    arc(xP, yP, 15, 15, 1.66f * PI, 2 * PI);    ellipse(xP, yP, 3, 3);    fill(PackageColor);    // parachute deployment    if (Package.yP > 600) {        quad(xP - 15, yP - 20, xP - 12, yP - 20, xP - 7, yP - 10, xP - 10, yP - 10);        quad(xP + 15, yP - 20, xP + 12, yP - 20, xP + 7, yP - 10, xP + 10, yP - 10);        arc(xP, yP - 19, 30, 25, PI, 2 * PI);        xP = xP - 0.5f;        yP = yP - 1.5f;    }    // transition    if (xP > 920) {        xP = Plane.x;        yP = Plane.y;    }    if (yP > 920) {        xP = Plane.x;        yP = Plane.y;    }}',correct
'y + 30',correct
'y = y + 4;',correct
'xP = xP - 0.5f;',correct
'{    xP = Plane.x;    yP = Plane.y;}',correct
'x - 5',correct
'x + 17.5f',correct
'0.33f',correct
'fill(PackageColor)',correct
'2 * PI',correct
'yP = yP - 1.5f',correct
'if (xP > 920) {    keyCode /= RIGHT;}',correct
'ellipse(550, 750, 400, 400);',correct
'Plane(float initX, float initY) {    planeColor = color(0);    x = initX;    y = initY;}',correct
'// declare array for the minionMinion[] minionBob = new Minion[numberOfMinions];',correct
'ellipse(minionX, minionY + 25, 100, 50);',correct
'rect(minionX, minionY + 25, 35, 10);',correct
'stroke(150);',correct
'point(fingertopX - 60, fingertopY - 16);',correct
'fingertopX = minionX - 10;',correct
'arc(minionX, minionY + 2, 35, 15, 0, PI);',correct
'positionY = mouseY',correct
'mouseClicked = true',correct
'ellipse(minionX + 22 - speedX, minionY - 25 - speedY, 28, 28);',correct
'ellipse(minionX + 22, minionY - 25, 40, 40);',correct
'minionX + 70',correct
'color(75, 105, 141)',correct
'println("My name is Bob!")',correct
'minionX - 13',correct
'height - 58',correct
'minionX - 8 - speedX',correct
'ellipse(minionX, minionY + 25, 100, 50)',correct
'minionX - 10',correct
'stroke(214, 147, 69);',correct
'// stores the x position of the mouse that is put in as an argumentfloat indicatorX;',TooManyFields
'ellipse(minionX + 18, minionY + 58, 10, 7);',correct
'line(minionX + 50, minionY + 12, minionX + 60, minionY - 8)',correct
'rect(minionX, minionY + 25, 60, 25)',correct
'// VARIABLES// stores the seconds that have passedint seconds;',TooManyFields
'strokeWeight(0.5f);',correct
'{    speedX = -speedX;}',correct
'quad(minionX - 30, minionY + 37, minionX + 30, minionY + 37, minionX + 20, minionY + 50, minionX - 20, minionY + 50)',correct
'minionX - 18',correct
'mouseMoved',correct
'// programming assignment',correct
'rect(minionX - 48, minionY - 25, 6, 16);',correct
'stroke(0);',correct
'stroke(0)',correct
'minionY = height / 2;',correct
'strokeWeight(1);',correct
'ellipse(minionX + 22, minionY - 25, 10, 10);',correct
'// checks if 2 seconds have passed, then the minions are sticking their tongue outif (seconds % 2 == 0) {    noStroke();    fill(tongueColor);    rect(minionX, minionY + 8, 10, 4);    ellipse(minionX, minionY + 10, 10, 4);}',correct
'// Eva Lahuis s1851985',correct
'new Minion[numberOfMinions]',correct
'minionX + 60',correct
'{    // light green background    background(img);    // using a for loop to draw and move the minions    for (int i = 0; i < minionBob.length; i++) {        minionBob[i].drawMinion();        minionBob[i].moveMinion(positionX, positionY);    }}',correct
'minionX + 64',correct
'// checks if the mouse is pressed and stores that in mouseClickedif (mousePressed) {    mouseClicked = true;} else {    mouseClicked = false;}',correct
'minionX - 8',correct
'bodyColor = color(250, 218, 58)',correct
'line(minionX - 30, minionY + 12, minionX - 50, minionY + 2);',correct
'minionX - 5',correct
'{    fingertopX = minionX - 10;    fingertopY = minionY + 8;}',correct
'minionX + 68',correct
'minionX > width - 68',correct
'stroke(100);',correct
'minionY + 2',correct
'minionY + 3',correct
'indicatorX',correct
'indicatorY',correct
'ellipse(minionX + 18, minionY + 58, 10, 7)',correct
'point(fingertopX - 68, fingertopY - 18)',correct
'{    mouseClicked = true;}',DecentralizedEventHandlingRule
'minionY + 8',correct
'tongueColor = color(255, 100, 100)',correct
'stroke(bodyColor)',correct
'fingertopX = minionX',correct
'fill(0);',correct
'// draw the shoesstrokeWeight(1);',correct
'{    speedY = -speedY;}',correct
'minionX - 30',correct
'// if the minion is hitting the wall, the x direction will be changedif (minionX > width - 68 || minionX < 68) {    speedX = -speedX;}',correct
'minionX < 68',correct
'// set the location of from which the rectangles are drawing to the centerrectMode(CENTER);',correct
'second()',correct
'-speedY',correct
'PImage',correct
'rect(minionX + 42, minionY - 25, 8, 20)',correct
'-speedX',correct
'minionX - 36',correct
'// using a for loop to draw and move the minionsfor (int i = 0; i < minionBob.length; i++) {    minionBob[i].drawMinion();    minionBob[i].moveMinion(positionX, positionY);}',correct
'fill(150);',correct
'"My name is Bob!"',correct
'indicatorX < minionX + 42',correct
'ellipse(minionX, minionY + 10, 10, 4)',correct
'// stores y position of the minions left fingertopfloat fingertopY;',TooManyFields
'rect(minionX - 48, minionY - 25, 6, 16)',correct
'speedX = -speedX;',correct
'rect(minionX - 42, minionY - 25, 8, 20)',correct
'point(fingertopX - 70, fingertopY - 10);',correct
'rectMode(CENTER)',correct
'width - 68',correct
'// checks if the mouse is on a couple of eyes, and if so the eyes are closingif (indicatorX >= minionX - 42 && indicatorX < minionX + 42 && indicatorY >= minionY - 65 && indicatorY < minionY + 15) {    stroke(bodyColor);    fill(bodyColor);    ellipse(minionX + 22 - speedX, minionY - 25 - speedY, 28, 28);    ellipse(minionX - 22 - speedX, minionY - 25 - speedY, 28, 28);    strokeWeight(1);    stroke(0);    line(minionX - 36 - speedX, minionY - 25 - speedY, minionX - 8 - speedX, minionY - 25 - speedY);    line(minionX + 36 - speedX, minionY - 25 - speedY, minionX + 8 - speedX, minionY - 25 - speedY);}',correct
'speedY',correct
'speedX',correct
'line(minionX - 36 - speedX, minionY - 25 - speedY, minionX - 8 - speedX, minionY - 25 - speedY);',correct
'minionX - 20',correct
'minionX = minionX + speedX',correct
'strokeWeight(8)',correct
'{    positionX = mouseX;    positionY = mouseY;}',correct
'point(minionX + 60, minionY - 16)',correct
'minionX - 22',correct
'speedY = random(-4, 4)',correct
'minionX + 22 - speedX',correct
'minionBob[i] = new Minion();',correct
'minionBob[i].drawMinion();',correct
'// checkprintln("My name is Bob!");',correct
'// checks if the mouse is pressed and changes the variable fingertop to let the left fingertop move when the mouse is pressedif (mouseClicked == true) {    fingertopX = minionX - 10;    fingertopY = minionY + 8;} else {    fingertopX = minionX;    fingertopY = minionY;}',correct
'dungareesColor = color(75, 105, 141)',correct
'minionBob[i]',correct
'minionX - 22 - speedX',correct
'rect(minionX, minionY + 8, 10, 4)',correct
'// the class for the minion(s)class Minion {    // VARIABLES    // stores the seconds that have passed    int seconds;    // checks if the mouse is clicked    boolean mouseClicked;    // stores x position of the minion    float minionX;    // stores y position of the minion    float minionY;    // stores x position of the minions left fingertop    float fingertopX;    // stores y position of the minions left fingertop    float fingertopY;    // stores the speed in the x direction    float speedX;    // stores the speed in the y direction    float speedY;    // stores the body the bodycolor    int bodyColor;    // stores the dungareesColor    int dungareesColor;    // stores the tongueColor    int tongueColor;    // stores the x position of the mouse that is put in as an argument    float indicatorX;    // stores the y position of the mouse that is put in as an argument    float indicatorY;    // CONSTRUCTOR    Minion() {        // each minion will start at a the middle of the screen        minionX = width / 2;        minionY = height / 2;        // the default value of the fingertop is the minion value        fingertopX = minionX;        fingertopY = minionY;        // each minion will move with a random speed        speedX = random(-4, 4);        speedY = random(-4, 4);        // yellow        bodyColor = color(250, 218, 58);        // blue        dungareesColor = color(75, 105, 141);        // red        tongueColor = color(255, 100, 100);    }    // MOVE MINION    void moveMinion(float indicatorX, float indicatorY) {        // moving the minion in the x direction        minionX = minionX + speedX;        // moving the minion in the y direction        minionY = minionY + speedY;        // if the minion is hitting the wall, the x direction will be changed        if (minionX > width - 68 || minionX < 68) {            speedX = -speedX;        }        // if the minion is hitting the wall, the y direction will be changed        if (minionY > height - 58 || minionY < 58) {            speedY = -speedY;        }        // checks if the mouse is pressed and changes the variable fingertop to let the left fingertop move when the mouse is pressed        if (mouseClicked == true) {            fingertopX = minionX - 10;            fingertopY = minionY + 8;        } else {            fingertopX = minionX;            fingertopY = minionY;        }        // checks if the mouse is on a couple of eyes, and if so the eyes are closing        if (indicatorX >= minionX - 42 && indicatorX < minionX + 42 && indicatorY >= minionY - 65 && indicatorY < minionY + 15) {            stroke(bodyColor);            fill(bodyColor);            ellipse(minionX + 22 - speedX, minionY - 25 - speedY, 28, 28);            ellipse(minionX - 22 - speedX, minionY - 25 - speedY, 28, 28);            strokeWeight(1);            stroke(0);            line(minionX - 36 - speedX, minionY - 25 - speedY, minionX - 8 - speedX, minionY - 25 - speedY);            line(minionX + 36 - speedX, minionY - 25 - speedY, minionX + 8 - speedX, minionY - 25 - speedY);        }    }    // DRAW MINION    void drawMinion() {        // stores seconds in this variable        seconds = second();        // set the location of from which the rectangles are drawing to the center        rectMode(CENTER);        // draw the body        stroke(bodyColor);        fill(bodyColor);        rect(minionX, minionY, 100, 50);        ellipse(minionX, minionY - 25, 100, 75);        ellipse(minionX, minionY + 25, 100, 50);        strokeWeight(8);        line(minionX - 50, minionY + 12, fingertopX - 60, fingertopY - 8);        line(minionX + 50, minionY + 12, minionX + 60, minionY - 8);        // draw the arms and gloves        strokeWeight(12);        stroke(0);        fill(0);        point(fingertopX - 64, fingertopY - 12);        point(minionX + 64, minionY - 12);        strokeWeight(8);        point(fingertopX - 70, fingertopY - 10);        point(fingertopX - 68, fingertopY - 18);        point(fingertopX - 60, fingertopY - 16);        point(minionX + 70, minionY - 10);        point(minionX + 68, minionY - 18);        point(minionX + 60, minionY - 16);        // draw the shoes        strokeWeight(1);        stroke(0);        fill(0);        rect(minionX - 10, minionY + 57, 16, 9);        rect(minionX + 10, minionY + 57, 16, 9);        ellipse(minionX - 18, minionY + 58, 10, 7);        ellipse(minionX + 18, minionY + 58, 10, 7);        // draw the dungarees        stroke(dungareesColor);        fill(dungareesColor);        arc(minionX, minionY + 25, 105, 55, 0, PI);        rect(minionX, minionY + 25, 60, 25);        strokeWeight(8);        line(minionX - 30, minionY + 12, minionX - 50, minionY + 2);        line(minionX + 30, minionY + 12, minionX + 50, minionY + 2);        quad(minionX - 30, minionY + 37, minionX + 30, minionY + 37, minionX + 20, minionY + 50, minionX - 20, minionY + 50);        strokeWeight(0.5f);        stroke(0);        rect(minionX, minionY + 25, 35, 10);        arc(minionX + 50, minionY + 25, 24, 12, HALF_PI, PI);        arc(minionX - 50, minionY + 25, 24, 12, 0, HALF_PI);        strokeWeight(3);        point(minionX - 30, minionY + 12);        point(minionX + 30, minionY + 12);        // draw the glasses and the eyes        stroke(0);        fill(0);        rect(minionX - 48, minionY - 25, 6, 16);        rect(minionX + 48, minionY - 25, 6, 16);        stroke(150);        fill(150);        rect(minionX - 42, minionY - 25, 8, 20);        rect(minionX + 42, minionY - 25, 8, 20);        strokeWeight(8);        stroke(100);        fill(255);        ellipse(minionX - 22, minionY - 25, 40, 40);        ellipse(minionX + 22, minionY - 25, 40, 40);        // draw the iris and the pupil        strokeWeight(3);        stroke(209, 165, 40);        fill(0);        ellipse(minionX - 22, minionY - 25, 10, 10);        strokeWeight(3);        stroke(214, 147, 69);        fill(0);        ellipse(minionX + 22, minionY - 25, 10, 10);        // draw the mouth        noStroke();        fill(0);        arc(minionX, minionY + 2, 35, 15, 0, PI);        fill(255);        arc(minionX - 13, minionY + 3, 6, 4, 0, PI);        arc(minionX - 5, minionY + 3, 8, 4, 0, PI);        arc(minionX + 5, minionY + 3, 8, 4, 0, PI);        arc(minionX + 13, minionY + 3, 6, 4, 0, PI);        // checks if the mouse is pressed and stores that in mouseClicked        if (mousePressed) {            mouseClicked = true;        } else {            mouseClicked = false;        }        // checks if 2 seconds have passed, then the minions are sticking their tongue out        if (seconds % 2 == 0) {            noStroke();            fill(tongueColor);            rect(minionX, minionY + 8, 10, 4);            ellipse(minionX, minionY + 10, 10, 4);        }        // check        println("My name is Bob!");    }}',correct
'arc(minionX - 5, minionY + 3, 8, 4, 0, PI);',correct
'// the default value of the fingertop is the minion valuefingertopX = minionX;',correct
'noStroke()',correct
'mouseClicked = false;',correct
'point(minionX - 30, minionY + 12);',correct
'speedY = -speedY',correct
'minionY + 37',correct
'minionY > height - 58 || minionY < 58',correct
'minionY > height - 58',correct
'// stores x position of the minions left fingertopfloat fingertopX;',TooManyFields
'speedY = -speedY;',correct
'indicatorX >= minionX - 42',correct
'{    // stores seconds in this variable    seconds = second();    // set the location of from which the rectangles are drawing to the center    rectMode(CENTER);    // draw the body    stroke(bodyColor);    fill(bodyColor);    rect(minionX, minionY, 100, 50);    ellipse(minionX, minionY - 25, 100, 75);    ellipse(minionX, minionY + 25, 100, 50);    strokeWeight(8);    line(minionX - 50, minionY + 12, fingertopX - 60, fingertopY - 8);    line(minionX + 50, minionY + 12, minionX + 60, minionY - 8);    // draw the arms and gloves    strokeWeight(12);    stroke(0);    fill(0);    point(fingertopX - 64, fingertopY - 12);    point(minionX + 64, minionY - 12);    strokeWeight(8);    point(fingertopX - 70, fingertopY - 10);    point(fingertopX - 68, fingertopY - 18);    point(fingertopX - 60, fingertopY - 16);    point(minionX + 70, minionY - 10);    point(minionX + 68, minionY - 18);    point(minionX + 60, minionY - 16);    // draw the shoes    strokeWeight(1);    stroke(0);    fill(0);    rect(minionX - 10, minionY + 57, 16, 9);    rect(minionX + 10, minionY + 57, 16, 9);    ellipse(minionX - 18, minionY + 58, 10, 7);    ellipse(minionX + 18, minionY + 58, 10, 7);    // draw the dungarees    stroke(dungareesColor);    fill(dungareesColor);    arc(minionX, minionY + 25, 105, 55, 0, PI);    rect(minionX, minionY + 25, 60, 25);    strokeWeight(8);    line(minionX - 30, minionY + 12, minionX - 50, minionY + 2);    line(minionX + 30, minionY + 12, minionX + 50, minionY + 2);    quad(minionX - 30, minionY + 37, minionX + 30, minionY + 37, minionX + 20, minionY + 50, minionX - 20, minionY + 50);    strokeWeight(0.5f);    stroke(0);    rect(minionX, minionY + 25, 35, 10);    arc(minionX + 50, minionY + 25, 24, 12, HALF_PI, PI);    arc(minionX - 50, minionY + 25, 24, 12, 0, HALF_PI);    strokeWeight(3);    point(minionX - 30, minionY + 12);    point(minionX + 30, minionY + 12);    // draw the glasses and the eyes    stroke(0);    fill(0);    rect(minionX - 48, minionY - 25, 6, 16);    rect(minionX + 48, minionY - 25, 6, 16);    stroke(150);    fill(150);    rect(minionX - 42, minionY - 25, 8, 20);    rect(minionX + 42, minionY - 25, 8, 20);    strokeWeight(8);    stroke(100);    fill(255);    ellipse(minionX - 22, minionY - 25, 40, 40);    ellipse(minionX + 22, minionY - 25, 40, 40);    // draw the iris and the pupil    strokeWeight(3);    stroke(209, 165, 40);    fill(0);    ellipse(minionX - 22, minionY - 25, 10, 10);    strokeWeight(3);    stroke(214, 147, 69);    fill(0);    ellipse(minionX + 22, minionY - 25, 10, 10);    // draw the mouth    noStroke();    fill(0);    arc(minionX, minionY + 2, 35, 15, 0, PI);    fill(255);    arc(minionX - 13, minionY + 3, 6, 4, 0, PI);    arc(minionX - 5, minionY + 3, 8, 4, 0, PI);    arc(minionX + 5, minionY + 3, 8, 4, 0, PI);    arc(minionX + 13, minionY + 3, 6, 4, 0, PI);    // checks if the mouse is pressed and stores that in mouseClicked    if (mousePressed) {        mouseClicked = true;    } else {        mouseClicked = false;    }    // checks if 2 seconds have passed, then the minions are sticking their tongue out    if (seconds % 2 == 0) {        noStroke();        fill(tongueColor);        rect(minionX, minionY + 8, 10, 4);        ellipse(minionX, minionY + 10, 10, 4);    }    // check    println("My name is Bob!");}',LongMethodRule
'// stores the location of the mouse in 2 variablesvoid mouseMoved() {    positionX = mouseX;    positionY = mouseY;}',correct
'new Minion()',correct
'float indicatorX',correct
'float indicatorY',correct
'minionX + 30',correct
'point(minionX + 70, minionY - 10);',correct
'minionX + 36',correct
'// draw the mouthnoStroke();',correct
'rect(minionX + 42, minionY - 25, 8, 20);',correct
'fill(bodyColor)',correct
'fingertopX = minionX;',correct
'// moving the minion in the y directionminionY = minionY + speedY;',correct
'Minion[]',correct
'// stores y position of the mousefloat positionY;',correct
'// draws my creature',correct
'"ACHTERGROND.jpg"',correct
'{    // moving the minion in the x direction    minionX = minionX + speedX;    // moving the minion in the y direction    minionY = minionY + speedY;    // if the minion is hitting the wall, the x direction will be changed    if (minionX > width - 68 || minionX < 68) {        speedX = -speedX;    }    // if the minion is hitting the wall, the y direction will be changed    if (minionY > height - 58 || minionY < 58) {        speedY = -speedY;    }    // checks if the mouse is pressed and changes the variable fingertop to let the left fingertop move when the mouse is pressed    if (mouseClicked == true) {        fingertopX = minionX - 10;        fingertopY = minionY + 8;    } else {        fingertopX = minionX;        fingertopY = minionY;    }    // checks if the mouse is on a couple of eyes, and if so the eyes are closing    if (indicatorX >= minionX - 42 && indicatorX < minionX + 42 && indicatorY >= minionY - 65 && indicatorY < minionY + 15) {        stroke(bodyColor);        fill(bodyColor);        ellipse(minionX + 22 - speedX, minionY - 25 - speedY, 28, 28);        ellipse(minionX - 22 - speedX, minionY - 25 - speedY, 28, 28);        strokeWeight(1);        stroke(0);        line(minionX - 36 - speedX, minionY - 25 - speedY, minionX - 8 - speedX, minionY - 25 - speedY);        line(minionX + 36 - speedX, minionY - 25 - speedY, minionX + 8 - speedX, minionY - 25 - speedY);    }}',correct
'point(minionX + 68, minionY - 18)',correct
'point(minionX + 64, minionY - 12)',correct
'strokeWeight(3);',correct
'// each minion will start at a the middle of the screenminionX = width / 2;',correct
'// bluedungareesColor = color(75, 105, 141);',correct
'line(minionX + 36 - speedX, minionY - 25 - speedY, minionX + 8 - speedX, minionY - 25 - speedY);',correct
'indicatorY < minionY + 15',correct
'{    fingertopX = minionX;    fingertopY = minionY;}',SimplifyBooleanExpressions
'minionX + 22',correct
'fill(0)',correct
'minionX + 20',correct
'height / 2',correct
'line(minionX - 50, minionY + 12, fingertopX - 60, fingertopY - 8);',correct
'minionX + 8 - speedX',correct
'stroke(100)',correct
'stroke(dungareesColor)',correct
'arc(minionX - 50, minionY + 25, 24, 12, 0, HALF_PI);',correct
'fill(bodyColor);',correct
'point(minionX - 30, minionY + 12)',correct
'point(minionX + 60, minionY - 16);',correct
'line(minionX + 36 - speedX, minionY - 25 - speedY, minionX + 8 - speedX, minionY - 25 - speedY)',correct
'minionY + 15',correct
'minionY + 12',correct
'// moving the minion in the x directionminionX = minionX + speedX;',correct
'minionY + 10',correct
'{    minionBob[i].drawMinion();    minionBob[i].moveMinion(positionX, positionY);}',correct
'// stores the backgroundPImage img;',correct
'minionY - 8',correct
'point(fingertopX - 60, fingertopY - 16)',correct
'{    stroke(bodyColor);    fill(bodyColor);    ellipse(minionX + 22 - speedX, minionY - 25 - speedY, 28, 28);    ellipse(minionX - 22 - speedX, minionY - 25 - speedY, 28, 28);    strokeWeight(1);    stroke(0);    line(minionX - 36 - speedX, minionY - 25 - speedY, minionX - 8 - speedX, minionY - 25 - speedY);    line(minionX + 36 - speedX, minionY - 25 - speedY, minionX + 8 - speedX, minionY - 25 - speedY);}',correct
'line(minionX + 30, minionY + 12, minionX + 50, minionY + 2);',correct
'fill(255)',correct
'random(-4, 4)',correct
'minionX + 50',correct
'Processing',correct
'// use full dimension of the screenimg = loadImage("ACHTERGROND.jpg");',correct
'ellipse(minionX + 22, minionY - 25, 40, 40)',correct
'minionY + speedY',correct
'stroke(214, 147, 69)',correct
'arc(minionX, minionY + 25, 105, 55, 0, PI);',correct
'minionBob[i].moveMinion(positionX, positionY)',correct
'// checks if the mouse is clickedboolean mouseClicked;',TooManyFields
'// draw the iris and the pupilstrokeWeight(3);',correct
'arc(minionX - 50, minionY + 25, 24, 12, 0, HALF_PI)',correct
'ellipse(minionX - 22 - speedX, minionY - 25 - speedY, 28, 28);',correct
'ellipse(minionX + 22, minionY - 25, 10, 10)',correct
'minionY + 25',correct
'rect(minionX + 10, minionY + 57, 16, 9)',correct
'// stores x position of the mousefloat positionX;',correct
'void setup() {    // use full dimension of the screen    img = loadImage("ACHTERGROND.jpg");    // using a for loop to create the minions (using the class tab, does not draw anything yet)    for (int i = 0; i < minionBob.length; i++) {        minionBob[i] = new Minion();    }}',correct
'indicatorX >= minionX - 42 && indicatorX < minionX + 42 && indicatorY >= minionY - 65 && indicatorY < minionY + 15',correct
'point(minionX + 64, minionY - 12);',correct
'minionX = width / 2',correct
'false',correct
'ellipse(minionX - 22, minionY - 25, 40, 40);',correct
'speedY = random(-4, 4);',correct
'// draw the arms and glovesstrokeWeight(12);',correct
'ellipse(minionX - 22, minionY - 25, 40, 40)',correct
'int i = 0',correct
'minionX + 42',correct
'rect(minionX - 10, minionY + 57, 16, 9)',correct
'minionX + 48',correct
'// stores the speed in the y directionfloat speedY;',TooManyFields
'ellipse(minionX, minionY - 25, 100, 75);',correct
'minionX > width - 68 || minionX < 68',correct
'{    mouseClicked = false;}',correct
'arc(minionX + 5, minionY + 3, 8, 4, 0, PI)',correct
'minionY = height / 2',correct
'setup',correct
'stroke(bodyColor);',correct
'// yellowbodyColor = color(250, 218, 58);',correct
'// draw the dungareesstroke(dungareesColor);',correct
'minionY - 18',correct
'i = 0',correct
'fingertopX',correct
'minionY - 16',correct
'ellipse(minionX - 22, minionY - 25, 10, 10);',correct
'fingertopY',correct
'// stores seconds in this variableseconds = second();',correct
'minionY - 12',correct
'positionY = mouseY;',correct
'// redtongueColor = color(255, 100, 100);',correct
'// use full dimension of the screen',correct
'// stores x position of the minionfloat minionX;',TooManyFields
'// VARIABLES',TooManyFields
'stroke(209, 165, 40);',correct
'arc(minionX + 5, minionY + 3, 8, 4, 0, PI);',correct
'seconds',correct
'seconds % 2',correct
'i < minionBob.length',correct
'indicatorY >= minionY - 65',correct
'[numberOfMinions]',correct
'minionY - 10',correct
'// CONSTRUCTORMinion() {    // each minion will start at a the middle of the screen    minionX = width / 2;    minionY = height / 2;    // the default value of the fingertop is the minion value    fingertopX = minionX;    fingertopY = minionY;    // each minion will move with a random speed    speedX = random(-4, 4);    speedY = random(-4, 4);    // yellow    bodyColor = color(250, 218, 58);    // blue    dungareesColor = color(75, 105, 141);    // red    tongueColor = color(255, 100, 100);}',TooManyFields
'positionX = mouseX;',correct
'// stores the speed in the x directionfloat speedX;',TooManyFields
'minionX + 36 - speedX',correct
'// stores y position of the minionfloat minionY;',TooManyFields
'minionX - 36 - speedX',correct
'minionY - 25',correct
'arc(minionX + 50, minionY + 25, 24, 12, HALF_PI, PI)',correct
'// draw the glasses and the eyesstroke(0);',correct
'minionX + speedX',correct
'fingertopY - 8',correct
'fill(dungareesColor);',correct
'// each minion will move with a random speedspeedX = random(-4, 4);',correct
'strokeWeight(12)',correct
'arc(minionX, minionY + 25, 105, 55, 0, PI)',correct
'ellipse(minionX - 18, minionY + 58, 10, 7);',correct
'noStroke();',correct
'rect(minionX, minionY + 25, 35, 10)',correct
'minionY < 58',correct
'drawMinion',LongMethodRule
'void draw() {    // light green background    background(img);    // using a for loop to draw and move the minions    for (int i = 0; i < minionBob.length; i++) {        minionBob[i].drawMinion();        minionBob[i].moveMinion(positionX, positionY);    }}',correct
'minionY + 58',correct
'minionY + 57',correct
'stroke(209, 165, 40)',correct
'ellipse(minionX - 22, minionY - 25, 10, 10)',correct
'loadImage("ACHTERGROND.jpg")',correct
'arc(minionX - 13, minionY + 3, 6, 4, 0, PI);',correct
'rect(minionX, minionY, 100, 50);',correct
'strokeWeight(1)',correct
'minionBob[i].moveMinion(positionX, positionY);',correct
'// MOVE MINIONvoid moveMinion(float indicatorX, float indicatorY) {    // moving the minion in the x direction    minionX = minionX + speedX;    // moving the minion in the y direction    minionY = minionY + speedY;    // if the minion is hitting the wall, the x direction will be changed    if (minionX > width - 68 || minionX < 68) {        speedX = -speedX;    }    // if the minion is hitting the wall, the y direction will be changed    if (minionY > height - 58 || minionY < 58) {        speedY = -speedY;    }    // checks if the mouse is pressed and changes the variable fingertop to let the left fingertop move when the mouse is pressed    if (mouseClicked == true) {        fingertopX = minionX - 10;        fingertopY = minionY + 8;    } else {        fingertopX = minionX;        fingertopY = minionY;    }    // checks if the mouse is on a couple of eyes, and if so the eyes are closing    if (indicatorX >= minionX - 42 && indicatorX < minionX + 42 && indicatorY >= minionY - 65 && indicatorY < minionY + 15) {        stroke(bodyColor);        fill(bodyColor);        ellipse(minionX + 22 - speedX, minionY - 25 - speedY, 28, 28);        ellipse(minionX - 22 - speedX, minionY - 25 - speedY, 28, 28);        strokeWeight(1);        stroke(0);        line(minionX - 36 - speedX, minionY - 25 - speedY, minionX - 8 - speedX, minionY - 25 - speedY);        line(minionX + 36 - speedX, minionY - 25 - speedY, minionX + 8 - speedX, minionY - 25 - speedY);    }}',TooManyFields
'rect(minionX + 48, minionY - 25, 6, 16)',correct
'tongueColor',correct
'minionX + 10',correct
'positionX = mouseX',correct
'mouseClicked = false',correct
'ellipse(minionX, minionY + 10, 10, 4);',correct
'mouseClicked = true;',correct
'{    minionBob[i] = new Minion();}',correct
'moveMinion',correct
'arc(minionX - 13, minionY + 3, 6, 4, 0, PI)',correct
'minionX + 13',correct
'line(minionX - 50, minionY + 12, fingertopX - 60, fingertopY - 8)',correct
'minionX + 18',correct
'fingertopX = minionX - 10',correct
'0.5f',correct
'numberOfMinions = 20',correct
'minionY + 50',correct
'arc(minionX + 50, minionY + 25, 24, 12, HALF_PI, PI);',correct
'arc(minionX - 5, minionY + 3, 8, 4, 0, PI)',correct
'// stores the y position of the mouse that is put in as an argumentfloat indicatorY;',TooManyFields
'arc(minionX + 13, minionY + 3, 6, 4, 0, PI);',correct
'speedX = -speedX',correct
'// draw the bodystroke(bodyColor);',correct
'ellipse(minionX + 22 - speedX, minionY - 25 - speedY, 28, 28)',correct
'strokeWeight(0.5f)',correct
'point(fingertopX - 68, fingertopY - 18);',correct
'draw',correct
'fingertopY = minionY;',correct
'point(minionX + 70, minionY - 10)',correct
'ellipse(minionX - 18, minionY + 58, 10, 7)',correct
'// programming assignment// draws my creature// Eva Lahuis s1851985// globl variables// number of minion drawnint numberOfMinions = 20;',correct
'seconds = second()',correct
'rect(minionX - 42, minionY - 25, 8, 20);',correct
'{    // use full dimension of the screen    img = loadImage("ACHTERGROND.jpg");    // using a for loop to create the minions (using the class tab, does not draw anything yet)    for (int i = 0; i < minionBob.length; i++) {        minionBob[i] = new Minion();    }}',correct
'rect(minionX + 48, minionY - 25, 6, 16);',correct
'point(minionX + 30, minionY + 12);',correct
'line(minionX + 50, minionY + 12, minionX + 60, minionY - 8);',correct
'fingertopY - 18',correct
'// DRAW MINIONvoid drawMinion() {    // stores seconds in this variable    seconds = second();    // set the location of from which the rectangles are drawing to the center    rectMode(CENTER);    // draw the body    stroke(bodyColor);    fill(bodyColor);    rect(minionX, minionY, 100, 50);    ellipse(minionX, minionY - 25, 100, 75);    ellipse(minionX, minionY + 25, 100, 50);    strokeWeight(8);    line(minionX - 50, minionY + 12, fingertopX - 60, fingertopY - 8);    line(minionX + 50, minionY + 12, minionX + 60, minionY - 8);    // draw the arms and gloves    strokeWeight(12);    stroke(0);    fill(0);    point(fingertopX - 64, fingertopY - 12);    point(minionX + 64, minionY - 12);    strokeWeight(8);    point(fingertopX - 70, fingertopY - 10);    point(fingertopX - 68, fingertopY - 18);    point(fingertopX - 60, fingertopY - 16);    point(minionX + 70, minionY - 10);    point(minionX + 68, minionY - 18);    point(minionX + 60, minionY - 16);    // draw the shoes    strokeWeight(1);    stroke(0);    fill(0);    rect(minionX - 10, minionY + 57, 16, 9);    rect(minionX + 10, minionY + 57, 16, 9);    ellipse(minionX - 18, minionY + 58, 10, 7);    ellipse(minionX + 18, minionY + 58, 10, 7);    // draw the dungarees    stroke(dungareesColor);    fill(dungareesColor);    arc(minionX, minionY + 25, 105, 55, 0, PI);    rect(minionX, minionY + 25, 60, 25);    strokeWeight(8);    line(minionX - 30, minionY + 12, minionX - 50, minionY + 2);    line(minionX + 30, minionY + 12, minionX + 50, minionY + 2);    quad(minionX - 30, minionY + 37, minionX + 30, minionY + 37, minionX + 20, minionY + 50, minionX - 20, minionY + 50);    strokeWeight(0.5f);    stroke(0);    rect(minionX, minionY + 25, 35, 10);    arc(minionX + 50, minionY + 25, 24, 12, HALF_PI, PI);    arc(minionX - 50, minionY + 25, 24, 12, 0, HALF_PI);    strokeWeight(3);    point(minionX - 30, minionY + 12);    point(minionX + 30, minionY + 12);    // draw the glasses and the eyes    stroke(0);    fill(0);    rect(minionX - 48, minionY - 25, 6, 16);    rect(minionX + 48, minionY - 25, 6, 16);    stroke(150);    fill(150);    rect(minionX - 42, minionY - 25, 8, 20);    rect(minionX + 42, minionY - 25, 8, 20);    strokeWeight(8);    stroke(100);    fill(255);    ellipse(minionX - 22, minionY - 25, 40, 40);    ellipse(minionX + 22, minionY - 25, 40, 40);    // draw the iris and the pupil    strokeWeight(3);    stroke(209, 165, 40);    fill(0);    ellipse(minionX - 22, minionY - 25, 10, 10);    strokeWeight(3);    stroke(214, 147, 69);    fill(0);    ellipse(minionX + 22, minionY - 25, 10, 10);    // draw the mouth    noStroke();    fill(0);    arc(minionX, minionY + 2, 35, 15, 0, PI);    fill(255);    arc(minionX - 13, minionY + 3, 6, 4, 0, PI);    arc(minionX - 5, minionY + 3, 8, 4, 0, PI);    arc(minionX + 5, minionY + 3, 8, 4, 0, PI);    arc(minionX + 13, minionY + 3, 6, 4, 0, PI);    // checks if the mouse is pressed and stores that in mouseClicked    if (mousePressed) {        mouseClicked = true;    } else {        mouseClicked = false;    }    // checks if 2 seconds have passed, then the minions are sticking their tongue out    if (seconds % 2 == 0) {        noStroke();        fill(tongueColor);        rect(minionX, minionY + 8, 10, 4);        ellipse(minionX, minionY + 10, 10, 4);    }    // check    println("My name is Bob!");}',TooManyFields
'arc(minionX + 13, minionY + 3, 6, 4, 0, PI)',correct
'fingertopY - 16',correct
'// using a for loop to create the minions (using the class tab, does not draw anything yet)for (int i = 0; i < minionBob.length; i++) {    minionBob[i] = new Minion();}',correct
'minionBob[i].drawMinion()',correct
'fingertopY - 12',correct
'i++',correct
'fingertopY - 10',correct
'fingertopY = minionY + 8;',correct
'minionX - 50',correct
'mousePressed',DecentralizedEventHandlingRule
'positionX',correct
'positionY',correct
'fill(255);',correct
'line(minionX + 30, minionY + 12, minionX + 50, minionY + 2)',correct
'point(minionX + 30, minionY + 12)',correct
'strokeWeight(3)',correct
'{    // each minion will start at a the middle of the screen    minionX = width / 2;    minionY = height / 2;    // the default value of the fingertop is the minion value    fingertopX = minionX;    fingertopY = minionY;    // each minion will move with a random speed    speedX = random(-4, 4);    speedY = random(-4, 4);    // yellow    bodyColor = color(250, 218, 58);    // blue    dungareesColor = color(75, 105, 141);    // red    tongueColor = color(255, 100, 100);}',correct
'fill(dungareesColor)',correct
'fingertopY = minionY + 8',correct
'void',correct
'// globl variables',correct
'-4',correct
'minionBob = new Minion[numberOfMinions]',correct
'rect(minionX, minionY + 8, 10, 4);',correct
'fingertopY = minionY',correct
'// stores the body the bodycolorint bodyColor;',TooManyFields
'minionX - 42',correct
'mouseClicked == true',SimplifyBooleanExpressions
'minionX + 5',correct
'ellipse(minionX, minionY - 25, 100, 75)',correct
'point(fingertopX - 70, fingertopY - 10)',correct
'minionX - 48',correct
'minionX + 8',correct
'mouseClicked',correct
'true',correct
'minionY - 65',correct
'background(img)',correct
'fingertopX - 70',correct
'point(minionX + 68, minionY - 18);',correct
'rect(minionX + 10, minionY + 57, 16, 9);',correct
'img',correct
'bodyColor',correct
'rect(minionX, minionY, 100, 50)',correct
'arc(minionX, minionY + 2, 35, 15, 0, PI)',correct
'// light green backgroundbackground(img);',correct
'indicatorX >= minionX - 42 && indicatorX < minionX + 42 && indicatorY >= minionY - 65',correct
'speedX = random(-4, 4)',correct
'minionY',correct
'minionX',correct
'minionY - 25 - speedY',correct
'minionY = minionY + speedY',correct
'indicatorX >= minionX - 42 && indicatorX < minionX + 42',correct
'fingertopX - 68',correct
'color(255, 100, 100)',correct
'minionBob[i] = new Minion()',correct
'ellipse(minionX - 22 - speedX, minionY - 25 - speedY, 28, 28)',correct
'rect(minionX, minionY + 25, 60, 25);',correct
'// if the minion is hitting the wall, the y direction will be changedif (minionY > height - 58 || minionY < 58) {    speedY = -speedY;}',correct
'img = loadImage("ACHTERGROND.jpg")',correct
'fingertopX - 60',correct
'color(250, 218, 58)',correct
'{    noStroke();    fill(tongueColor);    rect(minionX, minionY + 8, 10, 4);    ellipse(minionX, minionY + 10, 10, 4);}',correct
'seconds % 2 == 0',correct
'point(fingertopX - 64, fingertopY - 12)',correct
'fingertopX - 64',correct
'quad(minionX - 30, minionY + 37, minionX + 30, minionY + 37, minionX + 20, minionY + 50, minionX - 20, minionY + 50);',correct
'rect(minionX - 10, minionY + 57, 16, 9);',correct
'line(minionX - 36 - speedX, minionY - 25 - speedY, minionX - 8 - speedX, minionY - 25 - speedY)',correct
'// stores the dungareesColorint dungareesColor;',TooManyFields
'fill(tongueColor)',correct
'// stores the tongueColorint tongueColor;',TooManyFields
'width / 2',correct
'point(fingertopX - 64, fingertopY - 12);',correct
'dungareesColor',correct
'strokeWeight(8);',correct
'stroke(150)',correct
'fill(150)',correct
'Minion',TooManyFields
'line(minionX - 30, minionY + 12, minionX - 50, minionY + 2)',correct
'minionBob.length',correct
'fill(tongueColor);',correct
'void setup() {    puck = new Puck();    left = new Paddle(true);    right = new Paddle(false);}',correct
'y = constrain(y, h / 2, height - h / 2)',correct
'x = p.x + p.w / 2 + radius',correct
'rad = radians(45)',correct
'left.move(10);',correct
'x - radius > width',correct
'checkPaddleLeft',ShortVariable
'if (y < 0 || y > height) {    yspeed *= -1;}',correct
'y - 18',correct
'rightscore = 0',correct
'void keyReleased() {    left.move(0);    right.move(0);}',correct
'y = constrain(y, h / 2, height - h / 2);',correct
'{    left.move(10);}',correct
'10 * sin(angle)',correct
'puck.show()',correct
'p.x + p.w / 2',correct
'10 * cos(angle)',correct
'float radius = 18;',correct
'if (left) {    x = w;} else {    x = width - w;}',correct
'puck.checkPaddleLeft(left)',correct
'left.move(-10);',correct
'ychange = steps',correct
'float h = 100;',ShortVariable
'left',correct
'right.move(0);',correct
'random(1) < 0.5f',correct
'random(1)',correct
'float angle = map(diff, 0, p.h, -rad, rad)',correct
'textSize(32)',correct
'x = width - w',correct
'radius * 2',correct
'x + radius > p.x - p.w / 2',correct
'{    background(0);    // puck.checkPaddle(left);    puck.checkPaddleRight(right);    puck.checkPaddleLeft(left);    left.show();    right.show();    left.update();    right.update();    puck.update();    puck.edges();    puck.show();    fill(255);    textSize(32);    text(leftscore, 32, 40);    text(rightscore, width - 64, 40);}',correct
'ellipse(x - 7, y - 7, radius * 0.5f, radius * 0.5f)',correct
'float xspeed;',correct
'Puck() {    mouthWidth = 20;    mouthHeight = 20;    reset();}',correct
'// earsstroke(255);',correct
'fill(0);',correct
'diff = y - (p.y - p.h / 2)',correct
'rect(x, y, w, h)',correct
'x = width / 2;',correct
'fill(254, 174, 158)',correct
'h = 100',correct
'p.y + p.h / 2',correct
'arc(x, y + 7, mouthWidth, mouthHeight, PI / 10, PI - 0.5f);',correct
'if (random(1) < 0.5f) {    xspeed *= -1;}',correct
'boolean left',correct
'rectMode(CENTER)',correct
'class Paddle {    float x;    float y = height / 2;    float w = 20;    float h = 100;    float ychange = 0;    Paddle(boolean left) {        if (left) {            x = w;        } else {            x = width - w;        }    }    void update() {        y += ychange;        y = constrain(y, h / 2, height - h / 2);    }    void move(float steps) {        ychange = steps;    }    void show() {        fill(255);        rectMode(CENTER);        rect(x, y, w, h);    }}',correct
'a',correct
'mouthHeight',correct
'{    if (key == a) {        left.move(-10);    } else if (key == z) {        left.move(10);    }    if (key == j) {        right.move(-10);    } else if (key == m) {        right.move(10);    }}',correct
'left.update();',correct
'y - 7',correct
'mouthHeight = 20',correct
'width - 64',correct
'ellipse(x + 15, y - 18, radius * 1.5f, radius * 1.5f);',correct
'j',correct
'p.h',correct
'angle = map(diff, 0, p.h, radians(225), radians(135))',correct
'right',correct
'x + radius',correct
'yspeed',correct
'm',correct
'yspeed = 10 * sin(angle)',correct
'{    y += ychange;    y = constrain(y, h / 2, height - h / 2);}',correct
'left.update()',correct
'mouthWidth = 20;',correct
'p.w',correct
'x',correct
'rectMode(CENTER);',correct
'p.y',correct
'z',correct
'p.x',correct
'void move(float steps) {    ychange = steps;}',correct
'puck = new Puck();',correct
'float yspeed;',correct
'x + 15',correct
'noStroke()',correct
'right = new Paddle(false)',correct
'y - radius < p.y + p.h / 2 && y + radius > p.y - p.h / 2 && x - radius < p.x + p.w / 2',correct
'right.move(10)',correct
'leftscore++;',DrawingStateChangeRule
'ellipse(x + 15, y - 18, radius * 1.5f, radius * 1.5f)',correct
'ellipse(x - 15, y - 18, radius * 1.5f, radius * 1.5f)',correct
'if (key == m) {    right.move(10);}',correct
'height - h / 2',correct
'right = new Paddle(false);',correct
'puck = new Puck()',correct
'mouthWidth',correct
'{    xspeed *= -1;}',correct
'{    right.move(10);}',correct
'Paddle p',correct
'x = w;',correct
'angle = map(diff, 0, p.h, -rad, rad)',correct
'x + radius < 0',correct
'float angle = map(diff, 0, p.h, radians(225), radians(135));',correct
'radius = 18',correct
'x = p.x - p.w / 2 - radius;',correct
'fill(0)',correct
'fill(254, 174, 158);',correct
'height / 2',correct
'p.x + p.w / 2 + radius',correct
'// angle = 0;xspeed = 10 * cos(angle);',correct
'reset();',correct
'float diff = y - (p.y - p.h / 2)',correct
'p.y - p.h / 2',correct
'y += ychange',correct
'mouthWidth = 20',correct
'show',correct
'mouthHeight = 20;',correct
'float x;',correct
'p.h / 2',correct
'xspeed = 10 * cos(angle);',correct
'fill(255)',correct
'float diff = y - (p.y - p.h / 2);',correct
'y = height / 2',correct
'left.show()',correct
'Processing',correct
'y = height / 2;',correct
'{    if (x > p.x) {        float diff = y - (p.y - p.h / 2);        float rad = radians(45);        float angle = map(diff, 0, p.h, -rad, rad);        xspeed = 10 * cos(angle);        yspeed = 10 * sin(angle);        x = p.x + p.w / 2 + radius;    // xspeed *= -1;    }}',correct
'{    if (x < p.x) {        // xspeed *= -1;        float diff = y - (p.y - p.h / 2);        float angle = map(diff, 0, p.h, radians(225), radians(135));        xspeed = 10 * cos(angle);        yspeed = 10 * sin(angle);        x = p.x - p.w / 2 - radius;    }}',correct
'y = y + yspeed',correct
'Paddle left;',correct
'if (x + radius < 0) {    rightscore++;    reset();}',correct
'puck.edges();',correct
'right.move(10);',correct
'left.move(10)',correct
'y > height',correct
'-rad',correct
'{    x = width / 2;    y = height / 2;    float angle = random(-PI / 4, PI / 4);    // angle = 0;    xspeed = 10 * cos(angle);    yspeed = 10 * sin(angle);    if (random(1) < 0.5f) {        xspeed *= -1;    }}',correct
'ellipse(x, y, radius * 2, radius * 2)',correct
'{    left.move(0);    right.move(0);}',correct
'p.x - p.w / 2',correct
'leftscore++',correct
'void keyPressed() {    if (key == a) {        left.move(-10);    } else if (key == z) {        left.move(10);    }    if (key == j) {        right.move(-10);    } else if (key == m) {        right.move(10);    }}',correct
'-PI',correct
'x - radius',correct
'false',correct
'radius * 1.5f',correct
'left = new Paddle(true);',correct
'puck.update()',correct
'{    if (y < 0 || y > height) {        yspeed *= -1;    }    if (x - radius > width) {        leftscore++;        reset();    }    if (x + radius < 0) {        rightscore++;        reset();    }}',correct
'x + xspeed',correct
'xspeed *= -1',correct
'{    if (left) {        x = w;    } else {        x = width - w;    }}',correct
'void update() {    y += ychange;    y = constrain(y, h / 2, height - h / 2);}',correct
'void reset() {    x = width / 2;    y = height / 2;    float angle = random(-PI / 4, PI / 4);    // angle = 0;    xspeed = 10 * cos(angle);    yspeed = 10 * sin(angle);    if (random(1) < 0.5f) {        xspeed *= -1;    }}',correct
'{    fill(254, 174, 158);    // head    ellipse(x, y, radius * 2, radius * 2);    // ears    stroke(255);    fill(0);    ellipse(x + 15, y - 18, radius * 1.5f, radius * 1.5f);    ellipse(x - 15, y - 18, radius * 1.5f, radius * 1.5f);    fill(0);    noStroke();    // nose    ellipse(x, y + 2, radius * 0.6f, radius * 0.6f);    // eyes    ellipse(x - 7, y - 7, radius * 0.5f, radius * 0.5f);    ellipse(x + 7, y - 7, radius * 0.5f, radius * 0.5f);    arc(x, y + 7, mouthWidth, mouthHeight, PI / 10, PI - 0.5f);}',correct
'stroke(255)',correct
'float w = 20;',ShortVariable
'h / 2',correct
'random(-PI / 4, PI / 4)',correct
'y + radius',correct
'x - 15',correct
'y - radius',correct
'right.show()',correct
'float rad = radians(45)',correct
'rightscore++;',DrawingStateChangeRule
'y - radius < p.y + p.h / 2 && y + radius > p.y - p.h / 2 && x + radius > p.x - p.w / 2',correct
'x = w',correct
'ellipse(x + 7, y - 7, radius * 0.5f, radius * 0.5f)',correct
'void show() {    fill(255);    rectMode(CENTER);    rect(x, y, w, h);}',correct
'left.move(-10)',correct
'radians(45)',correct
'x < p.x',correct
'radius * 0.5f',correct
'-10',correct
'background(0)',correct
'puck',correct
'puck.edges()',correct
'float angle = map(diff, 0, p.h, -rad, rad);',correct
'text(leftscore, 32, 40)',correct
'void checkPaddleLeft(Paddle p) {    if (y - radius < p.y + p.h / 2 && y + radius > p.y - p.h / 2 && x - radius < p.x + p.w / 2) {        if (x > p.x) {            float diff = y - (p.y - p.h / 2);            float rad = radians(45);            float angle = map(diff, 0, p.h, -rad, rad);            xspeed = 10 * cos(angle);            yspeed = 10 * sin(angle);            x = p.x + p.w / 2 + radius;        // xspeed *= -1;        }    }}',correct
'xspeed *= -1;',correct
'PI / 10',correct
'radius * 0.6f',correct
'yspeed *= -1;',correct
'y + yspeed',correct
'puck.checkPaddleRight(right)',correct
'x = x + xspeed;',correct
'rightscore++',correct
'{    x = w;}',correct
'// headellipse(x, y, radius * 2, radius * 2);',correct
'textSize(32);',correct
'{    yspeed *= -1;}',correct
'float x = width / 2;',correct
'noStroke();',correct
'reset',correct
'arc(x, y + 7, mouthWidth, mouthHeight, PI / 10, PI - 0.5f)',correct
'float angle = random(-PI / 4, PI / 4);',correct
'ychange = 0',correct
'width - w',correct
'if (key == j) {    right.move(-10);} else if (key == m) {    right.move(10);}',correct
'new Paddle(true)',correct
'key == m',correct
'y + radius > p.y - p.h / 2',correct
'puck.update();',correct
'y - radius < p.y + p.h / 2',correct
'key == j',correct
'left.show();',correct
'void update() {    x = x + xspeed;    y = y + yspeed;}',correct
'int rightscore = 0;',correct
'PI / 4',correct
'key == a',correct
'float angle = map(diff, 0, p.h, radians(225), radians(135))',correct
'{    x = x + xspeed;    y = y + yspeed;}',correct
'x = x + xspeed',correct
'// xspeed *= -1;',correct
'left.move(0);',correct
'text(leftscore, 32, 40);',PixelHardcodeIgnoranceRule
'key == z',correct
'right.update()',correct
'0.5f',correct
'-PI / 4',correct
'right.move(-10);',correct
'// head',correct
'{    mouthWidth = 20;    mouthHeight = 20;    reset();}',correct
'radians(135)',correct
'y < 0 || y > height',correct
'background(0);',correct
'PI - 0.5f',correct
'Puck',correct
'float mouthWidth;',correct
'draw',correct
'{    float diff = y - (p.y - p.h / 2);    float rad = radians(45);    float angle = map(diff, 0, p.h, -rad, rad);    xspeed = 10 * cos(angle);    yspeed = 10 * sin(angle);    x = p.x + p.w / 2 + radius;// xspeed *= -1;}',correct
'puck.checkPaddleLeft(left);',correct
'x + 7',correct
'x = p.x - p.w / 2 - radius',correct
'text(rightscore, width - 64, 40);',PixelHardcodeIgnoranceRule
'void draw() {    background(0);    // puck.checkPaddle(left);    puck.checkPaddleRight(right);    puck.checkPaddleLeft(left);    left.show();    right.show();    left.update();    right.update();    puck.update();    puck.edges();    puck.show();    fill(255);    textSize(32);    text(leftscore, 32, 40);    text(rightscore, width - 64, 40);}',correct
'0.6f',correct
'right.move(0)',correct
'float rad = radians(45);',correct
'xspeed = 10 * cos(angle)',correct
'x = width / 2',correct
'if (key == a) {    left.move(-10);} else if (key == z) {    left.move(10);}',correct
'cos(angle)',correct
'xspeed',correct
'void edges() {    if (y < 0 || y > height) {        yspeed *= -1;    }    if (x - radius > width) {        leftscore++;        reset();    }    if (x + radius < 0) {        rightscore++;        reset();    }}',correct
'Paddle',correct
'ellipse(x - 15, y - 18, radius * 1.5f, radius * 1.5f);',correct
'radians(225)',correct
'sin(angle)',correct
'float mouthHeight;',correct
'y - (p.y - p.h / 2)',correct
'ellipse(x, y + 2, radius * 0.6f, radius * 0.6f)',correct
'// puck.checkPaddle(left);puck.checkPaddleRight(right);',correct
'angle = random(-PI / 4, PI / 4)',correct
'checkPaddleRight',ShortVariable
'p.w / 2',correct
'fill(255);',correct
'puck.show();',correct
'new Paddle(false)',correct
'{    leftscore++;    reset();}',correct
'{    rightscore++;    reset();}',correct
'{    puck = new Puck();    left = new Paddle(true);    right = new Paddle(false);}',correct
'y < 0',correct
'Puck puck;',correct
'class Puck {    float x = width / 2;    float y = height / 2;    float xspeed;    float yspeed;    float radius = 18;    float mouthWidth;    float mouthHeight;    Puck() {        mouthWidth = 20;        mouthHeight = 20;        reset();    }    void checkPaddleLeft(Paddle p) {        if (y - radius < p.y + p.h / 2 && y + radius > p.y - p.h / 2 && x - radius < p.x + p.w / 2) {            if (x > p.x) {                float diff = y - (p.y - p.h / 2);                float rad = radians(45);                float angle = map(diff, 0, p.h, -rad, rad);                xspeed = 10 * cos(angle);                yspeed = 10 * sin(angle);                x = p.x + p.w / 2 + radius;            // xspeed *= -1;            }        }    }    void checkPaddleRight(Paddle p) {        if (y - radius < p.y + p.h / 2 && y + radius > p.y - p.h / 2 && x + radius > p.x - p.w / 2) {            if (x < p.x) {                // xspeed *= -1;                float diff = y - (p.y - p.h / 2);                float angle = map(diff, 0, p.h, radians(225), radians(135));                xspeed = 10 * cos(angle);                yspeed = 10 * sin(angle);                x = p.x - p.w / 2 - radius;            }        }    }    void update() {        x = x + xspeed;        y = y + yspeed;    }    void reset() {        x = width / 2;        y = height / 2;        float angle = random(-PI / 4, PI / 4);        // angle = 0;        xspeed = 10 * cos(angle);        yspeed = 10 * sin(angle);        if (random(1) < 0.5f) {            xspeed *= -1;        }    }    void edges() {        if (y < 0 || y > height) {            yspeed *= -1;        }        if (x - radius > width) {            leftscore++;            reset();        }        if (x + radius < 0) {            rightscore++;            reset();        }    }    void show() {        fill(254, 174, 158);        // head        ellipse(x, y, radius * 2, radius * 2);        // ears        stroke(255);        fill(0);        ellipse(x + 15, y - 18, radius * 1.5f, radius * 1.5f);        ellipse(x - 15, y - 18, radius * 1.5f, radius * 1.5f);        fill(0);        noStroke();        // nose        ellipse(x, y + 2, radius * 0.6f, radius * 0.6f);        // eyes        ellipse(x - 7, y - 7, radius * 0.5f, radius * 0.5f);        ellipse(x + 7, y - 7, radius * 0.5f, radius * 0.5f);        arc(x, y + 7, mouthWidth, mouthHeight, PI / 10, PI - 0.5f);    }}',correct
'constrain(y, h / 2, height - h / 2)',correct
'float angle = random(-PI / 4, PI / 4)',correct
'map(diff, 0, p.h, -rad, rad)',correct
'void',correct
'ychange = steps;',correct
'yspeed = 10 * sin(angle);',correct
'-1',correct
'p.x - p.w / 2 - radius',correct
'right.move(-10)',correct
'new Puck()',correct
'void show() {    fill(254, 174, 158);    // head    ellipse(x, y, radius * 2, radius * 2);    // ears    stroke(255);    fill(0);    ellipse(x + 15, y - 18, radius * 1.5f, radius * 1.5f);    ellipse(x - 15, y - 18, radius * 1.5f, radius * 1.5f);    fill(0);    noStroke();    // nose    ellipse(x, y + 2, radius * 0.6f, radius * 0.6f);    // eyes    ellipse(x - 7, y - 7, radius * 0.5f, radius * 0.5f);    ellipse(x + 7, y - 7, radius * 0.5f, radius * 0.5f);    arc(x, y + 7, mouthWidth, mouthHeight, PI / 10, PI - 0.5f);}',correct
'{    if (y - radius < p.y + p.h / 2 && y + radius > p.y - p.h / 2 && x - radius < p.x + p.w / 2) {        if (x > p.x) {            float diff = y - (p.y - p.h / 2);            float rad = radians(45);            float angle = map(diff, 0, p.h, -rad, rad);            xspeed = 10 * cos(angle);            yspeed = 10 * sin(angle);            x = p.x + p.w / 2 + radius;        // xspeed *= -1;        }    }}',ShortVariable
'right.update();',correct
'y += ychange;',correct
'Paddle(boolean left) {    if (left) {        x = w;    } else {        x = width - w;    }}',correct
'Paddle right;',correct
'y - radius < p.y + p.h / 2 && y + radius > p.y - p.h / 2',correct
'// eyesellipse(x - 7, y - 7, radius * 0.5f, radius * 0.5f);',correct
'1.5f',correct
'// noseellipse(x, y + 2, radius * 0.6f, radius * 0.6f);',correct
'true',correct
'x - radius < p.x + p.w / 2',correct
'float ychange = 0;',correct
'{    // xspeed *= -1;    float diff = y - (p.y - p.h / 2);    float angle = map(diff, 0, p.h, radians(225), radians(135));    xspeed = 10 * cos(angle);    yspeed = 10 * sin(angle);    x = p.x - p.w / 2 - radius;}',correct
'left = new Paddle(true)',correct
'leftscore = 0',correct
'y = y + yspeed;',correct
'void checkPaddleRight(Paddle p) {    if (y - radius < p.y + p.h / 2 && y + radius > p.y - p.h / 2 && x + radius > p.x - p.w / 2) {        if (x < p.x) {            // xspeed *= -1;            float diff = y - (p.y - p.h / 2);            float angle = map(diff, 0, p.h, radians(225), radians(135));            xspeed = 10 * cos(angle);            yspeed = 10 * sin(angle);            x = p.x - p.w / 2 - radius;        }    }}',correct
'left.move(0)',correct
'right.show();',correct
'{    if (y - radius < p.y + p.h / 2 && y + radius > p.y - p.h / 2 && x + radius > p.x - p.w / 2) {        if (x < p.x) {            // xspeed *= -1;            float diff = y - (p.y - p.h / 2);            float angle = map(diff, 0, p.h, radians(225), radians(135));            xspeed = 10 * cos(angle);            yspeed = 10 * sin(angle);            x = p.x - p.w / 2 - radius;        }    }}',ShortVariable
'{    right.move(-10);}',correct
'x = p.x + p.w / 2 + radius;',correct
'ellipse(x + 7, y - 7, radius * 0.5f, radius * 0.5f);',correct
'{    x = width - w;}',correct
'y + 7',correct
'w = 20',correct
'// xspeed *= -1;float diff = y - (p.y - p.h / 2);',correct
'float y = height / 2;',correct
'if (key == z) {    left.move(10);}',correct
'int leftscore = 0;',correct
'y + 2',correct
'x > p.x',correct
'text(rightscore, width - 64, 40)',correct
'{    fill(255);    rectMode(CENTER);    rect(x, y, w, h);}',correct
'width / 2',correct
'float steps',correct
'rect(x, y, w, h);',correct
'x = width - w;',correct
'reset()',correct
'if (x - radius > width) {    leftscore++;    reset();}',correct
'{    left.move(-10);}',correct
'x - 7',correct
'map(diff, 0, p.h, radians(225), radians(135))',correct
'{    ychange = steps;}',correct
'yspeed *= -1',correct
'kumaX - 42',correct
'kumaX - 40',correct
'colours / 10',correct
'{    ellipse(kumaX - 30, kumaY, 12, 12);    ellipse(kumaX - 42, kumaY, 25, 12);    ellipse(kumaX - 55, kumaY, 15, 15);}',correct
'dy = -dy;',correct
'// legsellipse(monomiX - 10, monomiY + 50, 10, 10);',correct
'kumaY = random(height - 150) + 75',correct
'loselive && lives >= 0',correct
'monomiA.display();',correct
'ellipse(headX + 15, headY - 26, 15, 15)',correct
'if (lives <= 0) {    lives = 3;    trace = false;    level = 1;    hazard[0] = new Ball(random(width - 150) + 75, random(height - 150) + 75, random(30) / random(12), random(30) / random(12));}',correct
'monomiX + (4 * sparkleRadius / 3 + 45)',correct
'monomiY + 10',correct
'{    fill(0);    ellipse(kumaX + 30, kumaY, 12, 12);    ellipse(kumaX + 42, kumaY, 25, 12);    ellipse(kumaX + 55, kumaY, 15, 15);}',correct
'ballY = random(height - 150) + 75',correct
'colours == 0',correct
'headX + 25',correct
'arc(headX, headY, 53, 53, HALF_PI, PI + HALF_PI)',correct
'ellipse(headX - 5, headY + 2, 10, 10)',correct
'ballX < 25',correct
'-3 * sparkleRadius',correct
'ballX + dx',correct
'nextLevel = false;',DrawingStateChangeRule
'// // fifth petal',correct
'ellipse(kumaX - 42, kumaY, 25, 12)',correct
'if (colours == 0) {    fill(255);    ellipse(kumaX - 40, kumaY + 20, 15, 15);    ellipse(kumaX - 40, kumaY + 10, 10, 17);    ellipse(kumaX - 40, kumaY, 10, 10);    ellipse(kumaX - 32, kumaY, 15, 10);}',correct
'ellipse(monomiX - 40, monomiY + 20, 15, 15)',correct
'for (int i = 0; i < kuma.length; i++) {    kuma[i] = new Kuma(random(width - 150) + 75, random(height - 150) + 75);}',correct
'ballY = ballY + dy',correct
'ellipse(monomiX - 40, monomiY + 20, 15, 15);',correct
'fill(0, 0, 0)',correct
'if (colours == 0) {    fill(0);    ellipse(kumaX + 30, kumaY, 12, 12);    ellipse(kumaX + 42, kumaY, 25, 12);    ellipse(kumaX + 55, kumaY, 15, 15);}',correct
'{    fill(0);    ellipse(monomiX + 30, monomiY, 12, 12);    ellipse(monomiX + 42, monomiY, 25, 12);    ellipse(monomiX + 55, monomiY, 15, 15);}',correct
'ellipse(kumaX - 32, kumaY, 15, 10)',correct
'ellipse(sparkleX - random(-sparkleRadius / 2, sparkleRadius / 2), sparkleY + random(-sparkleRadius / 2, sparkleRadius / 2), sparkleSize, sparkleSize)',correct
'ellipse(sparkleX - random(-sparkleRadius, sparkleRadius), sparkleY + random(-sparkleRadius, sparkleRadius), sparkleSize, sparkleSize)',correct
'float headY = monomiY - 28;',correct
'hazard[n]',correct
'ellipse(headX - 35, headY - 13, 15, 25);',correct
'kumaX - 55',correct
'2.14f',correct
'ellipse(kumaX + 42, kumaY, 25, 12);',correct
'monomiY + 20',correct
'ellipse(kumaX + 40, kumaY - 20, 15, 15)',correct
'{    dy = -dy;}',correct
'kumaY = random(height - 150) + 75;',correct
'{    fill(random(255), 0, 0);    ellipse(kumaX + 10, kumaY - 38, 15, 15);}',correct
'n = 0',correct
'stroke(bodyColor)',correct
'fill(0);',correct
'monomiA = new Monomi(3 * width / 4, height / 2);',correct
'{    fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);    // centre circle    ellipse(ballX, ballY, 50, 50);// if (colours==255) {// // first petal// ellipse(ballX, ballY-50, 50, 70);// // second petal// // rotate 72 degrees// rotate(radians(72));// ellipse(ballX, ballY-50, 50, 70);// // third petal// rotate(radians(72));// ellipse(ballX, ballY-50, 50, 70);// // fourth petal// rotate(radians(72));// ellipse(ballX, ballY-50, 50, 70);// // fifth petal// rotate(radians(72));// ellipse(ballX, ballY-50, 50, 70);// }}',correct
'new Monomi(3 * width / 4, height / 2)',correct
'255 - colours',correct
'rect(monomiX + 10, monomiY + 40, 10, 20)',correct
'// controls the playtime and difficulty of the minigameint maxLevel = 20;',correct
'trace = true;',correct
'arc(headX, headY + 35, 60, 60, HALF_PI, PI + HALF_PI)',correct
'textAlign(CENTER)',correct
'colours / 1.42f',correct
'kumaX = initKumaX',correct
'text(level, 40, 40);',correct
'kumaY = initKumaY',correct
'for (int n = 0; n < (3 + (maxLevel / 5)); n++) {    hazard[n] = new Ball(random(width - 150) + 75, random(height - 150) + 75, random(30) / random(12), random(30) / random(12));}',correct
'{    kumaX = random(width - 150) + 75;    kumaY = random(height - 150) + 75;}',correct
'{    colours = 0;}',correct
'kuma.length',correct
'if (ballX > width - 25 && dx > 0) {    dx = -dx;}',correct
'rectMode(CENTER)',correct
'mouseY <= ballY + 25',correct
'colours = 0',correct
'monomiX = random(width - 150) + 75',correct
'(colours) / 1.42f',correct
'fill(colours / 10, colours / 2, colours)',correct
'void display() {    bodyColor = color(255);    float headX = kumaX;    float headY = kumaY - 28;    stroke(bodyColor);    fill(bodyColor);    // head    noStroke();    arc(headX, headY, 53, 53, HALF_PI, PI + HALF_PI);    noStroke();    arc(headX, headY + 35, 60, 60, HALF_PI, PI + HALF_PI);    // arms    if (colours == 255) {        ellipse(kumaX - 30, kumaY, 12, 12);        ellipse(kumaX - 42, kumaY, 25, 12);        ellipse(kumaX - 55, kumaY, 15, 15);    } else if (colours == 0) {        fill(255);        ellipse(kumaX - 40, kumaY + 20, 15, 15);        ellipse(kumaX - 40, kumaY + 10, 10, 17);        ellipse(kumaX - 40, kumaY, 10, 10);        ellipse(kumaX - 32, kumaY, 15, 10);    }    // legs    ellipse(kumaX - 10, kumaY + 50, 10, 10);    rect(kumaX - 10, kumaY + 40, 10, 20);    // ears    strokeWeight(3);    if (colours == 255) {        fill(255, 119, 180);        ellipse(headX + 15, headY - 28, 15, 25);        ellipse(headX + 25, headY - 38, 25, 15);        fill(bodyColor);        ellipse(headX - 25, headY - 23, 25, 15);        ellipse(headX - 35, headY - 13, 15, 25);    } else if (colours == 0) {        fill(0);        ellipse(headX + 15, headY - 26, 15, 15);        fill(bodyColor);        ellipse(headX - 15, headY - 26, 15, 15);    }    // Body Coloured :    noStroke();    fill(colours, colours / 2.14f, colours / 1.42f);    arc(headX, headY, 53, 53, PI + HALF_PI, TWO_PI + HALF_PI);    noStroke();    fill(colours, colours / 2.14f, colours / 1.42f);    arc(headX, headY + 35, 60, 60, PI + HALF_PI, TWO_PI + HALF_PI);    // legs b    fill(colours, colours / 2.14f, colours / 1.42f);    ellipse(kumaX + 10, kumaY + 50, 10, 10);    rect(kumaX + 10, kumaY + 40, 10, 20);    // arms b    if (colours == 255) {        ellipse(kumaX + 40, kumaY - 20, 15, 15);        ellipse(kumaX + 40, kumaY - 10, 10, 17);        ellipse(kumaX + 40, kumaY, 10, 10);        ellipse(kumaX + 32, kumaY, 15, 10);    } else if (colours == 0) {        fill(0);        ellipse(kumaX + 30, kumaY, 12, 12);        ellipse(kumaX + 42, kumaY, 25, 12);        ellipse(kumaX + 55, kumaY, 15, 15);    }    // eyes :    fill(colours / 10, colours / 2, colours);    ellipse(headX - 10, headY - 10, 7, 7);    if (colours == 0) {        fill(255, 0, 0);        quad(headX + 10, headY - 10, headX + 15, headY - 10, headX + 10, headY - 15, headX + 5, headY - 5);    } else {        fill(255, 0, 0);        ellipse(headX + 10, headY - 10, 7, 7);    }    // buttons    strokeWeight(3);    fill(bodyColor);    ellipse(headX, headY + 30, 15, 15);    fill(colours, colours / 2.14f, colours / 1.42f);    ellipse(headX, headY + 30, 12, 12);    ellipse(headX, headY + 45, 15, 15);    fill(bodyColor);    ellipse(headX, headY + 45, 12, 12);    // Mouth    fill(colours, colours / 2.14f, colours / 1.42f);    ellipse(headX - 5, headY + 2, 13, 13);    fill(colours, colours / 2.14f, colours / 1.42f);    ellipse(headX + 5, headY + 2, 13, 13);    fill(bodyColor);    ellipse(headX - 5, headY + 2, 10, 10);    ellipse(headX + 5, headY + 2, 10, 10);}',correct
'fill(255, 119, 180);',correct
'{    ballX = initX;    ballY = initY;    dx = initdx;    dy = initdy;}',correct
'float dx;',correct
'ellipse(monomiX + 30, monomiY, 12, 12)',correct
'{    sparkleX = mouseX;    sparkleY = mouseY;    trace = true;    monomiA.changepos();    for (int n = 0; n < (1 + level / 5); n++) {        hazard[n].hit();    }}',correct
'if (colours == 255) {    fill(255);    ellipse(monomiX - 40, monomiY + 20, 15, 15);    ellipse(monomiX - 40, monomiY + 10, 10, 17);    ellipse(monomiX - 40, monomiY, 10, 10);    ellipse(monomiX - 32, monomiY, 15, 10);}',correct
'ellipse(monomiX - 32, monomiY, 15, 10);',correct
'arc(headX, headY, 53, 53, PI + HALF_PI, TWO_PI + HALF_PI);',correct
'textSize(height / 6)',correct
'3 * sparkleRadius / 4',correct
'ellipse(headX, headY + 45, 15, 15)',correct
'monomiY = initMonomiY',correct
'rectMode(CENTER);',correct
'if (colours == 255) {    fill(255, 0, 0);    quad(headX + 10, headY - 10, headX + 15, headY - 10, headX + 10, headY - 15, headX + 5, headY - 5);} else {    fill(255, 0, 0);    ellipse(headX + 10, headY - 10, 7, 7);}',correct
'monomiY + 40',correct
'arc(headX, headY + 35, 60, 60, PI + HALF_PI, TWO_PI + HALF_PI)',correct
'// Sparkleif (trace) {    fill(colours, (colours) / 2.14f, (colours) / 1.42f);    sparkleRadius = 20;    float sparkleSize = 3;    for (int i = 0; i < 30; i++) {        ellipse(sparkleX - random(-sparkleRadius, sparkleRadius), sparkleY + random(-sparkleRadius, sparkleRadius), sparkleSize, sparkleSize);        ellipse(sparkleX - random(-sparkleRadius / 2, sparkleRadius / 2), sparkleY + random(-sparkleRadius / 2, sparkleRadius / 2), sparkleSize, sparkleSize);        ellipse(sparkleX - random(-4 * sparkleRadius / 3, 4 * sparkleRadius / 3), sparkleY + random(-3 * sparkleRadius / 4, 3 * sparkleRadius / 4), sparkleSize, sparkleSize);        ellipse(sparkleX - random(-3 * sparkleRadius / 4, 3 * sparkleRadius / 4), sparkleY + random(-4 * sparkleRadius / 3, 4 * sparkleRadius / 3), sparkleSize, sparkleSize);    }}',correct
'kuma[i].eyeglow()',correct
'monomiY = random(height - 150) + 75',correct
'headX - 10',correct
'-3 * sparkleRadius / 4',correct
'monomiX = initMonomiX;',correct
'text("You win", width / 2, height / 2);',correct
'headX - 15',correct
'ellipse(kumaX + 32, kumaY, 15, 10);',correct
'sparkleY = mouseY;',correct
'// Mouthfill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);',correct
'sparkleSize = 3',correct
'float dy;',correct
'{    lives = 3;    trace = false;    level = 1;    hazard[0] = new Ball(random(width - 150) + 75, random(height - 150) + 75, random(30) / random(12), random(30) / random(12));}',correct
'headY - 26',correct
'for (int n = 0; n < (3 + (level / 5)); n++) {    hazard[n].display();}',correct
'// Hitboxvoid changepos() {    if (sparkleX >= monomiX - (4 * sparkleRadius / 3 + 45) && sparkleX <= monomiX + (4 * sparkleRadius / 3 + 45) && sparkleY <= monomiY + (4 * sparkleRadius / 3 + 40) && sparkleY >= monomiY - (4 * sparkleRadius / 3 + 50)) {        monomiX = random(width - 150) + 75;        monomiY = random(height - 150) + 75;        monomiA.changeColour();        if (level >= maxLevel) {            level = 1;        } else            nextLevel = true;        for (int i = 0; i < kuma.length; i++) {            kuma[i] = new Kuma(random(width - 150) + 75, random(height - 150) + 75);        }    }}',correct
'ballY = initY',correct
'mouseX <= ballX + 25',correct
'dx',correct
'dy',correct
'headY - 23',correct
'random(30) / random(12)',correct
'colours / 2.14f',correct
'monomiY + 50',correct
'sparkleRadius',correct
'fill((255 - colours) / 10, (255 - colours) / 2, 255 - colours)',correct
'ellipse(headX, headY + 45, 12, 12);',correct
'kuma[i].display()',correct
'fill(bodyColor)',correct
'monomiX = initMonomiX',correct
'PI + HALF_PI',correct
'headY - 5',correct
'level += 1',correct
'1.42f',correct
'float monomiY;',correct
'void mouseWheel() {    for (int i = 0; i < level; i++) {        kuma[i].eyeglow();    }}',correct
'headX - 25',correct
'{    if (trace) {        trace = false;    }}',correct
'headX = kumaX',correct
'random(-4 * sparkleRadius / 3, 4 * sparkleRadius / 3)',correct
'float initdy',correct
'{    for (int i = 0; i < level; i++) {        kuma[i].eyeglow();    }}',correct
'float initdx',correct
'headY - 28',correct
'headY - 38',correct
'height - 25',correct
'monomiY - (4 * sparkleRadius / 3 + 50)',correct
'colours = 255',correct
'ellipse(kumaX - 40, kumaY + 10, 10, 17);',correct
'fill(bodyColor);',correct
'ellipse(kumaX + 40, kumaY - 10, 10, 17)',correct
'// Body Coloured :noStroke();',correct
'Kuma',correct
'colours',correct
'headX - 35',correct
'ellipse(headX + 25, headY - 38, 25, 15);',correct
'float monomiX;',correct
'fill(colours, colours / 2.14f, colours / 1.42f);',correct
'monomiA.changeColour()',correct
'ellipse(headX - 35, headY - 13, 15, 25)',correct
'hazard[n].hit()',correct
'ballX = random(width - 150) + 75;',correct
'level = 1;',correct
'Processing',correct
'ballY = ballY + dy;',correct
'sparkleRadius = 20;',DrawingStateChangeRule
'monomiY - 10',correct
'ellipse(kumaX + 10, kumaY - 38, 15, 15)',correct
'{    fill(255, 0, 0);    quad(headX + 10, headY - 10, headX + 15, headY - 10, headX + 10, headY - 15, headX + 5, headY - 5);}',correct
'// centre circleellipse(ballX, ballY, 50, 50);',correct
'lives -= 1;',DrawingStateChangeRule
'sparkleY',correct
'sparkleX',correct
'sparkleX <= monomiX + (4 * sparkleRadius / 3 + 45)',correct
'ellipse(kumaX - 55, kumaY, 15, 15);',correct
'// legsellipse(kumaX - 10, kumaY + 50, 10, 10);',correct
'float headY = monomiY - 28',correct
'colours / 2',correct
'false',correct
'float headX = kumaX',correct
'(colours) / 2.14f',correct
'headY - 15',correct
'ellipse(headX + 10, headY - 10, 7, 7);',correct
'level += 1;',DrawingStateChangeRule
'ellipse(headX, headY + 30, 15, 15);',correct
'monomiY - 28',correct
'headY - 13',correct
'monomiA.changepos()',correct
'headY - 10',correct
'ellipse(monomiX + 40, monomiY - 10, 10, 17);',correct
'lives -= 1',correct
'// headnoStroke();',correct
'monomiY - 20',correct
'stroke(bodyColor);',correct
'width - 25',correct
'headY = kumaY - 28',correct
'{    hazard[n] = new Ball(random(width - 150) + 75, random(height - 150) + 75, random(30) / random(12), random(30) / random(12));}',correct
'i = 0',correct
'ellipse(sparkleX - random(-sparkleRadius / 2, sparkleRadius / 2), sparkleY + random(-sparkleRadius / 2, sparkleRadius / 2), sparkleSize, sparkleSize);',correct
'ellipse(sparkleX - random(-sparkleRadius, sparkleRadius), sparkleY + random(-sparkleRadius, sparkleRadius), sparkleSize, sparkleSize);',correct
'// eyes :fill((255 - colours) / 10, (255 - colours) / 2, 255 - colours);',correct
'trace = false;',correct
'// arms bif (colours == 0) {    ellipse(monomiX + 40, monomiY - 20, 15, 15);    ellipse(monomiX + 40, monomiY - 10, 10, 17);    ellipse(monomiX + 40, monomiY, 10, 10);    ellipse(monomiX + 32, monomiY, 15, 10);} else if (colours == 255) {    fill(0);    ellipse(monomiX + 30, monomiY, 12, 12);    ellipse(monomiX + 42, monomiY, 25, 12);    ellipse(monomiX + 55, monomiY, 15, 15);}',correct
'ellipse(headX - 15, headY - 26, 15, 15);',correct
'void changepos() {    kumaX = random(width - 150) + 75;    kumaY = random(height - 150) + 75;}',correct
'kuma[i] = new Kuma(random(width - 150) + 75, random(height - 150) + 75)',correct
'monomiY - 38',correct
'ellipse(monomiX + 40, monomiY, 10, 10)',correct
'{    colours = 255;}',correct
'float ballY;',correct
'rect(kumaX - 10, kumaY + 40, 10, 20)',correct
'dy = -dy',correct
'hazard[n].move();',correct
'{    ellipse(monomiX + 40, monomiY - 20, 15, 15);    ellipse(monomiX + 40, monomiY - 10, 10, 17);    ellipse(monomiX + 40, monomiY, 10, 10);    ellipse(monomiX + 32, monomiY, 15, 10);}',correct
'ellipse(monomiX + 40, monomiY - 20, 15, 15)',correct
'4 * sparkleRadius / 3',correct
'level >= maxLevel',correct
'ellipse(headX - 5, headY + 2, 13, 13)',correct
'ballY < 25',correct
'headY + 2',correct
'monomiX + 10',correct
'// legs bfill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);',correct
'ellipse(headX - 10, headY - 10, 7, 7)',correct
'{    kuma[i] = new Kuma(random(width - 150) + 75, random(height - 150) + 75);}',correct
'n < (1 + level / 5)',correct
'ballY + dy',correct
'monomiY = initMonomiY;',correct
'int n = 0',correct
'noStroke();',correct
'headX - 5',correct
'float kumaX;',correct
'colours = 0;',correct
'sparkleX >= monomiX - (4 * sparkleRadius / 3 + 45)',correct
'(255 - colours) / 2.14f',correct
'float sparkleSize = 3;',correct
'ellipse(headX + 10, headY - 10, 7, 7)',correct
'random(30)',correct
'// // third petal',correct
'hazard[0] = new Ball(random(width - 150) + 75, random(height - 150) + 75, random(30) / random(12), random(30) / random(12))',correct
'ellipse(monomiX - 32, monomiY, 15, 10)',correct
'ellipse(monomiX + 55, monomiY, 15, 15);',correct
'random(height - 150) + 75',correct
'if (nextLevel && level < maxLevel) {    level += 1;    nextLevel = false;}',correct
'nextLevel && level < maxLevel',correct
'kumaY = initKumaY;',correct
'loselive',correct
'i < kuma.length',correct
'kumaY - 38',correct
'{    trace = false;}',correct
'sparkleY <= monomiY + (4 * sparkleRadius / 3 + 40)',correct
'float kumaY;',correct
'ellipse(kumaX + 40, kumaY - 20, 15, 15);',correct
'TWO_PI + HALF_PI',correct
'// legs bfill(colours, colours / 2.14f, colours / 1.42f);',correct
'dy = initdy',correct
'Monomi(float initMonomiX, float initMonomiY) {    monomiX = initMonomiX;    monomiY = initMonomiY;}',correct
'draw',LongMethodRule
'n < (3 + (maxLevel / 5))',correct
'lives = 3;',DrawingStateChangeRule
'fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);',correct
'ellipse(monomiX - 55, monomiY, 15, 15);',correct
'ellipse(headX + 5, headY + 2, 10, 10);',correct
'kumaX = random(width - 150) + 75;',correct
'sparkleRadius / 2',correct
'ellipse(headX, headY + 30, 12, 12)',correct
'dx = -dx',correct
'void display() {    fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);    // centre circle    ellipse(ballX, ballY, 50, 50);// if (colours==255) {// // first petal// ellipse(ballX, ballY-50, 50, 70);// // second petal// // rotate 72 degrees// rotate(radians(72));// ellipse(ballX, ballY-50, 50, 70);// // third petal// rotate(radians(72));// ellipse(ballX, ballY-50, 50, 70);// // fourth petal// rotate(radians(72));// ellipse(ballX, ballY-50, 50, 70);// // fifth petal// rotate(radians(72));// ellipse(ballX, ballY-50, 50, 70);// }}',correct
'if (level >= maxLevel) {    level = 1;} else    nextLevel = true;',correct
'kumaX',correct
'{    kumaX = initKumaX;    kumaY = initKumaY;}',correct
'-dx',correct
'kumaY',correct
'-dy',correct
'fill(255, 0, 0)',correct
'new Kuma[maxLevel]',correct
'headY = monomiY - 28',correct
'monomiA.changepos();',correct
'ellipse(sparkleX - random(-4 * sparkleRadius / 3, 4 * sparkleRadius / 3), sparkleY + random(-3 * sparkleRadius / 4, 3 * sparkleRadius / 4), sparkleSize, sparkleSize)',correct
'monomiA = new Monomi(3 * width / 4, height / 2)',correct
'monomiX + 42',correct
'monomiX + 40',correct
'void display() {    bodyColor = color(255);    float headX = monomiX;    float headY = monomiY - 28;    stroke(bodyColor);    fill(bodyColor);    // head    noStroke();    arc(headX, headY, 53, 53, HALF_PI, PI + HALF_PI);    noStroke();    arc(headX, headY + 35, 60, 60, HALF_PI, PI + HALF_PI);    // arms    if (colours == 0) {        ellipse(monomiX - 30, monomiY, 12, 12);        ellipse(monomiX - 42, monomiY, 25, 12);        ellipse(monomiX - 55, monomiY, 15, 15);    } else if (colours == 255) {        fill(255);        ellipse(monomiX - 40, monomiY + 20, 15, 15);        ellipse(monomiX - 40, monomiY + 10, 10, 17);        ellipse(monomiX - 40, monomiY, 10, 10);        ellipse(monomiX - 32, monomiY, 15, 10);    }    // legs    ellipse(monomiX - 10, monomiY + 50, 10, 10);    rect(monomiX - 10, monomiY + 40, 10, 20);    // ears    strokeWeight(3);    if (colours == 0) {        fill(255, 119, 180);        ellipse(headX + 15, headY - 28, 15, 25);        ellipse(headX + 25, headY - 38, 25, 15);        fill(bodyColor);        ellipse(headX - 25, headY - 23, 25, 15);        ellipse(headX - 35, headY - 13, 15, 25);    } else if (colours == 255) {        fill(0);        ellipse(headX + 15, headY - 26, 15, 15);        fill(bodyColor);        ellipse(headX - 15, headY - 26, 15, 15);    }    // Body Coloured :    noStroke();    fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);    arc(headX, headY, 53, 53, PI + HALF_PI, TWO_PI + HALF_PI);    noStroke();    fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);    arc(headX, headY + 35, 60, 60, PI + HALF_PI, TWO_PI + HALF_PI);    // legs b    fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);    ellipse(monomiX + 10, monomiY + 50, 10, 10);    rect(monomiX + 10, monomiY + 40, 10, 20);    // arms b    if (colours == 0) {        ellipse(monomiX + 40, monomiY - 20, 15, 15);        ellipse(monomiX + 40, monomiY - 10, 10, 17);        ellipse(monomiX + 40, monomiY, 10, 10);        ellipse(monomiX + 32, monomiY, 15, 10);    } else if (colours == 255) {        fill(0);        ellipse(monomiX + 30, monomiY, 12, 12);        ellipse(monomiX + 42, monomiY, 25, 12);        ellipse(monomiX + 55, monomiY, 15, 15);    }    // eyes :    fill((255 - colours) / 10, (255 - colours) / 2, 255 - colours);    ellipse(headX - 10, headY - 10, 7, 7);    if (colours == 255) {        fill(255, 0, 0);        quad(headX + 10, headY - 10, headX + 15, headY - 10, headX + 10, headY - 15, headX + 5, headY - 5);    } else {        fill(255, 0, 0);        ellipse(headX + 10, headY - 10, 7, 7);    }    // buttons    strokeWeight(3);    fill(bodyColor);    ellipse(headX, headY + 30, 15, 15);    fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);    ellipse(headX, headY + 30, 12, 12);    ellipse(headX, headY + 45, 15, 15);    fill(bodyColor);    ellipse(headX, headY + 45, 12, 12);    // Mouth    fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);    ellipse(headX - 5, headY + 2, 13, 13);    fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);    ellipse(headX + 5, headY + 2, 13, 13);    fill(bodyColor);    ellipse(headX - 5, headY + 2, 10, 10);    ellipse(headX + 5, headY + 2, 10, 10);}',correct
'ellipseMode(CENTER)',correct
'loselive = true',correct
'level < maxLevel',correct
'{    if (ballX > width - 25 && dx > 0) {        dx = -dx;    }    if (ballX < 25 && dx < 0) {        dx = -dx;    }    if (ballY > height - 25 && dy > 0) {        dy = -dy;    }    if (ballY < 25 && dy < 0) {        dy = -dy;    } else {        ballX = ballX + dx;        ballY = ballY + dy;    }}',correct
'strokeWeight(3)',correct
'fill(random(255), 0, 0);',correct
'kumaY - 10',correct
'trace = true',correct
'fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f)',correct
'sparkleX >= monomiX - (4 * sparkleRadius / 3 + 45) && sparkleX <= monomiX + (4 * sparkleRadius / 3 + 45) && sparkleY <= monomiY + (4 * sparkleRadius / 3 + 40)',correct
'// mouseDragged as boolean, used for sparkle.boolean trace;',correct
'ballX = initX;',correct
'kumaX = initKumaX;',correct
'void',correct
'mouseX >= ballX - 25 && mouseX <= ballX + 25 && mouseY >= ballY - 25 && mouseY <= ballY + 25',correct
'fill(255, 119, 180)',correct
'hazard = new Ball[(3 + (maxLevel / 5))]',correct
'level',correct
'-3',correct
'-4',correct
'(255 - colours) / 1.42f',correct
'mouseY >= ballY - 25',correct
'monomiX + 55',correct
'{    ellipse(sparkleX - random(-sparkleRadius, sparkleRadius), sparkleY + random(-sparkleRadius, sparkleRadius), sparkleSize, sparkleSize);    ellipse(sparkleX - random(-sparkleRadius / 2, sparkleRadius / 2), sparkleY + random(-sparkleRadius / 2, sparkleRadius / 2), sparkleSize, sparkleSize);    ellipse(sparkleX - random(-4 * sparkleRadius / 3, 4 * sparkleRadius / 3), sparkleY + random(-3 * sparkleRadius / 4, 3 * sparkleRadius / 4), sparkleSize, sparkleSize);    ellipse(sparkleX - random(-3 * sparkleRadius / 4, 3 * sparkleRadius / 4), sparkleY + random(-4 * sparkleRadius / 3, 4 * sparkleRadius / 3), sparkleSize, sparkleSize);}',correct
'sparkleX - random(-4 * sparkleRadius / 3, 4 * sparkleRadius / 3)',correct
'ellipse(monomiX - 40, monomiY + 10, 10, 17)',correct
'// eyes :fill(colours / 10, colours / 2, colours);',correct
'rect(monomiX + 10, monomiY + 40, 10, 20);',correct
'kumaY - 28',correct
'headX + 5',correct
'ellipse(kumaX + 32, kumaY, 15, 10)',correct
'ellipse(monomiX - 40, monomiY, 10, 10);',correct
'true',correct
'kumaY - 20',correct
'fill(colours, (colours) / 2.14f, (colours) / 1.42f)',correct
'{    level = 1;}',correct
'ellipse(kumaX + 30, kumaY, 12, 12)',correct
'(255 - colours) / 10',correct
'headX + 10',correct
'if (colours == 0) {    fill(255, 119, 180);    ellipse(headX + 15, headY - 28, 15, 25);    ellipse(headX + 25, headY - 38, 25, 15);    fill(bodyColor);    ellipse(headX - 25, headY - 23, 25, 15);    ellipse(headX - 35, headY - 13, 15, 25);} else if (colours == 255) {    fill(0);    ellipse(headX + 15, headY - 26, 15, 15);    fill(bodyColor);    ellipse(headX - 15, headY - 26, 15, 15);}',correct
'int lives;',correct
'ellipse(headX + 5, headY + 2, 13, 13);',correct
'ellipse(kumaX - 30, kumaY, 12, 12)',correct
'monomiY',correct
'monomiX',correct
'sparkleY >= monomiY - (4 * sparkleRadius / 3 + 50)',correct
'mouseX >= ballX - 25 && mouseX <= ballX + 25',correct
'hazard[n].hit();',correct
'monomiA',correct
'background(200, 255, 219);',correct
'sparkleY = mouseY',correct
'ellipse(headX - 25, headY - 23, 25, 15);',correct
'bodyColor = color(255);',correct
'random(-3 * sparkleRadius / 4, 3 * sparkleRadius / 4)',correct
'kumaY + 50',correct
'if (colours == 255) {    fill(255, 119, 180);    ellipse(headX + 15, headY - 28, 15, 25);    ellipse(headX + 25, headY - 38, 25, 15);    fill(bodyColor);    ellipse(headX - 25, headY - 23, 25, 15);    ellipse(headX - 35, headY - 13, 15, 25);} else if (colours == 0) {    fill(0);    ellipse(headX + 15, headY - 26, 15, 15);    fill(bodyColor);    ellipse(headX - 15, headY - 26, 15, 15);}',correct
'if (colours == 0) {    colours = 255;} else {    colours = 0;}',correct
'rect(kumaX - 10, kumaY + 40, 10, 20);',correct
'monomiX + 32',correct
'monomiA.changeColour();',correct
'rect(monomiX - 10, monomiY + 40, 10, 20);',correct
'monomiX + 30',correct
'{    bodyColor = color(255);    float headX = monomiX;    float headY = monomiY - 28;    stroke(bodyColor);    fill(bodyColor);    // head    noStroke();    arc(headX, headY, 53, 53, HALF_PI, PI + HALF_PI);    noStroke();    arc(headX, headY + 35, 60, 60, HALF_PI, PI + HALF_PI);    // arms    if (colours == 0) {        ellipse(monomiX - 30, monomiY, 12, 12);        ellipse(monomiX - 42, monomiY, 25, 12);        ellipse(monomiX - 55, monomiY, 15, 15);    } else if (colours == 255) {        fill(255);        ellipse(monomiX - 40, monomiY + 20, 15, 15);        ellipse(monomiX - 40, monomiY + 10, 10, 17);        ellipse(monomiX - 40, monomiY, 10, 10);        ellipse(monomiX - 32, monomiY, 15, 10);    }    // legs    ellipse(monomiX - 10, monomiY + 50, 10, 10);    rect(monomiX - 10, monomiY + 40, 10, 20);    // ears    strokeWeight(3);    if (colours == 0) {        fill(255, 119, 180);        ellipse(headX + 15, headY - 28, 15, 25);        ellipse(headX + 25, headY - 38, 25, 15);        fill(bodyColor);        ellipse(headX - 25, headY - 23, 25, 15);        ellipse(headX - 35, headY - 13, 15, 25);    } else if (colours == 255) {        fill(0);        ellipse(headX + 15, headY - 26, 15, 15);        fill(bodyColor);        ellipse(headX - 15, headY - 26, 15, 15);    }    // Body Coloured :    noStroke();    fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);    arc(headX, headY, 53, 53, PI + HALF_PI, TWO_PI + HALF_PI);    noStroke();    fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);    arc(headX, headY + 35, 60, 60, PI + HALF_PI, TWO_PI + HALF_PI);    // legs b    fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);    ellipse(monomiX + 10, monomiY + 50, 10, 10);    rect(monomiX + 10, monomiY + 40, 10, 20);    // arms b    if (colours == 0) {        ellipse(monomiX + 40, monomiY - 20, 15, 15);        ellipse(monomiX + 40, monomiY - 10, 10, 17);        ellipse(monomiX + 40, monomiY, 10, 10);        ellipse(monomiX + 32, monomiY, 15, 10);    } else if (colours == 255) {        fill(0);        ellipse(monomiX + 30, monomiY, 12, 12);        ellipse(monomiX + 42, monomiY, 25, 12);        ellipse(monomiX + 55, monomiY, 15, 15);    }    // eyes :    fill((255 - colours) / 10, (255 - colours) / 2, 255 - colours);    ellipse(headX - 10, headY - 10, 7, 7);    if (colours == 255) {        fill(255, 0, 0);        quad(headX + 10, headY - 10, headX + 15, headY - 10, headX + 10, headY - 15, headX + 5, headY - 5);    } else {        fill(255, 0, 0);        ellipse(headX + 10, headY - 10, 7, 7);    }    // buttons    strokeWeight(3);    fill(bodyColor);    ellipse(headX, headY + 30, 15, 15);    fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);    ellipse(headX, headY + 30, 12, 12);    ellipse(headX, headY + 45, 15, 15);    fill(bodyColor);    ellipse(headX, headY + 45, 12, 12);    // Mouth    fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);    ellipse(headX - 5, headY + 2, 13, 13);    fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);    ellipse(headX + 5, headY + 2, 13, 13);    fill(bodyColor);    ellipse(headX - 5, headY + 2, 10, 10);    ellipse(headX + 5, headY + 2, 10, 10);}',LongMethodRule
'Kuma(float initKumaX, float initKumaY) {    kumaX = initKumaX;    kumaY = initKumaY;}',correct
'{    background(200, 255, 219);    textSize(25);    fill(0, 0, 0);    text(level, 40, 40);    if (nextLevel && level < maxLevel) {        level += 1;        nextLevel = false;    }    if (loselive && lives >= 0) {        lives -= 1;        loselive = false;    } else if (lives <= 0) {        lives = 3;        trace = false;        level = 1;        hazard[0] = new Ball(random(width - 150) + 75, random(height - 150) + 75, random(30) / random(12), random(30) / random(12));    }    monomiA.display();    for (int i = 0; i < level; i++) {        kuma[i].display();    }    for (int n = 0; n < (3 + (level / 5)); n++) {        hazard[n].display();    }    for (int n = 0; n < (3 + (level / 5)); n++) {        hazard[n].move();    }    if (level >= maxLevel) {        fill(0);        textSize(height / 6);        text("You win", width / 2, height / 2);    }    // Sparkle    if (trace) {        fill(colours, (colours) / 2.14f, (colours) / 1.42f);        sparkleRadius = 20;        float sparkleSize = 3;        for (int i = 0; i < 30; i++) {            ellipse(sparkleX - random(-sparkleRadius, sparkleRadius), sparkleY + random(-sparkleRadius, sparkleRadius), sparkleSize, sparkleSize);            ellipse(sparkleX - random(-sparkleRadius / 2, sparkleRadius / 2), sparkleY + random(-sparkleRadius / 2, sparkleRadius / 2), sparkleSize, sparkleSize);            ellipse(sparkleX - random(-4 * sparkleRadius / 3, 4 * sparkleRadius / 3), sparkleY + random(-3 * sparkleRadius / 4, 3 * sparkleRadius / 4), sparkleSize, sparkleSize);            ellipse(sparkleX - random(-3 * sparkleRadius / 4, 3 * sparkleRadius / 4), sparkleY + random(-4 * sparkleRadius / 3, 4 * sparkleRadius / 3), sparkleSize, sparkleSize);        }    }}',LongMethodRule
'ellipse(monomiX + 55, monomiY, 15, 15)',correct
'ballX + 25',correct
'ellipse(monomiX + 10, monomiY - 38, 15, 15)',correct
'{    fill(0);    textSize(height / 6);    text("You win", width / 2, height / 2);}',correct
'hazard[n] = new Ball(random(width - 150) + 75, random(height - 150) + 75, random(30) / random(12), random(30) / random(12))',correct
'headX + 15',correct
'float ballX;',correct
'background(200, 255, 219)',correct
'Kuma[] kuma = new Kuma[maxLevel];',correct
'monomiX - (4 * sparkleRadius / 3 + 45)',correct
'Ball',correct
'// Hitbox',correct
'float headX = monomiX;',correct
'float headX;',correct
'fill(colours, (colours) / 2.14f, (colours) / 1.42f);',correct
'if (trace) {    trace = false;}',correct
'dx > 0',correct
'void changeColour() {    if (colours == 0) {        colours = 255;    } else {        colours = 0;    }}',correct
'kuma = new Kuma[maxLevel]',correct
'for (int i = 0; i < maxLevel; i++) {    kuma[i] = new Kuma(random(width - 150) + 75, random(height - 150) + 75);}',correct
'n < (3 + (level / 5))',correct
'textSize(25);',correct
'changepos',correct
'// // second petal',correct
'quad(headX + 10, headY - 10, headX + 15, headY - 10, headX + 10, headY - 15, headX + 5, headY - 5)',correct
'dy < 0',correct
'sparkleY + random(-3 * sparkleRadius / 4, 3 * sparkleRadius / 4)',correct
'Kuma[]',correct
'monomiX - 32',correct
'ballY < 25 && dy < 0',correct
'ballX < 25 && dx < 0',correct
'if (colours == 255) {    fill(0);    ellipse(monomiX + 30, monomiY, 12, 12);    ellipse(monomiX + 42, monomiY, 25, 12);    ellipse(monomiX + 55, monomiY, 15, 15);}',correct
'float headY;',correct
'sparkleX - random(-sparkleRadius / 2, sparkleRadius / 2)',correct
'random(width - 150)',correct
'for (int n = 0; n < (3 + (level / 5)); n++) {    hazard[n].move();}',correct
'monomiX - 30',correct
'ellipse(headX, headY + 30, 15, 15)',correct
'for (int i = 0; i < level; i++) {    kuma[i].eyeglow();}',correct
'for (int n = 0; n < (1 + level / 5); n++) {    hazard[n].hit();}',correct
'{    fill(255, 119, 180);    ellipse(headX + 15, headY - 28, 15, 25);    ellipse(headX + 25, headY - 38, 25, 15);    fill(bodyColor);    ellipse(headX - 25, headY - 23, 25, 15);    ellipse(headX - 35, headY - 13, 15, 25);}',correct
'ellipse(kumaX + 55, kumaY, 15, 15)',correct
'kumaY + 40',correct
'fill(255, 0, 0);',correct
'// }',correct
'lives >= 0',correct
'Ball(float initX, float initY, float initdx, float initdy) {    ballX = initX;    ballY = initY;    dx = initdx;    dy = initdy;}',correct
'ellipse(kumaX - 40, kumaY + 20, 15, 15);',correct
'boolean nextLevel;',correct
'maxLevel = 20',correct
'void eyeglow() {    fill(random(255), 0, 0);    ellipse(monomiX + 10, monomiY - 38, 15, 15);}',correct
'class Kuma {    int bodyColor;    float headX;    float headY;    float kumaX;    float kumaY;    Kuma(float initKumaX, float initKumaY) {        kumaX = initKumaX;        kumaY = initKumaY;    }    void display() {        bodyColor = color(255);        float headX = kumaX;        float headY = kumaY - 28;        stroke(bodyColor);        fill(bodyColor);        // head        noStroke();        arc(headX, headY, 53, 53, HALF_PI, PI + HALF_PI);        noStroke();        arc(headX, headY + 35, 60, 60, HALF_PI, PI + HALF_PI);        // arms        if (colours == 255) {            ellipse(kumaX - 30, kumaY, 12, 12);            ellipse(kumaX - 42, kumaY, 25, 12);            ellipse(kumaX - 55, kumaY, 15, 15);        } else if (colours == 0) {            fill(255);            ellipse(kumaX - 40, kumaY + 20, 15, 15);            ellipse(kumaX - 40, kumaY + 10, 10, 17);            ellipse(kumaX - 40, kumaY, 10, 10);            ellipse(kumaX - 32, kumaY, 15, 10);        }        // legs        ellipse(kumaX - 10, kumaY + 50, 10, 10);        rect(kumaX - 10, kumaY + 40, 10, 20);        // ears        strokeWeight(3);        if (colours == 255) {            fill(255, 119, 180);            ellipse(headX + 15, headY - 28, 15, 25);            ellipse(headX + 25, headY - 38, 25, 15);            fill(bodyColor);            ellipse(headX - 25, headY - 23, 25, 15);            ellipse(headX - 35, headY - 13, 15, 25);        } else if (colours == 0) {            fill(0);            ellipse(headX + 15, headY - 26, 15, 15);            fill(bodyColor);            ellipse(headX - 15, headY - 26, 15, 15);        }        // Body Coloured :        noStroke();        fill(colours, colours / 2.14f, colours / 1.42f);        arc(headX, headY, 53, 53, PI + HALF_PI, TWO_PI + HALF_PI);        noStroke();        fill(colours, colours / 2.14f, colours / 1.42f);        arc(headX, headY + 35, 60, 60, PI + HALF_PI, TWO_PI + HALF_PI);        // legs b        fill(colours, colours / 2.14f, colours / 1.42f);        ellipse(kumaX + 10, kumaY + 50, 10, 10);        rect(kumaX + 10, kumaY + 40, 10, 20);        // arms b        if (colours == 255) {            ellipse(kumaX + 40, kumaY - 20, 15, 15);            ellipse(kumaX + 40, kumaY - 10, 10, 17);            ellipse(kumaX + 40, kumaY, 10, 10);            ellipse(kumaX + 32, kumaY, 15, 10);        } else if (colours == 0) {            fill(0);            ellipse(kumaX + 30, kumaY, 12, 12);            ellipse(kumaX + 42, kumaY, 25, 12);            ellipse(kumaX + 55, kumaY, 15, 15);        }        // eyes :        fill(colours / 10, colours / 2, colours);        ellipse(headX - 10, headY - 10, 7, 7);        if (colours == 0) {            fill(255, 0, 0);            quad(headX + 10, headY - 10, headX + 15, headY - 10, headX + 10, headY - 15, headX + 5, headY - 5);        } else {            fill(255, 0, 0);            ellipse(headX + 10, headY - 10, 7, 7);        }        // buttons        strokeWeight(3);        fill(bodyColor);        ellipse(headX, headY + 30, 15, 15);        fill(colours, colours / 2.14f, colours / 1.42f);        ellipse(headX, headY + 30, 12, 12);        ellipse(headX, headY + 45, 15, 15);        fill(bodyColor);        ellipse(headX, headY + 45, 12, 12);        // Mouth        fill(colours, colours / 2.14f, colours / 1.42f);        ellipse(headX - 5, headY + 2, 13, 13);        fill(colours, colours / 2.14f, colours / 1.42f);        ellipse(headX + 5, headY + 2, 13, 13);        fill(bodyColor);        ellipse(headX - 5, headY + 2, 10, 10);        ellipse(headX + 5, headY + 2, 10, 10);    }    void changeColour() {        if (colours == 0) {            colours = 255;        } else {            colours = 0;        }    }    void changepos() {        kumaX = random(width - 150) + 75;        kumaY = random(height - 150) + 75;    }    void eyeglow() {        fill(random(255), 0, 0);        ellipse(kumaX + 10, kumaY - 38, 15, 15);    }}',correct
'random(height - 150)',correct
'n++',correct
'ellipse(monomiX - 40, monomiY + 10, 10, 17);',correct
'kumaY + 10',correct
'trace = false',correct
'class Ball {    float ballX;    float ballY;    float dx;    float dy;    Ball(float initX, float initY, float initdx, float initdy) {        ballX = initX;        ballY = initY;        dx = initdx;        dy = initdy;    }    void display() {        fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);        // centre circle        ellipse(ballX, ballY, 50, 50);    // if (colours==255) {    // // first petal    // ellipse(ballX, ballY-50, 50, 70);    // // second petal    // // rotate 72 degrees    // rotate(radians(72));    // ellipse(ballX, ballY-50, 50, 70);    // // third petal    // rotate(radians(72));    // ellipse(ballX, ballY-50, 50, 70);    // // fourth petal    // rotate(radians(72));    // ellipse(ballX, ballY-50, 50, 70);    // // fifth petal    // rotate(radians(72));    // ellipse(ballX, ballY-50, 50, 70);    // }    }    void move() {        if (ballX > width - 25 && dx > 0) {            dx = -dx;        }        if (ballX < 25 && dx < 0) {            dx = -dx;        }        if (ballY > height - 25 && dy > 0) {            dy = -dy;        }        if (ballY < 25 && dy < 0) {            dy = -dy;        } else {            ballX = ballX + dx;            ballY = ballY + dy;        }    }    void hit() {        if (mouseX >= ballX - 25 && mouseX <= ballX + 25 && mouseY >= ballY - 25 && mouseY <= ballY + 25) {            loselive = true;            ballX = random(width - 150) + 75;            ballY = random(height - 150) + 75;        }    }}',correct
'// if (colours==255) {',correct
'float headY = kumaY - 28',correct
'float sparkleSize = 3',correct
'// earsstrokeWeight(3);',correct
'monomiX - 10',correct
'ellipse(headX + 5, headY + 2, 10, 10)',correct
'Monomi',correct
'if (level >= maxLevel) {    fill(0);    textSize(height / 6);    text("You win", width / 2, height / 2);}',correct
'ellipse(monomiX + 32, monomiY, 15, 10);',correct
'kumaY + 20',correct
'random(-sparkleRadius / 2, sparkleRadius / 2)',correct
'{    monomiX = initMonomiX;    monomiY = initMonomiY;}',correct
'ellipse(monomiX + 42, monomiY, 25, 12)',correct
'{    if (sparkleX >= monomiX - (4 * sparkleRadius / 3 + 45) && sparkleX <= monomiX + (4 * sparkleRadius / 3 + 45) && sparkleY <= monomiY + (4 * sparkleRadius / 3 + 40) && sparkleY >= monomiY - (4 * sparkleRadius / 3 + 50)) {        monomiX = random(width - 150) + 75;        monomiY = random(height - 150) + 75;        monomiA.changeColour();        if (level >= maxLevel) {            level = 1;        } else            nextLevel = true;        for (int i = 0; i < kuma.length; i++) {            kuma[i] = new Kuma(random(width - 150) + 75, random(height - 150) + 75);        }    }}',correct
'Monomi monomiA;',correct
'hazard[n].move()',correct
'kuma[i].display();',correct
'3 * sparkleRadius',correct
'random(255)',correct
'// Mouthfill(colours, colours / 2.14f, colours / 1.42f);',correct
'noStroke()',correct
'ballX > width - 25',correct
'ellipse(kumaX - 40, kumaY, 10, 10);',correct
'ellipse(headX + 15, headY - 26, 15, 15);',correct
'i < maxLevel',correct
'textSize(25)',correct
'ellipse(monomiX + 40, monomiY - 20, 15, 15);',correct
'random(12)',correct
'if (loselive && lives >= 0) {    lives -= 1;    loselive = false;} else if (lives <= 0) {    lives = 3;    trace = false;    level = 1;    hazard[0] = new Ball(random(width - 150) + 75, random(height - 150) + 75, random(30) / random(12), random(30) / random(12));}',correct
'void eyeglow() {    fill(random(255), 0, 0);    ellipse(kumaX + 10, kumaY - 38, 15, 15);}',correct
'text(level, 40, 40)',correct
'ellipse(monomiX - 42, monomiY, 25, 12);',correct
'dx < 0',correct
'ballY = initY;',correct
'int sparkleRadius;',correct
'ballX = random(width - 150) + 75',correct
'hazard[n] = new Ball(random(width - 150) + 75, random(height - 150) + 75, random(30) / random(12), random(30) / random(12));',correct
'ellipse(monomiX + 40, monomiY, 10, 10);',correct
'arc(headX, headY + 35, 60, 60, PI + HALF_PI, TWO_PI + HALF_PI);',correct
'ellipse(kumaX - 40, kumaY + 20, 15, 15)',correct
'ellipse(kumaX + 42, kumaY, 25, 12)',correct
'{    hazard[n].display();}',correct
'kuma[i] = new Kuma(random(width - 150) + 75, random(height - 150) + 75);',correct
'{    ellipse(kumaX + 40, kumaY - 20, 15, 15);    ellipse(kumaX + 40, kumaY - 10, 10, 17);    ellipse(kumaX + 40, kumaY, 10, 10);    ellipse(kumaX + 32, kumaY, 15, 10);}',correct
'ballY > height - 25 && dy > 0',correct
'ellipse(kumaX + 10, kumaY + 50, 10, 10);',correct
'// rotate(radians(72));',correct
'ellipse(headX, headY + 30, 12, 12);',correct
'ballX - 25',correct
'ballX = ballX + dx;',correct
'height / 6',correct
'fill(0)',correct
'ellipse(headX - 10, headY - 10, 7, 7);',correct
'height / 2',correct
'-4 * sparkleRadius',correct
'sparkleX - random(-3 * sparkleRadius / 4, 3 * sparkleRadius / 4)',correct
'if (sparkleX >= monomiX - (4 * sparkleRadius / 3 + 45) && sparkleX <= monomiX + (4 * sparkleRadius / 3 + 45) && sparkleY <= monomiY + (4 * sparkleRadius / 3 + 40) && sparkleY >= monomiY - (4 * sparkleRadius / 3 + 50)) {    monomiX = random(width - 150) + 75;    monomiY = random(height - 150) + 75;    monomiA.changeColour();    if (level >= maxLevel) {        level = 1;    } else        nextLevel = true;    for (int i = 0; i < kuma.length; i++) {        kuma[i] = new Kuma(random(width - 150) + 75, random(height - 150) + 75);    }}',correct
'{    fill(random(255), 0, 0);    ellipse(monomiX + 10, monomiY - 38, 15, 15);}',correct
'ellipse(kumaX - 32, kumaY, 15, 10);',correct
'hazard[0] = new Ball(random(width - 150) + 75, random(height - 150) + 75, random(30) / random(12), random(30) / random(12));',DrawingStateChangeRule
'sparkleRadius = 20',correct
'{    fill(0);    ellipse(headX + 15, headY - 26, 15, 15);    fill(bodyColor);    ellipse(headX - 15, headY - 26, 15, 15);}',correct
'"You win"',correct
'monomiX - 42',correct
'void move() {    if (ballX > width - 25 && dx > 0) {        dx = -dx;    }    if (ballX < 25 && dx < 0) {        dx = -dx;    }    if (ballY > height - 25 && dy > 0) {        dy = -dy;    }    if (ballY < 25 && dy < 0) {        dy = -dy;    } else {        ballX = ballX + dx;        ballY = ballY + dy;    }}',correct
'(255 - colours) / 2',correct
'{    fill(255);    ellipse(monomiX - 40, monomiY + 20, 15, 15);    ellipse(monomiX - 40, monomiY + 10, 10, 17);    ellipse(monomiX - 40, monomiY, 10, 10);    ellipse(monomiX - 32, monomiY, 15, 10);}',correct
'int bodyColor;',correct
'[(3 + (maxLevel / 5))]',correct
'ellipse(monomiX - 40, monomiY, 10, 10)',correct
'fill(255)',correct
'ellipse(ballX, ballY, 50, 50)',correct
'void draw() {    background(200, 255, 219);    textSize(25);    fill(0, 0, 0);    text(level, 40, 40);    if (nextLevel && level < maxLevel) {        level += 1;        nextLevel = false;    }    if (loselive && lives >= 0) {        lives -= 1;        loselive = false;    } else if (lives <= 0) {        lives = 3;        trace = false;        level = 1;        hazard[0] = new Ball(random(width - 150) + 75, random(height - 150) + 75, random(30) / random(12), random(30) / random(12));    }    monomiA.display();    for (int i = 0; i < level; i++) {        kuma[i].display();    }    for (int n = 0; n < (3 + (level / 5)); n++) {        hazard[n].display();    }    for (int n = 0; n < (3 + (level / 5)); n++) {        hazard[n].move();    }    if (level >= maxLevel) {        fill(0);        textSize(height / 6);        text("You win", width / 2, height / 2);    }    // Sparkle    if (trace) {        fill(colours, (colours) / 2.14f, (colours) / 1.42f);        sparkleRadius = 20;        float sparkleSize = 3;        for (int i = 0; i < 30; i++) {            ellipse(sparkleX - random(-sparkleRadius, sparkleRadius), sparkleY + random(-sparkleRadius, sparkleRadius), sparkleSize, sparkleSize);            ellipse(sparkleX - random(-sparkleRadius / 2, sparkleRadius / 2), sparkleY + random(-sparkleRadius / 2, sparkleRadius / 2), sparkleSize, sparkleSize);            ellipse(sparkleX - random(-4 * sparkleRadius / 3, 4 * sparkleRadius / 3), sparkleY + random(-3 * sparkleRadius / 4, 3 * sparkleRadius / 4), sparkleSize, sparkleSize);            ellipse(sparkleX - random(-3 * sparkleRadius / 4, 3 * sparkleRadius / 4), sparkleY + random(-4 * sparkleRadius / 3, 4 * sparkleRadius / 3), sparkleSize, sparkleSize);        }    }}',correct
'hazard[n].display()',correct
'monomiX - 40',correct
'ellipse(monomiX + 10, monomiY + 50, 10, 10);',correct
'class Monomi {    int bodyColor;    float headX;    float headY;    float monomiX;    float monomiY;    Monomi(float initMonomiX, float initMonomiY) {        monomiX = initMonomiX;        monomiY = initMonomiY;    }    void display() {        bodyColor = color(255);        float headX = monomiX;        float headY = monomiY - 28;        stroke(bodyColor);        fill(bodyColor);        // head        noStroke();        arc(headX, headY, 53, 53, HALF_PI, PI + HALF_PI);        noStroke();        arc(headX, headY + 35, 60, 60, HALF_PI, PI + HALF_PI);        // arms        if (colours == 0) {            ellipse(monomiX - 30, monomiY, 12, 12);            ellipse(monomiX - 42, monomiY, 25, 12);            ellipse(monomiX - 55, monomiY, 15, 15);        } else if (colours == 255) {            fill(255);            ellipse(monomiX - 40, monomiY + 20, 15, 15);            ellipse(monomiX - 40, monomiY + 10, 10, 17);            ellipse(monomiX - 40, monomiY, 10, 10);            ellipse(monomiX - 32, monomiY, 15, 10);        }        // legs        ellipse(monomiX - 10, monomiY + 50, 10, 10);        rect(monomiX - 10, monomiY + 40, 10, 20);        // ears        strokeWeight(3);        if (colours == 0) {            fill(255, 119, 180);            ellipse(headX + 15, headY - 28, 15, 25);            ellipse(headX + 25, headY - 38, 25, 15);            fill(bodyColor);            ellipse(headX - 25, headY - 23, 25, 15);            ellipse(headX - 35, headY - 13, 15, 25);        } else if (colours == 255) {            fill(0);            ellipse(headX + 15, headY - 26, 15, 15);            fill(bodyColor);            ellipse(headX - 15, headY - 26, 15, 15);        }        // Body Coloured :        noStroke();        fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);        arc(headX, headY, 53, 53, PI + HALF_PI, TWO_PI + HALF_PI);        noStroke();        fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);        arc(headX, headY + 35, 60, 60, PI + HALF_PI, TWO_PI + HALF_PI);        // legs b        fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);        ellipse(monomiX + 10, monomiY + 50, 10, 10);        rect(monomiX + 10, monomiY + 40, 10, 20);        // arms b        if (colours == 0) {            ellipse(monomiX + 40, monomiY - 20, 15, 15);            ellipse(monomiX + 40, monomiY - 10, 10, 17);            ellipse(monomiX + 40, monomiY, 10, 10);            ellipse(monomiX + 32, monomiY, 15, 10);        } else if (colours == 255) {            fill(0);            ellipse(monomiX + 30, monomiY, 12, 12);            ellipse(monomiX + 42, monomiY, 25, 12);            ellipse(monomiX + 55, monomiY, 15, 15);        }        // eyes :        fill((255 - colours) / 10, (255 - colours) / 2, 255 - colours);        ellipse(headX - 10, headY - 10, 7, 7);        if (colours == 255) {            fill(255, 0, 0);            quad(headX + 10, headY - 10, headX + 15, headY - 10, headX + 10, headY - 15, headX + 5, headY - 5);        } else {            fill(255, 0, 0);            ellipse(headX + 10, headY - 10, 7, 7);        }        // buttons        strokeWeight(3);        fill(bodyColor);        ellipse(headX, headY + 30, 15, 15);        fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);        ellipse(headX, headY + 30, 12, 12);        ellipse(headX, headY + 45, 15, 15);        fill(bodyColor);        ellipse(headX, headY + 45, 12, 12);        // Mouth        fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);        ellipse(headX - 5, headY + 2, 13, 13);        fill((255 - colours), (255 - colours) / 2.14f, (255 - colours) / 1.42f);        ellipse(headX + 5, headY + 2, 13, 13);        fill(bodyColor);        ellipse(headX - 5, headY + 2, 10, 10);        ellipse(headX + 5, headY + 2, 10, 10);    }    void changeColour() {        if (colours == 0) {            colours = 255;        } else {            colours = 0;        }    }    // Hitbox    void changepos() {        if (sparkleX >= monomiX - (4 * sparkleRadius / 3 + 45) && sparkleX <= monomiX + (4 * sparkleRadius / 3 + 45) && sparkleY <= monomiY + (4 * sparkleRadius / 3 + 40) && sparkleY >= monomiY - (4 * sparkleRadius / 3 + 50)) {            monomiX = random(width - 150) + 75;            monomiY = random(height - 150) + 75;            monomiA.changeColour();            if (level >= maxLevel) {                level = 1;            } else                nextLevel = true;            for (int i = 0; i < kuma.length; i++) {                kuma[i] = new Kuma(random(width - 150) + 75, random(height - 150) + 75);            }        }    }    void eyeglow() {        fill(random(255), 0, 0);        ellipse(monomiX + 10, monomiY - 38, 15, 15);    }}',correct
'ballY - 25',correct
'colours = 255;',correct
'{    hazard[n].hit();}',correct
'ellipse(kumaX - 30, kumaY, 12, 12);',correct
'width - 150',correct
'ellipse(kumaX - 42, kumaY, 25, 12);',correct
'loselive = false',correct
'monomiX - 55',correct
'-4 * sparkleRadius / 3',correct
'fill(random(255), 0, 0)',correct
'loselive = true;',correct
'sparkleX - random(-sparkleRadius, sparkleRadius)',correct
'if (colours == 255) {    fill(0);    ellipse(headX + 15, headY - 26, 15, 15);    fill(bodyColor);    ellipse(headX - 15, headY - 26, 15, 15);}',correct
'ellipse(headX + 15, headY - 28, 15, 25);',correct
'dx = -dx;',correct
'kumaX + 10',correct
'// buttonsstrokeWeight(3);',correct
'textAlign(CENTER);',correct
'{    bodyColor = color(255);    float headX = kumaX;    float headY = kumaY - 28;    stroke(bodyColor);    fill(bodyColor);    // head    noStroke();    arc(headX, headY, 53, 53, HALF_PI, PI + HALF_PI);    noStroke();    arc(headX, headY + 35, 60, 60, HALF_PI, PI + HALF_PI);    // arms    if (colours == 255) {        ellipse(kumaX - 30, kumaY, 12, 12);        ellipse(kumaX - 42, kumaY, 25, 12);        ellipse(kumaX - 55, kumaY, 15, 15);    } else if (colours == 0) {        fill(255);        ellipse(kumaX - 40, kumaY + 20, 15, 15);        ellipse(kumaX - 40, kumaY + 10, 10, 17);        ellipse(kumaX - 40, kumaY, 10, 10);        ellipse(kumaX - 32, kumaY, 15, 10);    }    // legs    ellipse(kumaX - 10, kumaY + 50, 10, 10);    rect(kumaX - 10, kumaY + 40, 10, 20);    // ears    strokeWeight(3);    if (colours == 255) {        fill(255, 119, 180);        ellipse(headX + 15, headY - 28, 15, 25);        ellipse(headX + 25, headY - 38, 25, 15);        fill(bodyColor);        ellipse(headX - 25, headY - 23, 25, 15);        ellipse(headX - 35, headY - 13, 15, 25);    } else if (colours == 0) {        fill(0);        ellipse(headX + 15, headY - 26, 15, 15);        fill(bodyColor);        ellipse(headX - 15, headY - 26, 15, 15);    }    // Body Coloured :    noStroke();    fill(colours, colours / 2.14f, colours / 1.42f);    arc(headX, headY, 53, 53, PI + HALF_PI, TWO_PI + HALF_PI);    noStroke();    fill(colours, colours / 2.14f, colours / 1.42f);    arc(headX, headY + 35, 60, 60, PI + HALF_PI, TWO_PI + HALF_PI);    // legs b    fill(colours, colours / 2.14f, colours / 1.42f);    ellipse(kumaX + 10, kumaY + 50, 10, 10);    rect(kumaX + 10, kumaY + 40, 10, 20);    // arms b    if (colours == 255) {        ellipse(kumaX + 40, kumaY - 20, 15, 15);        ellipse(kumaX + 40, kumaY - 10, 10, 17);        ellipse(kumaX + 40, kumaY, 10, 10);        ellipse(kumaX + 32, kumaY, 15, 10);    } else if (colours == 0) {        fill(0);        ellipse(kumaX + 30, kumaY, 12, 12);        ellipse(kumaX + 42, kumaY, 25, 12);        ellipse(kumaX + 55, kumaY, 15, 15);    }    // eyes :    fill(colours / 10, colours / 2, colours);    ellipse(headX - 10, headY - 10, 7, 7);    if (colours == 0) {        fill(255, 0, 0);        quad(headX + 10, headY - 10, headX + 15, headY - 10, headX + 10, headY - 15, headX + 5, headY - 5);    } else {        fill(255, 0, 0);        ellipse(headX + 10, headY - 10, 7, 7);    }    // buttons    strokeWeight(3);    fill(bodyColor);    ellipse(headX, headY + 30, 15, 15);    fill(colours, colours / 2.14f, colours / 1.42f);    ellipse(headX, headY + 30, 12, 12);    ellipse(headX, headY + 45, 15, 15);    fill(bodyColor);    ellipse(headX, headY + 45, 12, 12);    // Mouth    fill(colours, colours / 2.14f, colours / 1.42f);    ellipse(headX - 5, headY + 2, 13, 13);    fill(colours, colours / 2.14f, colours / 1.42f);    ellipse(headX + 5, headY + 2, 13, 13);    fill(bodyColor);    ellipse(headX - 5, headY + 2, 10, 10);    ellipse(headX + 5, headY + 2, 10, 10);}',LongMethodRule
'// ellipse(ballX, ballY-50, 50, 70);',correct
'kumaX = random(width - 150) + 75',correct
'// armsif (colours == 0) {    ellipse(monomiX - 30, monomiY, 12, 12);    ellipse(monomiX - 42, monomiY, 25, 12);    ellipse(monomiX - 55, monomiY, 15, 15);} else if (colours == 255) {    fill(255);    ellipse(monomiX - 40, monomiY + 20, 15, 15);    ellipse(monomiX - 40, monomiY + 10, 10, 17);    ellipse(monomiX - 40, monomiY, 10, 10);    ellipse(monomiX - 32, monomiY, 15, 10);}',correct
'new Kuma(random(width - 150) + 75, random(height - 150) + 75)',correct
'ellipseMode(CENTER);',correct
'int i = 0',correct
'textSize(height / 6);',correct
'arc(headX, headY, 53, 53, PI + HALF_PI, TWO_PI + HALF_PI)',correct
'sparkleX >= monomiX - (4 * sparkleRadius / 3 + 45) && sparkleX <= monomiX + (4 * sparkleRadius / 3 + 45)',correct
'ellipse(kumaX - 10, kumaY + 50, 10, 10)',correct
'sparkleX = mouseX;',correct
'if (colours == 0) {    fill(0);    ellipse(headX + 15, headY - 26, 15, 15);    fill(bodyColor);    ellipse(headX - 15, headY - 26, 15, 15);}',correct
'i < level',correct
'void mouseDragged() {    sparkleX = mouseX;    sparkleY = mouseY;    trace = true;    monomiA.changepos();    for (int n = 0; n < (1 + level / 5); n++) {        hazard[n].hit();    }}',correct
'lives <= 0',correct
'ellipse(headX + 25, headY - 38, 25, 15)',correct
'color(255)',correct
'monomiA.display()',correct
'sparkleY + random(-sparkleRadius / 2, sparkleRadius / 2)',correct
'ellipse(headX + 5, headY + 2, 13, 13)',correct
'headY + 45',correct
'[maxLevel]',correct
'// switches the sprites and colours of everythingint colours;',correct
'hazard[n].display();',correct
'// // fourth petal',correct
'i < 30',correct
'ellipse(kumaX + 10, kumaY + 50, 10, 10)',correct
'ballX > width - 25 && dx > 0',correct
'sparkleY + random(-4 * sparkleRadius / 3, 4 * sparkleRadius / 3)',correct
'// armsif (colours == 255) {    ellipse(kumaX - 30, kumaY, 12, 12);    ellipse(kumaX - 42, kumaY, 25, 12);    ellipse(kumaX - 55, kumaY, 15, 15);} else if (colours == 0) {    fill(255);    ellipse(kumaX - 40, kumaY + 20, 15, 15);    ellipse(kumaX - 40, kumaY + 10, 10, 17);    ellipse(kumaX - 40, kumaY, 10, 10);    ellipse(kumaX - 32, kumaY, 15, 10);}',correct
'ellipse(headX, headY + 45, 15, 15);',correct
'{    fill(255);    ellipse(kumaX - 40, kumaY + 20, 15, 15);    ellipse(kumaX - 40, kumaY + 10, 10, 17);    ellipse(kumaX - 40, kumaY, 10, 10);    ellipse(kumaX - 32, kumaY, 15, 10);}',correct
'float headY = kumaY - 28;',correct
'monomiY + (4 * sparkleRadius / 3 + 40)',correct
'ellipse(monomiX + 32, monomiY, 15, 10)',correct
'if (ballY > height - 25 && dy > 0) {    dy = -dy;}',correct
'float headX = monomiX',correct
'height - 150',correct
'ellipse(sparkleX - random(-3 * sparkleRadius / 4, 3 * sparkleRadius / 4), sparkleY + random(-4 * sparkleRadius / 3, 4 * sparkleRadius / 3), sparkleSize, sparkleSize);',correct
'ellipse(headX, headY + 45, 12, 12)',correct
'lives',correct
'{    kuma[i].display();}',correct
'// arms bif (colours == 255) {    ellipse(kumaX + 40, kumaY - 20, 15, 15);    ellipse(kumaX + 40, kumaY - 10, 10, 17);    ellipse(kumaX + 40, kumaY, 10, 10);    ellipse(kumaX + 32, kumaY, 15, 10);} else if (colours == 0) {    fill(0);    ellipse(kumaX + 30, kumaY, 12, 12);    ellipse(kumaX + 42, kumaY, 25, 12);    ellipse(kumaX + 55, kumaY, 15, 15);}',correct
'nextLevel',correct
'ellipse(headX - 5, headY + 2, 10, 10);',correct
'kumaX + 32',correct
'kumaX + 30',correct
'ellipse(kumaX + 30, kumaY, 12, 12);',correct
'monomiY = random(height - 150) + 75;',correct
'ellipse(monomiX + 10, monomiY + 50, 10, 10)',correct
'ellipse(kumaX + 55, kumaY, 15, 15);',correct
'new Ball(random(width - 150) + 75, random(height - 150) + 75, random(30) / random(12), random(30) / random(12))',correct
'nextLevel = false',correct
'boolean loselive;',correct
'ellipse(kumaX + 10, kumaY - 38, 15, 15);',DecentralizedDrawingRule
'if (ballY < 25 && dy < 0) {    dy = -dy;} else {    ballX = ballX + dx;    ballY = ballY + dy;}',correct
'kumaX + 40',correct
'for (int i = 0; i < 30; i++) {    ellipse(sparkleX - random(-sparkleRadius, sparkleRadius), sparkleY + random(-sparkleRadius, sparkleRadius), sparkleSize, sparkleSize);    ellipse(sparkleX - random(-sparkleRadius / 2, sparkleRadius / 2), sparkleY + random(-sparkleRadius / 2, sparkleRadius / 2), sparkleSize, sparkleSize);    ellipse(sparkleX - random(-4 * sparkleRadius / 3, 4 * sparkleRadius / 3), sparkleY + random(-3 * sparkleRadius / 4, 3 * sparkleRadius / 4), sparkleSize, sparkleSize);    ellipse(sparkleX - random(-3 * sparkleRadius / 4, 3 * sparkleRadius / 4), sparkleY + random(-4 * sparkleRadius / 3, 4 * sparkleRadius / 3), sparkleSize, sparkleSize);}',correct
'ellipse(monomiX + 10, monomiY - 38, 15, 15);',DecentralizedDrawingRule
'ellipse(monomiX + 40, monomiY - 10, 10, 17)',correct
'if (ballX < 25 && dx < 0) {    dx = -dx;}',correct
'ellipse(kumaX + 40, kumaY - 10, 10, 17);',correct
'if (mouseX >= ballX - 25 && mouseX <= ballX + 25 && mouseY >= ballY - 25 && mouseY <= ballY + 25) {    loselive = true;    ballX = random(width - 150) + 75;    ballY = random(height - 150) + 75;}',correct
'kumaX + 42',correct
'headX = monomiX',correct
'text("You win", width / 2, height / 2)',correct
'ballY = random(height - 150) + 75;',correct
'ellipse(kumaX - 40, kumaY + 10, 10, 17)',correct
'level = 1',correct
'lives = 3',correct
'-sparkleRadius / 2',correct
'ellipse(monomiX + 30, monomiY, 12, 12);',correct
'ellipse(headX - 25, headY - 23, 25, 15)',correct
'display',correct
'void hit() {    if (mouseX >= ballX - 25 && mouseX <= ballX + 25 && mouseY >= ballY - 25 && mouseY <= ballY + 25) {        loselive = true;        ballX = random(width - 150) + 75;        ballY = random(height - 150) + 75;    }}',correct
'rect(monomiX - 10, monomiY + 40, 10, 20)',correct
'loselive = false;',DrawingStateChangeRule
'kumaX + 55',correct
'// displayed as a counter, controlls the number of distactionsint level;',correct
'sparkleX = mouseX',correct
'headY + 35',correct
'headY + 30',correct
'float headX = kumaX;',correct
'{    if (mouseX >= ballX - 25 && mouseX <= ballX + 25 && mouseY >= ballY - 25 && mouseY <= ballY + 25) {        loselive = true;        ballX = random(width - 150) + 75;        ballY = random(height - 150) + 75;    }}',correct
'quad(headX + 10, headY - 10, headX + 15, headY - 10, headX + 10, headY - 15, headX + 5, headY - 5);',correct
'ellipse(monomiX - 30, monomiY, 12, 12);',correct
'nextLevel = true',correct
'kuma[i]',correct
'ballX = ballX + dx',correct
'kuma[i].eyeglow();',correct
'sparkleY + random(-sparkleRadius, sparkleRadius)',correct
'3 * width',correct
'float initX',correct
'ellipse(headX + 15, headY - 28, 15, 25)',correct
'float initY',correct
'i++',correct
'ellipse(headX - 5, headY + 2, 13, 13);',correct
'{    if (colours == 0) {        colours = 255;    } else {        colours = 0;    }}',correct
'fill(colours, colours / 2.14f, colours / 1.42f)',correct
'fill(255);',correct
'headX',correct
'headY',correct
'3 * width / 4',correct
'rect(kumaX + 10, kumaY + 40, 10, 20);',correct
'sparkleX >= monomiX - (4 * sparkleRadius / 3 + 45) && sparkleX <= monomiX + (4 * sparkleRadius / 3 + 45) && sparkleY <= monomiY + (4 * sparkleRadius / 3 + 40) && sparkleY >= monomiY - (4 * sparkleRadius / 3 + 50)',correct
'dy > 0',correct
'ballY + 25',correct
'4 * sparkleRadius',correct
'ellipse(monomiX - 55, monomiY, 15, 15)',correct
'ellipse(monomiX - 42, monomiY, 25, 12)',correct
'ellipse(monomiX - 30, monomiY, 12, 12)',correct
'hazard[0]',correct
'ballY > height - 25',correct
'{    ballX = ballX + dx;    ballY = ballY + dy;}',correct
'if (colours == 0) {    fill(255, 0, 0);    quad(headX + 10, headY - 10, headX + 15, headY - 10, headX + 10, headY - 15, headX + 5, headY - 5);} else {    fill(255, 0, 0);    ellipse(headX + 10, headY - 10, 7, 7);}',correct
'ellipse(kumaX - 55, kumaY, 15, 15)',correct
'ballY',correct
'ballX',correct
'nextLevel = true;',IfElseStmtsMustUseBraces
'{    fill(255, 0, 0);    ellipse(headX + 10, headY - 10, 7, 7);}',correct
'kumaX - 10',correct
'random(-sparkleRadius, sparkleRadius)',correct
'ellipse(kumaX + 40, kumaY, 10, 10);',correct
'{    lives -= 1;    loselive = false;}',correct
'ballX = initX',correct
'monomiX = random(width - 150) + 75;',correct
'rect(kumaX + 10, kumaY + 40, 10, 20)',correct
'float sparkleX;',correct
'for (int i = 0; i < level; i++) {    kuma[i].display();}',correct
'colours == 255',correct
'bodyColor',correct
'{    ellipse(monomiX - 30, monomiY, 12, 12);    ellipse(monomiX - 42, monomiY, 25, 12);    ellipse(monomiX - 55, monomiY, 15, 15);}',correct
'arc(headX, headY, 53, 53, HALF_PI, PI + HALF_PI);',correct
'mouseX >= ballX - 25 && mouseX <= ballX + 25 && mouseY >= ballY - 25',correct
'// // rotate 72 degrees',correct
'dy = initdy;',correct
'{    level += 1;    nextLevel = false;}',correct
'fill(0, 0, 0);',correct
'{    kuma[i].eyeglow();}',correct
'bodyColor = color(255)',correct
'float initKumaX',correct
'random(width - 150) + 75',correct
'float initKumaY',correct
'trace',correct
'ellipse(monomiX - 10, monomiY + 50, 10, 10)',correct
'mouseX >= ballX - 25',correct
'{    loselive = true;    ballX = random(width - 150) + 75;    ballY = random(height - 150) + 75;}',correct
'float initMonomiX',correct
'{    monomiX = random(width - 150) + 75;    monomiY = random(height - 150) + 75;    monomiA.changeColour();    if (level >= maxLevel) {        level = 1;    } else        nextLevel = true;    for (int i = 0; i < kuma.length; i++) {        kuma[i] = new Kuma(random(width - 150) + 75, random(height - 150) + 75);    }}',correct
'float sparkleY;',correct
'void mouseReleased() {    if (trace) {        trace = false;    }}',correct
'dx = initdx',correct
'float initMonomiY',correct
'kumaX - 30',correct
'Ball[]',correct
'{    fill(colours, (colours) / 2.14f, (colours) / 1.42f);    sparkleRadius = 20;    float sparkleSize = 3;    for (int i = 0; i < 30; i++) {        ellipse(sparkleX - random(-sparkleRadius, sparkleRadius), sparkleY + random(-sparkleRadius, sparkleRadius), sparkleSize, sparkleSize);        ellipse(sparkleX - random(-sparkleRadius / 2, sparkleRadius / 2), sparkleY + random(-sparkleRadius / 2, sparkleRadius / 2), sparkleSize, sparkleSize);        ellipse(sparkleX - random(-4 * sparkleRadius / 3, 4 * sparkleRadius / 3), sparkleY + random(-3 * sparkleRadius / 4, 3 * sparkleRadius / 4), sparkleSize, sparkleSize);        ellipse(sparkleX - random(-3 * sparkleRadius / 4, 3 * sparkleRadius / 4), sparkleY + random(-4 * sparkleRadius / 3, 4 * sparkleRadius / 3), sparkleSize, sparkleSize);    }}',correct
'ellipse(monomiX + 42, monomiY, 25, 12);',correct
'new Ball[(3 + (maxLevel / 5))]',correct
'void setup() {    rectMode(CENTER);    ellipseMode(CENTER);    textAlign(CENTER);    lives = 3;    trace = false;    level = 1;    monomiA = new Monomi(3 * width / 4, height / 2);    for (int i = 0; i < maxLevel; i++) {        kuma[i] = new Kuma(random(width - 150) + 75, random(height - 150) + 75);    }    for (int n = 0; n < (3 + (maxLevel / 5)); n++) {        hazard[n] = new Ball(random(width - 150) + 75, random(height - 150) + 75, random(30) / random(12), random(30) / random(12));    }}',correct
'arc(headX, headY + 35, 60, 60, HALF_PI, PI + HALF_PI);',correct
'{    rectMode(CENTER);    ellipseMode(CENTER);    textAlign(CENTER);    lives = 3;    trace = false;    level = 1;    monomiA = new Monomi(3 * width / 4, height / 2);    for (int i = 0; i < maxLevel; i++) {        kuma[i] = new Kuma(random(width - 150) + 75, random(height - 150) + 75);    }    for (int n = 0; n < (3 + (maxLevel / 5)); n++) {        hazard[n] = new Ball(random(width - 150) + 75, random(height - 150) + 75, random(30) / random(12), random(30) / random(12));    }}',correct
'Ball[] hazard = new Ball[(3 + (maxLevel / 5))];',correct
'kumaX - 32',correct
'{    hazard[n].move();}',correct
'width / 2',correct
'dx = initdx;',correct
'-sparkleRadius',correct
'{    dx = -dx;}',correct
'ellipse(headX - 15, headY - 26, 15, 15)',correct
'ellipse(sparkleX - random(-3 * sparkleRadius / 4, 3 * sparkleRadius / 4), sparkleY + random(-4 * sparkleRadius / 3, 4 * sparkleRadius / 3), sparkleSize, sparkleSize)',correct
'ellipse(kumaX - 40, kumaY, 10, 10)',correct
'ellipse(sparkleX - random(-4 * sparkleRadius / 3, 4 * sparkleRadius / 3), sparkleY + random(-3 * sparkleRadius / 4, 3 * sparkleRadius / 4), sparkleSize, sparkleSize);',correct
'ellipse(kumaX + 40, kumaY, 10, 10)',correct
'// // first petal',correct
'height - 160',correct
'// interactionsif (mousePressed) {    text("Hes called Big Bird.", width - (width - 45), height - 50);} else if (!mousePressed) {    text("I have a little nephew!", width - (width - 30), height - 50);}',correct
'i = 0',correct
'i < Hoofden.length',correct
'"I have a little nephew!"',correct
'-10',correct
'void move() {    posX = posX + speedX;    posY = posY + speedY;    if (posX >= width - 175 || posX <= 75) {        speedX = -speedX;    }    if (posY >= height - 160 || posY <= 100) {        speedY = -speedY;    }}',correct
'ellipse(posX + 90, posY, 25, 25)',correct
'posX >= width - 175',correct
'fill(91, 233, 255)',correct
'height - 53',correct
'float posX;',correct
'{    speedX = -speedX;}',correct
'height - 50',correct
'{    text("Hes called Big Bird.", width - (width - 45), height - 50);}',DecentralizedEventHandlingRule
'width - (width - 30)',correct
'posY + 75',correct
'/*Moving Pino, made by Milan Boeren s1981552  if you press the mouse, the text balloon in the bottom left will change.  furthermore there are just some Pino heads floating around. */// here you assign how many headsHead[] Hoofden = new Head[5];',correct
'posY + 70',correct
'ellipse(width - (width - 100), height - 53, 160, 40);',correct
'Head',correct
'PImage img;',correct
'void setup() {    frameRate(60);    ellipseMode(CENTER);    for (int i = 0; i < Hoofden.length; i++) {        Hoofden[i] = new Head(width / 2, height / 2, random(-10, 10), random(-10, 10));    }    img = loadImage("Sesame-street-2.jpg");}',correct
'// eye whiteellipse(posX + 10, posY, 50, 60);',correct
'{    text("I have a little nephew!", width - (width - 30), height - 50);}',correct
'display();',correct
'Hoofden[i] = new Head(width / 2, height / 2, random(-10, 10), random(-10, 10));',correct
'fill(91, 233, 255);',correct
'posX - 20',correct
'if (posY >= height - 160 || posY <= 100) {    speedY = -speedY;}',correct
'new Head[5]',correct
'ellipse(posX + 90, posY, 50, 60);',correct
'posY = posY + speedY;',correct
'void tekenen() {    display();    move();}',correct
'float speedX;',correct
'noStroke();',correct
'text("Hes called Big Bird.", width - (width - 45), height - 50)',correct
'new Head(width / 2, height / 2, random(-10, 10), random(-10, 10))',correct
'image(img, 0, 0);',correct
'ellipse(posX + 10, posY, 50, 60)',correct
'width - (width - 100)',correct
'posX + 120',correct
'float headsize;',correct
'{    Hoofden[i] = new Head(width / 2, height / 2, random(-10, 10), random(-10, 10));}',correct
'!mousePressed',correct
'posX + 90',correct
'posY = initY',correct
'fill(0);',correct
'{    posX = initX;    posY = initY;    speedX = SX;    speedY = SY;}',correct
'{    speedY = -speedY;}',correct
'posY <= 100',correct
'class Head {    float posX;    float posY;    float headsize;    float speedX;    float speedY;    Head(float initX, float initY, float SX, float SY) {        posX = initX;        posY = initY;        speedX = SX;        speedY = SY;    }    void tekenen() {        display();        move();    }    void display() {        noStroke();        fill(91, 233, 255);        stroke(10);        // Head        ellipse(posX + 50, posY + 30, 240, 250);        noStroke();        fill(255, 255, 0);        // eye yellow        ellipse(posX + 10, posY, 100, 100);        ellipse(posX + 90, posY, 100, 100);        fill(0);        stroke(10);        fill(255);        // eye white        ellipse(posX + 10, posY, 50, 60);        ellipse(posX + 90, posY, 50, 60);        fill(250, 89, 19);        // beak        quad(posX + 50, posY, posX - 20, posY + 70, posX + 50, posY + 150, posX + 120, posY + 70);        fill(0);        // pupillen        ellipse(posX + 90, posY, 25, 25);        ellipse(posX + 10, posY, 25, 25);        // mouth        triangle(posX, posY + 75, posX + 100, posY + 75, posX + 50, posY + 140);    }    void move() {        posX = posX + speedX;        posY = posY + speedY;        if (posX >= width - 175 || posX <= 75) {            speedX = -speedX;        }        if (posY >= height - 160 || posY <= 100) {            speedY = -speedY;        }    }}',correct
'-speedY',correct
'PImage',correct
'float speedY;',correct
'frameRate(60);',correct
'posX + 10',correct
'-speedX',correct
'Hoofden[i]',correct
'speedX = SX',correct
'Hoofden[i].tekenen();',correct
'posY = posY + speedY',correct
'width - 175',correct
'posX <= 75',correct
'speedX = -speedX;',correct
'Head(float initX, float initY, float SX, float SY) {    posX = initX;    posY = initY;    speedX = SX;    speedY = SY;}',ShortVariable
'// textbaloonfill(255, 255, 255);',correct
'// textfill(0);',correct
'// mouthtriangle(posX, posY + 75, posX + 100, posY + 75, posX + 50, posY + 140);',correct
'speedY = SY;',correct
'[5]',correct
'for (int i = 0; i < Hoofden.length; i++) {    Hoofden[i] = new Head(width / 2, height / 2, random(-10, 10), random(-10, 10));}',correct
'fill(250, 89, 19)',correct
'float SY',correct
'speedY',correct
'{    noStroke();    fill(91, 233, 255);    stroke(10);    // Head    ellipse(posX + 50, posY + 30, 240, 250);    noStroke();    fill(255, 255, 0);    // eye yellow    ellipse(posX + 10, posY, 100, 100);    ellipse(posX + 90, posY, 100, 100);    fill(0);    stroke(10);    fill(255);    // eye white    ellipse(posX + 10, posY, 50, 60);    ellipse(posX + 90, posY, 50, 60);    fill(250, 89, 19);    // beak    quad(posX + 50, posY, posX - 20, posY + 70, posX + 50, posY + 150, posX + 120, posY + 70);    fill(0);    // pupillen    ellipse(posX + 90, posY, 25, 25);    ellipse(posX + 10, posY, 25, 25);    // mouth    triangle(posX, posY + 75, posX + 100, posY + 75, posX + 50, posY + 140);}',correct
'speedX',correct
'speedX = -speedX',correct
'if (posX >= width - 175 || posX <= 75) {    speedX = -speedX;}',correct
'display',correct
'float SX',correct
'draw',correct
'ellipse(posX + 90, posY, 100, 100);',correct
'headsize',correct
'ellipse(posX + 90, posY, 100, 100)',correct
'Hoofden[i].tekenen()',correct
'Hoofden = new Head[5]',correct
'ellipse(posX + 10, posY, 25, 25)',correct
'text("I have a little nephew!", width - (width - 30), height - 50)',correct
'stroke(10);',correct
'noStroke()',correct
'speedY = -speedY',correct
'// pupillenellipse(posX + 90, posY, 25, 25);',correct
'display()',correct
'float initX',correct
'loadImage("Sesame-street-2.jpg")',correct
'float initY',correct
'i++',correct
'posX = posX + speedX',correct
'speedY = -speedY;',correct
'mousePressed',DecentralizedEventHandlingRule
'fill(255);',correct
'ellipse(posX + 50, posY + 30, 240, 250)',correct
'Hoofden.length',correct
'ellipseMode(CENTER)',correct
'fill(255, 255, 0)',correct
'posX >= width - 175 || posX <= 75',correct
'posY = initY;',correct
'posY + 30',correct
'posY + 140',correct
'fill(255, 255, 255)',correct
'posY + speedY',correct
'void',correct
'text("Hes called Big Bird.", width - (width - 45), height - 50);',correct
'stroke(10)',correct
'posX = posX + speedX;',correct
'// eye yellowellipse(posX + 10, posY, 100, 100);',correct
'ellipse(width - (width - 100), height - 53, 160, 40)',correct
'"Hes called Big Bird."',correct
'/*Moving Pino, made by Milan Boeren s1981552  if you press the mouse, the text balloon in the bottom left will change.  furthermore there are just some Pino heads floating around. */',correct
'posX',correct
'posY',correct
'posX + speedX',correct
'fill(0)',correct
'posY >= height - 160 || posY <= 100',correct
'height / 2',correct
'{    display();    move();}',correct
'random(-10, 10)',correct
'{    image(img, 0, 0);    for (int i = 0; i < Hoofden.length; i++) {        Hoofden[i].tekenen();    }    // textbaloon    fill(255, 255, 255);    ellipse(width - (width - 100), height - 53, 160, 40);    // text    fill(0);    // interactions    if (mousePressed) {        text("Hes called Big Bird.", width - (width - 45), height - 50);    } else if (!mousePressed) {        text("I have a little nephew!", width - (width - 30), height - 50);    }}',correct
'fill(255, 255, 0);',correct
'// beakquad(posX + 50, posY, posX - 20, posY + 70, posX + 50, posY + 150, posX + 120, posY + 70);',correct
'{    frameRate(60);    ellipseMode(CENTER);    for (int i = 0; i < Hoofden.length; i++) {        Hoofden[i] = new Head(width / 2, height / 2, random(-10, 10), random(-10, 10));    }    img = loadImage("Sesame-street-2.jpg");}',correct
'text("I have a little nephew!", width - (width - 30), height - 50);',correct
'posY + 150',correct
'width - (width - 45)',correct
'move()',correct
'posX + 100',correct
'img',correct
'fill(250, 89, 19);',correct
'// Headellipse(posX + 50, posY + 30, 240, 250);',correct
'fill(255)',correct
'posX + 50',correct
'Processing',correct
'speedX = SX;',correct
'for (int i = 0; i < Hoofden.length; i++) {    Hoofden[i].tekenen();}',correct
'void display() {    noStroke();    fill(91, 233, 255);    stroke(10);    // Head    ellipse(posX + 50, posY + 30, 240, 250);    noStroke();    fill(255, 255, 0);    // eye yellow    ellipse(posX + 10, posY, 100, 100);    ellipse(posX + 90, posY, 100, 100);    fill(0);    stroke(10);    fill(255);    // eye white    ellipse(posX + 10, posY, 50, 60);    ellipse(posX + 90, posY, 50, 60);    fill(250, 89, 19);    // beak    quad(posX + 50, posY, posX - 20, posY + 70, posX + 50, posY + 150, posX + 120, posY + 70);    fill(0);    // pupillen    ellipse(posX + 90, posY, 25, 25);    ellipse(posX + 10, posY, 25, 25);    // mouth    triangle(posX, posY + 75, posX + 100, posY + 75, posX + 50, posY + 140);}',correct
'img = loadImage("Sesame-street-2.jpg");',correct
'quad(posX + 50, posY, posX - 20, posY + 70, posX + 50, posY + 150, posX + 120, posY + 70)',correct
'triangle(posX, posY + 75, posX + 100, posY + 75, posX + 50, posY + 140)',correct
'frameRate(60)',correct
'ellipse(posX + 10, posY, 100, 100)',correct
'if (!mousePressed) {    text("I have a little nephew!", width - (width - 30), height - 50);}',DecentralizedEventHandlingRule
'"Sesame-street-2.jpg"',correct
'image(img, 0, 0)',correct
'ellipse(posX + 90, posY, 50, 60)',correct
'posX = initX;',correct
'width / 2',correct
'int i = 0',correct
'ellipseMode(CENTER);',correct
'posX = initX',correct
'speedY = SY',correct
'void draw() {    image(img, 0, 0);    for (int i = 0; i < Hoofden.length; i++) {        Hoofden[i].tekenen();    }    // textbaloon    fill(255, 255, 255);    ellipse(width - (width - 100), height - 53, 160, 40);    // text    fill(0);    // interactions    if (mousePressed) {        text("Hes called Big Bird.", width - (width - 45), height - 50);    } else if (!mousePressed) {        text("I have a little nephew!", width - (width - 30), height - 50);    }}',correct
'float posY;',correct
'move();',correct
'{    posX = posX + speedX;    posY = posY + speedY;    if (posX >= width - 175 || posX <= 75) {        speedX = -speedX;    }    if (posY >= height - 160 || posY <= 100) {        speedY = -speedY;    }}',correct
'posY >= height - 160',correct
'{    Hoofden[i].tekenen();}',correct
'Head[]',correct
'img = loadImage("Sesame-street-2.jpg")',correct
'ellipse(posX + 10, posY, 25, 25);',correct
'Hoofden[i] = new Head(width / 2, height / 2, random(-10, 10), random(-10, 10))',correct
'sun1.sunChangePlay()',correct
'void display() {    // Sun    noStroke();    fill(sunColor);    ellipse(sunX, sunY, 300, 300);}',correct
'{    // These lines change the color and speed of the objects    dove1.doveChangePlay();    sun1.sunChangePlay();    backgColor = (255);    right.rightPlay();    left.leftPlay();    // If isRain == true it starts raining    if (isRain == true) {        for (int i = 0; i < rainDrop.length; i++) {            rainDrop[i].rainPlay();        }    }    // This draws the pause button    fill(0);    rectMode(CENTER);    rect(width - 50, height - 50, 10, 30);    rect(width - 35, height - 50, 10, 30);}',SimplifyBooleanExpressions
'// Headfill(headColor);',correct
'doveY - 85 <= 0',correct
'"Click to set me free"',correct
'textSize(200)',correct
'headColor',correct
'rainDrop[i].fall();',correct
'doveX - 30',correct
'doveSpeedX = -6',correct
'left.leftStart();',correct
'headColor = 120;',correct
'right = new rightmountain()',correct
'fill(sunColor)',correct
'height - 50',correct
'sun1.sunChangePlay();',correct
'',correct
'{    sunY = height + 200;}',correct
'{    bodyColor = color(66, 197, 244);    wingColor = color(0, 153, 209);    tailColor = color(34, 190, 247);    neckColor = color(18, 173, 229);    headColor = color(0, 136, 186);    // This makes the dove move    doveY = doveY + doveSpeedY;    doveX = doveX + doveSpeedX;    // This respawns the Dove once it is out of sight    if (doveX < -110) {        doveX = width + 65;        doveY = height / 1.5f;    }    // This keeps the Dove from flying out of the screen on the top and bottom    if (doveY - 85 <= 0) {        doveY = 85;    }    if (doveY + 65 >= height) {        doveY = height - 65;    }}',correct
'doveSpeedY = -0.7f',correct
'// FX2D draws object much faster for a smooth looking program// Matching the new object slots to a class and declaring the values of the objects// rainDrop is agian an array so that every slot has been filled by a raindropdove1 = new Dove(width / 2, height / 2);',correct
'{    // If isStart is true the bird will be grey and the text will be printed under the bird    bodyColor = 160;    wingColor = 100;    tailColor = 200;    neckColor = 180;    headColor = 120;    fill(200);    textSize(16);    textAlign(CENTER);    text("Click to set me free", doveX + 25, doveY + 90);    doveX = width / 2;    doveY = height / 2;}',correct
'// This makes the dove movedoveY = doveY + doveSpeedY;',correct
'-0.3f',correct
'doveSpeedX = -3',correct
'{    sunX = initX;    sunY = initY;}',correct
'doveX + 80',correct
'{    // Sun    noStroke();    fill(sunColor);    ellipse(sunX, sunY, 300, 300);}',correct
'height - 65',correct
'new Sun(width / 4, height + 40)',correct
'left',correct
'{    sunColor = color(255, 208, 0);    sunSpeed = -0.3f;    sunY = sunY + sunSpeed;    // This respawns the sun when it it out of sight    if (sunY + 150 < 0) {        sunY = height + 200;    }}',correct
'{    // These lines change the color and speed of the objects    dove1.doveChangeStart();    sun1.sunChangeStart();    backgColor = (70);    right.rightStart();    left.leftStart();    // If isRain == true it starts raining    if (isRain == true) {        for (int i = 0; i < rainDrop.length; i++) {            rainDrop[i].rainStart();        }    }    // This is the starting title of the Program    fill(160);    textSize(150);    text("Dove Simulator", width / 2, height / 2 - 200);}',SimplifyBooleanExpressions
'rainSpeed = random(4, 15)',correct
'doveSpeedY = 6;',correct
'sunSpeed = -0.3f',correct
'{    isRain = !isRain;}',correct
'// Variablesfloat doveX;',correct
'width - 55',correct
'fill(wingColor)',correct
'width - 50',correct
'rainY + rainSpeed',correct
'rainDrop = new rain[1000]',correct
'stroke(bodyColor)',correct
'doveX - 10',correct
'fill(0);',correct
'// Giving the booleans a starting value (true or false)isStart = true;',correct
'height - 35',correct
'doveChangePlay',correct
'// This is the pause button and play buttonif (mouseX >= width - 55 && mouseX <= width - 30 && mouseY >= height - 65 && mouseY <= height - 35) {    isPause = !isPause;}',correct
'R',correct
'textAlign(CENTER)',correct
'right.rightStart()',correct
'leftColor = 100;',correct
'// Colorsint bodyColor;',correct
'sunColor = 230',correct
'stroke(wingColor);',correct
'wingColor = color(0, 153, 209);',correct
'void sunChangePlay() {    sunColor = color(255, 208, 0);    sunSpeed = -0.3f;    sunY = sunY + sunSpeed;    // This respawns the sun when it it out of sight    if (sunY + 150 < 0) {        sunY = height + 200;    }}',correct
'doveMousePressed',correct
'// This is the "game", with colors and speeds for the different moving objectsvoid doveChangePlay() {    bodyColor = color(66, 197, 244);    wingColor = color(0, 153, 209);    tailColor = color(34, 190, 247);    neckColor = color(18, 173, 229);    headColor = color(0, 136, 186);    // This makes the dove move    doveY = doveY + doveSpeedY;    doveX = doveX + doveSpeedX;    // This respawns the Dove once it is out of sight    if (doveX < -110) {        doveX = width + 65;        doveY = height / 1.5f;    }    // This keeps the Dove from flying out of the screen on the top and bottom    if (doveY - 85 <= 0) {        doveY = 85;    }    if (doveY + 65 >= height) {        doveY = height - 65;    }}',correct
'rectMode(CENTER)',correct
'doveY = height - 65;',correct
'color(66, 197, 244)',correct
'!isRain',correct
'right',correct
'isRain = false',correct
'isPause = !isPause;',correct
'// Dick Dekker, 2069644// Creative Technology student// 03-10-2018// This program is called Dove Simulator. When you click on the Dove on the beginning screen the Dove starts flying.// You can move the dove with the keys: UP, DOWN, LEFT and RIGHT.// When you press the spacebar the game pauses, you can also use the pause icon in the downright corner.// In the pause menu you can press Restart in the downleft corner, goes back to the homescreen.// When you press R it will start raining. Press R again and it stops raining.// When you drag your mouse, the sun will drag over the screen.// Booleansboolean isPause;',correct
'{    rainDrop[i] = new rain();}',correct
'rectMode(CENTER);',correct
'// This changes the color of the mountain during Start, Pause and Playvoid leftStart() {    leftColor = 100;}',AtLeastOneConstructor
'// When you release a key, it goes back to the normal speedvoid doveKeyReleased() {    if (keyCode == UP) {        doveSpeedY = -0.7f;    }    if (keyCode == DOWN) {        doveSpeedY = -0.7f;    }    if (keyCode == LEFT) {        doveSpeedX = -3;    }    if (keyCode == RIGHT) {        doveSpeedX = -3;    }}',correct
'{    if (keyCode == UP) {        doveSpeedY = -6;    }    if (keyCode == DOWN) {        doveSpeedY = 6;    }    if (keyCode == LEFT) {        doveSpeedX = -6;    }    if (keyCode == RIGHT) {        doveSpeedX = -1.5f;    }}',correct
'sun1.sunDragged()',correct
'doveY - 85',correct
'{    // Calls Sun for sunDragged    sun1.sunDragged();}',correct
'width - 35',correct
'// Calling classes to make new spots for objects',correct
'triangle(doveX, doveY - 50, doveX + 50, doveY + 65, doveX - 40, doveY + 10);',correct
'width - 30',correct
'headColor = color(0, 136, 186)',correct
'rain[] rainDrop = new rain[1000];',correct
'{    rainY = rainY + rainSpeed;}',correct
'doveX + 50',correct
'text("Pause", width / 2, height / 2)',correct
'doveX + doveSpeedX',correct
'mouseY <= height - 35',correct
'rainStart',correct
'doveY = 85;',correct
'sunSpeed = -0.05f;',correct
'rainSpeed = 1;',correct
'fill(bodyColor)',correct
'bodyColor = color(66, 197, 244);',correct
'headColor = 120',correct
'for (int i = 0; i < rainDrop.length; i++) {    rainDrop[i].fall();    rainDrop[i].display();}',correct
'void display() {    // The Dove    // Body    fill(bodyColor);    stroke(bodyColor);    triangle(doveX, doveY - 50, doveX + 50, doveY + 65, doveX - 40, doveY + 10);    // Wing    fill(wingColor);    stroke(wingColor);    triangle(doveX, doveY - 50, doveX + 80, doveY - 85, doveX + 33, doveY + 25);    // Tail    fill(tailColor);    stroke(tailColor);    quad(doveX + 33, doveY + 25, doveX + 44, doveY, doveX + 110, doveY + 65, doveX + 50, doveY + 65);    // Neck    fill(neckColor);    stroke(neckColor);    quad(doveX - 50, doveY - 55, doveX - 30, doveY - 55, doveX - 10, doveY - 35, doveX - 40, doveY + 10);    // Head    fill(headColor);    stroke(headColor);    triangle(doveX - 65, doveY - 28, doveX - 50, doveY - 55, doveX - 48, doveY - 40);}',correct
'// 03-10-2018',correct
'int sunColor;',correct
'doveX + 44',correct
'textSize(30);',correct
'sunX = initX;',correct
'Dove(float initX, float initY) {    doveX = initX;    doveY = initY;}',correct
'doveX < -110',correct
'Dove',correct
'// Dick Dekker, 2069644',correct
'doveX = width / 2;',correct
'sun1.sunChangePause()',correct
'bodyColor = color(66, 197, 244)',correct
'quad(doveX + 33, doveY + 25, doveX + 44, doveY, doveX + 110, doveY + 65, doveX + 50, doveY + 65)',correct
'// This draws sun1 from the Class: Sunsun1.display();',correct
'doveX + 33',correct
'{    // Calls Dove or doveKeyReleased    dove1.doveKeyReleased();}',correct
'sunY = initY;',correct
'Processing',correct
'doveY + doveSpeedY',correct
'mouseX >= 30 && mouseX <= 130',correct
'doveX = width + 65;',correct
'{    rainY = -30;    rainX = random(width);}',correct
'isStart = false',correct
'{    rainColor = color(0, 97, 255);    rainSpeed = random(4, 15);    // If rain>height it comes back to the top randomly    if (rainY > height) {        rainY = random(-1200, -100);        rainX = random(width);    }}',correct
'sunY = sunY + sunSpeed;',correct
'if (keyCode == UP) {    doveSpeedY = -6;}',correct
'isPause == false',SimplifyBooleanExpressions
'for (int i = 0; i < rainDrop.length; i++) {    rainDrop[i].rainStart();}',correct
'{    doveSpeedY = -0.7f;}',correct
'backgColor',correct
'dove1.doveChangePause()',correct
'doveX + 25',correct
'height + 200',correct
'false',correct
'// This line changes the color and speed of the rain',correct
'rightmountain right;',correct
'!isPause',correct
'rainY > height',correct
'sunX = initX',correct
'sunChangePause',correct
'rainDrop[i] = new rain();',correct
'for (int i = 0; i < rainDrop.length; i++) {    rainDrop[i].rainPlay();}',correct
'fill(headColor)',correct
'setup',correct
'// This is a for loop which draws 1000 rainDrops from the Class: rainif (isRain == true) {    for (int i = 0; i < rainDrop.length; i++) {        rainDrop[i].fall();        rainDrop[i].display();    }}',correct
'isStart == false',correct
'void sunChangePause() {    sunColor = 230;    sunSpeed = -0.05f;    sunY = sunY + sunSpeed;    // This respawns the sun when it it out of sight    if (sunY + 150 < 0) {        sunY = height + 200;    }}',correct
'// These lines change the color and speed of the objectsdove1.doveChangePause();',correct
'rainColor',correct
'stroke(bodyColor);',correct
'// This keeps the Dove from flying out of the screen on the top and bottomif (doveY - 85 <= 0) {    doveY = 85;}',correct
'sunX = mouseX;',correct
'float sunSpeed;',correct
'i = 0',correct
'tailColor',correct
'rightColor = 160;',correct
'headColor = color(0, 136, 186);',correct
'// Tailfill(tailColor);',correct
'doveChangePause',correct
'0.3f',correct
'stroke(neckColor)',correct
'sun1.sunChangeStart()',correct
'// This calls the class Dove for doveMousePresseddove1.doveMousePressed();',correct
'"Dove Simulator"',correct
'mouseX > doveX - 50 && mouseX < doveX + 110',correct
'dove1.display()',correct
'void keyReleased() {    // Calls Dove or doveKeyReleased    dove1.doveKeyReleased();}',correct
'rightColor',correct
'doveKeyPressed',correct
'int headColor;',correct
'random(10, 20)',correct
'width + 65',correct
'// When you press the spacebar the game pauses, you can also use the pause icon in the downright corner.',correct
'doveSpeedY = -6',correct
'rainColor = 140;',correct
'{    bodyColor = 160;    wingColor = 100;    tailColor = 200;    neckColor = 180;    headColor = 120;}',correct
'isStart = false;',correct
'isStart = true;',correct
'isRain == true',correct
'mouseX < doveX + 110',correct
'fill(160)',correct
'noStroke();',correct
'rainDrop[i].display();',correct
'rainDrop[i].rainStart()',correct
'quad(doveX + 33, doveY + 25, doveX + 44, doveY, doveX + 110, doveY + 65, doveX + 50, doveY + 65);',correct
'rightColor = color(90, 221, 99);',correct
'mouseX > doveX - 50',correct
'rect(width - 35, height - 50, 10, 30)',correct
'random(-1200, -100)',correct
'bodyColor = 160',correct
'// The Dove// Bodyfill(bodyColor);',correct
'float doveSpeedX = -3;',correct
'sunX = mouseX',correct
'doveY = doveY + doveSpeedY',correct
'isStart == true',correct
'// This is the starting title of the Programfill(160);',correct
'color(18, 173, 229)',correct
'sunColor = 230;',correct
'rainDrop[i]',correct
'new rain[1000]',correct
'{    rainDrop[i].rainPlay();}',correct
'keyCode == UP',correct
'void mousePressed() {    // This calls the class Dove for doveMousePressed    dove1.doveMousePressed();    // This is the pause button and play button    if (mouseX >= width - 55 && mouseX <= width - 30 && mouseY >= height - 65 && mouseY <= height - 35) {        isPause = !isPause;    }    // this is the restart button    if (mouseX >= 30 && mouseX <= 130 && mouseY >= height - 65 && mouseY <= height - 35 && isPause == true) {        isStart = true;        isPause = false;    }}',correct
'doveY = initY',correct
'left = new leftmountain()',correct
'// This respawns the Dove once it is out of sightif (doveX < -110) {    doveX = width + 65;    doveY = height / 1.5f;}',correct
'isStart = true',correct
'rainX = random(width);',correct
'stroke(tailColor);',correct
'// This dragges the sun around the screen when you drag the mousevoid sunDragged() {    sunX = mouseX;    sunY = mouseY;}',correct
'// this is the restart buttonif (mouseX >= 30 && mouseX <= 130 && mouseY >= height - 65 && mouseY <= height - 35 && isPause == true) {    isStart = true;    isPause = false;}',correct
'draw',LongMethodRule
'triangle(doveX - 65, doveY - 28, doveX - 50, doveY - 55, doveX - 48, doveY - 40);',correct
'class Dove {    // Variables    float doveX;    float doveY;    float doveSpeedX = -3;    float doveSpeedY = -0.7f;    // Colors    int bodyColor;    int wingColor;    int tailColor;    int neckColor;    int headColor;    Dove(float initX, float initY) {        doveX = initX;        doveY = initY;    }    void display() {        // The Dove        // Body        fill(bodyColor);        stroke(bodyColor);        triangle(doveX, doveY - 50, doveX + 50, doveY + 65, doveX - 40, doveY + 10);        // Wing        fill(wingColor);        stroke(wingColor);        triangle(doveX, doveY - 50, doveX + 80, doveY - 85, doveX + 33, doveY + 25);        // Tail        fill(tailColor);        stroke(tailColor);        quad(doveX + 33, doveY + 25, doveX + 44, doveY, doveX + 110, doveY + 65, doveX + 50, doveY + 65);        // Neck        fill(neckColor);        stroke(neckColor);        quad(doveX - 50, doveY - 55, doveX - 30, doveY - 55, doveX - 10, doveY - 35, doveX - 40, doveY + 10);        // Head        fill(headColor);        stroke(headColor);        triangle(doveX - 65, doveY - 28, doveX - 50, doveY - 55, doveX - 48, doveY - 40);    }    void doveChangeStart() {        // If isStart is true the bird will be grey and the text will be printed under the bird        bodyColor = 160;        wingColor = 100;        tailColor = 200;        neckColor = 180;        headColor = 120;        fill(200);        textSize(16);        textAlign(CENTER);        text("Click to set me free", doveX + 25, doveY + 90);        doveX = width / 2;        doveY = height / 2;    }    // This is the Pause "menu", the dove is grey    void doveChangePause() {        bodyColor = 160;        wingColor = 100;        tailColor = 200;        neckColor = 180;        headColor = 120;    }    // This is the "game", with colors and speeds for the different moving objects    void doveChangePlay() {        bodyColor = color(66, 197, 244);        wingColor = color(0, 153, 209);        tailColor = color(34, 190, 247);        neckColor = color(18, 173, 229);        headColor = color(0, 136, 186);        // This makes the dove move        doveY = doveY + doveSpeedY;        doveX = doveX + doveSpeedX;        // This respawns the Dove once it is out of sight        if (doveX < -110) {            doveX = width + 65;            doveY = height / 1.5f;        }        // This keeps the Dove from flying out of the screen on the top and bottom        if (doveY - 85 <= 0) {            doveY = 85;        }        if (doveY + 65 >= height) {            doveY = height - 65;        }    }    void doveMousePressed() {        // When clicked on the Dove isStart becomes false. And isPause becomes false which will let the bird fly        if (mouseX > doveX - 50 && mouseX < doveX + 110 && mouseY > doveY - 55 && mouseY < doveY + 65 && isStart == true) {            isPause = false;            isStart = false;        }    }    // This makes the speed of the dove move by pressing up, down, left and right    void doveKeyPressed() {        if (keyCode == UP) {            doveSpeedY = -6;        }        if (keyCode == DOWN) {            doveSpeedY = 6;        }        if (keyCode == LEFT) {            doveSpeedX = -6;        }        if (keyCode == RIGHT) {            doveSpeedX = -1.5f;        }    }    // When you release a key, it goes back to the normal speed    void doveKeyReleased() {        if (keyCode == UP) {            doveSpeedY = -0.7f;        }        if (keyCode == DOWN) {            doveSpeedY = -0.7f;        }        if (keyCode == LEFT) {            doveSpeedX = -3;        }        if (keyCode == RIGHT) {            doveSpeedX = -3;        }    }}',correct
'rainDrop.length',correct
'dove1.doveChangeStart()',correct
'{    doveSpeedX = -3;}',correct
'doveY = height / 2;',correct
'mouseX >= width - 55 && mouseX <= width - 30 && mouseY >= height - 65',correct
'fill(rainColor);',correct
'stroke(leftColor)',correct
'float rainY = random(-1200, -100);',correct
'mouseX > doveX - 50 && mouseX < doveX + 110 && mouseY > doveY - 55 && mouseY < doveY + 65',correct
'void display() {    // Left Mountain    fill(leftColor);    stroke(leftColor);    triangle(0, height, 0, height / 1.25f, width / 1.25f, height);}',AtLeastOneConstructor
'ellipse(sunX, sunY, 300, 300);',correct
'sunChangePlay',correct
'isRain = !isRain;',correct
'{    doveSpeedY = 6;}',correct
'new rightmountain()',correct
'leftmountain',correct
'if (doveY + 65 >= height) {    doveY = height - 65;}',correct
'{    textAlign(LEFT);    fill(0);    textSize(30);    text("Restart", 30, height - 35);}',correct
'mouseY >= height - 65',correct
'{    doveSpeedY = -6;}',correct
'stroke(leftColor);',correct
'1.25f',correct
'mousePressed',correct
'float doveY;',correct
'sunY + 150 < 0',correct
'void doveMousePressed() {    // When clicked on the Dove isStart becomes false. And isPause becomes false which will let the bird fly    if (mouseX > doveX - 50 && mouseX < doveX + 110 && mouseY > doveY - 55 && mouseY < doveY + 65 && isStart == true) {        isPause = false;        isStart = false;    }}',correct
'{    rightColor = color(90, 221, 99);}',correct
'text("Restart", 30, height - 35);',PixelHardcodeIgnoranceRule
'fill(rightColor)',correct
'0.7f',correct
'sunDragged',correct
'sun1 = new Sun(width / 4, height + 40);',correct
'void',correct
'// This respawns the sun when it it out of sightif (sunY + 150 < 0) {    sunY = height + 200;}',correct
'{    // This calls the class Dove for doveMousePressed    dove1.doveMousePressed();    // This is the pause button and play button    if (mouseX >= width - 55 && mouseX <= width - 30 && mouseY >= height - 65 && mouseY <= height - 35) {        isPause = !isPause;    }    // this is the restart button    if (mouseX >= 30 && mouseX <= 130 && mouseY >= height - 65 && mouseY <= height - 35 && isPause == true) {        isStart = true;        isPause = false;    }}',correct
'doveX + 110',correct
'-3',correct
'right.rightPause()',correct
'if (isPause == false) {    // These lines change the color and speed of the objects    dove1.doveChangePlay();    sun1.sunChangePlay();    backgColor = (255);    right.rightPlay();    left.leftPlay();    // If isRain == true it starts raining    if (isRain == true) {        for (int i = 0; i < rainDrop.length; i++) {            rainDrop[i].rainPlay();        }    }    // This draws the pause button    fill(0);    rectMode(CENTER);    rect(width - 50, height - 50, 10, 30);    rect(width - 35, height - 50, 10, 30);}',SimplifyBooleanExpressions
'float rainSpeed = random(4, 15);',correct
'-6',correct
'doveX - 65',correct
'-0.7f',correct
'isPause',correct
'triangle(doveX, doveY - 50, doveX + 50, doveY + 65, doveX - 40, doveY + 10)',correct
'void mouseDragged() {    // Calls Sun for sunDragged    sun1.sunDragged();}',correct
'left.leftPause();',correct
'doveY = height - 65',correct
'mouseX > doveX - 50 && mouseX < doveX + 110 && mouseY > doveY - 55 && mouseY < doveY + 65 && isStart == true',correct
'{    isPause = !isPause;}',SimplifyBooleanExpressions
'stroke(tailColor)',correct
'doveX = width + 65',correct
'doveY = initY;',correct
'doveY = height / 2',correct
'true',correct
'rainDrop[i].display()',correct
'1.5f',correct
'i < rainDrop.length',correct
'rightColor = color(90, 221, 99)',correct
'// If isStart is true the bird will be grey and the text will be printed under the birdbodyColor = 160;',correct
'boolean isRain;',correct
'backgColor = (255)',correct
'-1.5f',correct
'{    // One raindrop    noStroke();    fill(rainColor);    ellipse(rainX, rainY, 3, rainLength);}',correct
'bodyColor = 160;',correct
'mouseX <= 130',correct
'doveX - 50',correct
'textSize(150);',correct
'// Wingfill(wingColor);',correct
'right.display()',correct
'leftColor',correct
'for (int i = 0; i < rainDrop.length; i++) {    rainDrop[i] = new rain();}',correct
'if (keyCode == RIGHT) {    doveSpeedX = -1.5f;}',correct
'mouseX <= width - 30',correct
'class leftmountain {    // Colors    int leftColor;    void display() {        // Left Mountain        fill(leftColor);        stroke(leftColor);        triangle(0, height, 0, height / 1.25f, width / 1.25f, height);    }    // This changes the color of the mountain during Start, Pause and Play    void leftStart() {        leftColor = 100;    }    void leftPause() {        leftColor = 100;    }    void leftPlay() {        leftColor = color(0, 119, 7);    }}',correct
'doveX = doveX + doveSpeedX',correct
'doveSpeedY = -0.7f;',correct
'{    // Right Mountain    fill(rightColor);    noStroke();    triangle(width / 3, height, width, height / 1.9f, width, width);}',correct
'{    rightColor = 160;}',correct
'right.rightPlay();',correct
'// Variables',AtLeastOneConstructor
'left.leftPlay()',correct
'// This draws the play buttonfill(0);',correct
'rain[]',correct
'doveX - 48',correct
'mouseX > doveX - 50 && mouseX < doveX + 110 && mouseY > doveY - 55',correct
'rect(width - 50, height - 50, 10, 30)',correct
'leftColor = color(0, 119, 7);',correct
'doveX - 40',correct
'text("Dove Simulator", width / 2, height / 2 - 200)',correct
'fill(neckColor)',correct
'fill(tailColor)',correct
'{    doveSpeedX = -1.5f;}',correct
'isPause = !isPause',correct
'rainDrop[i].rainStart();',correct
'if (keyCode == LEFT) {    doveSpeedX = -6;}',correct
'random(width)',correct
'tailColor = color(34, 190, 247)',correct
'class Sun {    // Sun    float sunX;    float sunY;    float sunSpeed;    int sunColor;    Sun(float initX, float initY) {        sunX = initX;        sunY = initY;    }    void display() {        // Sun        noStroke();        fill(sunColor);        ellipse(sunX, sunY, 300, 300);    }    // sunChangeStart, sunChangePause and sunChangePlay change the color and speed of the sun    void sunChangeStart() {        sunColor = 230;        sunSpeed = -0.05f;        sunY = sunY + sunSpeed;        // This respawns the sun when it it out of sight        if (sunY + 150 < 0) {            sunY = height + 200;        }    }    void sunChangePause() {        sunColor = 230;        sunSpeed = -0.05f;        sunY = sunY + sunSpeed;        // This respawns the sun when it it out of sight        if (sunY + 150 < 0) {            sunY = height + 200;        }    }    void sunChangePlay() {        sunColor = color(255, 208, 0);        sunSpeed = -0.3f;        sunY = sunY + sunSpeed;        // This respawns the sun when it it out of sight        if (sunY + 150 < 0) {            sunY = height + 200;        }    }    // This dragges the sun around the screen when you drag the mouse    void sunDragged() {        sunX = mouseX;        sunY = mouseY;    }}',correct
'mouseDragged',correct
'// This program is called Dove Simulator. When you click on the Dove on the beginning screen the Dove starts flying.',correct
'triangle(0, height, 0, height / 1.25f, width / 1.25f, height)',correct
'mouseY < doveY + 65',correct
'right = new rightmountain();',correct
'doveY + 25',correct
'rainPlay',correct
'class rightmountain {    // Colors    int rightColor;    void display() {        // Right Mountain        fill(rightColor);        noStroke();        triangle(width / 3, height, width, height / 1.9f, width, width);    }    // This changes the color of the mountain during Start, Pause and Play    void rightStart() {        rightColor = 160;    }    void rightPause() {        rightColor = 160;    }    void rightPlay() {        rightColor = color(90, 221, 99);    }}',correct
'{    rainY = random(-1200, -100);    rainX = random(width);}',correct
'void leftPlay() {    leftColor = color(0, 119, 7);}',correct
'mouseY > doveY - 55',correct
'doveX = initX',correct
'// This is the pause menu wordtextAlign(CENTER);',correct
'float sunY;',correct
'text("Click to set me free", doveX + 25, doveY + 90);',correct
'// This draws left from the Class: leftmountainleft.display();',correct
'// Calling classes to make new spots for objects// rainDrop is an array of 1000 spotsDove dove1;',correct
'quad(doveX - 50, doveY - 55, doveX - 30, doveY - 55, doveX - 10, doveY - 35, doveX - 40, doveY + 10)',correct
'text("Click to set me free", doveX + 25, doveY + 90)',correct
'// SunnoStroke();',correct
'rainY = -30;',correct
'{    // Left Mountain    fill(leftColor);    stroke(leftColor);    triangle(0, height, 0, height / 1.25f, width / 1.25f, height);}',correct
'rightColor = 160',correct
'// This changes the color of the mountain during Start, Pause and Playvoid rightStart() {    rightColor = 160;}',AtLeastOneConstructor
'doveY + 10',correct
'doveY + 65 >= height',correct
'if (keyCode == UP) {    doveSpeedY = -0.7f;}',correct
'isStart',correct
'Sun',correct
'doveSpeedX = -6;',correct
'// This draws the pause buttonfill(0);',correct
'// If rain>height it comes back to the top randomlyif (rainY > height) {    rainY = random(-1200, -100);    rainX = random(width);}',correct
'mouseX >= 30 && mouseX <= 130 && mouseY >= height - 65',correct
'1.9f',correct
'// Left Mountainfill(leftColor);',correct
'{    for (int i = 0; i < rainDrop.length; i++) {        rainDrop[i].rainStart();    }}',SimplifyBooleanExpressions
'mouseX >= 30 && mouseX <= 130 && mouseY >= height - 65 && mouseY <= height - 35',correct
'rainColor = 140',correct
'// Neckfill(neckColor);',correct
'doveKeyReleased',correct
'height / 1.5f',correct
'void display() {    // One raindrop    noStroke();    fill(rainColor);    ellipse(rainX, rainY, 3, rainLength);}',AtLeastOneConstructor
'height / 1.25f',correct
'if (keyCode == LEFT) {    doveSpeedX = -3;}',correct
'sun1.sunChangePause();',correct
'sunY = initY',correct
'doveSpeedX = -3;',correct
'sunSpeed = -0.3f;',correct
'right.rightStart();',correct
'sunChangeStart',correct
'sunColor = color(255, 208, 0)',correct
'int wingColor;',correct
'float rainLength = random(10, 20);',correct
'if (isStart == true) {    // These lines change the color and speed of the objects    dove1.doveChangeStart();    sun1.sunChangeStart();    backgColor = (70);    right.rightStart();    left.leftStart();    // If isRain == true it starts raining    if (isRain == true) {        for (int i = 0; i < rainDrop.length; i++) {            rainDrop[i].rainStart();        }    }    // This is the starting title of the Program    fill(160);    textSize(150);    text("Dove Simulator", width / 2, height / 2 - 200);} else if (isPause == true) {    // These lines change the color and speed of the objects    dove1.doveChangePause();    sun1.sunChangePause();    backgColor = (70);    right.rightPause();    left.leftPause();    // If isRain == true it starts raining    if (isRain == true) {        for (int i = 0; i < rainDrop.length; i++) {            rainDrop[i].rainStart();        }    }    // This draws the play button    fill(0);    triangle(width - 55, height - 35, width - 55, height - 65, width - 30, height - 50);    // This is the pause menu word    textAlign(CENTER);    textSize(200);    fill(255);    text("Pause", width / 2, height / 2);} else if (isPause == false) {    // These lines change the color and speed of the objects    dove1.doveChangePlay();    sun1.sunChangePlay();    backgColor = (255);    right.rightPlay();    left.leftPlay();    // If isRain == true it starts raining    if (isRain == true) {        for (int i = 0; i < rainDrop.length; i++) {            rainDrop[i].rainPlay();        }    }    // This draws the pause button    fill(0);    rectMode(CENTER);    rect(width - 50, height - 50, 10, 30);    rect(width - 35, height - 50, 10, 30);}',correct
'// If isRain == true it starts rainingif (isRain == true) {    for (int i = 0; i < rainDrop.length; i++) {        rainDrop[i].rainStart();    }}',correct
'// In the pause menu you can press Restart in the downleft corner, goes back to the homescreen.',correct
'isRain = false;',correct
'{    doveY = height - 65;}',correct
'void rainPause() {    rainColor = 140;    rainSpeed = 1;    // If rain>height it comes back to the top randomly    if (rainY > height) {        rainY = -30;        rainX = random(width);    }}',AtLeastOneConstructor
'height / 2 - 200',correct
'rainColor = color(0, 97, 255);',correct
'ellipse(sunX, sunY, 300, 300)',correct
'// Matching the new object slots to a class and declaring the values of the objects',correct
'sunY + sunSpeed',correct
'[1000]',correct
'// When you drag your mouse, the sun will drag over the screen.',correct
'{    isStart = true;    isPause = false;}',correct
'{    sunColor = 230;    sunSpeed = -0.05f;    sunY = sunY + sunSpeed;    // This respawns the sun when it it out of sight    if (sunY + 150 < 0) {        sunY = height + 200;    }}',correct
'isRain',correct
'Sun(float initX, float initY) {    sunX = initX;    sunY = initY;}',correct
'fill(rainColor)',correct
'textSize(30)',correct
'noStroke()',correct
'sunSpeed',correct
'isPause = false',correct
'leftmountain left;',correct
'fill(sunColor);',correct
'stroke(headColor)',correct
'neckColor',correct
'text("Restart", 30, height - 35)',correct
'sunColor = color(255, 208, 0);',correct
'right.rightPlay()',correct
'key ==',correct
'sunY = height + 200',correct
'sunColor',correct
'backgColor = (255);',correct
'sunY = height + 200;',correct
'mouseX >= 30 && mouseX <= 130 && mouseY >= height - 65 && mouseY <= height - 35 && isPause == true',correct
'doveY = height / 1.5f;',correct
'void doveChangeStart() {    // If isStart is true the bird will be grey and the text will be printed under the bird    bodyColor = 160;    wingColor = 100;    tailColor = 200;    neckColor = 180;    headColor = 120;    fill(200);    textSize(16);    textAlign(CENTER);    text("Click to set me free", doveX + 25, doveY + 90);    doveX = width / 2;    doveY = height / 2;}',correct
'// this draws the text in the Pause "menu" which will be the bottom to restart the programif (isPause == true) {    textAlign(LEFT);    fill(0);    textSize(30);    text("Restart", 30, height - 35);}',correct
'rainY = rainY + rainSpeed;',correct
'wingColor = color(0, 153, 209)',correct
'doveY = 85',correct
'// Colorsint rightColor;',AtLeastOneConstructor
'{    // This calls the class Dove for doveKeyPressed    dove1.doveKeyPressed();    // This is the spacebar pause button    if (key ==   && isStart == false) {        isPause = !isPause;    }    // This is the letter R, when it is pressed it starts raining    if (key == R) {        isRain = !isRain;    }}',correct
'{    // Fills the background with backgColor    background(backgColor);    // This draws sun1 from the Class: Sun    sun1.display();    // This draws right from the Class: rightmountain    right.display();    // This draws dove1 from the Class: Dove    dove1.display();    // This is a for loop which draws 1000 rainDrops from the Class: rain    if (isRain == true) {        for (int i = 0; i < rainDrop.length; i++) {            rainDrop[i].fall();            rainDrop[i].display();        }    }    // This draws left from the Class: leftmountain    left.display();    if (isStart == true) {        // These lines change the color and speed of the objects        dove1.doveChangeStart();        sun1.sunChangeStart();        backgColor = (70);        right.rightStart();        left.leftStart();        // If isRain == true it starts raining        if (isRain == true) {            for (int i = 0; i < rainDrop.length; i++) {                rainDrop[i].rainStart();            }        }        // This is the starting title of the Program        fill(160);        textSize(150);        text("Dove Simulator", width / 2, height / 2 - 200);    } else if (isPause == true) {        // These lines change the color and speed of the objects        dove1.doveChangePause();        sun1.sunChangePause();        backgColor = (70);        right.rightPause();        left.leftPause();        // If isRain == true it starts raining        if (isRain == true) {            for (int i = 0; i < rainDrop.length; i++) {                rainDrop[i].rainStart();            }        }        // This draws the play button        fill(0);        triangle(width - 55, height - 35, width - 55, height - 65, width - 30, height - 50);        // This is the pause menu word        textAlign(CENTER);        textSize(200);        fill(255);        text("Pause", width / 2, height / 2);    } else if (isPause == false) {        // These lines change the color and speed of the objects        dove1.doveChangePlay();        sun1.sunChangePlay();        backgColor = (255);        right.rightPlay();        left.leftPlay();        // If isRain == true it starts raining        if (isRain == true) {            for (int i = 0; i < rainDrop.length; i++) {                rainDrop[i].rainPlay();            }        }        // This draws the pause button        fill(0);        rectMode(CENTER);        rect(width - 50, height - 50, 10, 30);        rect(width - 35, height - 50, 10, 30);    }    // this draws the text in the Pause "menu" which will be the bottom to restart the program    if (isPause == true) {        textAlign(LEFT);        fill(0);        textSize(30);        text("Restart", 30, height - 35);    }}',LongMethodRule
'sunY = mouseY;',correct
'doveY',correct
'doveX',correct
'isPause == true',correct
'dove1.doveKeyPressed()',correct
'Sun sun1;',correct
'// This is the spacebar pause buttonif (key ==   && isStart == false) {    isPause = !isPause;}',correct
'-100',correct
'// Right Mountainfill(rightColor);',correct
'fill(0)',correct
'stroke(headColor);',correct
'height / 2',correct
'isRain = !isRain',correct
'sun1 = new Sun(width / 4, height + 40)',correct
'neckColor = color(18, 173, 229);',correct
'key == R',correct
'class rain {    // Colors    int rainColor;    // Variables    // Chooses a random X-position, Y-position, Speed and Length    float rainX = random(width);    float rainY = random(-1200, -100);    float rainSpeed = random(4, 15);    float rainLength = random(10, 20);    void display() {        // One raindrop        noStroke();        fill(rainColor);        ellipse(rainX, rainY, 3, rainLength);    }    // This determences the speed of the raindrop    void fall() {        rainY = rainY + rainSpeed;    }    // rainStart, rainPause and rainPlay give the rain different colors, speed and spawnlocation    void rainStart() {        rainColor = 140;        rainSpeed = 1;        // If rain>height it comes back to the top randomly        if (rainY > height) {            rainY = -30;            rainX = random(width);        }    }    void rainPause() {        rainColor = 140;        rainSpeed = 1;        // If rain>height it comes back to the top randomly        if (rainY > height) {            rainY = -30;            rainX = random(width);        }    }    void rainPlay() {        rainColor = color(0, 97, 255);        rainSpeed = random(4, 15);        // If rain>height it comes back to the top randomly        if (rainY > height) {            rainY = random(-1200, -100);            rainX = random(width);        }    }}',correct
'// rainStart, rainPause and rainPlay give the rain different colors, speed and spawnlocationvoid rainStart() {    rainColor = 140;    rainSpeed = 1;    // If rain>height it comes back to the top randomly    if (rainY > height) {        rainY = -30;        rainX = random(width);    }}',AtLeastOneConstructor
'height / 1.9f',correct
'rainY = -30',correct
'new leftmountain()',correct
'fill(255)',correct
'rainDrop[i].rainPlay();',correct
'fill(leftColor)',correct
'// One raindropnoStroke();',correct
'-110',correct
'color(0, 97, 255)',correct
'rainY = random(-1200, -100)',correct
'// Variables// Chooses a random X-position, Y-position, Speed and Lengthfloat rainX = random(width);',AtLeastOneConstructor
'{    sunX = mouseX;    sunY = mouseY;}',correct
'rainColor = color(0, 97, 255)',correct
'sunY + 150',correct
'left.leftStart()',correct
'right.rightPause();',correct
'stroke(neckColor);',correct
'{    doveX = width + 65;    doveY = height / 1.5f;}',correct
'textSize(16);',correct
'color(255, 208, 0)',correct
'rainY = rainY + rainSpeed',correct
'textAlign(CENTER);',correct
'if (keyCode == RIGHT) {    doveSpeedX = -3;}',correct
'void draw() {    // Fills the background with backgColor    background(backgColor);    // This draws sun1 from the Class: Sun    sun1.display();    // This draws right from the Class: rightmountain    right.display();    // This draws dove1 from the Class: Dove    dove1.display();    // This is a for loop which draws 1000 rainDrops from the Class: rain    if (isRain == true) {        for (int i = 0; i < rainDrop.length; i++) {            rainDrop[i].fall();            rainDrop[i].display();        }    }    // This draws left from the Class: leftmountain    left.display();    if (isStart == true) {        // These lines change the color and speed of the objects        dove1.doveChangeStart();        sun1.sunChangeStart();        backgColor = (70);        right.rightStart();        left.leftStart();        // If isRain == true it starts raining        if (isRain == true) {            for (int i = 0; i < rainDrop.length; i++) {                rainDrop[i].rainStart();            }        }        // This is the starting title of the Program        fill(160);        textSize(150);        text("Dove Simulator", width / 2, height / 2 - 200);    } else if (isPause == true) {        // These lines change the color and speed of the objects        dove1.doveChangePause();        sun1.sunChangePause();        backgColor = (70);        right.rightPause();        left.leftPause();        // If isRain == true it starts raining        if (isRain == true) {            for (int i = 0; i < rainDrop.length; i++) {                rainDrop[i].rainStart();            }        }        // This draws the play button        fill(0);        triangle(width - 55, height - 35, width - 55, height - 65, width - 30, height - 50);        // This is the pause menu word        textAlign(CENTER);        textSize(200);        fill(255);        text("Pause", width / 2, height / 2);    } else if (isPause == false) {        // These lines change the color and speed of the objects        dove1.doveChangePlay();        sun1.sunChangePlay();        backgColor = (255);        right.rightPlay();        left.leftPlay();        // If isRain == true it starts raining        if (isRain == true) {            for (int i = 0; i < rainDrop.length; i++) {                rainDrop[i].rainPlay();            }        }        // This draws the pause button        fill(0);        rectMode(CENTER);        rect(width - 50, height - 50, 10, 30);        rect(width - 35, height - 50, 10, 30);    }    // this draws the text in the Pause "menu" which will be the bottom to restart the program    if (isPause == true) {        textAlign(LEFT);        fill(0);        textSize(30);        text("Restart", 30, height - 35);    }}',correct
'if (keyCode == DOWN) {    doveSpeedY = -0.7f;}',correct
'"Restart"',correct
'rainSpeed = random(4, 15);',correct
'key ==   && isStart == false',SimplifyBooleanExpressions
'int i = 0',correct
'fill(200);',correct
'// This draws dove1 from the Class: Dovedove1.display();',correct
'backgColor = (70)',correct
'new Dove(width / 2, height / 2)',correct
'color(0, 119, 7)',correct
'0.05f',correct
'// sunChangeStart, sunChangePause and sunChangePlay change the color and speed of the sunvoid sunChangeStart() {    sunColor = 230;    sunSpeed = -0.05f;    sunY = sunY + sunSpeed;    // This respawns the sun when it it out of sight    if (sunY + 150 < 0) {        sunY = height + 200;    }}',correct
'tailColor = color(34, 190, 247);',correct
'wingColor = 100',correct
'// If rain>height it comes back to the top randomlyif (rainY > height) {    rainY = -30;    rainX = random(width);}',correct
'doveX = width / 2',correct
'triangle(0, height, 0, height / 1.25f, width / 1.25f, height);',correct
'left = new leftmountain();',correct
'doveY - 40',correct
'rightStart',correct
'tailColor = 200',correct
'new rain()',correct
'rainDrop[i].fall()',correct
'"Pause"',correct
'rainDrop[i] = new rain()',correct
'{    // These lines change the color and speed of the objects    dove1.doveChangePause();    sun1.sunChangePause();    backgColor = (70);    right.rightPause();    left.leftPause();    // If isRain == true it starts raining    if (isRain == true) {        for (int i = 0; i < rainDrop.length; i++) {            rainDrop[i].rainStart();        }    }    // This draws the play button    fill(0);    triangle(width - 55, height - 35, width - 55, height - 65, width - 30, height - 50);    // This is the pause menu word    textAlign(CENTER);    textSize(200);    fill(255);    text("Pause", width / 2, height / 2);}',SimplifyBooleanExpressions
'text("Pause", width / 2, height / 2);',correct
'// Sunfloat sunX;',correct
'rightmountain',correct
'{    rainDrop[i].rainStart();}',correct
'stroke(wingColor)',correct
'triangle(doveX, doveY - 50, doveX + 80, doveY - 85, doveX + 33, doveY + 25)',correct
'-1200',correct
'textSize(16)',correct
'dove1.doveMousePressed()',correct
'doveY - 35',correct
'rect(width - 35, height - 50, 10, 30);',correct
'dove1.doveChangePlay()',correct
'leftColor = color(0, 119, 7)',correct
'keyCode == LEFT',correct
'// This is the letter R, when it is pressed it starts rainingif (key == R) {    isRain = !isRain;}',correct
'{    // When clicked on the Dove isStart becomes false. And isPause becomes false which will let the bird fly    if (mouseX > doveX - 50 && mouseX < doveX + 110 && mouseY > doveY - 55 && mouseY < doveY + 65 && isStart == true) {        isPause = false;        isStart = false;    }}',correct
'void keyPressed() {    // This calls the class Dove for doveKeyPressed    dove1.doveKeyPressed();    // This is the spacebar pause button    if (key ==   && isStart == false) {        isPause = !isPause;    }    // This is the letter R, when it is pressed it starts raining    if (key == R) {        isRain = !isRain;    }}',correct
'triangle(width - 55, height - 35, width - 55, height - 65, width - 30, height - 50);',correct
'void rightPause() {    rightColor = 160;}',correct
'quad(doveX - 50, doveY - 55, doveX - 30, doveY - 55, doveX - 10, doveY - 35, doveX - 40, doveY + 10);',correct
'height + 40',correct
'{    doveX = initX;    doveY = initY;}',correct
'doveY + 90',correct
'dove1',correct
'// You can move the dove with the keys: UP, DOWN, LEFT and RIGHT.',correct
'rainPause',correct
'width / 1.25f',correct
'doveSpeedX = -1.5f;',correct
'// Creative Technology student',correct
'-30',correct
'rainLength = random(10, 20)',correct
'dove1 = new Dove(width / 2, height / 2)',correct
'tailColor = 200;',correct
'sun1',correct
'fall',correct
'void rainPlay() {    rainColor = color(0, 97, 255);    rainSpeed = random(4, 15);    // If rain>height it comes back to the top randomly    if (rainY > height) {        rainY = random(-1200, -100);        rainX = random(width);    }}',AtLeastOneConstructor
'{    rainDrop[i].fall();    rainDrop[i].display();}',correct
'keyReleased',correct
'void rightPlay() {    rightColor = color(90, 221, 99);}',AtLeastOneConstructor
'textAlign(LEFT);',correct
'color(0, 153, 209)',correct
'color(0, 136, 186)',correct
'sunSpeed = -0.05f',correct
'keyCode == RIGHT',correct
'mouseX >= width - 55 && mouseX <= width - 30 && mouseY >= height - 65 && mouseY <= height - 35',correct
'rainX = random(width)',correct
'mouseX >= 30',correct
'display',correct
'doveY - 55',correct
'sunY = sunY + sunSpeed',correct
'mouseX >= width - 55',correct
'left.leftPlay();',correct
'sun1.display()',correct
'// When you press R it will start raining. Press R again and it stops raining.',correct
'wingColor = 100;',correct
'doveSpeedY = 6',correct
'fill(200)',correct
'{    // The Dove    // Body    fill(bodyColor);    stroke(bodyColor);    triangle(doveX, doveY - 50, doveX + 50, doveY + 65, doveX - 40, doveY + 10);    // Wing    fill(wingColor);    stroke(wingColor);    triangle(doveX, doveY - 50, doveX + 80, doveY - 85, doveX + 33, doveY + 25);    // Tail    fill(tailColor);    stroke(tailColor);    quad(doveX + 33, doveY + 25, doveX + 44, doveY, doveX + 110, doveY + 65, doveX + 50, doveY + 65);    // Neck    fill(neckColor);    stroke(neckColor);    quad(doveX - 50, doveY - 55, doveX - 30, doveY - 55, doveX - 10, doveY - 35, doveX - 40, doveY + 10);    // Head    fill(headColor);    stroke(headColor);    triangle(doveX - 65, doveY - 28, doveX - 50, doveY - 55, doveX - 48, doveY - 40);}',correct
'{    doveY = 85;}',correct
'triangle(width - 55, height - 35, width - 55, height - 65, width - 30, height - 50)',correct
'color(34, 190, 247)',correct
'doveY - 50',correct
'ellipse(rainX, rainY, 3, rainLength)',correct
'mouseX >= width - 55 && mouseX <= width - 30',correct
'// This makes the speed of the dove move by pressing up, down, left and rightvoid doveKeyPressed() {    if (keyCode == UP) {        doveSpeedY = -6;    }    if (keyCode == DOWN) {        doveSpeedY = 6;    }    if (keyCode == LEFT) {        doveSpeedX = -6;    }    if (keyCode == RIGHT) {        doveSpeedX = -1.5f;    }}',correct
'left.display()',correct
'triangle(width / 3, height, width, height / 1.9f, width, width);',correct
'// The Dove',correct
'// These lines change the color and speed of the objectsdove1.doveChangeStart();',correct
'float initX',correct
'doveY + 65',correct
'float initY',correct
'i++',correct
'{    // FX2D draws object much faster for a smooth looking program    // Matching the new object slots to a class and declaring the values of the objects    // rainDrop is agian an array so that every slot has been filled by a raindrop    dove1 = new Dove(width / 2, height / 2);    sun1 = new Sun(width / 4, height + 40);    right = new rightmountain();    left = new leftmountain();    for (int i = 0; i < rainDrop.length; i++) {        rainDrop[i] = new rain();    }    // Giving the booleans a starting value (true or false)    isStart = true;    isRain = false;}',correct
'// Colorsint leftColor;',AtLeastOneConstructor
'{    rainColor = 140;    rainSpeed = 1;    // If rain>height it comes back to the top randomly    if (rainY > height) {        rainY = -30;        rainX = random(width);    }}',correct
'backgColor = (70);',correct
'doveSpeedY = -6;',correct
'{    isPause = false;    isStart = false;}',SimplifyBooleanExpressions
'leftColor = 100',correct
'// Colorsint backgColor;',correct
'fill(255);',correct
'neckColor = color(18, 173, 229)',correct
'dove1.doveKeyReleased()',correct
'int neckColor;',correct
'rainDrop[i].rainPlay()',correct
'// This calls the class Dove for doveKeyPresseddove1.doveKeyPressed();',correct
'keyCode == DOWN',correct
'// Colorsint rainColor;',AtLeastOneConstructor
'// Fills the background with backgColorbackground(backgColor);',correct
'{    leftColor = 100;}',correct
'color(90, 221, 99)',correct
'boolean isStart;',correct
'// This determences the speed of the raindropvoid fall() {    rainY = rainY + rainSpeed;}',AtLeastOneConstructor
'// This draws right from the Class: rightmountainright.display();',correct
'rain',correct
'keyPressed',correct
'wingColor',correct
'triangle(doveX - 65, doveY - 28, doveX - 50, doveY - 55, doveX - 48, doveY - 40)',correct
'left.leftPause()',correct
'leftStart',correct
'{    for (int i = 0; i < rainDrop.length; i++) {        rainDrop[i].fall();        rainDrop[i].display();    }}',correct
'ellipse(rainX, rainY, 3, rainLength);',correct
'-0.05f',correct
'rect(width - 50, height - 50, 10, 30);',correct
'rainY = random(-1200, -100);',correct
'random(4, 15)',correct
'sunX',correct
'triangle(doveX, doveY - 50, doveX + 80, doveY - 85, doveX + 33, doveY + 25);',correct
'sunY',correct
'isPause = false;',correct
'textSize(200);',correct
'// FX2D draws object much faster for a smooth looking programvoid setup() {    // FX2D draws object much faster for a smooth looking program    // Matching the new object slots to a class and declaring the values of the objects    // rainDrop is agian an array so that every slot has been filled by a raindrop    dove1 = new Dove(width / 2, height / 2);    sun1 = new Sun(width / 4, height + 40);    right = new rightmountain();    left = new leftmountain();    for (int i = 0; i < rainDrop.length; i++) {        rainDrop[i] = new rain();    }    // Giving the booleans a starting value (true or false)    isStart = true;    isRain = false;}',correct
'textAlign(LEFT)',correct
'doveSpeedX = -1.5f',correct
'bodyColor',correct
'neckColor = 180;',correct
'doveChangeStart',correct
'doveY - 28',correct
'// These lines change the color and speed of the objectsdove1.doveChangePlay();',correct
'// If isRain == true it starts rainingif (isRain == true) {    for (int i = 0; i < rainDrop.length; i++) {        rainDrop[i].rainPlay();    }}',correct
'{    leftColor = color(0, 119, 7);}',correct
'float doveSpeedY = -0.7f;',correct
'doveX = initX;',correct
'// FX2D draws object much faster for a smooth looking program',correct
'{    doveSpeedX = -6;}',correct
'text("Dove Simulator", width / 2, height / 2 - 200);',correct
'int tailColor;',correct
'doveY = height / 1.5f',correct
'if (isPause == true) {    // These lines change the color and speed of the objects    dove1.doveChangePause();    sun1.sunChangePause();    backgColor = (70);    right.rightPause();    left.leftPause();    // If isRain == true it starts raining    if (isRain == true) {        for (int i = 0; i < rainDrop.length; i++) {            rainDrop[i].rainStart();        }    }    // This draws the play button    fill(0);    triangle(width - 55, height - 35, width - 55, height - 65, width - 30, height - 50);    // This is the pause menu word    textAlign(CENTER);    textSize(200);    fill(255);    text("Pause", width / 2, height / 2);} else if (isPause == false) {    // These lines change the color and speed of the objects    dove1.doveChangePlay();    sun1.sunChangePlay();    backgColor = (255);    right.rightPlay();    left.leftPlay();    // If isRain == true it starts raining    if (isRain == true) {        for (int i = 0; i < rainDrop.length; i++) {            rainDrop[i].rainPlay();        }    }    // This draws the pause button    fill(0);    rectMode(CENTER);    rect(width - 50, height - 50, 10, 30);    rect(width - 35, height - 50, 10, 30);}',SimplifyBooleanExpressions
'void leftPause() {    leftColor = 100;}',AtLeastOneConstructor
'neckColor = 180',correct
'sunY = mouseY',correct
'background(backgColor)',correct
'textSize(150)',correct
'triangle(width / 3, height, width, height / 1.9f, width, width)',correct
'{    for (int i = 0; i < rainDrop.length; i++) {        rainDrop[i].rainPlay();    }}',correct
'width / 2',correct
'rainSpeed = 1',correct
'void display() {    // Right Mountain    fill(rightColor);    noStroke();    triangle(width / 3, height, width, height / 1.9f, width, width);}',AtLeastOneConstructor
'{    if (keyCode == UP) {        doveSpeedY = -0.7f;    }    if (keyCode == DOWN) {        doveSpeedY = -0.7f;    }    if (keyCode == LEFT) {        doveSpeedX = -3;    }    if (keyCode == RIGHT) {        doveSpeedX = -3;    }}',correct
'doveX = doveX + doveSpeedX;',correct
'if (keyCode == DOWN) {    doveSpeedY = 6;}',correct
'width / 4',correct
'// This is the Pause "menu", the dove is greyvoid doveChangePause() {    bodyColor = 160;    wingColor = 100;    tailColor = 200;    neckColor = 180;    headColor = 120;}',correct
'sun1.sunChangeStart();',correct
'width / 3',correct
'// in earsstroke(bellyColor);',correct
'wolkX - 30',correct
'zonX = sunX;',correct
'fill(244, 145, 160)',correct
'void display() {    rectMode(CENTER);    noStroke();    fill(backgroundColor);    rect(achtergrondX, achtergrondY, 800, 800);    fill(grasColor);    rect(achtergrondX, achtergrondY + 200, 800, 400);}',correct
'class Wolk {    float wolkX;    float wolkY;    Wolk(float cloudX, float cloudY) {        wolkX = cloudX;        wolkY = cloudY;    }    void display() {        ellipseMode(CENTER);        rectMode(CENTER);        // wolk        stroke(255);        fill(255);        ellipse(wolkX, wolkY, 80, 80);        ellipse(wolkX - 55, wolkY + 8, 60, 60);        ellipse(wolkX - 90, wolkY + 24, 50, 50);        ellipse(wolkX - 65, wolkY + 45, 30, 30);        ellipse(wolkX - 30, wolkY + 40, 45, 45);        ellipse(wolkX + 15, wolkY + 30, 60, 60);    }}',correct
'{    background01.display();    background01.update();    huis01.display();    herbert01.display();    for (int i = 0; i < 20; i++) {        flower[i].display();    }    herbert01.update();}',correct
'sterY = starY;',correct
'herbert01.display()',correct
'new Zon(800, 0)',correct
'// headstroke(bodyColor);',correct
'float starY',correct
'Moon(float moonX, float moonY) {    maanX = moonX;    maanY = moonY;}',correct
'float starX',correct
'fill(47, 145, 160);',correct
'stroke(0)',correct
'theta = 0',correct
'float zonY;',correct
'ellipse(wolkX - 30, wolkY + 40, 45, 45);',correct
'stroke(pupilColor)',correct
'{    huisX = homeX;    huisY = homeY;}',correct
'ellipse(herbertX + 25, herbertY + 45, 30, 30)',correct
'vertex(0, 12);',correct
'Wolk(float cloudX, float cloudY) {    wolkX = cloudX;    wolkY = cloudY;}',correct
'sterX = starX',correct
'float sterY;',correct
'float flowerY',correct
'sin(theta)',correct
'float flowerX',correct
'{    maanX = moonX;    maanY = moonY;}',correct
'ellipse(huisX + 8, huisY + 6, 9, 9)',correct
'triangle(huisX + 18, huisY - 15, huisX - 18, huisY - 15, huisX, huisY - 32);',correct
'return night;',correct
'{    star[a].display();}',correct
'grasColor = color(65, 119, 64);',correct
'for (int a = 0; a < 10; a++) {    star[a].display();}',correct
'stroke(bodyColor)',correct
'stroke(180, 145, 244)',correct
'float zonX;',correct
'ellipse(herbertX - 33, herbertY - 108, 25, 25);',correct
'bloemX',correct
'// pupilsstroke(pupilColor);',correct
'bloemY',correct
'zonY = sunY',correct
'huisY = homeY',correct
'ellipse(wolkX - 90, wolkY + 24, 50, 50);',correct
'bloemX + 8',correct
'fill(8, 62, 108)',correct
'wolkX - 55',correct
'herbert01.pressed()',correct
'fill(180, 145, 244);',correct
'void display() {    ellipseMode(CENTER);    stroke(187, 194, 199);    fill(187, 194, 199);    ellipse(maanX, maanY, 250, 250);    stroke(8, 62, 108);    fill(8, 62, 108);    ellipse(maanX + 50, maanY - 50, 175, 175);}',correct
'vertex(-15, 20);',correct
'rectMode(CENTER)',correct
'// float bloemX;// float bloemY;int bodyColor;',correct
'float homeX',correct
'float homeY',correct
'float theta = 0;',correct
'Herbert herbert01;',correct
'stroke(8, 62, 108)',correct
'grasColor = color(65, 119, 64)',correct
'fill(backgroundColor)',correct
'fill(pupilColor)',correct
'{    night = true;}',correct
'huis01.display()',correct
'maan01.display();',correct
'huisX + 8',correct
'wolk03 = new Wolk(450, 100)',correct
'fill(245, 219, 136)',correct
'// lightbrownbellyColor = color(240, 229, 184);',correct
'eyeColor = color(255)',correct
'background01',correct
'ellipse(herbertX - 25, herbertY + 45, 30, 30);',correct
'void update() {    if (night) {        backgroundColor = color(8, 62, 108);        maan01.display();        grasColor = color(65, 119, 64);        for (int a = 0; a < 10; a++) {            star[a].display();        }    } else {        backgroundColor = color(145, 209, 244);        grasColor = color(130, 240, 136);        wolk01.display();        wolk02.display();        wolk03.display();        zon01.display();    }}',correct
'ellipse(bloemX - 12, bloemY - 5, 15, 15)',correct
'rectMode(CENTER);',correct
'wolkX - 65',correct
'ellipse(herbertX + 31, herbertY - 106, 15, 15)',correct
'stroke(230, 145, 244)',correct
'vertex(0, -25);',correct
'new Bloem[20]',correct
'void display() {    ellipseMode(CENTER);    stroke(245, 219, 136);    fill(245, 219, 136);    ellipse(zonX, zonY, 250, 250);}',correct
'// whiteeyeColor = color(255);',correct
'bellyColor = color(240, 229, 184)',correct
'huisX - 10',correct
'flower[i]',correct
'herbert01.update()',correct
'ellipse(bloemX, bloemY, 15, 15);',correct
'class Moon {    float maanX;    float maanY;    Moon(float moonX, float moonY) {        maanX = moonX;        maanY = moonY;    }    void display() {        ellipseMode(CENTER);        stroke(187, 194, 199);        fill(187, 194, 199);        ellipse(maanX, maanY, 250, 250);        stroke(8, 62, 108);        fill(8, 62, 108);        ellipse(maanX + 50, maanY - 50, 175, 175);    }}',correct
'float maanY;',correct
'wolk02.display();',correct
'huisX - 18',correct
'rect(huisX - 7, huisY - 4, 9, 9);',correct
'fill(bodyColor)',correct
'void mousePressed() {    herbert01.pressed();    background01.isNight();}',correct
'background01.update()',correct
'// void eat(){',correct
'{    herbertX = mouseX;    line = mouseY;}',correct
'ellipse(herbertX - 33, herbertY - 108, 25, 25)',correct
'color(130, 240, 136)',correct
'fill(108, 185, 251)',correct
'stroke(108, 185, 251)',correct
'rect(achtergrondX, achtergrondY + 200, 800, 400);',correct
'bellyColor',correct
'// flower[i].display=false;',correct
'fill(bodyColor);',correct
'new Star((PApplet.parseInt(random(150, 750))), (PApplet.parseInt(random(25, 300))))',correct
'rect(achtergrondX, achtergrondY, 800, 800);',correct
'// blackpupilColor = color(0);',correct
'{    herbertX = creatureX;    herbertY = creatureY;}',correct
'ellipse(herbertX - 10, herbertY - 85, 5, 5)',correct
'translate(sterX, sterY)',correct
'stroke(180, 145, 244);',correct
'ellipse(herbertX - 31, herbertY - 106, 15, 15);',correct
'wolkX - 90',correct
'fill(8, 62, 108);',correct
'counter++',correct
'star[a]',correct
'Processing',correct
'herbert01.pressed();',correct
'{    ellipseMode(CENTER);    stroke(245, 219, 136);    fill(245, 219, 136);    ellipse(zonX, zonY, 250, 250);}',correct
'star[a].display();',correct
'ellipse(bloemX + 8, bloemY + 10, 15, 15);',correct
'pushMatrix()',correct
'vertex(24, -8);',correct
'boolean isNight() {    counter++;    if (counter % 2 == 0) {        night = false;    } else {        night = true;    }    return night;}',correct
'float sterX;',correct
'wolkX = cloudX;',correct
'fill(193, 102, 53)',correct
'{    backgroundColor = color(8, 62, 108);    maan01.display();    grasColor = color(65, 119, 64);    for (int a = 0; a < 10; a++) {        star[a].display();    }}',correct
'fill(145, 209, 244);',correct
'false',correct
'counter',correct
'ellipse(herbertX - 10, herbertY - 85, 5, 5);',correct
'endShape(CLOSE);',correct
'herbertX - 50',correct
'line = mouseY',correct
'i < 20',correct
'ellipse(wolkX, wolkY, 80, 80);',correct
'fill(244, 145, 160);',correct
'float maanX;',correct
'wolk03.display()',correct
'rect(huisX + 8, huisY + 11, 9, 9);',correct
'sterX = starX;',correct
'Star[] star = new Star[10];',correct
'stroke(bodyColor);',correct
'zon01.display()',correct
'maanY - 50',correct
'i = 0',correct
'maan01 = new Moon(200, 150)',correct
'class Bloem {    float bloemX;    float bloemY;    Bloem(float flowerX, float flowerY) {        bloemX = flowerX;        bloemY = flowerY;    }    void display() {        ellipseMode(CENTER);        rectMode(CENTER);        // bloem        stroke(47, 145, 35);        fill(47, 145, 35);        rect(bloemX, bloemY + 25, 2, 32);        stroke(108, 185, 251);        fill(108, 185, 251);        ellipse(bloemX - 8, bloemY + 10, 15, 15);        stroke(47, 145, 160);        fill(47, 145, 160);        ellipse(bloemX + 8, bloemY + 10, 15, 15);        stroke(244, 145, 160);        fill(244, 145, 160);        ellipse(bloemX, bloemY - 14, 15, 15);        stroke(180, 145, 244);        fill(180, 145, 244);        ellipse(bloemX + 12, bloemY - 5, 15, 15);        stroke(230, 145, 244);        fill(230, 145, 244);        ellipse(bloemX - 12, bloemY - 5, 15, 15);        stroke(245, 219, 136);        fill(245, 219, 136);        ellipse(bloemX, bloemY, 15, 15);    }}',correct
'background01 = new Background(400, 400);',correct
'maan01',correct
'void setup() {    for (int i = 0; i < 20; i++) {        flower[i] = new Bloem((PApplet.parseInt(random(30, 770))), (PApplet.parseInt(random(500, 700))));    }    herbert01 = new Herbert(400, 400);    huis01 = new Huis(200, 400);    background01 = new Background(400, 400);}',correct
'maanX + 50',correct
'{    counter++;    if (counter % 2 == 0) {        night = false;    } else {        night = true;    }    return night;}',correct
'ellipse(zonX, zonY, 250, 250);',correct
'int eyeColor;',correct
'maanY = moonY;',correct
'wolkX + 15',correct
'background01.update();',correct
'void display() {    ellipseMode(CENTER);    rectMode(CENTER);    // wolk    stroke(255);    fill(255);    ellipse(wolkX, wolkY, 80, 80);    ellipse(wolkX - 55, wolkY + 8, 60, 60);    ellipse(wolkX - 90, wolkY + 24, 50, 50);    ellipse(wolkX - 65, wolkY + 45, 30, 30);    ellipse(wolkX - 30, wolkY + 40, 45, 45);    ellipse(wolkX + 15, wolkY + 30, 60, 60);}',correct
'wolk02.display()',correct
'class Star {    float sterX;    float sterY;    Star(float starX, float starY) {        sterX = starX;        sterY = starY;    }    void display() {        pushMatrix();        translate(sterX, sterY);        fill(255);        stroke(255);        beginShape();        vertex(0, -25);        vertex(8, -10);        vertex(24, -8);        vertex(12, 4);        vertex(14, 20);        vertex(0, 12);        vertex(-15, 20);        vertex(-12, 4);        vertex(-24, -8);        vertex(-7, -10);        endShape(CLOSE);        popMatrix();    }}',correct
'// bodyellipse(herbertX, herbertY, 100, 100);',correct
'wolk01.display()',correct
'Wolk wolk01;',correct
'wolk02 = new Wolk(600, 200);',correct
'herbertX - 31',correct
'void draw() {    background01.display();    background01.update();    huis01.display();    herbert01.display();    for (int i = 0; i < 20; i++) {        flower[i].display();    }    herbert01.update();}',correct
'star[a] = new Star((PApplet.parseInt(random(150, 750))), (PApplet.parseInt(random(25, 300))));',correct
'herbertX - 33',correct
'// huis-doorstroke(0);',correct
'zon01.display();',correct
'noStroke();',correct
'beginShape()',correct
'float sunY',correct
'float sunX',correct
'Bloem[]',correct
'stroke(244, 145, 160)',correct
'// huis-roofstroke(0);',correct
'maan01.display()',correct
'fill(47, 145, 160)',correct
'float backgroundX',correct
'float backgroundY',correct
'{    flower[i] = new Bloem((PApplet.parseInt(random(30, 770))), (PApplet.parseInt(random(500, 700))));}',correct
'Huis huis01;',correct
'{    for (int i = 0; i < 20; i++) {        flower[i] = new Bloem((PApplet.parseInt(random(30, 770))), (PApplet.parseInt(random(500, 700))));    }    herbert01 = new Herbert(400, 400);    huis01 = new Huis(200, 400);    background01 = new Background(400, 400);}',correct
'wolk03 = new Wolk(450, 100);',correct
'herbertX - 25',correct
'void display() {    pushMatrix();    translate(sterX, sterY);    fill(255);    stroke(255);    beginShape();    vertex(0, -25);    vertex(8, -10);    vertex(24, -8);    vertex(12, 4);    vertex(14, 20);    vertex(0, 12);    vertex(-15, 20);    vertex(-12, 4);    vertex(-24, -8);    vertex(-7, -10);    endShape(CLOSE);    popMatrix();}',correct
'triangle(huisX + 18, huisY - 15, huisX - 18, huisY - 15, huisX, huisY - 32)',correct
'background01.isNight();',correct
'huisX + 18',correct
'stroke(245, 219, 136);',correct
'wolk02 = new Wolk(600, 200)',correct
'void update() {    // Sine movement    herbertY = map(sin(theta), -1, 1, (line) - 20, (line) + 20);    theta += 0.05f;}',correct
'stroke(244, 145, 160);',correct
'maan01 = new Moon(200, 150);',correct
'Star[]',correct
'bloemY - 5',correct
'fill(grasColor)',correct
'ellipse(maanX, maanY, 250, 250)',correct
'stroke(47, 145, 35)',correct
'ellipse(wolkX - 55, wolkY + 8, 60, 60);',correct
'stroke(187, 194, 199)',correct
'rect(bloemX, bloemY + 25, 2, 32)',correct
'zon01',correct
'huisY - 4',correct
'herbertX - 10',correct
'zonY = sunY;',correct
'fill(eyeColor);',correct
'ellipse(maanX + 50, maanY - 50, 175, 175)',correct
'fill(47, 145, 35);',correct
'a++',correct
'star[a].display()',correct
'fill(255, 0, 0)',correct
'herbertY - 85',correct
'// wolkstroke(255);',correct
'wolkY = cloudY',correct
'herbertX + 50',correct
'huisY - 15',correct
'ellipseMode(CENTER)',correct
'backgroundColor = color(8, 62, 108);',correct
'flower[i].display();',correct
'maanY',correct
'ellipse(bloemX - 8, bloemY + 10, 15, 15)',correct
'fill(145, 209, 244)',correct
'maanX',correct
'ellipse(wolkX - 55, wolkY + 8, 60, 60)',correct
'herbertY = creatureY',correct
'void',correct
'fill(230, 145, 244)',correct
'-1',correct
'{    // Sine movement    herbertY = map(sin(theta), -1, 1, (line) - 20, (line) + 20);    theta += 0.05f;}',correct
'fill(250, 195, 24)',correct
'a = 0',correct
'-7',correct
'-8',correct
'ellipse(bloemX, bloemY - 14, 15, 15);',correct
'ellipse(maanX + 50, maanY - 50, 175, 175);',correct
'huisY - 26',correct
'// bloemX = flowerX;',correct
'huisX',correct
'background01 = new Background(400, 400)',correct
'huisY',correct
'Herbert',correct
'true',correct
'if (counter % 2 == 0) {    night = false;} else {    night = true;}',correct
'fill(eyeColor)',correct
'huis01.display();',correct
'ellipse(wolkX - 90, wolkY + 24, 50, 50)',correct
'for (int i = 0; i < 20; i++) {    flower[i] = new Bloem((PApplet.parseInt(random(30, 770))), (PApplet.parseInt(random(500, 700))));}',correct
'ellipse(herbertX + 50, herbertY - 25, 25, 25)',correct
'counter++;',correct
'sterX',correct
'line = mouseY;',correct
'sterY',correct
'ellipse(wolkX - 65, wolkY + 45, 30, 30)',correct
'popMatrix()',correct
'ellipse(wolkX, wolkY, 80, 80)',correct
'herbertX + 33',correct
'herbertX + 31',correct
'// bloemY = flowerY;',correct
'huisY - 32',correct
'bloemX - 8',correct
'translate(sterX, sterY);',correct
'rect(huisX, huisY, 36, 30)',correct
'{    wolkX = cloudX;    wolkY = cloudY;}',correct
'maanX = moonX',correct
'ellipse(huisX + 8, huisY + 6, 9, 9);',correct
'wolk01.display();',correct
'{    ellipseMode(CENTER);    rectMode(CENTER);    // brown    bodyColor = color(213, 139, 95);    // white    eyeColor = color(255);    // black    pupilColor = color(0);    // lightbrown    bellyColor = color(240, 229, 184);    stroke(bodyColor);    fill(bodyColor);    // body    ellipse(herbertX, herbertY, 100, 100);    // feet    ellipse(herbertX + 25, herbertY + 45, 30, 30);    ellipse(herbertX - 25, herbertY + 45, 30, 30);    // belly    stroke(bellyColor);    fill(bellyColor);    ellipse(herbertX, herbertY, 50, 70);    // ears    stroke(bodyColor);    fill(bodyColor);    ellipse(herbertX + 33, herbertY - 108, 25, 25);    ellipse(herbertX - 33, herbertY - 108, 25, 25);    // in ears    stroke(bellyColor);    fill(bellyColor);    ellipse(herbertX + 31, herbertY - 106, 15, 15);    ellipse(herbertX - 31, herbertY - 106, 15, 15);    // head    stroke(bodyColor);    fill(bodyColor);    ellipse(herbertX, herbertY - 75, 75, 75);    // hands    ellipse(herbertX + 50, herbertY - 25, 25, 25);    ellipse(herbertX - 50, herbertY - 25, 25, 25);    // eyes base    stroke(eyeColor);    fill(eyeColor);    ellipse(herbertX + 10, herbertY - 85, 10, 10);    ellipse(herbertX - 10, herbertY - 85, 10, 10);    // pupils    stroke(pupilColor);    fill(pupilColor);    ellipse(herbertX + 10, herbertY - 85, 5, 5);    ellipse(herbertX - 10, herbertY - 85, 5, 5);    // nose    ellipse(herbertX, herbertY - 73, 5, 5);}',LongMethodRule
'beginShape();',correct
'Bloem(float flowerX, float flowerY) {    bloemX = flowerX;    bloemY = flowerY;}',correct
'new Wolk(450, 100)',correct
'rect(achtergrondX, achtergrondY, 800, 800)',correct
'ellipse(herbertX - 25, herbertY + 45, 30, 30)',correct
'vertex(14, 20)',correct
'ellipse(herbertX - 50, herbertY - 25, 25, 25)',correct
'ellipse(bloemX + 12, bloemY - 5, 15, 15);',correct
'{    herbert01.pressed();    background01.isNight();}',correct
'ellipse(herbertX - 50, herbertY - 25, 25, 25);',correct
'ellipse(zonX, zonY, 250, 250)',correct
'{    star[a] = new Star((PApplet.parseInt(random(150, 750))), (PApplet.parseInt(random(25, 300))));}',correct
'// huis-basestroke(0);',correct
'fill(bellyColor)',correct
'vertex(0, -25)',correct
'herbertX = mouseX;',correct
'vertex(14, 20);',correct
'{    achtergrondX = backgroundX;    achtergrondY = backgroundY;    zon01 = new Zon(800, 0);    wolk01 = new Wolk(200, 200);    wolk02 = new Wolk(600, 200);    wolk03 = new Wolk(450, 100);    for (int a = 0; a < 10; a++) {        star[a] = new Star((PApplet.parseInt(random(150, 750))), (PApplet.parseInt(random(25, 300))));    }    maan01 = new Moon(200, 150);}',correct
'float herbertX;',correct
'huisX - 7',correct
'huis01 = new Huis(200, 400)',correct
'Moon maan01;',correct
'fill(187, 194, 199)',correct
'vertex(-7, -10)',correct
'{    ellipseMode(CENTER);    rectMode(CENTER);    // huis-base    stroke(0);    fill(250, 195, 24);    rect(huisX, huisY, 36, 30);    // huis-chimney    stroke(0);    fill(255);    rect(huisX - 10, huisY - 26, 6, 8);    // huis-door    stroke(0);    fill(193, 102, 53);    ellipse(huisX + 8, huisY + 6, 9, 9);    rect(huisX + 8, huisY + 11, 9, 9);    // huis-window    stroke(0);    fill(145, 209, 244);    rect(huisX - 7, huisY - 4, 9, 9);    // huis-roof    stroke(0);    fill(255, 0, 0);    triangle(huisX + 18, huisY - 15, huisX - 18, huisY - 15, huisX, huisY - 32);}',correct
'huisY + 6',correct
'bloemY = flowerY;',correct
'flower[i].display()',correct
'ellipse(herbertX, herbertY, 50, 70);',correct
'rect(huisX, huisY, 36, 30);',correct
'zon01 = new Zon(800, 0);',correct
'grasColor = color(130, 240, 136)',correct
'maanX = moonX;',correct
'vertex(-7, -10);',correct
'herbertX + 10',correct
'achtergrondY = backgroundY;',correct
'float herbertY;',correct
'ellipse(herbertX + 33, herbertY - 108, 25, 25)',correct
'// bloemstroke(47, 145, 35);',correct
'herbertX = mouseX',correct
'// if (herbertX-50 == bloemX){',correct
'wolk01 = new Wolk(200, 200)',correct
'ellipse(herbertX - 31, herbertY - 106, 15, 15)',correct
'new Moon(200, 150)',correct
'ellipse(bloemX + 12, bloemY - 5, 15, 15)',correct
'bloemX + 12',correct
'ellipse(herbertX + 10, herbertY - 85, 10, 10)',correct
'pupilColor',correct
'wolkX',correct
'ellipse(herbertX + 31, herbertY - 106, 15, 15);',correct
'wolkY',correct
'int backgroundColor;',correct
'Background',correct
'herbertX + 25',correct
'night',correct
'color(240, 229, 184)',correct
'herbert01 = new Herbert(400, 400);',correct
'{    flower[i].display();}',correct
'class Zon {    float zonX;    float zonY;    Zon(float sunX, float sunY) {        zonX = sunX;        zonY = sunY;    }    void display() {        ellipseMode(CENTER);        stroke(245, 219, 136);        fill(245, 219, 136);        ellipse(zonX, zonY, 250, 250);    }}',correct
'pushMatrix();',correct
'// eyes basestroke(eyeColor);',correct
'grasColor',correct
'fill(230, 145, 244);',correct
'wolkY = cloudY;',correct
'backgroundColor = color(8, 62, 108)',correct
'backgroundColor = color(145, 209, 244);',correct
'wolk03.display();',correct
'ellipse(herbertX + 33, herbertY - 108, 25, 25);',correct
'star[a] = new Star((PApplet.parseInt(random(150, 750))), (PApplet.parseInt(random(25, 300))))',correct
'float achtergrondX;',correct
'line = height / 2',correct
'ellipse(bloemX, bloemY, 15, 15)',correct
'fill(255, 0, 0);',correct
'// }',correct
'for (int a = 0; a < 10; a++) {    star[a] = new Star((PApplet.parseInt(random(150, 750))), (PApplet.parseInt(random(25, 300))));}',correct
'int bellyColor;',correct
'ellipse(herbertX - 10, herbertY - 85, 10, 10);',correct
'new Background(400, 400)',correct
'boolean night;',correct
'star = new Star[10]',correct
'rect(huisX - 10, huisY - 26, 6, 8);',correct
'wolkY + 30',correct
'fill(pupilColor);',correct
'Star',correct
'for (int i = 0; i < 20; i++) {    flower[i].display();}',correct
'ellipse(herbertX, herbertY - 75, 75, 75)',correct
'new Star[10]',correct
'wolkY + 8',correct
'Wolk',correct
'rect(achtergrondX, achtergrondY + 200, 800, 400)',correct
'backgroundColor',correct
'huisY = homeY;',correct
'class Huis {    float huisX;    float huisY;    Huis(float homeX, float homeY) {        huisX = homeX;        huisY = homeY;    }    void display() {        ellipseMode(CENTER);        rectMode(CENTER);        // huis-base        stroke(0);        fill(250, 195, 24);        rect(huisX, huisY, 36, 30);        // huis-chimney        stroke(0);        fill(255);        rect(huisX - 10, huisY - 26, 6, 8);        // huis-door        stroke(0);        fill(193, 102, 53);        ellipse(huisX + 8, huisY + 6, 9, 9);        rect(huisX + 8, huisY + 11, 9, 9);        // huis-window        stroke(0);        fill(145, 209, 244);        rect(huisX - 7, huisY - 4, 9, 9);        // huis-roof        stroke(0);        fill(255, 0, 0);        triangle(huisX + 18, huisY - 15, huisX - 18, huisY - 15, huisX, huisY - 32);    }}',correct
'herbertY - 73',correct
'Star(float starX, float starY) {    sterX = starX;    sterY = starY;}',correct
'herbertY - 75',correct
'ellipse(wolkX + 15, wolkY + 30, 60, 60);',correct
'wolkY + 24',correct
'fill(187, 194, 199);',correct
'popMatrix();',correct
'vertex(24, -8)',correct
'Bloem[] flower = new Bloem[20];',correct
'int a = 0',correct
'herbertY - 108',correct
'herbertY - 106',correct
'noStroke()',correct
'theta += 0.05f',correct
'float wolkX;',correct
'maanY = moonY',correct
'// Bloem (float flowerX, float flowerY)// {// bloemX = flowerX;// bloemY = flowerY;// }// void eat(){// if (herbertX-50 == bloemX){// flower[i].display=false;// }// }void display() {    ellipseMode(CENTER);    rectMode(CENTER);    // brown    bodyColor = color(213, 139, 95);    // white    eyeColor = color(255);    // black    pupilColor = color(0);    // lightbrown    bellyColor = color(240, 229, 184);    stroke(bodyColor);    fill(bodyColor);    // body    ellipse(herbertX, herbertY, 100, 100);    // feet    ellipse(herbertX + 25, herbertY + 45, 30, 30);    ellipse(herbertX - 25, herbertY + 45, 30, 30);    // belly    stroke(bellyColor);    fill(bellyColor);    ellipse(herbertX, herbertY, 50, 70);    // ears    stroke(bodyColor);    fill(bodyColor);    ellipse(herbertX + 33, herbertY - 108, 25, 25);    ellipse(herbertX - 33, herbertY - 108, 25, 25);    // in ears    stroke(bellyColor);    fill(bellyColor);    ellipse(herbertX + 31, herbertY - 106, 15, 15);    ellipse(herbertX - 31, herbertY - 106, 15, 15);    // head    stroke(bodyColor);    fill(bodyColor);    ellipse(herbertX, herbertY - 75, 75, 75);    // hands    ellipse(herbertX + 50, herbertY - 25, 25, 25);    ellipse(herbertX - 50, herbertY - 25, 25, 25);    // eyes base    stroke(eyeColor);    fill(eyeColor);    ellipse(herbertX + 10, herbertY - 85, 10, 10);    ellipse(herbertX - 10, herbertY - 85, 10, 10);    // pupils    stroke(pupilColor);    fill(pupilColor);    ellipse(herbertX + 10, herbertY - 85, 5, 5);    ellipse(herbertX - 10, herbertY - 85, 5, 5);    // nose    ellipse(herbertX, herbertY - 73, 5, 5);}',correct
'night = false;',correct
'rect(huisX - 7, huisY - 4, 9, 9)',correct
'ellipse(herbertX + 10, herbertY - 85, 5, 5);',correct
'grasColor = color(130, 240, 136);',correct
'new Wolk(600, 200)',correct
'color(213, 139, 95)',correct
'vertex(-24, -8);',correct
'herbertX = creatureX',correct
'// bellystroke(bellyColor);',correct
'backgroundColor = color(145, 209, 244)',correct
'// earsstroke(bodyColor);',correct
'vertex(-12, 4)',correct
'bloemY - 14',correct
'bloemX = flowerX;',correct
'ellipse(wolkX - 65, wolkY + 45, 30, 30);',correct
'herbertY = map(sin(theta), -1, 1, (line) - 20, (line) + 20)',correct
'float bloemX;',correct
'flower[i] = new Bloem((PApplet.parseInt(random(30, 770))), (PApplet.parseInt(random(500, 700))));',correct
'{    pushMatrix();    translate(sterX, sterY);    fill(255);    stroke(255);    beginShape();    vertex(0, -25);    vertex(8, -10);    vertex(24, -8);    vertex(12, 4);    vertex(14, 20);    vertex(0, 12);    vertex(-15, 20);    vertex(-12, 4);    vertex(-24, -8);    vertex(-7, -10);    endShape(CLOSE);    popMatrix();}',correct
'background01.display();',correct
'rect(huisX - 10, huisY - 26, 6, 8)',correct
'height / 2',correct
'ellipse(herbertX, herbertY - 75, 75, 75);',correct
'fill(108, 185, 251);',correct
'herbertY - 25',correct
'void display() {    ellipseMode(CENTER);    rectMode(CENTER);    // bloem    stroke(47, 145, 35);    fill(47, 145, 35);    rect(bloemX, bloemY + 25, 2, 32);    stroke(108, 185, 251);    fill(108, 185, 251);    ellipse(bloemX - 8, bloemY + 10, 15, 15);    stroke(47, 145, 160);    fill(47, 145, 160);    ellipse(bloemX + 8, bloemY + 10, 15, 15);    stroke(244, 145, 160);    fill(244, 145, 160);    ellipse(bloemX, bloemY - 14, 15, 15);    stroke(180, 145, 244);    fill(180, 145, 244);    ellipse(bloemX + 12, bloemY - 5, 15, 15);    stroke(230, 145, 244);    fill(230, 145, 244);    ellipse(bloemX - 12, bloemY - 5, 15, 15);    stroke(245, 219, 136);    fill(245, 219, 136);    ellipse(bloemX, bloemY, 15, 15);}',correct
'theta += 0.05f;',correct
'int line = height / 2;',correct
'night = true',correct
'fill(grasColor);',correct
'huisY + 11',correct
'update',correct
'// Bloem (float flowerX, float flowerY)',correct
'fill(255)',correct
'ellipse(wolkX - 30, wolkY + 40, 45, 45)',correct
'Wolk wolk02;',correct
'float bloemY;',correct
'fill(250, 195, 24);',correct
'stroke(245, 219, 136)',correct
'{    if (night) {        backgroundColor = color(8, 62, 108);        maan01.display();        grasColor = color(65, 119, 64);        for (int a = 0; a < 10; a++) {            star[a].display();        }    } else {        backgroundColor = color(145, 209, 244);        grasColor = color(130, 240, 136);        wolk01.display();        wolk02.display();        wolk03.display();        zon01.display();    }}',correct
'ellipse(bloemX, bloemY - 14, 15, 15)',correct
'fill(bellyColor);',correct
'bloemX - 12',correct
'class Herbert {    float herbertX;    float herbertY;    float theta = 0;    // float bloemX;    // float bloemY;    int bodyColor;    int eyeColor;    int pupilColor;    int bellyColor;    int line = height / 2;    Herbert(float creatureX, float creatureY) {        herbertX = creatureX;        herbertY = creatureY;    }    // Bloem (float flowerX, float flowerY)    // {    // bloemX = flowerX;    // bloemY = flowerY;    // }    // void eat(){    // if (herbertX-50 == bloemX){    // flower[i].display=false;    // }    // }    void display() {        ellipseMode(CENTER);        rectMode(CENTER);        // brown        bodyColor = color(213, 139, 95);        // white        eyeColor = color(255);        // black        pupilColor = color(0);        // lightbrown        bellyColor = color(240, 229, 184);        stroke(bodyColor);        fill(bodyColor);        // body        ellipse(herbertX, herbertY, 100, 100);        // feet        ellipse(herbertX + 25, herbertY + 45, 30, 30);        ellipse(herbertX - 25, herbertY + 45, 30, 30);        // belly        stroke(bellyColor);        fill(bellyColor);        ellipse(herbertX, herbertY, 50, 70);        // ears        stroke(bodyColor);        fill(bodyColor);        ellipse(herbertX + 33, herbertY - 108, 25, 25);        ellipse(herbertX - 33, herbertY - 108, 25, 25);        // in ears        stroke(bellyColor);        fill(bellyColor);        ellipse(herbertX + 31, herbertY - 106, 15, 15);        ellipse(herbertX - 31, herbertY - 106, 15, 15);        // head        stroke(bodyColor);        fill(bodyColor);        ellipse(herbertX, herbertY - 75, 75, 75);        // hands        ellipse(herbertX + 50, herbertY - 25, 25, 25);        ellipse(herbertX - 50, herbertY - 25, 25, 25);        // eyes base        stroke(eyeColor);        fill(eyeColor);        ellipse(herbertX + 10, herbertY - 85, 10, 10);        ellipse(herbertX - 10, herbertY - 85, 10, 10);        // pupils        stroke(pupilColor);        fill(pupilColor);        ellipse(herbertX + 10, herbertY - 85, 5, 5);        ellipse(herbertX - 10, herbertY - 85, 5, 5);        // nose        ellipse(herbertX, herbertY - 73, 5, 5);    }    void update() {        // Sine movement        herbertY = map(sin(theta), -1, 1, (line) - 20, (line) + 20);        theta += 0.05f;    }    void pressed() {        herbertX = mouseX;        line = mouseY;    }}',correct
'ellipse(herbertX, herbertY, 100, 100)',correct
'float wolkY;',correct
'ellipse(bloemX - 8, bloemY + 10, 15, 15);',correct
'bodyColor = color(213, 139, 95)',correct
'Wolk wolk03;',correct
'ellipse(maanX, maanY, 250, 250);',correct
'ellipse(herbertX, herbertY, 50, 70)',correct
'ellipseMode(CENTER);',correct
'herbert01',correct
'int i = 0',correct
'sterY = starY',correct
'vertex(8, -10)',correct
'endShape(CLOSE)',correct
'stroke(255)',correct
'0.05f',correct
'ellipse(herbertX + 10, herbertY - 85, 5, 5)',correct
'{    backgroundColor = color(145, 209, 244);    grasColor = color(130, 240, 136);    wolk01.display();    wolk02.display();    wolk03.display();    zon01.display();}',correct
'stroke(47, 145, 160);',correct
'bloemY + 25',correct
'color(255)',correct
'Moon',correct
'int grasColor;',correct
'-10',correct
'-12',correct
'-15',correct
'night = false',correct
'int counter;',correct
'int pupilColor;',correct
'vertex(12, 4)',correct
'if (night) {    backgroundColor = color(8, 62, 108);    maan01.display();    grasColor = color(65, 119, 64);    for (int a = 0; a < 10; a++) {        star[a].display();    }} else {    backgroundColor = color(145, 209, 244);    grasColor = color(130, 240, 136);    wolk01.display();    wolk02.display();    wolk03.display();    zon01.display();}',correct
'stroke(187, 194, 199);',correct
'stroke(230, 145, 244);',correct
'huis01',correct
'Herbert(float creatureX, float creatureY) {    herbertX = creatureX;    herbertY = creatureY;}',correct
'map(sin(theta), -1, 1, (line) - 20, (line) + 20)',correct
'(line) + 20',correct
'vertex(-15, 20)',correct
'pupilColor = color(0)',correct
'achtergrondY + 200',correct
'-24',correct
'-25',correct
'fill(193, 102, 53);',correct
'color(65, 119, 64)',correct
'Huis',correct
'stroke(bellyColor)',correct
'ellipse(bloemX + 8, bloemY + 10, 15, 15)',correct
'zon01 = new Zon(800, 0)',correct
'// Sine movementherbertY = map(sin(theta), -1, 1, (line) - 20, (line) + 20);',correct
'Background(float backgroundX, float backgroundY) {    achtergrondX = backgroundX;    achtergrondY = backgroundY;    zon01 = new Zon(800, 0);    wolk01 = new Wolk(200, 200);    wolk02 = new Wolk(600, 200);    wolk03 = new Wolk(450, 100);    for (int a = 0; a < 10; a++) {        star[a] = new Star((PApplet.parseInt(random(150, 750))), (PApplet.parseInt(random(25, 300))));    }    maan01 = new Moon(200, 150);}',correct
'new Herbert(400, 400)',correct
'// noseellipse(herbertX, herbertY - 73, 5, 5);',correct
'new Huis(200, 400)',correct
'ellipse(herbertX, herbertY - 73, 5, 5)',correct
'new Bloem((PApplet.parseInt(random(30, 770))), (PApplet.parseInt(random(500, 700))))',correct
'herbertY + 45',correct
'bloemX = flowerX',correct
'{    zonX = sunX;    zonY = sunY;}',correct
'// handsellipse(herbertX + 50, herbertY - 25, 25, 25);',correct
'zonX = sunX',correct
'herbertX',correct
'herbertY',correct
'eyeColor',correct
'color(0)',correct
'bloemY + 10',correct
'vertex(-12, 4);',correct
'ellipse(wolkX + 15, wolkY + 30, 60, 60)',correct
'display',correct
'class Background {    float achtergrondX;    float achtergrondY;    int backgroundColor;    int grasColor;    boolean night;    int counter;    Star[] star = new Star[10];    Moon maan01;    Zon zon01;    Wolk wolk01;    Wolk wolk02;    Wolk wolk03;    Background(float backgroundX, float backgroundY) {        achtergrondX = backgroundX;        achtergrondY = backgroundY;        zon01 = new Zon(800, 0);        wolk01 = new Wolk(200, 200);        wolk02 = new Wolk(600, 200);        wolk03 = new Wolk(450, 100);        for (int a = 0; a < 10; a++) {            star[a] = new Star((PApplet.parseInt(random(150, 750))), (PApplet.parseInt(random(25, 300))));        }        maan01 = new Moon(200, 150);    }    void display() {        rectMode(CENTER);        noStroke();        fill(backgroundColor);        rect(achtergrondX, achtergrondY, 800, 800);        fill(grasColor);        rect(achtergrondX, achtergrondY + 200, 800, 400);    }    void update() {        if (night) {            backgroundColor = color(8, 62, 108);            maan01.display();            grasColor = color(65, 119, 64);            for (int a = 0; a < 10; a++) {                star[a].display();            }        } else {            backgroundColor = color(145, 209, 244);            grasColor = color(130, 240, 136);            wolk01.display();            wolk02.display();            wolk03.display();            zon01.display();        }    }    boolean isNight() {        counter++;        if (counter % 2 == 0) {            night = false;        } else {            night = true;        }        return night;    }}',correct
'counter % 2 == 0',correct
'Zon(float sunX, float sunY) {    zonX = sunX;    zonY = sunY;}',correct
'Bloem',correct
'{    sterX = starX;    sterY = starY;}',correct
'achtergrondX = backgroundX',correct
'stroke(108, 185, 251);',correct
'// huis-chimneystroke(0);',correct
'counter % 2',correct
'a < 10',correct
'color(8, 62, 108)',correct
'i++',correct
'herbertY = creatureY;',correct
'vertex(-24, -8)',correct
'float moonX',correct
'vertex(0, 12)',correct
'float huisY;',correct
'[20]',correct
'stroke(8, 62, 108);',correct
'float moonY',correct
'fill(255);',correct
'rect(bloemX, bloemY + 25, 2, 32);',correct
'huisX = homeX',correct
'background01.display()',correct
'herbert01.update();',correct
'flower = new Bloem[20]',correct
'herbert01.display();',correct
'stroke(47, 145, 160)',correct
'zonY',correct
'achtergrondY = backgroundY',correct
'// brownbodyColor = color(213, 139, 95);',correct
'achtergrondX = backgroundX;',correct
'stroke(eyeColor)',correct
'zonX',correct
'{    bloemX = flowerX;    bloemY = flowerY;}',correct
'wolkX = cloudX',correct
'float creatureX',correct
'achtergrondY',correct
'vertex(12, 4);',correct
'achtergrondX',correct
'float creatureY',correct
'wolkY + 45',correct
'{    ellipseMode(CENTER);    rectMode(CENTER);    // bloem    stroke(47, 145, 35);    fill(47, 145, 35);    rect(bloemX, bloemY + 25, 2, 32);    stroke(108, 185, 251);    fill(108, 185, 251);    ellipse(bloemX - 8, bloemY + 10, 15, 15);    stroke(47, 145, 160);    fill(47, 145, 160);    ellipse(bloemX + 8, bloemY + 10, 15, 15);    stroke(244, 145, 160);    fill(244, 145, 160);    ellipse(bloemX, bloemY - 14, 15, 15);    stroke(180, 145, 244);    fill(180, 145, 244);    ellipse(bloemX + 12, bloemY - 5, 15, 15);    stroke(230, 145, 244);    fill(230, 145, 244);    ellipse(bloemX - 12, bloemY - 5, 15, 15);    stroke(245, 219, 136);    fill(245, 219, 136);    ellipse(bloemX, bloemY, 15, 15);}',correct
'Zon zon01;',correct
'float huisX;',correct
'// float bloemX;',correct
'wolkY + 40',correct
'huis01 = new Huis(200, 400);',correct
'Zon',correct
'Huis(float homeX, float homeY) {    huisX = homeX;    huisY = homeY;}',correct
'new Wolk(200, 200)',correct
'vertex(8, -10);',correct
'// {',correct
'// huis-windowstroke(0);',correct
'bodyColor',correct
'{    rectMode(CENTER);    noStroke();    fill(backgroundColor);    rect(achtergrondX, achtergrondY, 800, 800);    fill(grasColor);    rect(achtergrondX, achtergrondY + 200, 800, 400);}',correct
'wolk03',correct
'wolk02',correct
'wolk01',correct
'stroke(255);',correct
'[10]',correct
'ellipse(bloemX - 12, bloemY - 5, 15, 15);',correct
'// float bloemY;',correct
'fill(47, 145, 35)',correct
'herbert01 = new Herbert(400, 400)',correct
'float achtergrondY;',correct
'huisX = homeX;',correct
'wolk01 = new Wolk(200, 200);',correct
'bloemY = flowerY',correct
'rect(huisX + 8, huisY + 11, 9, 9)',correct
'color(145, 209, 244)',correct
'{    ellipseMode(CENTER);    rectMode(CENTER);    // wolk    stroke(255);    fill(255);    ellipse(wolkX, wolkY, 80, 80);    ellipse(wolkX - 55, wolkY + 8, 60, 60);    ellipse(wolkX - 90, wolkY + 24, 50, 50);    ellipse(wolkX - 65, wolkY + 45, 30, 30);    ellipse(wolkX - 30, wolkY + 40, 45, 45);    ellipse(wolkX + 15, wolkY + 30, 60, 60);}',correct
'float cloudY',correct
'float cloudX',correct
'ellipse(herbertX + 10, herbertY - 85, 10, 10);',correct
'fill(180, 145, 244)',correct
'herbertX = creatureX;',correct
'(line) - 20',correct
'fill(245, 219, 136);',correct
'void display() {    ellipseMode(CENTER);    rectMode(CENTER);    // huis-base    stroke(0);    fill(250, 195, 24);    rect(huisX, huisY, 36, 30);    // huis-chimney    stroke(0);    fill(255);    rect(huisX - 10, huisY - 26, 6, 8);    // huis-door    stroke(0);    fill(193, 102, 53);    ellipse(huisX + 8, huisY + 6, 9, 9);    rect(huisX + 8, huisY + 11, 9, 9);    // huis-window    stroke(0);    fill(145, 209, 244);    rect(huisX - 7, huisY - 4, 9, 9);    // huis-roof    stroke(0);    fill(255, 0, 0);    triangle(huisX + 18, huisY - 15, huisX - 18, huisY - 15, huisX, huisY - 32);}',correct
'// feetellipse(herbertX + 25, herbertY + 45, 30, 30);',correct
'background01.isNight()',correct
'{    ellipseMode(CENTER);    stroke(187, 194, 199);    fill(187, 194, 199);    ellipse(maanX, maanY, 250, 250);    stroke(8, 62, 108);    fill(8, 62, 108);    ellipse(maanX + 50, maanY - 50, 175, 175);}',correct
'void pressed() {    herbertX = mouseX;    line = mouseY;}',correct
'Background background01;',correct
'fill(backgroundColor);',correct
'flower[i] = new Bloem((PApplet.parseInt(random(30, 770))), (PApplet.parseInt(random(500, 700))))',correct
'{    night = false;}',correct
'night = true;',correct
'ellipse(herbertX - 10, herbertY - 85, 10, 10)',correct
'triangle(deadpoolX + 16, deadpoolY - 65, deadpoolX + 5, deadpoolY - 70, deadpoolX + 16, deadpoolY - 85);',correct
'rect(deadpoolX, deadpoolY - 70, 40, 40);',correct
'rect(0, 0, 15, 40)',correct
'isDancing',correct
'duration = random(34, 1200)',correct
'// swordspushMatrix();',correct
'ellipse(deadpoolX - 17, deadpoolY - 90, 10, 10)',correct
'// rightpushMatrix();',correct
'ellipse(deadpoolX - 27, deadpoolY - 33, 15, 15)',correct
'ellipse(deadpoolX + 20, deadpoolY - 34, 10, 10);',correct
'deadpoolX + 5',correct
'deadpoolX + 16',correct
'random(0, 255)',correct
'deadpoolX + 17',correct
'// bodyfill(bodyColor);',correct
'deadpoolX + 24',correct
'ellipse(deadpoolX - 20, deadpoolY - 34, 10, 10);',correct
'ellipse(deadpoolX + 56, deadpoolY - 17, 17, 15)',correct
'deadpoolY - 50',correct
'deadpoolX + 20',correct
'rect(0, 0, 15, 40);',correct
'random(50, width - 50)',correct
'translate(deadpoolX + 40, deadpoolY - 25)',correct
'height - 50',correct
'rotate(4);',correct
'ellipse(deadpoolX + 10, deadpoolY - 65, 12, 15);',correct
'pushMatrix();',correct
'ellipse(deadpoolX + 17, deadpoolY - 50, 10, 10)',correct
'deadpoolX + 27',correct
'ellipse(deadpoolX + 56, deadpoolY - 17, 17, 15);',correct
'Deadpool[]',correct
'currentTime',correct
'rect(deadpoolX - 17, deadpoolY - 70, 10, 34)',correct
'rect(deadpoolX, deadpoolY, 50, 60);',correct
'translate(deadpoolX - 45, deadpoolY - 25);',correct
'stroke(accessiores);',correct
'deadpoolY - 62',correct
'void setup() {    duration = random(34, 1200);    for (int i = 0; i < deadpools.length; i++) {        deadpools[i] = new Deadpool(random(50, width - 50), random(50, height - 50));    }}',correct
'color(255, 0, 0)',correct
'rect(deadpoolX, deadpoolY + 35, 40, 10);',correct
'// armsrectMode(CENTER);',correct
'deadpoolY - 65',correct
'rect(deadpoolX, deadpoolY - 50, 30, 10)',correct
'ellipse(deadpoolX - 17, deadpoolY - 90, 10, 10);',correct
'println(currentTime)',correct
'{    previousTime = currentTime;    background(random(0, 255), random(0, 255), random(0, 255));    status = !status;}',correct
'width - 50',correct
'rect(deadpoolX - 17, deadpoolY - 70, 10, 34);',correct
'ellipse(deadpoolX + 10, deadpoolY - 65, 12, 15)',correct
'float deadpoolY1',correct
'stroke(bodyColor)',correct
'new Deadpool[20]',correct
'translate(deadpoolX + 20, deadpoolY + 50);',correct
'deadpoolY = height / 2',correct
'deadpoolX + 45',correct
'deadpoolY + 90',correct
'float duration;',correct
'translate(deadpoolX, deadpoolY - 10)',correct
'rect(deadpoolX + 17, deadpoolY - 70, 10, 34)',correct
'deadpoolX + 40',correct
'deadpoolY - 33',correct
'deadpoolY - 34',correct
'deadpoolY - 35',correct
'background(random(0, 255), random(0, 255), random(0, 255))',correct
'ellipse(deadpoolX - 10, deadpoolY - 65, 12, 15);',correct
'rectMode(CENTER)',correct
'rotate(3);',correct
'// legs// rightrectMode(CENTER);',correct
'{    duration = random(34, 1200);    for (int i = 0; i < deadpools.length; i++) {        deadpools[i] = new Deadpool(random(50, width - 50), random(50, height - 50));    }}',correct
'boolean isDancing;',correct
'float deadpoolX1',correct
'deadpools[i].display()',correct
'duration = random(34, 1200);',correct
'popMatrix();',correct
'rect(deadpoolX - 10, deadpoolY - 65, 10, 10);',correct
'class Deadpool {    float deadpoolX = width / 2;    float deadpoolY = height / 2;    int bodyColor = color(255, 0, 0);    int accessiores = color(0, 0, 0);    boolean isDancing;    Deadpool(float deadpoolX1, float deadpoolY1) {        deadpoolX = deadpoolX1;        deadpoolY = deadpoolY1;    }    void display() {        currentTime = millis();        stroke(bodyColor);        fill(bodyColor);        // legs        // right        rectMode(CENTER);        fill(bodyColor);        stroke(bodyColor);        pushMatrix();        translate(deadpoolX + 20, deadpoolY + 50);        rotate(3);        rect(0, 0, 15, 40);        popMatrix();        rect(deadpoolX + 24, deadpoolY + 90, 15, 40);        // left        fill(bodyColor);        stroke(bodyColor);        pushMatrix();        translate(deadpoolX - 20, deadpoolY + 50);        rotate(-3);        rect(0, 0, 15, 40);        popMatrix();        rect(deadpoolX - 24, deadpoolY + 90, 15, 40);        // knees        fill(accessiores);        stroke(accessiores);        ellipse(deadpoolX + 24, deadpoolY + 70, 17, 15);        ellipse(deadpoolX - 24, deadpoolY + 70, 17, 15);        // swords        pushMatrix();        translate(deadpoolX + 20, deadpoolY - 44);        rotate(2);        ellipse(0, 0, 5, 15);        popMatrix();        pushMatrix();        translate(deadpoolX - 20, deadpoolY - 44);        rotate(12);        ellipse(0, 0, 8, 60);        popMatrix();        pushMatrix();        translate(deadpoolX - 20, deadpoolY - 44);        rotate(-2);        ellipse(0, 0, 5, 15);        popMatrix();        pushMatrix();        translate(deadpoolX + 20, deadpoolY - 44);        rotate(-12);        ellipse(0, 0, 8, 60);        popMatrix();        // body        fill(bodyColor);        stroke(bodyColor);        rectMode(CENTER);        rect(deadpoolX, deadpoolY, 50, 60);        fill(accessiores);        stroke(accessiores);        ellipse(deadpoolX - 20, deadpoolY + 34, 10, 10);        ellipse(deadpoolX + 20, deadpoolY + 34, 10, 10);        rect(deadpoolX, deadpoolY + 35, 40, 10);        ellipse(deadpoolX - 20, deadpoolY - 34, 10, 10);        ellipse(deadpoolX + 20, deadpoolY - 34, 10, 10);        fill(bodyColor);        stroke(bodyColor);        rect(deadpoolX, deadpoolY - 35, 40, 10);        // neck        rectMode(CORNER);        rect(deadpoolX - 5, deadpoolY, 10, -50);        // arms        if (isDancing) {            rectMode(CENTER);            fill(bodyColor);            stroke(bodyColor);            // right            pushMatrix();            translate(deadpoolX + 40, deadpoolY - 25);            rotate(2);            rect(0, 0, 15, 40);            popMatrix();            rect(deadpoolX - 55, deadpoolY - 62, 15, 40);            // left            pushMatrix();            translate(deadpoolX - 40, deadpoolY - 40);            rotate(2);            rect(0, 0, 15, 40);            popMatrix();            rect(deadpoolX + 55, deadpoolY, 15, 40);            // shoulders            fill(accessiores);            stroke(accessiores);            ellipse(deadpoolX - 27, deadpoolY - 33, 15, 15);            ellipse(deadpoolX + 27, deadpoolY - 33, 15, 15);            // elbows            ellipse(deadpoolX - 55, deadpoolY - 47, 17, 15);            ellipse(deadpoolX + 56, deadpoolY - 17, 17, 15);        } else {            // arms            rectMode(CENTER);            // right            pushMatrix();            translate(deadpoolX + 45, deadpoolY - 40);            rotate(-2);            rect(0, 0, 15, 40);            popMatrix();            rect(deadpoolX + 65, deadpoolY - 65, 15, 40);            // left            pushMatrix();            translate(deadpoolX - 45, deadpoolY - 25);            rotate(-2);            rect(0, 0, 15, 40);            popMatrix();            rect(deadpoolX - 65, deadpoolY, 15, 40);            // shoulders            fill(accessiores);            stroke(accessiores);            ellipse(deadpoolX - 27, deadpoolY - 33, 15, 15);            ellipse(deadpoolX + 27, deadpoolY - 33, 15, 15);            // elbows            ellipse(deadpoolX - 65, deadpoolY - 16, 17, 15);            ellipse(deadpoolX + 65, deadpoolY - 49, 17, 15);        }        // head        fill(bodyColor);        stroke(bodyColor);        rect(deadpoolX, deadpoolY - 70, 40, 40);        ellipse(deadpoolX - 17, deadpoolY - 90, 10, 10);        ellipse(deadpoolX + 17, deadpoolY - 90, 10, 10);        ellipse(deadpoolX - 17, deadpoolY - 50, 10, 10);        ellipse(deadpoolX + 17, deadpoolY - 50, 10, 10);        rect(deadpoolX, deadpoolY - 90, 30, 10);        rect(deadpoolX, deadpoolY - 50, 30, 10);        rect(deadpoolX - 17, deadpoolY - 70, 10, 34);        rect(deadpoolX + 17, deadpoolY - 70, 10, 34);        // eyes        fill(accessiores);        stroke(accessiores);        rect(deadpoolX - 10, deadpoolY - 65, 10, 10);        ellipse(deadpoolX - 10, deadpoolY - 65, 12, 15);        triangle(deadpoolX - 16, deadpoolY - 65, deadpoolX - 5, deadpoolY - 70, deadpoolX - 16, deadpoolY - 85);        rect(deadpoolX + 10, deadpoolY - 65, 10, 10);        ellipse(deadpoolX + 10, deadpoolY - 65, 12, 15);        triangle(deadpoolX + 16, deadpoolY - 65, deadpoolX + 5, deadpoolY - 70, deadpoolX + 16, deadpoolY - 85);        fill(255, 255, 255);        ellipse(deadpoolX + 10, deadpoolY - 65, 7, 7);        ellipse(deadpoolX - 10, deadpoolY - 65, 7, 7);        // belts        fill(accessiores);        rectMode(CENTER);        pushMatrix();        translate(deadpoolX, deadpoolY - 10);        rotate(4);        rect(0, 0, 10, 70);        popMatrix();        fill(accessiores);        rectMode(CENTER);        pushMatrix();        translate(deadpoolX, deadpoolY - 10);        rotate(-4);        rect(0, 0, 10, 70);        popMatrix();        // feet        ellipse(deadpoolX + 27, deadpoolY + 107, 25, 10);        ellipse(deadpoolX - 27, deadpoolY + 107, 25, 10);    }}',correct
'deadpoolX + 55',correct
'previousTime = currentTime;',DrawingStateChangeRule
'deadpoolX + 56',correct
'deadpoolY - 40',correct
'Deadpool[] deadpools = new Deadpool[20];',correct
'deadpoolY - 44',correct
'rect(deadpoolX - 55, deadpoolY - 62, 15, 40);',correct
'ellipse(0, 0, 8, 60)',correct
'triangle(deadpoolX - 16, deadpoolY - 65, deadpoolX - 5, deadpoolY - 70, deadpoolX - 16, deadpoolY - 85);',correct
'rectMode(CENTER);',correct
'millis()',correct
'Deadpool(float deadpoolX1, float deadpoolY1) {    deadpoolX = deadpoolX1;    deadpoolY = deadpoolY1;}',correct
'deadpoolY - 49',correct
'deadpoolY - 47',correct
'void equal() {    println(currentTime);    if (currentTime > previousTime + duration) {        previousTime = currentTime;        background(random(0, 255), random(0, 255), random(0, 255));        status = !status;    }}',correct
'translate(deadpoolX + 20, deadpoolY + 50)',correct
'rect(deadpoolX, deadpoolY - 35, 40, 10);',correct
'ellipse(deadpoolX + 20, deadpoolY + 34, 10, 10);',correct
'deadpools = new Deadpool[20]',correct
'ellipse(deadpoolX + 27, deadpoolY - 33, 15, 15)',correct
'deadpoolY - 90',correct
'deadpools[i] = new Deadpool(random(50, width - 50), random(50, height - 50));',correct
'fill(bodyColor)',correct
'rotate(2)',correct
'ellipse(deadpoolX + 17, deadpoolY - 90, 10, 10)',correct
'status = !status',correct
'bodyColor = color(255, 0, 0)',correct
'rotate(2);',correct
'deadpools.length',correct
'rect(0, 0, 10, 70)',correct
'height / 2',correct
'fill(bodyColor);',correct
'rotate(-2);',correct
'rect(deadpoolX, deadpoolY - 90, 30, 10)',correct
'rotate(3)',correct
'rotate(-3)',correct
'Processing',correct
'duration',correct
'deadpoolY - 70',correct
'background(random(0, 255), random(0, 255), random(0, 255));',correct
'rect(deadpoolX + 10, deadpoolY - 65, 10, 10);',correct
'// neckrectMode(CORNER);',correct
'rect(deadpoolX - 65, deadpoolY, 15, 40)',correct
'pushMatrix()',correct
'// elbowsellipse(deadpoolX - 55, deadpoolY - 47, 17, 15);',correct
'currentTime > previousTime + duration',correct
'translate(deadpoolX + 20, deadpoolY - 44);',correct
'ellipse(deadpoolX + 24, deadpoolY + 70, 17, 15);',correct
'{    rectMode(CENTER);    fill(bodyColor);    stroke(bodyColor);    // right    pushMatrix();    translate(deadpoolX + 40, deadpoolY - 25);    rotate(2);    rect(0, 0, 15, 40);    popMatrix();    rect(deadpoolX - 55, deadpoolY - 62, 15, 40);    // left    pushMatrix();    translate(deadpoolX - 40, deadpoolY - 40);    rotate(2);    rect(0, 0, 15, 40);    popMatrix();    rect(deadpoolX + 55, deadpoolY, 15, 40);    // shoulders    fill(accessiores);    stroke(accessiores);    ellipse(deadpoolX - 27, deadpoolY - 33, 15, 15);    ellipse(deadpoolX + 27, deadpoolY - 33, 15, 15);    // elbows    ellipse(deadpoolX - 55, deadpoolY - 47, 17, 15);    ellipse(deadpoolX + 56, deadpoolY - 17, 17, 15);}',correct
'// leftpushMatrix();',correct
'ellipse(deadpoolX + 10, deadpoolY - 65, 7, 7);',correct
'ellipse(deadpoolX - 10, deadpoolY - 65, 12, 15)',correct
'rotate(4)',correct
'// kneesfill(accessiores);',correct
'rect(deadpoolX, deadpoolY - 70, 40, 40)',correct
'previousTime = 1000',correct
'rotate(-2)',correct
'{    deadpools[i].isDancing = status;    deadpools[i].display();}',correct
'ellipse(deadpoolX - 27, deadpoolY + 107, 25, 10);',correct
'deadpoolX + 10',correct
'ellipse(deadpoolX - 27, deadpoolY - 33, 15, 15);',correct
'translate(deadpoolX + 45, deadpoolY - 40)',correct
'int i = 0',correct
'{    deadpools[i] = new Deadpool(random(50, width - 50), random(50, height - 50));}',correct
'deadpoolY - 85',correct
'deadpools[i].isDancing = status',correct
'translate(deadpoolX + 45, deadpoolY - 40);',correct
'deadpools[i] = new Deadpool(random(50, width - 50), random(50, height - 50))',correct
'ellipse(deadpoolX + 27, deadpoolY + 107, 25, 10)',correct
'stroke(bodyColor);',correct
'ellipse(deadpoolX - 65, deadpoolY - 16, 17, 15)',correct
'rotate(-3);',correct
'new Deadpool(random(50, width - 50), random(50, height - 50))',correct
'equal();',correct
'i = 0',correct
'random(34, 1200)',correct
'translate(deadpoolX - 20, deadpoolY - 44);',correct
'deadpoolY = deadpoolY1;',correct
'rect(deadpoolX - 24, deadpoolY + 90, 15, 40);',correct
'rect(deadpoolX - 5, deadpoolY, 10, -50);',correct
'-12',correct
'rect(deadpoolX + 24, deadpoolY + 90, 15, 40)',correct
'deadpoolX - 45',correct
'translate(deadpoolX - 20, deadpoolY - 44)',correct
'fill(255, 255, 255);',correct
'{    equal();    for (int i = 0; i < deadpools.length; i++) {        deadpools[i].isDancing = status;        deadpools[i].display();    }}',correct
'rect(deadpoolX - 55, deadpoolY - 62, 15, 40)',correct
'for (int i = 0; i < deadpools.length; i++) {    deadpools[i] = new Deadpool(random(50, width - 50), random(50, height - 50));}',correct
'deadpoolX - 40',correct
'deadpoolY + 34',correct
'ellipse(deadpoolX - 24, deadpoolY + 70, 17, 15)',correct
'deadpoolY + 35',correct
'// eyesfill(accessiores);',correct
'deadpools[i].display();',correct
'fill(accessiores);',correct
'!status',correct
'rect(deadpoolX + 24, deadpoolY + 90, 15, 40);',correct
'rectMode(CORNER)',correct
'for (int i = 0; i < deadpools.length; i++) {    deadpools[i].isDancing = status;    deadpools[i].display();}',correct
'rotate(-4)',correct
'translate(deadpoolX + 20, deadpoolY - 44)',correct
'float deadpoolY = height / 2;',correct
'rect(deadpoolX + 10, deadpoolY - 65, 10, 10)',correct
'previousTime + duration',correct
'deadpoolX - 55',correct
'previousTime = currentTime',correct
'{    currentTime = millis();    stroke(bodyColor);    fill(bodyColor);    // legs    // right    rectMode(CENTER);    fill(bodyColor);    stroke(bodyColor);    pushMatrix();    translate(deadpoolX + 20, deadpoolY + 50);    rotate(3);    rect(0, 0, 15, 40);    popMatrix();    rect(deadpoolX + 24, deadpoolY + 90, 15, 40);    // left    fill(bodyColor);    stroke(bodyColor);    pushMatrix();    translate(deadpoolX - 20, deadpoolY + 50);    rotate(-3);    rect(0, 0, 15, 40);    popMatrix();    rect(deadpoolX - 24, deadpoolY + 90, 15, 40);    // knees    fill(accessiores);    stroke(accessiores);    ellipse(deadpoolX + 24, deadpoolY + 70, 17, 15);    ellipse(deadpoolX - 24, deadpoolY + 70, 17, 15);    // swords    pushMatrix();    translate(deadpoolX + 20, deadpoolY - 44);    rotate(2);    ellipse(0, 0, 5, 15);    popMatrix();    pushMatrix();    translate(deadpoolX - 20, deadpoolY - 44);    rotate(12);    ellipse(0, 0, 8, 60);    popMatrix();    pushMatrix();    translate(deadpoolX - 20, deadpoolY - 44);    rotate(-2);    ellipse(0, 0, 5, 15);    popMatrix();    pushMatrix();    translate(deadpoolX + 20, deadpoolY - 44);    rotate(-12);    ellipse(0, 0, 8, 60);    popMatrix();    // body    fill(bodyColor);    stroke(bodyColor);    rectMode(CENTER);    rect(deadpoolX, deadpoolY, 50, 60);    fill(accessiores);    stroke(accessiores);    ellipse(deadpoolX - 20, deadpoolY + 34, 10, 10);    ellipse(deadpoolX + 20, deadpoolY + 34, 10, 10);    rect(deadpoolX, deadpoolY + 35, 40, 10);    ellipse(deadpoolX - 20, deadpoolY - 34, 10, 10);    ellipse(deadpoolX + 20, deadpoolY - 34, 10, 10);    fill(bodyColor);    stroke(bodyColor);    rect(deadpoolX, deadpoolY - 35, 40, 10);    // neck    rectMode(CORNER);    rect(deadpoolX - 5, deadpoolY, 10, -50);    // arms    if (isDancing) {        rectMode(CENTER);        fill(bodyColor);        stroke(bodyColor);        // right        pushMatrix();        translate(deadpoolX + 40, deadpoolY - 25);        rotate(2);        rect(0, 0, 15, 40);        popMatrix();        rect(deadpoolX - 55, deadpoolY - 62, 15, 40);        // left        pushMatrix();        translate(deadpoolX - 40, deadpoolY - 40);        rotate(2);        rect(0, 0, 15, 40);        popMatrix();        rect(deadpoolX + 55, deadpoolY, 15, 40);        // shoulders        fill(accessiores);        stroke(accessiores);        ellipse(deadpoolX - 27, deadpoolY - 33, 15, 15);        ellipse(deadpoolX + 27, deadpoolY - 33, 15, 15);        // elbows        ellipse(deadpoolX - 55, deadpoolY - 47, 17, 15);        ellipse(deadpoolX + 56, deadpoolY - 17, 17, 15);    } else {        // arms        rectMode(CENTER);        // right        pushMatrix();        translate(deadpoolX + 45, deadpoolY - 40);        rotate(-2);        rect(0, 0, 15, 40);        popMatrix();        rect(deadpoolX + 65, deadpoolY - 65, 15, 40);        // left        pushMatrix();        translate(deadpoolX - 45, deadpoolY - 25);        rotate(-2);        rect(0, 0, 15, 40);        popMatrix();        rect(deadpoolX - 65, deadpoolY, 15, 40);        // shoulders        fill(accessiores);        stroke(accessiores);        ellipse(deadpoolX - 27, deadpoolY - 33, 15, 15);        ellipse(deadpoolX + 27, deadpoolY - 33, 15, 15);        // elbows        ellipse(deadpoolX - 65, deadpoolY - 16, 17, 15);        ellipse(deadpoolX + 65, deadpoolY - 49, 17, 15);    }    // head    fill(bodyColor);    stroke(bodyColor);    rect(deadpoolX, deadpoolY - 70, 40, 40);    ellipse(deadpoolX - 17, deadpoolY - 90, 10, 10);    ellipse(deadpoolX + 17, deadpoolY - 90, 10, 10);    ellipse(deadpoolX - 17, deadpoolY - 50, 10, 10);    ellipse(deadpoolX + 17, deadpoolY - 50, 10, 10);    rect(deadpoolX, deadpoolY - 90, 30, 10);    rect(deadpoolX, deadpoolY - 50, 30, 10);    rect(deadpoolX - 17, deadpoolY - 70, 10, 34);    rect(deadpoolX + 17, deadpoolY - 70, 10, 34);    // eyes    fill(accessiores);    stroke(accessiores);    rect(deadpoolX - 10, deadpoolY - 65, 10, 10);    ellipse(deadpoolX - 10, deadpoolY - 65, 12, 15);    triangle(deadpoolX - 16, deadpoolY - 65, deadpoolX - 5, deadpoolY - 70, deadpoolX - 16, deadpoolY - 85);    rect(deadpoolX + 10, deadpoolY - 65, 10, 10);    ellipse(deadpoolX + 10, deadpoolY - 65, 12, 15);    triangle(deadpoolX + 16, deadpoolY - 65, deadpoolX + 5, deadpoolY - 70, deadpoolX + 16, deadpoolY - 85);    fill(255, 255, 255);    ellipse(deadpoolX + 10, deadpoolY - 65, 7, 7);    ellipse(deadpoolX - 10, deadpoolY - 65, 7, 7);    // belts    fill(accessiores);    rectMode(CENTER);    pushMatrix();    translate(deadpoolX, deadpoolY - 10);    rotate(4);    rect(0, 0, 10, 70);    popMatrix();    fill(accessiores);    rectMode(CENTER);    pushMatrix();    translate(deadpoolX, deadpoolY - 10);    rotate(-4);    rect(0, 0, 10, 70);    popMatrix();    // feet    ellipse(deadpoolX + 27, deadpoolY + 107, 25, 10);    ellipse(deadpoolX - 27, deadpoolY + 107, 25, 10);}',LongMethodRule
'rotate(12);',correct
'rect(deadpoolX + 55, deadpoolY, 15, 40)',correct
'// leftfill(bodyColor);',correct
'status',correct
'rotate(-4);',correct
'float deadpoolX = width / 2;',correct
'Deadpool',correct
'rect(deadpoolX + 55, deadpoolY, 15, 40);',correct
'ellipse(deadpoolX - 55, deadpoolY - 47, 17, 15)',correct
'long previousTime = 1000;',correct
'ellipse(deadpoolX - 10, deadpoolY - 65, 7, 7);',correct
'{    deadpoolX = deadpoolX1;    deadpoolY = deadpoolY1;}',correct
'ellipse(deadpoolX - 20, deadpoolY - 34, 10, 10)',correct
'ellipse(deadpoolX + 27, deadpoolY - 33, 15, 15);',correct
'ellipse(0, 0, 5, 15)',correct
'deadpoolX - 65',correct
'triangle(deadpoolX - 16, deadpoolY - 65, deadpoolX - 5, deadpoolY - 70, deadpoolX - 16, deadpoolY - 85)',correct
'ellipse(deadpoolX - 20, deadpoolY + 34, 10, 10)',correct
'translate(deadpoolX, deadpoolY - 10);',correct
'if (currentTime > previousTime + duration) {    previousTime = currentTime;    background(random(0, 255), random(0, 255), random(0, 255));    status = !status;}',correct
'void draw() {    equal();    for (int i = 0; i < deadpools.length; i++) {        deadpools[i].isDancing = status;        deadpools[i].display();    }}',correct
'// headfill(bodyColor);',correct
'display',LongMethodRule
'rect(deadpoolX - 24, deadpoolY + 90, 15, 40)',correct
'rotate(-12)',correct
'equal()',correct
'stroke(accessiores)',correct
'translate(deadpoolX - 20, deadpoolY + 50)',correct
'ellipse(deadpoolX - 24, deadpoolY + 70, 17, 15);',correct
'rect(0, 0, 10, 70);',correct
'ellipse(deadpoolX + 65, deadpoolY - 49, 17, 15)',correct
'// legs',correct
'ellipse(deadpoolX + 24, deadpoolY + 70, 17, 15)',correct
'ellipse(deadpoolX - 17, deadpoolY - 50, 10, 10);',correct
'long currentTime;',correct
'i++',correct
'-50',correct
'ellipse(deadpoolX + 10, deadpoolY - 65, 7, 7)',correct
'rect(deadpoolX - 5, deadpoolY, 10, -50)',correct
'translate(deadpoolX - 45, deadpoolY - 25)',correct
'deadpoolX - 5',correct
'[20]',correct
'ellipse(deadpoolX - 17, deadpoolY - 50, 10, 10)',correct
'rect(deadpoolX - 65, deadpoolY, 15, 40);',correct
'deadpoolX + 65',correct
'ellipse(deadpoolX - 20, deadpoolY + 34, 10, 10);',correct
'ellipse(deadpoolX - 27, deadpoolY + 107, 25, 10)',correct
'deadpoolY + 70',correct
'int bodyColor = color(255, 0, 0);',correct
'deadpoolX = width / 2',correct
'translate(deadpoolX - 40, deadpoolY - 40);',correct
'rect(deadpoolX - 10, deadpoolY - 65, 10, 10)',correct
'rotate(-12);',correct
'deadpoolY + 107',correct
'rect(deadpoolX, deadpoolY - 50, 30, 10);',correct
'ellipse(deadpoolX + 17, deadpoolY - 50, 10, 10);',correct
'deadpoolY - 10',correct
'fill(255, 255, 255)',correct
'deadpoolY - 16',correct
'translate(deadpoolX - 20, deadpoolY + 50);',correct
'translate(deadpoolX - 40, deadpoolY - 40)',correct
'rect(deadpoolX, deadpoolY - 35, 40, 10)',correct
'deadpoolY - 17',correct
'void',correct
'deadpoolY = deadpoolY1',correct
'-2',correct
'-3',correct
'-4',correct
'ellipse(0, 0, 5, 15);',correct
'rect(deadpoolX + 65, deadpoolY - 65, 15, 40)',correct
'deadpools[i].isDancing',correct
'currentTime = millis()',correct
'color(0, 0, 0)',correct
'// beltsfill(accessiores);',correct
'rect(deadpoolX, deadpoolY, 50, 60)',correct
'ellipse(deadpoolX + 20, deadpoolY - 34, 10, 10)',correct
'ellipse(deadpoolX + 65, deadpoolY - 49, 17, 15);',correct
'i < deadpools.length',correct
'deadpoolX - 10',correct
'// shouldersfill(accessiores);',correct
'// armsif (isDancing) {    rectMode(CENTER);    fill(bodyColor);    stroke(bodyColor);    // right    pushMatrix();    translate(deadpoolX + 40, deadpoolY - 25);    rotate(2);    rect(0, 0, 15, 40);    popMatrix();    rect(deadpoolX - 55, deadpoolY - 62, 15, 40);    // left    pushMatrix();    translate(deadpoolX - 40, deadpoolY - 40);    rotate(2);    rect(0, 0, 15, 40);    popMatrix();    rect(deadpoolX + 55, deadpoolY, 15, 40);    // shoulders    fill(accessiores);    stroke(accessiores);    ellipse(deadpoolX - 27, deadpoolY - 33, 15, 15);    ellipse(deadpoolX + 27, deadpoolY - 33, 15, 15);    // elbows    ellipse(deadpoolX - 55, deadpoolY - 47, 17, 15);    ellipse(deadpoolX + 56, deadpoolY - 17, 17, 15);} else {    // arms    rectMode(CENTER);    // right    pushMatrix();    translate(deadpoolX + 45, deadpoolY - 40);    rotate(-2);    rect(0, 0, 15, 40);    popMatrix();    rect(deadpoolX + 65, deadpoolY - 65, 15, 40);    // left    pushMatrix();    translate(deadpoolX - 45, deadpoolY - 25);    rotate(-2);    rect(0, 0, 15, 40);    popMatrix();    rect(deadpoolX - 65, deadpoolY, 15, 40);    // shoulders    fill(accessiores);    stroke(accessiores);    ellipse(deadpoolX - 27, deadpoolY - 33, 15, 15);    ellipse(deadpoolX + 27, deadpoolY - 33, 15, 15);    // elbows    ellipse(deadpoolX - 65, deadpoolY - 16, 17, 15);    ellipse(deadpoolX + 65, deadpoolY - 49, 17, 15);}',correct
'ellipse(deadpoolX + 20, deadpoolY + 34, 10, 10)',correct
'// elbowsellipse(deadpoolX - 65, deadpoolY - 16, 17, 15);',correct
'deadpoolY - 25',correct
'{    // arms    rectMode(CENTER);    // right    pushMatrix();    translate(deadpoolX + 45, deadpoolY - 40);    rotate(-2);    rect(0, 0, 15, 40);    popMatrix();    rect(deadpoolX + 65, deadpoolY - 65, 15, 40);    // left    pushMatrix();    translate(deadpoolX - 45, deadpoolY - 25);    rotate(-2);    rect(0, 0, 15, 40);    popMatrix();    rect(deadpoolX - 65, deadpoolY, 15, 40);    // shoulders    fill(accessiores);    stroke(accessiores);    ellipse(deadpoolX - 27, deadpoolY - 33, 15, 15);    ellipse(deadpoolX + 27, deadpoolY - 33, 15, 15);    // elbows    ellipse(deadpoolX - 65, deadpoolY - 16, 17, 15);    ellipse(deadpoolX + 65, deadpoolY - 49, 17, 15);}',correct
'deadpools[i].isDancing = status;',correct
'int accessiores = color(0, 0, 0);',correct
'popMatrix()',correct
'random(50, height - 50)',correct
'deadpools[i]',correct
'deadpoolX - 17',correct
'deadpoolX - 16',correct
'deadpoolX = deadpoolX1',correct
'fill(accessiores)',correct
'deadpoolX - 24',correct
'println(currentTime);',correct
'deadpoolX = deadpoolX1;',correct
'deadpoolX - 20',correct
'ellipse(deadpoolX + 17, deadpoolY - 90, 10, 10);',correct
'accessiores = color(0, 0, 0)',correct
'deadpoolY + 50',correct
'currentTime = millis();',correct
'translate(deadpoolX + 40, deadpoolY - 25);',correct
'ellipse(deadpoolX - 10, deadpoolY - 65, 7, 7)',correct
'ellipse(0, 0, 8, 60);',correct
'rect(deadpoolX, deadpoolY + 35, 40, 10)',correct
'rect(deadpoolX, deadpoolY - 90, 30, 10);',correct
'rotate(12)',correct
'boolean status;',correct
'status = !status;',DrawingStateChangeRule
'void display() {    currentTime = millis();    stroke(bodyColor);    fill(bodyColor);    // legs    // right    rectMode(CENTER);    fill(bodyColor);    stroke(bodyColor);    pushMatrix();    translate(deadpoolX + 20, deadpoolY + 50);    rotate(3);    rect(0, 0, 15, 40);    popMatrix();    rect(deadpoolX + 24, deadpoolY + 90, 15, 40);    // left    fill(bodyColor);    stroke(bodyColor);    pushMatrix();    translate(deadpoolX - 20, deadpoolY + 50);    rotate(-3);    rect(0, 0, 15, 40);    popMatrix();    rect(deadpoolX - 24, deadpoolY + 90, 15, 40);    // knees    fill(accessiores);    stroke(accessiores);    ellipse(deadpoolX + 24, deadpoolY + 70, 17, 15);    ellipse(deadpoolX - 24, deadpoolY + 70, 17, 15);    // swords    pushMatrix();    translate(deadpoolX + 20, deadpoolY - 44);    rotate(2);    ellipse(0, 0, 5, 15);    popMatrix();    pushMatrix();    translate(deadpoolX - 20, deadpoolY - 44);    rotate(12);    ellipse(0, 0, 8, 60);    popMatrix();    pushMatrix();    translate(deadpoolX - 20, deadpoolY - 44);    rotate(-2);    ellipse(0, 0, 5, 15);    popMatrix();    pushMatrix();    translate(deadpoolX + 20, deadpoolY - 44);    rotate(-12);    ellipse(0, 0, 8, 60);    popMatrix();    // body    fill(bodyColor);    stroke(bodyColor);    rectMode(CENTER);    rect(deadpoolX, deadpoolY, 50, 60);    fill(accessiores);    stroke(accessiores);    ellipse(deadpoolX - 20, deadpoolY + 34, 10, 10);    ellipse(deadpoolX + 20, deadpoolY + 34, 10, 10);    rect(deadpoolX, deadpoolY + 35, 40, 10);    ellipse(deadpoolX - 20, deadpoolY - 34, 10, 10);    ellipse(deadpoolX + 20, deadpoolY - 34, 10, 10);    fill(bodyColor);    stroke(bodyColor);    rect(deadpoolX, deadpoolY - 35, 40, 10);    // neck    rectMode(CORNER);    rect(deadpoolX - 5, deadpoolY, 10, -50);    // arms    if (isDancing) {        rectMode(CENTER);        fill(bodyColor);        stroke(bodyColor);        // right        pushMatrix();        translate(deadpoolX + 40, deadpoolY - 25);        rotate(2);        rect(0, 0, 15, 40);        popMatrix();        rect(deadpoolX - 55, deadpoolY - 62, 15, 40);        // left        pushMatrix();        translate(deadpoolX - 40, deadpoolY - 40);        rotate(2);        rect(0, 0, 15, 40);        popMatrix();        rect(deadpoolX + 55, deadpoolY, 15, 40);        // shoulders        fill(accessiores);        stroke(accessiores);        ellipse(deadpoolX - 27, deadpoolY - 33, 15, 15);        ellipse(deadpoolX + 27, deadpoolY - 33, 15, 15);        // elbows        ellipse(deadpoolX - 55, deadpoolY - 47, 17, 15);        ellipse(deadpoolX + 56, deadpoolY - 17, 17, 15);    } else {        // arms        rectMode(CENTER);        // right        pushMatrix();        translate(deadpoolX + 45, deadpoolY - 40);        rotate(-2);        rect(0, 0, 15, 40);        popMatrix();        rect(deadpoolX + 65, deadpoolY - 65, 15, 40);        // left        pushMatrix();        translate(deadpoolX - 45, deadpoolY - 25);        rotate(-2);        rect(0, 0, 15, 40);        popMatrix();        rect(deadpoolX - 65, deadpoolY, 15, 40);        // shoulders        fill(accessiores);        stroke(accessiores);        ellipse(deadpoolX - 27, deadpoolY - 33, 15, 15);        ellipse(deadpoolX + 27, deadpoolY - 33, 15, 15);        // elbows        ellipse(deadpoolX - 65, deadpoolY - 16, 17, 15);        ellipse(deadpoolX + 65, deadpoolY - 49, 17, 15);    }    // head    fill(bodyColor);    stroke(bodyColor);    rect(deadpoolX, deadpoolY - 70, 40, 40);    ellipse(deadpoolX - 17, deadpoolY - 90, 10, 10);    ellipse(deadpoolX + 17, deadpoolY - 90, 10, 10);    ellipse(deadpoolX - 17, deadpoolY - 50, 10, 10);    ellipse(deadpoolX + 17, deadpoolY - 50, 10, 10);    rect(deadpoolX, deadpoolY - 90, 30, 10);    rect(deadpoolX, deadpoolY - 50, 30, 10);    rect(deadpoolX - 17, deadpoolY - 70, 10, 34);    rect(deadpoolX + 17, deadpoolY - 70, 10, 34);    // eyes    fill(accessiores);    stroke(accessiores);    rect(deadpoolX - 10, deadpoolY - 65, 10, 10);    ellipse(deadpoolX - 10, deadpoolY - 65, 12, 15);    triangle(deadpoolX - 16, deadpoolY - 65, deadpoolX - 5, deadpoolY - 70, deadpoolX - 16, deadpoolY - 85);    rect(deadpoolX + 10, deadpoolY - 65, 10, 10);    ellipse(deadpoolX + 10, deadpoolY - 65, 12, 15);    triangle(deadpoolX + 16, deadpoolY - 65, deadpoolX + 5, deadpoolY - 70, deadpoolX + 16, deadpoolY - 85);    fill(255, 255, 255);    ellipse(deadpoolX + 10, deadpoolY - 65, 7, 7);    ellipse(deadpoolX - 10, deadpoolY - 65, 7, 7);    // belts    fill(accessiores);    rectMode(CENTER);    pushMatrix();    translate(deadpoolX, deadpoolY - 10);    rotate(4);    rect(0, 0, 10, 70);    popMatrix();    fill(accessiores);    rectMode(CENTER);    pushMatrix();    translate(deadpoolX, deadpoolY - 10);    rotate(-4);    rect(0, 0, 10, 70);    popMatrix();    // feet    ellipse(deadpoolX + 27, deadpoolY + 107, 25, 10);    ellipse(deadpoolX - 27, deadpoolY + 107, 25, 10);}',correct
'deadpoolX - 27',correct
'{    println(currentTime);    if (currentTime > previousTime + duration) {        previousTime = currentTime;        background(random(0, 255), random(0, 255), random(0, 255));        status = !status;    }}',correct
'rect(deadpoolX + 17, deadpoolY - 70, 10, 34);',correct
'width / 2',correct
'rect(deadpoolX + 65, deadpoolY - 65, 15, 40);',correct
'// feetellipse(deadpoolX + 27, deadpoolY + 107, 25, 10);',correct
'triangle(deadpoolX + 16, deadpoolY - 65, deadpoolX + 5, deadpoolY - 70, deadpoolX + 16, deadpoolY - 85)',correct
'TWO_PI + 0.13f * PI',correct
'pokeball = new wallpaper[1]',correct
'// pupil2ellipse(kabutoX + 82, kabutoY - 131, 4, 4);',correct
'random(175, height)',correct
'{    strokeWeight(2);    pushMatrix();    scale(0.5f);    // body    fill(0);    stroke(0);    rect(kabutoX, kabutoY, 200, 240);    fill(bodyColor);    arc(kabutoX, kabutoY, 310, 350, 0.75f * PI, TWO_PI + 0.25f * PI);    fill(255);    // belly    noStroke();    fill(160, 100, 70);    arc(kabutoX, kabutoY + 50, 243, 375, 0.88f * PI, TWO_PI + 0.12f * PI);    popMatrix();    pushMatrix();    scale(0.5f);    // forehead line    strokeWeight(2);    stroke(0);    line(kabutoX, kabutoY - 175, kabutoX, kabutoY + 100);    // shadows on body    fill(0);    noStroke();    arc(kabutoX, kabutoY + 50, 230, 350, 0.87f * PI, TWO_PI + 0.13f * PI);    popMatrix();    pushMatrix();    scale(0.5f);    // eyes    fill(0);    // fake-eye1    ellipse(kabutoX - 80, kabutoY - 130, 10, 10);    // fake-eye2    ellipse(kabutoX + 80, kabutoY - 130, 10, 10);    fill(255);    stroke(255);    // pupil1    ellipse(kabutoX - 82, kabutoY - 131, 4, 4);    // pupil2    ellipse(kabutoX + 82, kabutoY - 131, 4, 4);    strokeWeight(4);    stroke(230, 25, 110);    fill(230, 110, 160);    // eye1    ellipse(kabutoX - 50, kabutoY - 75, 40, 40);    // eye2    ellipse(kabutoX + 50, kabutoY - 75, 40, 40);    // legs    strokeWeight(2);    stroke(0);    fill(255, 200, 0);    // arm1right    quad(kabutoX + 50, kabutoY - 30, kabutoX + 150, kabutoY - 20, kabutoX + 120, kabutoY + 7, kabutoX + 50, kabutoY);    // arm1left    quad(kabutoX - 50, kabutoY - 30, kabutoX - 150, kabutoY - 20, kabutoX - 120, kabutoY + 7, kabutoX - 50, kabutoY);    // armright2    quad(kabutoX + 40, kabutoY + 40, kabutoX + 140, kabutoY + 60, kabutoX + 110, kabutoY + 84, kabutoX + 40, kabutoY + 70);    // armleft2    quad(kabutoX - 40, kabutoY + 40, kabutoX - 140, kabutoY + 60, kabutoX - 110, kabutoY + 84, kabutoX - 40, kabutoY + 70);    popMatrix();}',LongMethodRule
'kabutoY = initY',correct
'((kabutoX / 2 + 50) > width && speedX > 0) || (kabutoX < 155)',correct
'kabutoX + 120',correct
'kabutoX + 80',correct
'quad(kabutoX + 40, kabutoY + 40, kabutoX + 140, kabutoY + 60, kabutoX + 110, kabutoY + 84, kabutoX + 40, kabutoY + 70)',correct
'kabutoX + 82',correct
'0.88f',correct
'scale(0.5f);',correct
'{    speedX = -speedX;}',correct
'Kabutos[n].changeColor();',correct
'color(180, 120, 70)',correct
'ellipse(kabutoX - 50, kabutoY - 75, 40, 40)',correct
'backgroundC = 50',correct
'stroke(0);',correct
'stroke(0)',correct
'0.13f * PI',correct
'pushMatrix();',correct
'0.75f',correct
'0.87f',correct
'kabutoX + speedX',correct
'for (int n = 0; n < pokeball.length; n++) {    pokeball[n] = new wallpaper(width / 2, height / 2);}',correct
'{    if (value == 0) {        for (int n = 0; n < Kabutos.length; n++) {            Kabutos[n].changeColorBack();        }    }}',correct
'if (((kabutoY / 2 + 50) > height && speedY > 0) || (kabutoY < 180)) {    speedY = -speedY;}',correct
'{    for (int n = 0; n < pokeball.length; n++) {        pokeball[n] = new wallpaper(width / 2, height / 2);    }    for (int n = 0; n < Kabutos.length; n++) {        Kabutos[n] = new body(random(150, width + 200), random(175, height));    }}',correct
'fill(255, 0, 0);',correct
'ellipse(width / 2, height / 2, 130, 130)',correct
'arc(kabutoX, kabutoY + 50, 243, 375, 0.88f * PI, TWO_PI + 0.12f * PI)',correct
'rect(0, height, width * 2, height);',correct
'n = 0',correct
'0.87f * PI',correct
'// bodyfill(0);',correct
'Kabutos[n].moveVer()',correct
'fill(0);',correct
'// fake-eye2ellipse(kabutoX + 80, kabutoY - 130, 10, 10);',correct
'{    speedY = -speedY;}',correct
'n < pokeball.length',correct
'kabutoX + 140',correct
'n++',correct
'-speedY',correct
'kabutoX - 40',correct
'-speedX',correct
'new wallpaper[1]',correct
'Kabutos[n].changeColor()',correct
'kabutoX = initX;',correct
'body(float initX, float initY) {    kabutoX = initX;    kabutoY = initY;    rectMode(CENTER);    ellipseMode(CENTER);    backgroundC = 50;    bodyColor = color(180, 120, 70);    frameRate(120);}',correct
'fill(150);',correct
'color(0, 255, 0)',correct
'speedX = -speedX;',correct
'new body[69]',correct
'// shadows on bodyfill(0);',correct
'rect(0, 0, width * 2, height);',correct
'rectMode(CENTER)',correct
'Kabutos[n].moveHor()',correct
'g',correct
'if (((kabutoX / 2 + 50) > width && speedX > 0) || (kabutoX < 155)) {    speedX = -speedX;}',correct
'kabutoX + 150',correct
'popMatrix();',correct
'strokeWeight(2);',correct
'{    Kabutos[n].display();    Kabutos[n].moveVer();    Kabutos[n].moveHor();}',correct
'fill(160, 100, 70)',correct
'rectMode(CENTER);',correct
'wallpaper[]',correct
'noStroke()',correct
'speedY = -speedY',correct
'if (key == g) {    for (int n = 0; n < Kabutos.length; n++) {        Kabutos[n].changeColor();    }}',correct
'ellipse(width / 2, height / 2, 80, 80);',correct
'0.75f * PI',correct
'speedY = -speedY;',correct
'void moveVer() {    kabutoY = kabutoY + speedY;    if (((kabutoY / 2 + 50) > height && speedY > 0) || (kabutoY < 180)) {        speedY = -speedY;    }}',correct
'void keyPressed() {    if (keyPressed) {        if (key == g) {            for (int n = 0; n < Kabutos.length; n++) {                Kabutos[n].changeColor();            }        }    }}',correct
'for (int n = 0; n < Kabutos.length; n++) {    Kabutos[n].changeColorBack();}',correct
'{    ballX = initX;    ballY = initY;    ellipseMode(CENTER);    frameRate(60);}',correct
'ballY = initY;',correct
'ballY = initY',correct
'{    if (keyPressed) {        if (key == g) {            for (int n = 0; n < Kabutos.length; n++) {                Kabutos[n].changeColor();            }        }    }}',correct
'ellipse(width / 2, height / 2, 130, 130);',correct
'backgroundC = 50;',correct
'{    kabutoY = kabutoY + speedY;    if (((kabutoY / 2 + 50) > height && speedY > 0) || (kabutoY < 180)) {        speedY = -speedY;    }}',correct
'fill(bodyColor)',correct
'frameRate(120)',correct
'fill(255, 200, 0);',correct
'width + 200',correct
'// eye1ellipse(kabutoX - 50, kabutoY - 75, 40, 40);',correct
'kabutoY - 75',correct
'backgroundC',correct
'quad(kabutoX - 50, kabutoY - 30, kabutoX - 150, kabutoY - 20, kabutoX - 120, kabutoY + 7, kabutoX - 50, kabutoY)',correct
'kabutoX = kabutoX + speedX',correct
'Kabutos[n] = new body(random(150, width + 200), random(175, height))',correct
'strokeWeight(3);',correct
'ellipse(width / 2, height / 2, 200, 200);',correct
'kabutoX - 50',correct
'0.25f * PI',correct
'fill(0)',correct
'height / 2',correct
'bodyColor = color(180, 120, 70)',correct
'width * 2',correct
'frameRate(120);',correct
'fill(bodyColor);',correct
'Kabutos[n].display();',correct
'pokeball[n].display()',correct
'scale(0.5f)',correct
'{    Kabutos[n] = new body(random(150, width + 200), random(175, height));}',correct
'int bodyColor;',correct
'value == 0',correct
'fill(255)',correct
'Processing',correct
'pokeball[n] = new wallpaper(width / 2, height / 2);',correct
'kabutoX - 82',correct
'pushMatrix()',correct
'{    pokeball[n] = new wallpaper(width / 2, height / 2);}',correct
'{    for (int n = 0; n < Kabutos.length; n++) {        Kabutos[n].changeColor();    }}',correct
'for (int n = 0; n < Kabutos.length; n++) {    Kabutos[n].display();    Kabutos[n].moveVer();    Kabutos[n].moveHor();}',correct
'kabutoX - 80',correct
'Kabutos[n] = new body(random(150, width + 200), random(175, height));',correct
'{    kabutoX = initX;    kabutoY = initY;    rectMode(CENTER);    ellipseMode(CENTER);    backgroundC = 50;    bodyColor = color(180, 120, 70);    frameRate(120);}',correct
'arc(kabutoX, kabutoY, 310, 350, 0.75f * PI, TWO_PI + 0.25f * PI)',correct
'Kabutos[n].moveHor();',correct
'// armleft2quad(kabutoX - 40, kabutoY + 40, kabutoX - 140, kabutoY + 60, kabutoX - 110, kabutoY + 84, kabutoX - 40, kabutoY + 70);',correct
'speedX = random(10, 20)',correct
'strokeWeight(4);',correct
'kabutoX - 110',correct
'ellipseMode(CENTER);',correct
'{    pokeball[n].display();}',correct
'stroke(255)',correct
'TWO_PI + 0.12f * PI',correct
'{    for (int n = 0; n < Kabutos.length; n++) {        Kabutos[n].changeColorBack();    }}',correct
'kabutoY + speedY',correct
'kabutoY + 84',correct
'body[]',correct
'kabutoY - 20',correct
'for (int n = 0; n < Kabutos.length; n++) {    Kabutos[n] = new body(random(150, width + 200), random(175, height));}',correct
'fill(230, 110, 160);',correct
'rect(0, height, width * 2, height)',correct
'wallpaper[] pokeball = new wallpaper[1];',correct
'kabutoX - 120',correct
'Kabutos = new body[69]',correct
'stroke(230, 25, 110);',correct
'// arm1rightquad(kabutoX + 50, kabutoY - 30, kabutoX + 150, kabutoY - 20, kabutoX + 120, kabutoY + 7, kabutoX + 50, kabutoY);',correct
'pokeball[n]',correct
'fill(255, 255, 255);',correct
'float ballY;',correct
'// bellynoStroke();',correct
'// armright2quad(kabutoX + 40, kabutoY + 40, kabutoX + 140, kabutoY + 60, kabutoX + 110, kabutoY + 84, kabutoX + 40, kabutoY + 70);',correct
'0.12f',correct
'random(150, width + 200)',correct
'// arm1leftquad(kabutoX - 50, kabutoY - 30, kabutoX - 150, kabutoY - 20, kabutoX - 120, kabutoY + 7, kabutoX - 50, kabutoY);',correct
'// forehead linestrokeWeight(2);',correct
'random(10, 20)',correct
'body[] Kabutos = new body[69];',correct
'kabutoY - 30',correct
'speedY = random(10, 20)',correct
'ellipse(width / 2, height / 2, 200, 200)',correct
'kabutoX',correct
'kabutoY',correct
'void changeColorBack() {    bodyColor = color(180, 120, 70);}',correct
'{    bodyColor = color(180, 120, 70);}',correct
'n < Kabutos.length',correct
'{    Kabutos[n].changeColor();}',correct
'Kabutos[n].changeColorBack();',correct
'stroke(230, 25, 110)',correct
'{    kabutoX = kabutoX + speedX;    if (((kabutoX / 2 + 50) > width && speedX > 0) || (kabutoX < 155)) {        speedX = -speedX;    }}',correct
'int n = 0',correct
'line(kabutoX, kabutoY - 175, kabutoX, kabutoY + 100);',correct
'ellipse(kabutoX + 50, kabutoY - 75, 40, 40)',correct
'noStroke();',correct
'rect(kabutoX, kabutoY, 200, 240)',correct
'fill(255, 200, 0)',correct
'quad(kabutoX - 40, kabutoY + 40, kabutoX - 140, kabutoY + 60, kabutoX - 110, kabutoY + 84, kabutoX - 40, kabutoY + 70)',correct
'kabutoY + 60',correct
'key == g',correct
'frameRate(60);',correct
'kabutoX - 140',correct
'void draw() {    for (int n = 0; n < pokeball.length; n++) {        pokeball[n].display();    }    for (int n = 0; n < Kabutos.length; n++) {        Kabutos[n].display();        Kabutos[n].moveVer();        Kabutos[n].moveHor();    }}',correct
'kabutoY = kabutoY + speedY',correct
'arc(kabutoX, kabutoY, 310, 350, 0.75f * PI, TWO_PI + 0.25f * PI);',correct
'kabutoX = initX',correct
'// pupil1ellipse(kabutoX - 82, kabutoY - 131, 4, 4);',correct
'0.5f',correct
'Kabutos[n]',correct
'for (int n = 0; n < pokeball.length; n++) {    pokeball[n].display();}',correct
'bodyColor = color(0, 255, 0)',correct
'{    for (int n = 0; n < pokeball.length; n++) {        pokeball[n].display();    }    for (int n = 0; n < Kabutos.length; n++) {        Kabutos[n].display();        Kabutos[n].moveVer();        Kabutos[n].moveHor();    }}',correct
'speedX = -speedX',correct
'kabutoY + 70',correct
'display',LongMethodRule
'new body(random(150, width + 200), random(175, height))',correct
'{    if (key == g) {        for (int n = 0; n < Kabutos.length; n++) {            Kabutos[n].changeColor();        }    }}',correct
'kabutoY + 7',correct
'ellipse(width / 2, height / 2, 80, 80)',correct
'Kabutos[n].changeColorBack()',correct
'kabutoX - 150',correct
'kabutoY - 130',correct
'void keyReleased() {    if (value == 0) {        for (int n = 0; n < Kabutos.length; n++) {            Kabutos[n].changeColorBack();        }    }}',correct
'kabutoY - 131',correct
'rect(0, height / 2, width * 2, 40);',correct
'for (int n = 0; n < Kabutos.length; n++) {    Kabutos[n].changeColor();}',correct
'if (keyPressed) {    if (key == g) {        for (int n = 0; n < Kabutos.length; n++) {            Kabutos[n].changeColor();        }    }}',correct
'int value = 0;',correct
'0.13f',correct
'arc(kabutoX, kabutoY + 50, 243, 375, 0.88f * PI, TWO_PI + 0.12f * PI);',correct
'wallpaper(float initX, float initY) {    ballX = initX;    ballY = initY;    ellipseMode(CENTER);    frameRate(60);}',correct
'quad(kabutoX + 50, kabutoY - 30, kabutoX + 150, kabutoY - 20, kabutoX + 120, kabutoY + 7, kabutoX + 50, kabutoY)',correct
'// eyesfill(0);',correct
'0.25f',correct
'arc(kabutoX, kabutoY + 50, 230, 350, 0.87f * PI, TWO_PI + 0.13f * PI)',correct
'{    bodyColor = color(0, 255, 0);}',correct
'kabutoY + 40',correct
'fill(255, 0, 0)',correct
'new wallpaper(width / 2, height / 2)',correct
'float initX',correct
'float initY',correct
'ellipse(kabutoX + 80, kabutoY - 130, 10, 10)',correct
'body',correct
'0.12f * PI',correct
'fill(255);',correct
'ellipseMode(CENTER)',correct
'// fake-eye1ellipse(kabutoX - 80, kabutoY - 130, 10, 10);',correct
'kabutoX + 40',correct
'[69]',correct
'strokeWeight(3)',correct
'void display() {    strokeWeight(2);    pushMatrix();    scale(0.5f);    // body    fill(0);    stroke(0);    rect(kabutoX, kabutoY, 200, 240);    fill(bodyColor);    arc(kabutoX, kabutoY, 310, 350, 0.75f * PI, TWO_PI + 0.25f * PI);    fill(255);    // belly    noStroke();    fill(160, 100, 70);    arc(kabutoX, kabutoY + 50, 243, 375, 0.88f * PI, TWO_PI + 0.12f * PI);    popMatrix();    pushMatrix();    scale(0.5f);    // forehead line    strokeWeight(2);    stroke(0);    line(kabutoX, kabutoY - 175, kabutoX, kabutoY + 100);    // shadows on body    fill(0);    noStroke();    arc(kabutoX, kabutoY + 50, 230, 350, 0.87f * PI, TWO_PI + 0.13f * PI);    popMatrix();    pushMatrix();    scale(0.5f);    // eyes    fill(0);    // fake-eye1    ellipse(kabutoX - 80, kabutoY - 130, 10, 10);    // fake-eye2    ellipse(kabutoX + 80, kabutoY - 130, 10, 10);    fill(255);    stroke(255);    // pupil1    ellipse(kabutoX - 82, kabutoY - 131, 4, 4);    // pupil2    ellipse(kabutoX + 82, kabutoY - 131, 4, 4);    strokeWeight(4);    stroke(230, 25, 110);    fill(230, 110, 160);    // eye1    ellipse(kabutoX - 50, kabutoY - 75, 40, 40);    // eye2    ellipse(kabutoX + 50, kabutoY - 75, 40, 40);    // legs    strokeWeight(2);    stroke(0);    fill(255, 200, 0);    // arm1right    quad(kabutoX + 50, kabutoY - 30, kabutoX + 150, kabutoY - 20, kabutoX + 120, kabutoY + 7, kabutoX + 50, kabutoY);    // arm1left    quad(kabutoX - 50, kabutoY - 30, kabutoX - 150, kabutoY - 20, kabutoX - 120, kabutoY + 7, kabutoX - 50, kabutoY);    // armright2    quad(kabutoX + 40, kabutoY + 40, kabutoX + 140, kabutoY + 60, kabutoX + 110, kabutoY + 84, kabutoX + 40, kabutoY + 70);    // armleft2    quad(kabutoX - 40, kabutoY + 40, kabutoX - 140, kabutoY + 60, kabutoX - 110, kabutoY + 84, kabutoX - 40, kabutoY + 70);    popMatrix();}',correct
'fill(255, 255, 255)',correct
'value = 0',correct
'kabutoY = kabutoY + speedY;',correct
'ballX = initX;',correct
'void',correct
'float speedX = random(10, 20);',correct
'kabutoY + 50',correct
'void setup() {    for (int n = 0; n < pokeball.length; n++) {        pokeball[n] = new wallpaper(width / 2, height / 2);    }    for (int n = 0; n < Kabutos.length; n++) {        Kabutos[n] = new body(random(150, width + 200), random(175, height));    }}',correct
'ballY',correct
'arc(kabutoX, kabutoY + 50, 230, 350, 0.87f * PI, TWO_PI + 0.13f * PI);',correct
'ballX',correct
'float backgroundC;',correct
'{    Kabutos[n].changeColorBack();}',correct
'((kabutoY / 2 + 50) > height && speedY > 0) || (kabutoY < 180)',correct
'fill(160, 100, 70);',correct
'float speedY = random(10, 20);',correct
'TWO_PI + 0.25f * PI',correct
'kabutoX = kabutoX + speedX;',correct
'ballX = initX',correct
'0.88f * PI',correct
'strokeWeight(2)',correct
'bodyColor = color(0, 255, 0);',correct
'class body {    float kabutoX;    float kabutoY;    float speedX = random(10, 20);    float speedY = random(10, 20);    float backgroundC;    int bodyColor;    body(float initX, float initY) {        kabutoX = initX;        kabutoY = initY;        rectMode(CENTER);        ellipseMode(CENTER);        backgroundC = 50;        bodyColor = color(180, 120, 70);        frameRate(120);    }    void display() {        strokeWeight(2);        pushMatrix();        scale(0.5f);        // body        fill(0);        stroke(0);        rect(kabutoX, kabutoY, 200, 240);        fill(bodyColor);        arc(kabutoX, kabutoY, 310, 350, 0.75f * PI, TWO_PI + 0.25f * PI);        fill(255);        // belly        noStroke();        fill(160, 100, 70);        arc(kabutoX, kabutoY + 50, 243, 375, 0.88f * PI, TWO_PI + 0.12f * PI);        popMatrix();        pushMatrix();        scale(0.5f);        // forehead line        strokeWeight(2);        stroke(0);        line(kabutoX, kabutoY - 175, kabutoX, kabutoY + 100);        // shadows on body        fill(0);        noStroke();        arc(kabutoX, kabutoY + 50, 230, 350, 0.87f * PI, TWO_PI + 0.13f * PI);        popMatrix();        pushMatrix();        scale(0.5f);        // eyes        fill(0);        // fake-eye1        ellipse(kabutoX - 80, kabutoY - 130, 10, 10);        // fake-eye2        ellipse(kabutoX + 80, kabutoY - 130, 10, 10);        fill(255);        stroke(255);        // pupil1        ellipse(kabutoX - 82, kabutoY - 131, 4, 4);        // pupil2        ellipse(kabutoX + 82, kabutoY - 131, 4, 4);        strokeWeight(4);        stroke(230, 25, 110);        fill(230, 110, 160);        // eye1        ellipse(kabutoX - 50, kabutoY - 75, 40, 40);        // eye2        ellipse(kabutoX + 50, kabutoY - 75, 40, 40);        // legs        strokeWeight(2);        stroke(0);        fill(255, 200, 0);        // arm1right        quad(kabutoX + 50, kabutoY - 30, kabutoX + 150, kabutoY - 20, kabutoX + 120, kabutoY + 7, kabutoX + 50, kabutoY);        // arm1left        quad(kabutoX - 50, kabutoY - 30, kabutoX - 150, kabutoY - 20, kabutoX - 120, kabutoY + 7, kabutoX - 50, kabutoY);        // armright2        quad(kabutoX + 40, kabutoY + 40, kabutoX + 140, kabutoY + 60, kabutoX + 110, kabutoY + 84, kabutoX + 40, kabutoY + 70);        // armleft2        quad(kabutoX - 40, kabutoY + 40, kabutoX - 140, kabutoY + 60, kabutoX - 110, kabutoY + 84, kabutoX - 40, kabutoY + 70);        popMatrix();    }    void changeColor() {        bodyColor = color(0, 255, 0);    }    void changeColorBack() {        bodyColor = color(180, 120, 70);    }    void moveHor() {        kabutoX = kabutoX + speedX;        if (((kabutoX / 2 + 50) > width && speedX > 0) || (kabutoX < 155)) {            speedX = -speedX;        }    }    void moveVer() {        kabutoY = kabutoY + speedY;        if (((kabutoY / 2 + 50) > height && speedY > 0) || (kabutoY < 180)) {            speedY = -speedY;        }    }}',correct
'bodyColor = color(180, 120, 70);',correct
'bodyColor',correct
'rect(0, height / 2, width * 2, 40)',correct
'popMatrix()',correct
'stroke(255);',correct
'void display() {    noStroke();    fill(255, 0, 0);    rect(0, 0, width * 2, height);    fill(255, 255, 255);    rect(0, height, width * 2, height);    fill(0);    rect(0, height / 2, width * 2, 40);    ellipse(width / 2, height / 2, 200, 200);    fill(150);    stroke(0);    strokeWeight(3);    ellipse(width / 2, height / 2, 130, 130);    ellipse(width / 2, height / 2, 80, 80);}',correct
'float kabutoY;',correct
'pokeball.length',correct
'Kabutos[n].display()',correct
'ellipse(kabutoX - 82, kabutoY - 131, 4, 4)',correct
'pokeball[n].display();',correct
'frameRate(60)',correct
'kabutoY = initY;',correct
'void changeColor() {    bodyColor = color(0, 255, 0);}',correct
'class wallpaper {    float ballX;    float ballY;    wallpaper(float initX, float initY) {        ballX = initX;        ballY = initY;        ellipseMode(CENTER);        frameRate(60);    }    void display() {        noStroke();        fill(255, 0, 0);        rect(0, 0, width * 2, height);        fill(255, 255, 255);        rect(0, height, width * 2, height);        fill(0);        rect(0, height / 2, width * 2, 40);        ellipse(width / 2, height / 2, 200, 200);        fill(150);        stroke(0);        strokeWeight(3);        ellipse(width / 2, height / 2, 130, 130);        ellipse(width / 2, height / 2, 80, 80);    }}',correct
'rect(0, 0, width * 2, height)',correct
'wallpaper',correct
'[1]',correct
'line(kabutoX, kabutoY - 175, kabutoX, kabutoY + 100)',correct
'void moveHor() {    kabutoX = kabutoX + speedX;    if (((kabutoX / 2 + 50) > width && speedX > 0) || (kabutoX < 155)) {        speedX = -speedX;    }}',correct
'Kabutos.length',correct
'ellipse(kabutoX - 80, kabutoY - 130, 10, 10)',correct
'kabutoX + 110',correct
'float kabutoX;',correct
'Kabutos[n].moveVer();',correct
'width / 2',correct
'if (value == 0) {    for (int n = 0; n < Kabutos.length; n++) {        Kabutos[n].changeColorBack();    }}',correct
'{    noStroke();    fill(255, 0, 0);    rect(0, 0, width * 2, height);    fill(255, 255, 255);    rect(0, height, width * 2, height);    fill(0);    rect(0, height / 2, width * 2, 40);    ellipse(width / 2, height / 2, 200, 200);    fill(150);    stroke(0);    strokeWeight(3);    ellipse(width / 2, height / 2, 130, 130);    ellipse(width / 2, height / 2, 80, 80);}',correct
'fill(150)',correct
'strokeWeight(4)',correct
'pokeball[n] = new wallpaper(width / 2, height / 2)',correct
'kabutoX + 50',correct
'kabutoY - 175',correct
'kabutoY + 100',correct
'float ballX;',correct
'rect(kabutoX, kabutoY, 200, 240);',correct
'ellipse(kabutoX + 82, kabutoY - 131, 4, 4)',correct
'fill(230, 110, 160)',correct
'// eye2ellipse(kabutoX + 50, kabutoY - 75, 40, 40);',correct
'// legsstrokeWeight(2);',correct
'B.move()',correct
'{    // --------------bird-----------------------//    noStroke();    // leg    fill(255, 140, 10);    rect(birdX - sizeBirdX * 15, birdY, sizeBirdX * 7, sizeBirdY * 50);    rect(birdX - sizeBirdX * 18, birdY + sizeBirdY * 45, sizeBirdX * 20, sizeBirdY * 5);    // println("leg drawn");    // beack    fill(255, 255, 0);    triangle(birdX, birdY, birdX, birdY + sizeBirdY * 20, birdX + sizeBirdX * 30, birdY);    fill(255, 100, 0);    triangle(birdX, birdY - sizeBirdY * 20, birdX, birdY, birdX + sizeBirdX * 45, birdY);    // println("beack drawn");    // body    fill(20, 150, 0);    triangle(birdX - sizeBirdX * 110, birdY + sizeBirdY * 10, birdX, birdY + sizeBirdY * 30, birdX, birdY - sizeBirdY * 35);    // println("body drawn");    // wing    fill(10, 200, 0);    triangle(birdX - sizeBirdX * 20, birdY - sizeBirdY * 15, birdX - sizeBirdX * 28, birdY + sizeBirdY * 15, birdX - sizeBirdX * 80, birdY + sizeBirdY * 10);    // println("wing drawn");    // head    fill(5, 100, 15);    triangle(birdX, birdY + sizeBirdY * 20, birdX, birdY - sizeBirdY * 20, birdX - sizeBirdX * 40, birdY);    // println("head drawn");    // eye    // white part    fill(255, 255, 255);    triangle(birdX - sizeBirdX * 10, birdY + sizeBirdY * 10, birdX - sizeBirdX * 30, birdY, birdX - sizeBirdX * 10, birdY - sizeBirdY * 10);    // black part    fill(0);    triangle(birdX - sizeBirdX * 13, birdY - sizeBirdY * 3, birdX - sizeBirdX * 13, birdY + sizeBirdY * 3, birdX - sizeBirdX * 23, birdY);// println("eye drawn");}',correct
'B.move();',correct
'W = new World()',correct
'triangle(birdX, birdY, birdX, birdY + sizeBirdY * 20, birdX + sizeBirdX * 30, birdY);',correct
'// println("eye drawn");',correct
'if (sizeBirdX >= 0) {    sizeBirdX = -1 * sizeBirdX;    println("left");}',AvoidDeeplyNestedIfStmts
'{    if (key == CODED) {        if (keyCode == RIGHT) {            birdX = birdX + 30;            if (sizeBirdX < 0) {                sizeBirdX = sizeBirdX * -1;                println("right");            }        }        if (keyCode == LEFT) {            birdX = birdX - 30;            if (sizeBirdX >= 0) {                sizeBirdX = -1 * sizeBirdX;                println("left");            }        }    }}',correct
'sizeBirdY * 20',correct
'Bird B;',ShortVariable
'sizeBirdX * 7',correct
'int groundlevel;',correct
'sizeBirdX = sizeBirdX * -1;',correct
'// println("leg drawn");',correct
'new World()',correct
'sizeBirdX * 80',correct
'B.jump()',correct
'sizeBirdX = -1 * sizeBirdX',correct
'gravity = gravity * 1.05f',correct
'World W;',ShortVariable
'gravity * 1.05f',correct
'sizeBirdY * 15',correct
'gravity = gravity * 1.05f;',correct
'sizeBirdY * 10',correct
'// println("body drawn");',correct
'birdY = birdY - 100',correct
'"left"',correct
'B',correct
'triangle(birdX, birdY + sizeBirdY * 20, birdX, birdY - sizeBirdY * 20, birdX - sizeBirdX * 40, birdY)',correct
'// println("leg drawn");// beackfill(255, 255, 0);',correct
'sizeBirdX = sBX;',correct
'// println("wing drawn");',correct
'float sBY',correct
'float sBX',correct
'// println("wing drawn");// headfill(5, 100, 15);',correct
'groundlevel = 630',correct
'sizeBirdY * 45',correct
'W',correct
'// println("head drawn");',correct
'// println("bird on the ground");',correct
'groundlevel',correct
'class Bird {    float gravity;    float birdX;    float birdY;    float time;    float sizeBirdX;    float sizeBirdY;    Bird(float bX, float bY, float sBX, float sBY) {        birdX = bX;        birdY = bY;        sizeBirdX = sBX;        sizeBirdY = sBY;        time = 0;        gravity = 0.1f;    }    void display() {        // --------------bird-----------------------//        noStroke();        // leg        fill(255, 140, 10);        rect(birdX - sizeBirdX * 15, birdY, sizeBirdX * 7, sizeBirdY * 50);        rect(birdX - sizeBirdX * 18, birdY + sizeBirdY * 45, sizeBirdX * 20, sizeBirdY * 5);        // println("leg drawn");        // beack        fill(255, 255, 0);        triangle(birdX, birdY, birdX, birdY + sizeBirdY * 20, birdX + sizeBirdX * 30, birdY);        fill(255, 100, 0);        triangle(birdX, birdY - sizeBirdY * 20, birdX, birdY, birdX + sizeBirdX * 45, birdY);        // println("beack drawn");        // body        fill(20, 150, 0);        triangle(birdX - sizeBirdX * 110, birdY + sizeBirdY * 10, birdX, birdY + sizeBirdY * 30, birdX, birdY - sizeBirdY * 35);        // println("body drawn");        // wing        fill(10, 200, 0);        triangle(birdX - sizeBirdX * 20, birdY - sizeBirdY * 15, birdX - sizeBirdX * 28, birdY + sizeBirdY * 15, birdX - sizeBirdX * 80, birdY + sizeBirdY * 10);        // println("wing drawn");        // head        fill(5, 100, 15);        triangle(birdX, birdY + sizeBirdY * 20, birdX, birdY - sizeBirdY * 20, birdX - sizeBirdX * 40, birdY);        // println("head drawn");        // eye        // white part        fill(255, 255, 255);        triangle(birdX - sizeBirdX * 10, birdY + sizeBirdY * 10, birdX - sizeBirdX * 30, birdY, birdX - sizeBirdX * 10, birdY - sizeBirdY * 10);        // black part        fill(0);        triangle(birdX - sizeBirdX * 13, birdY - sizeBirdY * 3, birdX - sizeBirdX * 13, birdY + sizeBirdY * 3, birdX - sizeBirdX * 23, birdY);    // println("eye drawn");    }    void move() {        if (key == CODED) {            if (keyCode == RIGHT) {                birdX = birdX + 30;                if (sizeBirdX < 0) {                    sizeBirdX = sizeBirdX * -1;                    println("right");                }            }            if (keyCode == LEFT) {                birdX = birdX - 30;                if (sizeBirdX >= 0) {                    sizeBirdX = -1 * sizeBirdX;                    println("left");                }            }        }    }    void jump() {        if (key == CODED) {            if (keyCode == UP) {                gravity = 1;                birdY = birdY - 100;                println("jump");            }        }    }    void update() {        if (birdY >= W.groundlevel - 50) {            birdY = W.groundlevel - 50;        // println("bird on the ground");        } else {            birdY = birdY + gravity;        }        gravity = gravity * 1.05f;    }}',correct
'birdY = birdY + gravity;',correct
'fill(255, 100, 0);',correct
'birdY - sizeBirdY * 3',correct
'birdX - sizeBirdX * 110',correct
'W = new World();',correct
'// println("beack drawn");// bodyfill(20, 150, 0);',correct
'birdX = birdX - 30',correct
'// legfill(255, 140, 10);',correct
'{    if (birdY >= W.groundlevel - 50) {        birdY = W.groundlevel - 50;    // println("bird on the ground");    } else {        birdY = birdY + gravity;    }    gravity = gravity * 1.05f;}',correct
'sizeBirdY * 35',correct
'birdY = bY',correct
'sizeBirdY * 30',correct
'B.display()',correct
'sizeBirdX = sizeBirdX * -1',correct
'println("jump")',correct
'noStroke()',correct
'if (keyCode == LEFT) {    birdX = birdX - 30;    if (sizeBirdX >= 0) {        sizeBirdX = -1 * sizeBirdX;        println("left");    }}',correct
'birdX = bX;',correct
'sizeBirdX * -1',correct
'{    if (keyCode == RIGHT) {        birdX = birdX + 30;        if (sizeBirdX < 0) {            sizeBirdX = sizeBirdX * -1;            println("right");        }    }    if (keyCode == LEFT) {        birdX = birdX - 30;        if (sizeBirdX >= 0) {            sizeBirdX = -1 * sizeBirdX;            println("left");        }    }}',correct
'{    birdX = birdX + 30;    if (sizeBirdX < 0) {        sizeBirdX = sizeBirdX * -1;        println("right");    }}',correct
'{    birdY = birdY + gravity;}',correct
'float gravity;',correct
'void draw() {    W.display();    B.display();    B.update();}',correct
'sizeBirdY * 5',correct
'sizeBirdY * 3',correct
'rect(birdX - sizeBirdX * 15, birdY, sizeBirdX * 7, sizeBirdY * 50);',correct
'void display() {    background(50, 50, 200);    fill(0, 200, 0);    rect(0, groundlevel, width, 100);}',correct
'{    birdY = W.groundlevel - 50;// println("bird on the ground");}',correct
'void display() {    // --------------bird-----------------------//    noStroke();    // leg    fill(255, 140, 10);    rect(birdX - sizeBirdX * 15, birdY, sizeBirdX * 7, sizeBirdY * 50);    rect(birdX - sizeBirdX * 18, birdY + sizeBirdY * 45, sizeBirdX * 20, sizeBirdY * 5);    // println("leg drawn");    // beack    fill(255, 255, 0);    triangle(birdX, birdY, birdX, birdY + sizeBirdY * 20, birdX + sizeBirdX * 30, birdY);    fill(255, 100, 0);    triangle(birdX, birdY - sizeBirdY * 20, birdX, birdY, birdX + sizeBirdX * 45, birdY);    // println("beack drawn");    // body    fill(20, 150, 0);    triangle(birdX - sizeBirdX * 110, birdY + sizeBirdY * 10, birdX, birdY + sizeBirdY * 30, birdX, birdY - sizeBirdY * 35);    // println("body drawn");    // wing    fill(10, 200, 0);    triangle(birdX - sizeBirdX * 20, birdY - sizeBirdY * 15, birdX - sizeBirdX * 28, birdY + sizeBirdY * 15, birdX - sizeBirdX * 80, birdY + sizeBirdY * 10);    // println("wing drawn");    // head    fill(5, 100, 15);    triangle(birdX, birdY + sizeBirdY * 20, birdX, birdY - sizeBirdY * 20, birdX - sizeBirdX * 40, birdY);    // println("head drawn");    // eye    // white part    fill(255, 255, 255);    triangle(birdX - sizeBirdX * 10, birdY + sizeBirdY * 10, birdX - sizeBirdX * 30, birdY, birdX - sizeBirdX * 10, birdY - sizeBirdY * 10);    // black part    fill(0);    triangle(birdX - sizeBirdX * 13, birdY - sizeBirdY * 3, birdX - sizeBirdX * 13, birdY + sizeBirdY * 3, birdX - sizeBirdX * 23, birdY);// println("eye drawn");}',correct
'rect(birdX - sizeBirdX * 18, birdY + sizeBirdY * 45, sizeBirdX * 20, sizeBirdY * 5)',correct
'triangle(birdX - sizeBirdX * 110, birdY + sizeBirdY * 10, birdX, birdY + sizeBirdY * 30, birdX, birdY - sizeBirdY * 35);',correct
'rect(0, groundlevel, width, 100);',PixelHardcodeIgnoranceRule
'sizeBirdX < 0',correct
'key == CODED',correct
'birdY = W.groundlevel - 50',correct
'// println("body drawn");// wingfill(10, 200, 0);',correct
'float birdY;',correct
'// println("head drawn");// eye// white partfill(255, 255, 255);',correct
'float birdX;',correct
'triangle(birdX, birdY - sizeBirdY * 20, birdX, birdY, birdX + sizeBirdX * 45, birdY)',correct
'fill(0)',correct
'background(50, 50, 200)',correct
'birdY >= W.groundlevel - 50',correct
'groundlevel = 630;',correct
'triangle(birdX - sizeBirdX * 110, birdY + sizeBirdY * 10, birdX, birdY + sizeBirdY * 30, birdX, birdY - sizeBirdY * 35)',correct
'// println("beack drawn");',correct
'{    birdX = birdX - 30;    if (sizeBirdX >= 0) {        sizeBirdX = -1 * sizeBirdX;        println("left");    }}',correct
'W.display();',correct
'class World {    int groundlevel;    World() {        groundlevel = 630;    }    void display() {        background(50, 50, 200);        fill(0, 200, 0);        rect(0, groundlevel, width, 100);    }}',correct
'B.update();',correct
'sizeBirdY * 50',correct
'if (keyCode == UP) {    gravity = 1;    birdY = birdY - 100;    println("jump");}',correct
'sizeBirdX',correct
'sizeBirdY',correct
'"jump"',correct
'background(50, 50, 200);',correct
'0.1f',correct
'Bird',correct
'triangle(birdX - sizeBirdX * 20, birdY - sizeBirdY * 15, birdX - sizeBirdX * 28, birdY + sizeBirdY * 15, birdX - sizeBirdX * 80, birdY + sizeBirdY * 10)',correct
'gravity = 1;',correct
'update',correct
'void setup() {    B = new Bird(900, 500, 1, 1);    W = new World();}',correct
'birdY - sizeBirdY * 35',correct
'// black partfill(0);',correct
'Processing',correct
'birdY = W.groundlevel - 50;',correct
'time = 0;',correct
'birdX + sizeBirdX * 30',correct
'triangle(birdX - sizeBirdX * 10, birdY + sizeBirdY * 10, birdX - sizeBirdX * 30, birdY, birdX - sizeBirdX * 10, birdY - sizeBirdY * 10)',correct
'triangle(birdX - sizeBirdX * 13, birdY - sizeBirdY * 3, birdX - sizeBirdX * 13, birdY + sizeBirdY * 3, birdX - sizeBirdX * 23, birdY);',correct
'B.display();',correct
'birdX = birdX + 30;',correct
'gravity',correct
'Bird(float bX, float bY, float sBX, float sBY) {    birdX = bX;    birdY = bY;    sizeBirdX = sBX;    sizeBirdY = sBY;    time = 0;    gravity = 0.1f;}',correct
'birdX + sizeBirdX * 45',correct
'time',correct
'W.groundlevel - 50',correct
'sizeBirdX * 13',correct
'fill(10, 200, 0)',correct
'gravity = 0.1f;',correct
'sizeBirdX * 15',correct
'sizeBirdX * 18',correct
'World() {    groundlevel = 630;}',correct
'birdY - sizeBirdY * 10',correct
'sizeBirdX * 110',correct
'1.05f',correct
'birdY = bY;',correct
'sizeBirdX * 10',correct
'birdY - sizeBirdY * 15',correct
'birdX - sizeBirdX * 40',correct
'triangle(birdX - sizeBirdX * 20, birdY - sizeBirdY * 15, birdX - sizeBirdX * 28, birdY + sizeBirdY * 15, birdX - sizeBirdX * 80, birdY + sizeBirdY * 10);',correct
'triangle(birdX, birdY, birdX, birdY + sizeBirdY * 20, birdX + sizeBirdX * 30, birdY)',correct
'println("left");',correct
'sizeBirdY = sBY',correct
'fill(20, 150, 0)',correct
'birdY - sizeBirdY * 20',correct
'keyCode == LEFT',correct
'birdX',correct
'time = 0',correct
'birdX - sizeBirdX * 30',correct
'W.groundlevel',correct
'sizeBirdX >= 0',correct
'fill(0, 200, 0);',correct
'birdY = birdY - 100;',correct
'birdY + gravity',correct
'"right"',correct
'{    birdX = bX;    birdY = bY;    sizeBirdX = sBX;    sizeBirdY = sBY;    time = 0;    gravity = 0.1f;}',correct
'new Bird(900, 500, 1, 1)',correct
'triangle(birdX - sizeBirdX * 13, birdY - sizeBirdY * 3, birdX - sizeBirdX * 13, birdY + sizeBirdY * 3, birdX - sizeBirdX * 23, birdY)',correct
'float sizeBirdY;',correct
'birdX - sizeBirdX * 28',correct
'println("left")',correct
'// --------------bird-----------------------//noStroke();',correct
'keyCode == UP',correct
'birdX - sizeBirdX * 20',correct
'birdX - sizeBirdX * 23',correct
'birdX + 30',correct
'birdY',correct
'birdY - 100',correct
'fill(0, 200, 0)',correct
'keyCode == RIGHT',correct
'fill(5, 100, 15)',correct
'float sizeBirdX;',correct
'{    B.move();    B.jump();}',correct
'triangle(birdX, birdY + sizeBirdY * 20, birdX, birdY - sizeBirdY * 20, birdX - sizeBirdX * 40, birdY);',correct
'println("right")',correct
'display',correct
'if (birdY >= W.groundlevel - 50) {    birdY = W.groundlevel - 50;// println("bird on the ground");} else {    birdY = birdY + gravity;}',correct
'sizeBirdY = sBY;',correct
'birdX - sizeBirdX * 15',correct
'{    gravity = 1;    birdY = birdY - 100;    println("jump");}',correct
'birdX - sizeBirdX * 18',correct
'if (sizeBirdX < 0) {    sizeBirdX = sizeBirdX * -1;    println("right");}',AvoidDeeplyNestedIfStmts
'if (key == CODED) {    if (keyCode == RIGHT) {        birdX = birdX + 30;        if (sizeBirdX < 0) {            sizeBirdX = sizeBirdX * -1;            println("right");        }    }    if (keyCode == LEFT) {        birdX = birdX - 30;        if (sizeBirdX >= 0) {            sizeBirdX = -1 * sizeBirdX;            println("left");        }    }}',correct
'birdX - sizeBirdX * 10',correct
'birdX - sizeBirdX * 13',correct
'println("right");',correct
'gravity = 0.1f',correct
'println("jump");',correct
'{    sizeBirdX = sizeBirdX * -1;    println("right");}',correct
'if (key == CODED) {    if (keyCode == UP) {        gravity = 1;        birdY = birdY - 100;        println("jump");    }}',correct
'{    background(50, 50, 200);    fill(0, 200, 0);    rect(0, groundlevel, width, 100);}',correct
'B.jump();',correct
'World',correct
'birdY + sizeBirdY * 15',correct
'fill(255, 255, 0)',correct
'birdX - 30',correct
'birdY + sizeBirdY * 10',correct
'{    if (key == CODED) {        if (keyCode == UP) {            gravity = 1;            birdY = birdY - 100;            println("jump");        }    }}',correct
'triangle(birdX, birdY - sizeBirdY * 20, birdX, birdY, birdX + sizeBirdX * 45, birdY);',correct
'B = new Bird(900, 500, 1, 1)',correct
'fill(255, 255, 255)',correct
'birdX - sizeBirdX * 80',correct
'sizeBirdX * 45',correct
'void',correct
'-1',correct
'fill(255, 100, 0)',correct
'B.update()',correct
'{    sizeBirdX = -1 * sizeBirdX;    println("left");}',correct
'{    if (keyCode == UP) {        gravity = 1;        birdY = birdY - 100;        println("jump");    }}',correct
'birdX = birdX + 30',correct
'birdY = birdY + gravity',correct
'B = new Bird(900, 500, 1, 1);',correct
'sizeBirdX * 40',correct
'void update() {    if (birdY >= W.groundlevel - 50) {        birdY = W.groundlevel - 50;    // println("bird on the ground");    } else {        birdY = birdY + gravity;    }    gravity = gravity * 1.05f;}',correct
'// eye',correct
'float bX',correct
'float bY',correct
'birdY + sizeBirdY * 20',correct
'gravity = 1',correct
'sizeBirdX = -1 * sizeBirdX;',correct
'if (keyCode == RIGHT) {    birdX = birdX + 30;    if (sizeBirdX < 0) {        sizeBirdX = sizeBirdX * -1;        println("right");    }}',correct
'triangle(birdX - sizeBirdX * 10, birdY + sizeBirdY * 10, birdX - sizeBirdX * 30, birdY, birdX - sizeBirdX * 10, birdY - sizeBirdY * 10);',correct
'-1 * sizeBirdX',correct
'rect(birdX - sizeBirdX * 15, birdY, sizeBirdX * 7, sizeBirdY * 50)',correct
'void jump() {    if (key == CODED) {        if (keyCode == UP) {            gravity = 1;            birdY = birdY - 100;            println("jump");        }    }}',correct
'fill(255, 140, 10)',correct
'birdY + sizeBirdY * 3',correct
'{    W.display();    B.display();    B.update();}',correct
'W.display()',correct
'birdX = birdX - 30;',correct
'{    B = new Bird(900, 500, 1, 1);    W = new World();}',correct
'sizeBirdX * 30',correct
'void keyPressed() {    B.move();    B.jump();}',correct
'float time;',correct
'rect(0, groundlevel, width, 100)',correct
'birdY + sizeBirdY * 30',correct
'birdX = bX',correct
'rect(birdX - sizeBirdX * 18, birdY + sizeBirdY * 45, sizeBirdX * 20, sizeBirdY * 5);',correct
'sizeBirdX * 23',correct
'sizeBirdX * 28',correct
'{    groundlevel = 630;}',correct
'sizeBirdX * 20',correct
'birdY + sizeBirdY * 45',correct
'sizeBirdX = sBX',correct
'void move() {    if (key == CODED) {        if (keyCode == RIGHT) {            birdX = birdX + 30;            if (sizeBirdX < 0) {                sizeBirdX = sizeBirdX * -1;                println("right");            }        }        if (keyCode == LEFT) {            birdX = birdX - 30;            if (sizeBirdX >= 0) {                sizeBirdX = -1 * sizeBirdX;                println("left");            }        }    }}',correct
'{    fill(255, 255, 255);    textSize(30);    textAlign(CENTER);    stroke(255, 255, 255);    text("or not", 200, 30);}',correct
'BodyA.ChangeColorback()',correct
'text("I belief I can fly!!", 200, 30);',PixelHardcodeIgnoranceRule
'ufoX = initX;',correct
'Ufo UfoA;',correct
'creatureY + 135',correct
'UfoA',correct
'UfoB',correct
'void fly() {    heady = heady - 5;    flytext = true;}',correct
'{    BodyA.ChangeColorback();}',correct
'Ufomove = false',correct
'// arms',correct
'stroke(255, 255, 255);',correct
'rect(headx, heady - 100, 80, 40);',correct
'ufoX + 50',correct
'flybacktext = true;',correct
'ufoX',correct
'ufoY',correct
'heady = heady + 5',correct
'arc(ufoX, ufoY, 100, 80, PI, TWO_PI)',correct
'UfoB.display()',correct
'arc(headx - 30, heady - 100, 50, 50, HALF_PI, PI)',correct
'void ChangeColorback() {    bodyColor1 = color(255, 170, 40);    bodyColor2 = color(200, 0, 0);}',MethodNamingConventions
'dist(mouseX, mouseY, creatureX, creatureY, headx, heady)',correct
'if (key == v) {    BodyA.ChangeColorback();}',correct
'// mouthfill(bodyColor2);',correct
'void keyReleased() {    if (key == g) {        BodyA.flybacktextoff();    }    if (key == h) {        BodyA.flytextoff();    }}',correct
'stroke(150, 150, 150)',correct
'quad(headx, heady - 45, headx + 23, heady - 20, headx + 20, heady - 45, headx + 10, heady - 45);',correct
'creatureX',correct
'quad(ufoX - 10, ufoY, ufoX - 50, ufoY + 100, ufoX + 50, ufoY + 100, ufoX + 10, ufoY)',correct
'// flamefill(255, 0, 0);',correct
'boolean flytext = false;',correct
'creatureY',correct
'UfoA.beam();',correct
'stroke(0, 255, 0);',correct
'textAlign(CENTER)',correct
'ellipse(headx + 30, heady - 120, 20, 20);',correct
'quad(headx - 10, heady - 45, headx + 13, heady - 20, headx + 10, heady - 45, headx, heady - 45)',correct
'{    UfoA.beam();    UfoB.beam();}',correct
'beam == false',correct
'rect(creatureX + 80, creatureY - 20, 20, 50)',correct
'{    UfoA.move(mouseX, mouseY);    UfoB.move(mouseX, mouseY);}',correct
'stroke(bodyColor1);',correct
'{    // mouth    fill(bodyColor2);    stroke(bodyColor2);    rect(headx, heady - 100, 80, 40);    fill(bodyColor1);    stroke(bodyColor1);    // head    rect(headx, heady - 60, 60, 40);    arc(headx + 30, heady - 100, 50, 50, 0, HALF_PI);    arc(headx - 30, heady - 100, 50, 50, HALF_PI, PI);    rect(headx, heady - 130, 110, 70);    fill(bodyColor2);    stroke(bodyColor2);    ellipse(headx - 55, heady - 160, 40, 40);    ellipse(headx + 55, heady - 160, 40, 40);    rect(headx, heady - 160, 40, 10);    // eyes    fill(bodyColor2);    stroke(bodyColor2);    ellipse(headx - 30, heady - 120, 20, 20);    ellipse(headx + 30, heady - 120, 20, 20);    fill(bodyColor1);    stroke(bodyColor1);    ellipse(headx - 30, heady - 120, 10, 10);    ellipse(headx + 30, heady - 120, 10, 10);    // flame    fill(255, 0, 0);    stroke(255, 0, 0);    quad(headx - 30, heady - 45, headx - 32, heady - 20, headx - 10, heady - 45, headx - 20, heady - 45);    quad(headx - 20, heady - 45, headx - 22, heady - 20, headx, heady - 45, headx - 10, heady - 45);    quad(headx - 10, heady - 45, headx - 12, heady - 20, headx + 10, heady - 45, headx, heady - 45);    quad(headx + 10, heady - 45, headx + 33, heady - 20, headx + 30, heady - 45, headx + 20, heady - 45);    quad(headx, heady - 45, headx + 23, heady - 20, headx + 20, heady - 45, headx + 10, heady - 45);    quad(headx - 10, heady - 45, headx + 13, heady - 20, headx + 10, heady - 45, headx, heady - 45);    stroke(bodyColor1);    fill(bodyColor1);    // legs    fill(bodyColor2);    stroke(bodyColor2);    rect(creatureX + 50, creatureY + 75, 30, 100);    rect(creatureX - 50, creatureY + 75, 30, 100);    arc(creatureX + 50, creatureY + 30, 30, 50, PI + HALF_PI, TWO_PI);    arc(creatureX - 50, creatureY + 30, 30, 50, PI, PI + HALF_PI);    fill(bodyColor1);    stroke(bodyColor1);    rect(creatureX + 50, creatureY + 135, 50, 20);    rect(creatureX - 50, creatureY + 135, 50, 20);    // body    rect(creatureX, creatureY, 100, 120);    fill(bodyColor2);    stroke(bodyColor2);    rect(creatureX, creatureY + 35, 100, 60);    rect(creatureX, creatureY, 20, 120);    arc(creatureX + 10, creatureY + 10, 50, 50, PI + HALF_PI, TWO_PI);    arc(creatureX - 10, creatureY + 10, 50, 50, PI, PI + HALF_PI);    fill(bodyColor1);    stroke(bodyColor1);    // arms    rect(creatureX - 80, creatureY - 20, 20, 50);    rect(creatureX + 80, creatureY - 20, 20, 50);    fill(bodyColor1);    arc(creatureX + 70, creatureY - 40, 40, 40, PI + HALF_PI, TWO_PI);    arc(creatureX - 70, creatureY - 40, 40, 40, PI, PI + HALF_PI);    rect(creatureX - 45, creatureY - 50, 50, 20);    rect(creatureX + 45, creatureY - 50, 50, 20);}',LongMethodRule
'rectMode(CENTER)',correct
'{    heady = heady + 5;    flybacktext = true;}',correct
'b',correct
'if (key == c) {    BodyA.changeColor();}',correct
'creatureX = initX;',correct
'new Body(200, 200)',correct
'c',correct
'BodyA.flybacktextoff()',correct
'g',correct
'quad(headx - 10, heady - 45, headx - 12, heady - 20, headx + 10, heady - 45, headx, heady - 45)',correct
'mouseButton == LEFT',correct
'h',correct
'Ufo UfoB;',VariableNamingConventions
'{    flybacktext = false;}',correct
'ellipse(headx + 55, heady - 160, 40, 40)',correct
'UfoB = new Ufo(300, 100)',correct
'fill(0, 150, 255);',correct
'rect(creatureX + 45, creatureY - 50, 50, 20);',correct
'v',correct
'stroke(0, 255, 0)',correct
'rectMode(CENTER);',correct
'UfoA.beam()',correct
'void move(float _x, float _y) {    if (dist(mouseX, mouseY, creatureX, creatureY, headx, heady) <= 100 || dist(mouseX, mouseY, headx, heady) <= 100) {        creatureX = _x;        creatureY = _y;        headx = _x;        heady = _y;    }}',ShortVariable
'BodyA.ChangeColorback();',correct
'{    fill(0, 255, 0);    stroke(0, 255, 0);    quad(ufoX - 10, ufoY, ufoX - 50, ufoY + 100, ufoX + 50, ufoY + 100, ufoX + 10, ufoY);}',correct
'arc(headx + 30, heady - 100, 50, 50, 0, HALF_PI)',correct
'if (heady <= creatureY - 5) {    heady = heady + 5;    flybacktext = true;}',correct
'heady = initY',correct
'{    beam = true;}',correct
'dist(mouseX, mouseY, ufoX, ufoY) <= 75',correct
'BodyA.move(mouseX, mouseY);',correct
'heady = _y',correct
'beam = false',correct
'stroke(bodyColor2);',correct
'PI + HALF_PI',correct
'creatureY + 10',correct
'{    BodyA.move(mouseX, mouseY);}',correct
'ufoX + 10',correct
'rect(headx, heady - 160, 40, 10)',correct
'textSize(30);',correct
'ellipse(headx - 55, heady - 160, 40, 40);',correct
'color(255, 170, 40)',correct
'bodyColor2 = color(random(255), random(255), random(255));',correct
'UfoB.beam()',correct
'float creatureX;',correct
'ufoY + 100',correct
'creatureX = initX',correct
'ellipse(headx + 30, heady - 120, 20, 20)',correct
'fill(0, 150, 255)',correct
'boolean Ufomove = false;',VariableNamingConventions
'void flybacktext() {    if (flybacktext == true) {        fill(255, 255, 255);        textSize(30);        textAlign(CENTER);        stroke(255, 255, 255);        text("or not", 200, 30);    }}',correct
'{    if (heady <= creatureY - 5) {        heady = heady + 5;        flybacktext = true;    }}',correct
'{    if (flybacktext == true) {        fill(255, 255, 255);        textSize(30);        textAlign(CENTER);        stroke(255, 255, 255);        text("or not", 200, 30);    }}',correct
'bodyColor1 = color(255, 170, 40);',correct
'beam = false;',correct
'{    BodyA.changeColor();}',correct
'rect(creatureX - 50, creatureY + 135, 50, 20)',correct
'headx = _x;',correct
'Processing',correct
'ellipse(headx - 30, heady - 120, 10, 10)',correct
'beam == true',correct
'float creatureY;',correct
'creatureY + 30',correct
'{    flytext = false;}',correct
'Body(float initX, float initY) {    creatureX = initX;    creatureY = initY;    bodyColor1 = color(255, 170, 40);    bodyColor2 = color(200, 0, 0);    headx = initX;    heady = initY;}',correct
'creatureY + 35',correct
'false',correct
'rect(creatureX - 45, creatureY - 50, 50, 20)',correct
'arc(creatureX + 10, creatureY + 10, 50, 50, PI + HALF_PI, TWO_PI);',correct
'headx = initX;',correct
'if (key == h) {    BodyA.flytextoff();}',correct
'ellipse(ufoX, ufoY, 200, 30);',correct
'Ufo(float initX, float initY) {    ufoX = initX;    ufoY = initY;}',correct
'arc(creatureX - 10, creatureY + 10, 50, 50, PI, PI + HALF_PI)',correct
'ellipse(headx - 55, heady - 160, 40, 40)',correct
'beam = true',correct
'fill(0, 255, 0)',correct
'void flytextoff() {    flytext = false;}',correct
'fill(255, 255, 255);',correct
'{    if (flytext == true) {        fill(255, 255, 255);        stroke(255, 255, 255);        textSize(30);        text("I belief I can fly!!", 200, 30);        textAlign(CENTER);    }}',correct
'float ufoY;',correct
'backgroundColor = color(0, 0, 0);',correct
'BodyA.changeColor();',correct
'void beam() {    fill(0, 255, 0);    stroke(0, 255, 0);    quad(ufoX - 10, ufoY, ufoX - 50, ufoY + 100, ufoX + 50, ufoY + 100, ufoX + 10, ufoY);}',correct
'rect(creatureX + 50, creatureY + 75, 30, 100)',correct
'background(backgroundColor)',correct
'new Ufo(100, 100)',correct
'bodyColor1 = color(255, 170, 40)',correct
'ellipse(headx + 30, heady - 120, 10, 10);',correct
'dist(mouseX, mouseY, headx, heady)',correct
'BodyA.display()',correct
'text("or not", 200, 30);',PixelHardcodeIgnoranceRule
'if (key == h) {    BodyA.fly();}',correct
'{    creatureX = initX;    creatureY = initY;    bodyColor1 = color(255, 170, 40);    bodyColor2 = color(200, 0, 0);    headx = initX;    heady = initY;}',correct
'float ufoX;',correct
'UfoA = new Ufo(100, 100);',correct
'{    if (dist(mouseX, mouseY, creatureX, creatureY, headx, heady) <= 100 || dist(mouseX, mouseY, headx, heady) <= 100) {        creatureX = _x;        creatureY = _y;        headx = _x;        heady = _y;    }}',correct
'bodyColor1 = color(random(255), random(255), random(255));',correct
'heady = heady - 5;',correct
'creatureY - 20',correct
'"or not"',correct
'ufoY = _y;',correct
'arc(creatureX - 50, creatureY + 30, 30, 50, PI, PI + HALF_PI);',correct
'if (beam == true) {    UfoA.beam();    UfoB.beam();}',SimplifyBooleanExpressions
'{    fill(255, 255, 255);    stroke(255, 255, 255);    textSize(30);    text("I belief I can fly!!", 200, 30);    textAlign(CENTER);}',correct
'// eyes',correct
'{    bodyColor1 = color(255, 170, 40);    bodyColor2 = color(200, 0, 0);}',correct
'creatureY = _y',correct
'ufoX - 50',correct
'creatureY + 75',correct
'stroke(0, 150, 255);',correct
'rect(creatureX + 50, creatureY + 75, 30, 100);',correct
'BodyA',correct
'dist(mouseX, mouseY, headx, heady) <= 100',correct
'{    if (dist(mouseX, mouseY, ufoX, ufoY) <= 75) {        ufoX = _x;        ufoY = _y;    }}',correct
'rect(headx, heady - 130, 110, 70);',correct
'if (mouseButton == LEFT) {    BodyA.move(mouseX, mouseY);}',correct
'class Ufo {    float ufoX;    float ufoY;    int ufoColor1;    int ufoColor2;    boolean Ufomove = false;    Ufo(float initX, float initY) {        ufoX = initX;        ufoY = initY;    }    void display() {        fill(0, 150, 255);        stroke(0, 150, 255);        arc(ufoX, ufoY, 100, 80, PI, TWO_PI);        fill(150, 150, 150);        stroke(150, 150, 150);        ellipse(ufoX, ufoY, 200, 30);    }    void move(float _x, float _y) {        if (dist(mouseX, mouseY, ufoX, ufoY) <= 75) {            ufoX = _x;            ufoY = _y;        }    }    void beam() {        fill(0, 255, 0);        stroke(0, 255, 0);        quad(ufoX - 10, ufoY, ufoX - 50, ufoY + 100, ufoX + 50, ufoY + 100, ufoX + 10, ufoY);    }}',correct
'fill(150, 150, 150);',correct
'{    if (mouseButton == LEFT) {        BodyA.move(mouseX, mouseY);    }    if (mouseButton == RIGHT) {        UfoA.move(mouseX, mouseY);        UfoB.move(mouseX, mouseY);    }}',correct
'void display() {    // mouth    fill(bodyColor2);    stroke(bodyColor2);    rect(headx, heady - 100, 80, 40);    fill(bodyColor1);    stroke(bodyColor1);    // head    rect(headx, heady - 60, 60, 40);    arc(headx + 30, heady - 100, 50, 50, 0, HALF_PI);    arc(headx - 30, heady - 100, 50, 50, HALF_PI, PI);    rect(headx, heady - 130, 110, 70);    fill(bodyColor2);    stroke(bodyColor2);    ellipse(headx - 55, heady - 160, 40, 40);    ellipse(headx + 55, heady - 160, 40, 40);    rect(headx, heady - 160, 40, 10);    // eyes    fill(bodyColor2);    stroke(bodyColor2);    ellipse(headx - 30, heady - 120, 20, 20);    ellipse(headx + 30, heady - 120, 20, 20);    fill(bodyColor1);    stroke(bodyColor1);    ellipse(headx - 30, heady - 120, 10, 10);    ellipse(headx + 30, heady - 120, 10, 10);    // flame    fill(255, 0, 0);    stroke(255, 0, 0);    quad(headx - 30, heady - 45, headx - 32, heady - 20, headx - 10, heady - 45, headx - 20, heady - 45);    quad(headx - 20, heady - 45, headx - 22, heady - 20, headx, heady - 45, headx - 10, heady - 45);    quad(headx - 10, heady - 45, headx - 12, heady - 20, headx + 10, heady - 45, headx, heady - 45);    quad(headx + 10, heady - 45, headx + 33, heady - 20, headx + 30, heady - 45, headx + 20, heady - 45);    quad(headx, heady - 45, headx + 23, heady - 20, headx + 20, heady - 45, headx + 10, heady - 45);    quad(headx - 10, heady - 45, headx + 13, heady - 20, headx + 10, heady - 45, headx, heady - 45);    stroke(bodyColor1);    fill(bodyColor1);    // legs    fill(bodyColor2);    stroke(bodyColor2);    rect(creatureX + 50, creatureY + 75, 30, 100);    rect(creatureX - 50, creatureY + 75, 30, 100);    arc(creatureX + 50, creatureY + 30, 30, 50, PI + HALF_PI, TWO_PI);    arc(creatureX - 50, creatureY + 30, 30, 50, PI, PI + HALF_PI);    fill(bodyColor1);    stroke(bodyColor1);    rect(creatureX + 50, creatureY + 135, 50, 20);    rect(creatureX - 50, creatureY + 135, 50, 20);    // body    rect(creatureX, creatureY, 100, 120);    fill(bodyColor2);    stroke(bodyColor2);    rect(creatureX, creatureY + 35, 100, 60);    rect(creatureX, creatureY, 20, 120);    arc(creatureX + 10, creatureY + 10, 50, 50, PI + HALF_PI, TWO_PI);    arc(creatureX - 10, creatureY + 10, 50, 50, PI, PI + HALF_PI);    fill(bodyColor1);    stroke(bodyColor1);    // arms    rect(creatureX - 80, creatureY - 20, 20, 50);    rect(creatureX + 80, creatureY - 20, 20, 50);    fill(bodyColor1);    arc(creatureX + 70, creatureY - 40, 40, 40, PI + HALF_PI, TWO_PI);    arc(creatureX - 70, creatureY - 40, 40, 40, PI, PI + HALF_PI);    rect(creatureX - 45, creatureY - 50, 50, 20);    rect(creatureX + 45, creatureY - 50, 50, 20);}',correct
'creatureX + 10',correct
'BodyA.flybacktextoff();',correct
'BodyA.fly()',correct
'ufoY = initY;',correct
'fill(255, 0, 0)',correct
'flytext = true;',correct
'quad(headx - 10, heady - 45, headx - 12, heady - 20, headx + 10, heady - 45, headx, heady - 45);',correct
'if (mouseButton == RIGHT) {    UfoA.move(mouseX, mouseY);    UfoB.move(mouseX, mouseY);}',correct
'fill(bodyColor1);',correct
'creatureY - 40',correct
'stroke(255, 255, 255)',correct
'{    BodyA.flyback();}',correct
'BodyA.flytextoff()',correct
'"I belief I can fly!!"',correct
'quad(ufoX - 10, ufoY, ufoX - 50, ufoY + 100, ufoX + 50, ufoY + 100, ufoX + 10, ufoY);',correct
'fill(255, 255, 255)',correct
'UfoA.move(mouseX, mouseY);',correct
'void',correct
'UfoB = new Ufo(300, 100);',correct
'UfoB.move(mouseX, mouseY);',correct
'flytext = false;',correct
'true',correct
'ufoColor2',correct
'ufoColor1',correct
'flytext = true',correct
'quad(headx - 30, heady - 45, headx - 32, heady - 20, headx - 10, heady - 45, headx - 20, heady - 45);',correct
'void setup() {    rectMode(CENTER);    backgroundColor = color(0, 0, 0);    BodyA = new Body(200, 200);    UfoA = new Ufo(100, 100);    UfoB = new Ufo(300, 100);}',correct
'{    fill(0, 150, 255);    stroke(0, 150, 255);    arc(ufoX, ufoY, 100, 80, PI, TWO_PI);    fill(150, 150, 150);    stroke(150, 150, 150);    ellipse(ufoX, ufoY, 200, 30);}',correct
'arc(creatureX + 50, creatureY + 30, 30, 50, PI + HALF_PI, TWO_PI);',correct
'arc(ufoX, ufoY, 100, 80, PI, TWO_PI);',correct
'// body',correct
'arc(headx + 30, heady - 100, 50, 50, 0, HALF_PI);',correct
'stroke(bodyColor1)',correct
'BodyA.fly();',correct
'ufoX = _x',correct
'ufoX = _x;',correct
'Body',correct
'boolean flybacktext = false;',AvoidFieldNameMatchingMethodName
'stroke(255, 0, 0)',correct
'quad(headx + 10, heady - 45, headx + 33, heady - 20, headx + 30, heady - 45, headx + 20, heady - 45);',correct
'void flyback() {    if (heady <= creatureY - 5) {        heady = heady + 5;        flybacktext = true;    }}',correct
'creatureY - 50',correct
'arc(creatureX + 70, creatureY - 40, 40, 40, PI + HALF_PI, TWO_PI)',correct
'ufoX - 10',correct
'flybacktext = true',correct
'ellipse(ufoX, ufoY, 200, 30)',correct
'stroke(bodyColor2)',correct
'dist(mouseX, mouseY, creatureX, creatureY, headx, heady) <= 100 || dist(mouseX, mouseY, headx, heady) <= 100',correct
'if (dist(mouseX, mouseY, creatureX, creatureY, headx, heady) <= 100 || dist(mouseX, mouseY, headx, heady) <= 100) {    creatureX = _x;    creatureY = _y;    headx = _x;    heady = _y;}',correct
'flytext = false',correct
'heady = heady + 5;',correct
'float heady;',correct
'rect(creatureX - 50, creatureY + 75, 30, 100);',correct
'if (key == g) {    BodyA.flybacktextoff();}',correct
'quad(headx + 10, heady - 45, headx + 33, heady - 20, headx + 30, heady - 45, headx + 20, heady - 45)',correct
'UfoB.display();',correct
'headx - 30',correct
'creatureX = _x',correct
'headx - 32',correct
'UfoB.move(mouseX, mouseY)',correct
'flybacktext = false;',correct
'BodyA.flytextoff();',correct
'bodyColor2 = color(random(255), random(255), random(255))',correct
'rect(creatureX - 45, creatureY - 50, 50, 20);',correct
'{    beam = false;}',correct
'int backgroundColor;',correct
'boolean beam = false;',correct
'heady - 130',correct
'flytext == true',correct
'ufoY = initY',correct
'if (key == b && beam == false) {    beam = true;} else if (key == b && beam == true) {    beam = false;}',SimplifyBooleanExpressions
'headx - 20',correct
'headx - 22',correct
'UfoA.move(mouseX, mouseY)',correct
'rect(creatureX + 45, creatureY - 50, 50, 20)',correct
'{    if (key == g) {        BodyA.flybacktextoff();    }    if (key == h) {        BodyA.flytextoff();    }}',correct
'creatureX + 70',correct
'rect(headx, heady - 100, 80, 40)',correct
'creatureX - 10',correct
'beam = true;',correct
'{    heady = heady - 5;    flytext = true;}',correct
'bodyColor1',correct
'void draw() {    background(backgroundColor);    if (beam == true) {        UfoA.beam();        UfoB.beam();    }    UfoA.display();    UfoB.display();    BodyA.flybacktext();    BodyA.textfly();    BodyA.display();}',correct
'bodyColor2',correct
'color(random(255), random(255), random(255))',correct
'rect(creatureX + 50, creatureY + 135, 50, 20);',correct
'background(backgroundColor);',correct
'fill(bodyColor2);',correct
'heady = _y;',correct
'heady - 160',correct
'headx - 55',correct
'ellipse(headx - 30, heady - 120, 10, 10);',correct
'ellipse(headx + 55, heady - 160, 40, 40);',correct
'creatureX + 80',correct
'rect(creatureX + 80, creatureY - 20, 20, 50);',correct
'if (dist(mouseX, mouseY, ufoX, ufoY) <= 75) {    ufoX = _x;    ufoY = _y;}',correct
'if (key == g) {    BodyA.flyback();}',correct
'mouseButton == RIGHT',correct
'backgroundColor',correct
'{    BodyA.fly();}',correct
'quad(headx - 20, heady - 45, headx - 22, heady - 20, headx, heady - 45, headx - 10, heady - 45)',correct
'textSize(30)',correct
'random(255)',correct
'flybacktext == true',correct
'creatureY = initY',correct
'{    creatureX = _x;    creatureY = _y;    headx = _x;    heady = _y;}',correct
'// legsfill(bodyColor2);',correct
'heady - 100',correct
'void display() {    fill(0, 150, 255);    stroke(0, 150, 255);    arc(ufoX, ufoY, 100, 80, PI, TWO_PI);    fill(150, 150, 150);    stroke(150, 150, 150);    ellipse(ufoX, ufoY, 200, 30);}',correct
'{    BodyA.flytextoff();}',correct
'headx + 55',correct
'UfoB.beam();',correct
'BodyA.textfly()',correct
'BodyA = new Body(200, 200);',correct
'new Ufo(300, 100)',correct
'// armsrect(creatureX - 80, creatureY - 20, 20, 50);',correct
'ellipse(headx + 30, heady - 120, 10, 10)',correct
'arc(creatureX + 50, creatureY + 30, 30, 50, PI + HALF_PI, TWO_PI)',correct
'flybacktext = false',correct
'BodyA.changeColor()',correct
'void keyPressed() {    if (key == b && beam == false) {        beam = true;    } else if (key == b && beam == true) {        beam = false;    }    if (key == c) {        BodyA.changeColor();    }    if (key == v) {        BodyA.ChangeColorback();    }    if (key == h) {        BodyA.fly();    }    if (key == g) {        BodyA.flyback();    }}',correct
'backgroundColor = color(0, 0, 0)',correct
'text("or not", 200, 30)',correct
'heady - 5',correct
'class Body {    float creatureX;    float creatureY;    int bodyColor1;    int bodyColor2;    float headx;    float heady;    boolean flytext = false;    boolean flybacktext = false;    Body(float initX, float initY) {        creatureX = initX;        creatureY = initY;        bodyColor1 = color(255, 170, 40);        bodyColor2 = color(200, 0, 0);        headx = initX;        heady = initY;    }    void display() {        // mouth        fill(bodyColor2);        stroke(bodyColor2);        rect(headx, heady - 100, 80, 40);        fill(bodyColor1);        stroke(bodyColor1);        // head        rect(headx, heady - 60, 60, 40);        arc(headx + 30, heady - 100, 50, 50, 0, HALF_PI);        arc(headx - 30, heady - 100, 50, 50, HALF_PI, PI);        rect(headx, heady - 130, 110, 70);        fill(bodyColor2);        stroke(bodyColor2);        ellipse(headx - 55, heady - 160, 40, 40);        ellipse(headx + 55, heady - 160, 40, 40);        rect(headx, heady - 160, 40, 10);        // eyes        fill(bodyColor2);        stroke(bodyColor2);        ellipse(headx - 30, heady - 120, 20, 20);        ellipse(headx + 30, heady - 120, 20, 20);        fill(bodyColor1);        stroke(bodyColor1);        ellipse(headx - 30, heady - 120, 10, 10);        ellipse(headx + 30, heady - 120, 10, 10);        // flame        fill(255, 0, 0);        stroke(255, 0, 0);        quad(headx - 30, heady - 45, headx - 32, heady - 20, headx - 10, heady - 45, headx - 20, heady - 45);        quad(headx - 20, heady - 45, headx - 22, heady - 20, headx, heady - 45, headx - 10, heady - 45);        quad(headx - 10, heady - 45, headx - 12, heady - 20, headx + 10, heady - 45, headx, heady - 45);        quad(headx + 10, heady - 45, headx + 33, heady - 20, headx + 30, heady - 45, headx + 20, heady - 45);        quad(headx, heady - 45, headx + 23, heady - 20, headx + 20, heady - 45, headx + 10, heady - 45);        quad(headx - 10, heady - 45, headx + 13, heady - 20, headx + 10, heady - 45, headx, heady - 45);        stroke(bodyColor1);        fill(bodyColor1);        // legs        fill(bodyColor2);        stroke(bodyColor2);        rect(creatureX + 50, creatureY + 75, 30, 100);        rect(creatureX - 50, creatureY + 75, 30, 100);        arc(creatureX + 50, creatureY + 30, 30, 50, PI + HALF_PI, TWO_PI);        arc(creatureX - 50, creatureY + 30, 30, 50, PI, PI + HALF_PI);        fill(bodyColor1);        stroke(bodyColor1);        rect(creatureX + 50, creatureY + 135, 50, 20);        rect(creatureX - 50, creatureY + 135, 50, 20);        // body        rect(creatureX, creatureY, 100, 120);        fill(bodyColor2);        stroke(bodyColor2);        rect(creatureX, creatureY + 35, 100, 60);        rect(creatureX, creatureY, 20, 120);        arc(creatureX + 10, creatureY + 10, 50, 50, PI + HALF_PI, TWO_PI);        arc(creatureX - 10, creatureY + 10, 50, 50, PI, PI + HALF_PI);        fill(bodyColor1);        stroke(bodyColor1);        // arms        rect(creatureX - 80, creatureY - 20, 20, 50);        rect(creatureX + 80, creatureY - 20, 20, 50);        fill(bodyColor1);        arc(creatureX + 70, creatureY - 40, 40, 40, PI + HALF_PI, TWO_PI);        arc(creatureX - 70, creatureY - 40, 40, 40, PI, PI + HALF_PI);        rect(creatureX - 45, creatureY - 50, 50, 20);        rect(creatureX + 45, creatureY - 50, 50, 20);    }    void move(float _x, float _y) {        if (dist(mouseX, mouseY, creatureX, creatureY, headx, heady) <= 100 || dist(mouseX, mouseY, headx, heady) <= 100) {            creatureX = _x;            creatureY = _y;            headx = _x;            heady = _y;        }    }    void changeColor() {        bodyColor1 = color(random(255), random(255), random(255));        bodyColor2 = color(random(255), random(255), random(255));    }    void ChangeColorback() {        bodyColor1 = color(255, 170, 40);        bodyColor2 = color(200, 0, 0);    }    void fly() {        heady = heady - 5;        flytext = true;    }    void textfly() {        if (flytext == true) {            fill(255, 255, 255);            stroke(255, 255, 255);            textSize(30);            text("I belief I can fly!!", 200, 30);            textAlign(CENTER);        }    }    void flyback() {        if (heady <= creatureY - 5) {            heady = heady + 5;            flybacktext = true;        }    }    void flybacktext() {        if (flybacktext == true) {            fill(255, 255, 255);            textSize(30);            textAlign(CENTER);            stroke(255, 255, 255);            text("or not", 200, 30);        }    }    void flybacktextoff() {        flybacktext = false;    }    void flytextoff() {        flytext = false;    }}',correct
'headx - 12',correct
'{    rectMode(CENTER);    backgroundColor = color(0, 0, 0);    BodyA = new Body(200, 200);    UfoA = new Ufo(100, 100);    UfoB = new Ufo(300, 100);}',correct
'heady - 120',correct
'void flybacktextoff() {    flybacktext = false;}',correct
'headx - 10',correct
'UfoA = new Ufo(100, 100)',correct
'rect(creatureX, creatureY, 20, 120);',correct
'// bodyrect(creatureX, creatureY, 100, 120);',correct
'bodyColor2 = color(200, 0, 0);',correct
'creatureX + 45',correct
'// headrect(headx, heady - 60, 60, 40);',correct
'rect(creatureX, creatureY, 20, 120)',correct
'arc(headx - 30, heady - 100, 50, 50, HALF_PI, PI);',correct
'bodyColor1 = color(random(255), random(255), random(255))',correct
'textAlign(CENTER);',correct
'arc(creatureX + 10, creatureY + 10, 50, 50, PI + HALF_PI, TWO_PI)',correct
'creatureX + 50',correct
'rect(headx, heady - 60, 60, 40)',correct
'{    ufoX = _x;    ufoY = _y;}',correct
'ellipse(headx - 30, heady - 120, 20, 20)',correct
'arc(creatureX - 70, creatureY - 40, 40, 40, PI, PI + HALF_PI);',correct
'key == b && beam == false',correct
'headx = _x',correct
'{    bodyColor1 = color(random(255), random(255), random(255));    bodyColor2 = color(random(255), random(255), random(255));}',correct
'fill(150, 150, 150)',correct
'int bodyColor2;',correct
'BodyA.flybacktext()',correct
'headx + 13',correct
'headx + 10',correct
'heady - 45',correct
'creatureX - 80',correct
'BodyA.flyback()',correct
'void textfly() {    if (flytext == true) {        fill(255, 255, 255);        stroke(255, 255, 255);        textSize(30);        text("I belief I can fly!!", 200, 30);        textAlign(CENTER);    }}',correct
'BodyA.display();',correct
'quad(headx - 20, heady - 45, headx - 22, heady - 20, headx, heady - 45, headx - 10, heady - 45);',correct
'int bodyColor1;',correct
'arc(creatureX - 70, creatureY - 40, 40, 40, PI, PI + HALF_PI)',correct
'rect(creatureX - 50, creatureY + 135, 50, 20);',correct
'ufoY = _y',correct
'if (flybacktext == true) {    fill(255, 255, 255);    textSize(30);    textAlign(CENTER);    stroke(255, 255, 255);    text("or not", 200, 30);}',SimplifyBooleanExpressions
'dist(mouseX, mouseY, ufoX, ufoY)',correct
'stroke(0, 150, 255)',correct
'text("I belief I can fly!!", 200, 30)',correct
'rect(creatureX - 50, creatureY + 75, 30, 100)',correct
'{    BodyA.flybacktextoff();}',correct
'heady + 5',correct
'key == h',correct
'key == g',correct
'key == c',correct
'headx = initX',correct
'headx + 30',correct
'creatureY = _y;',correct
'creatureY - 5',correct
'arc(creatureX - 50, creatureY + 30, 30, 50, PI, PI + HALF_PI)',correct
'{    ufoX = initX;    ufoY = initY;}',correct
'key == b',correct
'headx + 33',correct
'heady - 20',correct
'creatureX = _x;',correct
'rect(creatureX, creatureY + 35, 100, 60);',correct
'void move(float _x, float _y) {    if (dist(mouseX, mouseY, ufoX, ufoY) <= 75) {        ufoX = _x;        ufoY = _y;    }}',ShortVariable
'key == v',correct
'void mouseDragged() {    if (mouseButton == LEFT) {        BodyA.move(mouseX, mouseY);    }    if (mouseButton == RIGHT) {        UfoA.move(mouseX, mouseY);        UfoB.move(mouseX, mouseY);    }}',correct
'{    if (key == b && beam == false) {        beam = true;    } else if (key == b && beam == true) {        beam = false;    }    if (key == c) {        BodyA.changeColor();    }    if (key == v) {        BodyA.ChangeColorback();    }    if (key == h) {        BodyA.fly();    }    if (key == g) {        BodyA.flyback();    }}',correct
'rect(headx, heady - 160, 40, 10);',correct
'int ufoColor1;',correct
'arc(creatureX + 70, creatureY - 40, 40, 40, PI + HALF_PI, TWO_PI);',correct
'BodyA.flybacktext();',correct
'display',LongMethodRule
'headx + 20',correct
'rect(creatureX + 50, creatureY + 135, 50, 20)',correct
'arc(creatureX - 10, creatureY + 10, 50, 50, PI, PI + HALF_PI);',correct
'heady = initY;',correct
'headx + 23',correct
'headx',correct
'heady',correct
'// legs',correct
'ellipse(headx - 30, heady - 120, 20, 20);',correct
'int ufoColor2;',correct
'quad(headx, heady - 45, headx + 23, heady - 20, headx + 20, heady - 45, headx + 10, heady - 45)',correct
'fill(bodyColor1)',correct
'float initX',correct
'float initY',correct
'fill(0, 255, 0);',correct
'quad(headx - 30, heady - 45, headx - 32, heady - 20, headx - 10, heady - 45, headx - 20, heady - 45)',correct
'BodyA.flyback();',correct
'color(200, 0, 0)',correct
'if (flytext == true) {    fill(255, 255, 255);    stroke(255, 255, 255);    textSize(30);    text("I belief I can fly!!", 200, 30);    textAlign(CENTER);}',SimplifyBooleanExpressions
'quad(headx - 10, heady - 45, headx + 13, heady - 20, headx + 10, heady - 45, headx, heady - 45);',correct
'creatureX - 45',correct
'heady <= creatureY - 5',correct
'rect(creatureX, creatureY, 100, 120)',correct
'fill(bodyColor2)',correct
'if (key == b && beam == true) {    beam = false;}',SimplifyBooleanExpressions
'color(0, 0, 0)',correct
'{    background(backgroundColor);    if (beam == true) {        UfoA.beam();        UfoB.beam();    }    UfoA.display();    UfoB.display();    BodyA.flybacktext();    BodyA.textfly();    BodyA.display();}',correct
'heady = heady - 5',correct
'creatureX - 50',correct
'rect(creatureX - 80, creatureY - 20, 20, 50)',correct
'key == b && beam == true',correct
'dist(mouseX, mouseY, creatureX, creatureY, headx, heady) <= 100',correct
'UfoA.display();',correct
'stroke(255, 0, 0);',correct
'bodyColor2 = color(200, 0, 0)',correct
'Body BodyA;',correct
'creatureY = initY;',correct
'ufoX = initX',correct
'// eyesfill(bodyColor2);',correct
'UfoA.display()',correct
'heady - 60',correct
'Ufo',correct
'BodyA.textfly();',correct
'float headx;',correct
'BodyA.move(mouseX, mouseY)',correct
'stroke(150, 150, 150);',correct
'float _y',correct
'rect(creatureX, creatureY + 35, 100, 60)',correct
'BodyA = new Body(200, 200)',correct
'void changeColor() {    bodyColor1 = color(random(255), random(255), random(255));    bodyColor2 = color(random(255), random(255), random(255));}',correct
'rect(headx, heady - 130, 110, 70)',correct
'float _x',correct
'creatureX - 70',correct
'// head// bluefill(bodyColorB);',correct
'flower1 = color(255, 0, 0)',correct
'// grass , hills',correct
'int moonColor;',correct
'// darkbluemoonShaper = color(0, 17, 121);',correct
'width / 4.3f',correct
'skyD = new DaySky();',correct
'// bluebodyColorB = color(191, 252, 255);',correct
'ellipse(treeX + 23, treeY - 36, 20, 20);',correct
'bearY - 53',correct
'stroke(0);',correct
'void setup() {    teddy = new Bear();    moon = new Moon();    day = new DayLandscape();    skyD = new DaySky();    fish = new Fish();    printArray(f);}',correct
'bearX + 25',correct
'{    skyD.drawDaySky();}',correct
'bearY - 50',correct
'int cloudWhite;',correct
'line(800, 220, 800, 270)',correct
'bearY = mouseY;',correct
'// redeyeColor = color(255, 0, 0);',correct
'color(255, 0, 0)',correct
'fill(moonColor);',correct
'bearX + 15',correct
'fish2Y = random(370, 600);',correct
'fish3X = random(0, 1000)',correct
'ellipse(tree2X + 43, tree2Y - 36, 20, 20);',correct
'// light blueinside = color(214, 253, 255);',correct
'bearX + 18',correct
'ellipse(tree2X - 2, tree2Y - 46, 20, 20);',correct
'void drawFish() {    // fish 1    // body    noStroke();    // grey    fill(bodyColorF);    // body    ellipse(fishX - 70, fishY + 300, 30, 15);    // tail    triangle(fishX - 85, fishY + 300, fishX - 92, fishY + 307, fishX - 92, fishY + 293);    // face    fill(eyeF);    // eye    ellipse(fishX - 62, fishY + 298, 4, 4);    fishX = fishX + 0.7f;    if (fishX > 1050) {        fishX = 0;    }    // fish 2    // grey    fill(bodyColorF);    // body    ellipse(fish2X - 70, fish2Y + 350, 30, 15);    // tail    triangle(fish2X - 85, fish2Y + 350, fish2X - 92, fish2Y + 357, fish2X - 92, fish2Y + 343);    // face    fill(eyeF);    // eye    ellipse(fish2X - 62, fish2Y + 348, 4, 4);    fish2X = fish2X + 1.3f;    if (fish2X > 1050) {        fish2X = 0;    }    // fish 3    // grey    fill(bodyColorF);    // body    ellipse(fish3X - 70, fish3Y + 350, 32, 18);    // tail    triangle(fish3X - 55, fish3Y + 350, fish3X - 42, fish3Y + 357, fish3X - 42, fish3Y + 343);    // face    fill(eyeF);    // eye    ellipse(fish3X - 77, fish3Y + 348, 4, 4);    fish3X = fish3X - 1.8f;    if (fish3X < 0) {        fish3X = 1050;    }}',correct
'ellipse(tree2X + 38, tree2Y - 21, 20, 20)',correct
'line(750, 195, 710, 235)',correct
'fill(treeBrown);',correct
'ellipse(treeX + 18, treeY - 11, 20, 20);',correct
'if (fishX > 1050) {    fishX = 0;}',correct
'line(750, 195, 710, 235);',PixelHardcodeIgnoranceRule
'tree2Y = height / 2.8f;',correct
'ellipse(830, 150, 100, 100);',PixelHardcodeIgnoranceRule
'bearY - 70',correct
'fish = new Fish()',correct
'// face// mouth, leftarc(bearX - 3, bearY - 42, 6, 6, 0, PI);',correct
'// legs// bluefill(bodyColorB);',correct
'treeBrown',correct
'// filling leg rightellipse(bearX + 18, bearY + 10, 15, 15);',correct
'ellipse(tree2X - 17, tree2Y - 16, 20, 20)',correct
'flower2 = color(255, 213, 0)',correct
'int sunC;',correct
'fill(flower1)',correct
'color(0, 202, 255)',correct
'color(191, 252, 255)',correct
'fish2X = 0;',correct
'// whiteeyeColor = color(255);',correct
'fish2X + 1.3f',correct
'Bear() {    // blue    bodyColorB = color(191, 252, 255);    // lighter blue    inside = color(214, 253, 255);    // white    eyeColor = color(255);    // black    faceColor = color(0);    bearX = width / 2;    bearY = height / 2;}',StatelessClassRule
'fishY + 300',correct
'// yellowflower2 = color(255, 213, 0);',correct
'ellipse(treeX - 17, treeY - 16, 20, 20);',correct
'bearY - 25',correct
'bearY - 10',correct
'ellipse(flX, flY, 10, 10)',correct
'ellipse(tree2X + 28, tree2Y - 11, 20, 20)',correct
'ellipse(treeX + 8, treeY - 51, 20, 20);',correct
'ellipse(250, 650, 600, 400);',correct
'ellipse(flX - 6, flY + 5, 8, 8)',correct
'// left legellipse(bearX - 18, bearY + 10, 25, 25);',correct
'fishY + 307',correct
'ellipse(cloudX, cloudY, 50, 50)',correct
'ellipse(cloudX + 55, cloudY + 15, 50, 50);',correct
'ellipse(bearX - 15, bearY - 70, 20, 20)',correct
'ellipse(tree2X - 12, tree2Y - 6, 20, 20);',correct
'ellipse(treeX - 2, treeY + 4, 20, 20);',correct
'{    // green    grassGreen = color(10, 180, 2);    // blue    skyBlue = color(0, 202, 255);    // blue    waterBlue = color(21, 218, 255);    // brown    treeBrown = color(118, 61, 6);    // green    leafs = color(0, 88, 15);    // red    flower1 = color(255, 0, 0);    // yellow    flower2 = color(255, 213, 0);    treeX = width / 4.3f;    treeY = height / 2.5f;    tree2X = width / 1.3f;    tree2Y = height / 2.8f;    flX = width / 5.2f;    flY = height / 1.8f;}',correct
'int eyeF;',correct
'bearY - 42',correct
'bearY - 44',correct
'fish3X = 1050;',correct
'ellipse(treeX - 2, treeY - 11, 20, 20)',correct
'ellipse(cloudX + 40, cloudY + 30, 50, 50);',correct
'ellipse(tree2X - 12, tree2Y - 6, 20, 20)',correct
'inside = color(255)',correct
'fishX',correct
'fishY',correct
'color(77, 76, 75)',correct
'ellipse(fish3X - 77, fish3Y + 348, 4, 4)',correct
'ellipse(treeX - 12, treeY - 6, 20, 20)',correct
'ellipse(cloudX + 40, cloudY, 50, 50)',correct
'bearY - 48',correct
'fill(flower2)',correct
'line(875, 150, 925, 150);',PixelHardcodeIgnoranceRule
'// skyfill(skyBlue);',correct
'{    // fish 1    // body    noStroke();    // grey    fill(bodyColorF);    // body    ellipse(fishX - 70, fishY + 300, 30, 15);    // tail    triangle(fishX - 85, fishY + 300, fishX - 92, fishY + 307, fishX - 92, fishY + 293);    // face    fill(eyeF);    // eye    ellipse(fishX - 62, fishY + 298, 4, 4);    fishX = fishX + 0.7f;    if (fishX > 1050) {        fishX = 0;    }    // fish 2    // grey    fill(bodyColorF);    // body    ellipse(fish2X - 70, fish2Y + 350, 30, 15);    // tail    triangle(fish2X - 85, fish2Y + 350, fish2X - 92, fish2Y + 357, fish2X - 92, fish2Y + 343);    // face    fill(eyeF);    // eye    ellipse(fish2X - 62, fish2Y + 348, 4, 4);    fish2X = fish2X + 1.3f;    if (fish2X > 1050) {        fish2X = 0;    }    // fish 3    // grey    fill(bodyColorF);    // body    ellipse(fish3X - 70, fish3Y + 350, 32, 18);    // tail    triangle(fish3X - 55, fish3Y + 350, fish3X - 42, fish3Y + 357, fish3X - 42, fish3Y + 343);    // face    fill(eyeF);    // eye    ellipse(fish3X - 77, fish3Y + 348, 4, 4);    fish3X = fish3X - 1.8f;    if (fish3X < 0) {        fish3X = 1050;    }}',LongMethodRule
'void drawMoon() {    noStroke();    fill(moonColor);    ellipse(800, 150, 100, 100);    // star    triangle(starX, starY, starX + 20, starY + 35, starX - 20, starY + 35);    triangle(starX, starY + 45, starX - 20, starY + 12, starX + 20, starY + 12);    triangle(starX - 80, starY - 10, starX - 60, starY + 25, starX - 100, starY + 25);    triangle(starX - 80, starY + 35, starX - 100, starY + 2, starX - 60, starY + 2);    triangle(starX + 80, starY + 10, starX + 60, starY - 25, starX + 100, starY - 25);    triangle(starX + 80, starY - 35, starX + 100, starY - 2, starX + 60, starY - 2);    fill(moonShaper);    ellipse(830, 150, 100, 100);    fill(moonColor);}',correct
'{    bearX = mouseX;    bearY = mouseY;}',correct
'Fish fish;',correct
'new Bear()',correct
'ellipse(bearX + 9, bearY - 53, 10, 10)',correct
'line(850, 195, 890, 235)',correct
'ellipse(500, 590, 600, 400);',correct
'// dark greytreeBrown = color(77, 76, 75);',correct
'bearY = height / 2',correct
'line(850, 100, 885, 65)',correct
'ellipse(flX + 6, flY - 5, 8, 8)',correct
'stroke(255, 235, 3);',correct
'int treeBrown;',correct
'ellipse(treeX - 2, treeY - 11, 20, 20);',correct
'noStroke();',correct
'ellipse(flX, flY - 8, 8, 8);',correct
'// arms// bluefill(bodyColorB);',correct
'ellipse(bearX + 18, bearY + 10, 15, 15)',correct
'ellipse(tree2X + 8, tree2Y - 51, 20, 20);',correct
'strokeWeight(1)',correct
'ellipse(treeX + 38, treeY - 6, 20, 20)',correct
'color(21, 218, 255)',correct
'skyD.drawDaySky()',correct
'ellipse(bearX + 15, bearY - 70, 20, 20)',correct
'// whitefill(eyeColor);',correct
'// facefill(eyeF);',correct
'moonShaper',correct
'triangle(starX, starY + 45, starX - 20, starY + 12, starX + 20, starY + 12)',correct
'// whitecloudWhite = color(255);',correct
'random(370, 600)',correct
'f = { 0.1f, 0.2f, 0.3f, 0.4f, 0.5f }',correct
'ellipse(treeX + 48, treeY - 26, 20, 20)',correct
'1.3f',correct
'// riverfill(waterBlue);',correct
'{    // white , yellowish    moonColor = color(252, 251, 199);    // darkblue    moonShaper = color(0, 17, 121);    starX = random(200, 600);    starY = random(0, 250);}',correct
'ellipse(tree2X - 12, tree2Y - 36, 20, 20)',correct
'bearY = height / 2;',correct
'ellipse(flX + 6, flY + 5, 8, 8)',correct
'float tree2Y;',correct
'skyD = new DaySky()',correct
'ellipse(treeX + 8, treeY - 1, 20, 20);',correct
'fish3X < 0',correct
'ellipse(tree2X + 28, tree2Y - 26, 20, 20);',correct
'// sky',correct
'float fish3X;',correct
'{    teddy = new Bear();    moon = new Moon();    day = new DayLandscape();    skyD = new DaySky();    fish = new Fish();    printArray(f);}',correct
'fishX = 0',correct
'// whitefaceColor = color(255);',correct
'inside = color(214, 253, 255)',correct
'// cloud',correct
'new Fish()',correct
'int grassGreen;',correct
'fish2Y + 348',correct
'{    moon.drawMoon();}',correct
'mousePressed',correct
'line(750, 100, 700, 60)',correct
'random(200, 600)',correct
'fish2Y + 357',correct
'fish2Y + 350',correct
'float tree2X;',correct
'fill(sun)',correct
'int bodyColorF;',correct
'DaySky',correct
'// bluewaterBlue = color(21, 218, 255);',correct
'void',LongMethodRule
'{    // sky    fill(skyBlue);    strokeWeight(1);    rect(-2, -2, 1005, 1005);    // grass , hills    noStroke();    fill(grassGreen);    ellipse(500, 590, 600, 400);    ellipse(750, 650, 600, 400);    ellipse(250, 650, 600, 400);    ellipse(150, 600, 600, 400);    ellipse(850, 600, 600, 400);    stroke(0);    // river    fill(waterBlue);    rect(-2, 650, 1002, 600);    // tree    noStroke();    fill(treeBrown);    rect(treeX, treeY, 30, 90);    fill(leafs);    ellipse(treeX - 12, treeY - 6, 20, 20);    ellipse(treeX - 2, treeY + 4, 20, 20);    ellipse(treeX - 2, treeY + 4, 20, 20);    ellipse(treeX + 8, treeY + 4, 20, 20);    ellipse(treeX + 18, treeY + 4, 20, 20);    ellipse(treeX + 28, treeY + 4, 20, 20);    ellipse(treeX + 38, treeY - 6, 20, 20);    ellipse(treeX + 48, treeY - 16, 20, 20);    ellipse(treeX + 48, treeY - 26, 20, 20);    ellipse(treeX + 43, treeY - 36, 20, 20);    ellipse(treeX + 38, treeY - 46, 20, 20);    ellipse(treeX + 28, treeY - 51, 20, 20);    ellipse(treeX + 18, treeY - 51, 20, 20);    ellipse(treeX + 8, treeY - 51, 20, 20);    ellipse(treeX - 2, treeY - 46, 20, 20);    ellipse(treeX - 12, treeY - 36, 20, 20);    ellipse(treeX - 17, treeY - 26, 20, 20);    ellipse(treeX - 17, treeY - 16, 20, 20);    ellipse(treeX - 2, treeY - 11, 20, 20);    ellipse(treeX + 8, treeY - 1, 20, 20);    ellipse(treeX + 18, treeY - 11, 20, 20);    ellipse(treeX + 28, treeY - 11, 20, 20);    ellipse(treeX - 2, treeY - 26, 20, 20);    ellipse(treeX + 8, treeY - 26, 20, 20);    ellipse(treeX + 18, treeY - 26, 20, 20);    ellipse(treeX + 28, treeY - 26, 20, 20);    ellipse(treeX + 38, treeY - 21, 20, 20);    ellipse(treeX + 3, treeY - 36, 20, 20);    ellipse(treeX + 13, treeY - 36, 20, 20);    ellipse(treeX + 23, treeY - 36, 20, 20);    ellipse(treeX, treeY - 18, 20, 20);    // tree 2    noStroke();    fill(treeBrown);    rect(tree2X, tree2Y, 30, 90);    fill(leafs);    ellipse(tree2X - 12, tree2Y - 6, 20, 20);    ellipse(tree2X - 2, tree2Y + 4, 20, 20);    ellipse(tree2X - 2, tree2Y + 4, 20, 20);    ellipse(tree2X + 8, tree2Y + 4, 20, 20);    ellipse(tree2X + 18, tree2Y + 4, 20, 20);    ellipse(tree2X + 28, tree2Y + 4, 20, 20);    ellipse(tree2X + 38, tree2Y - 6, 20, 20);    ellipse(tree2X + 48, tree2Y - 16, 20, 20);    ellipse(tree2X + 48, tree2Y - 26, 20, 20);    ellipse(tree2X + 43, tree2Y - 36, 20, 20);    ellipse(tree2X + 38, tree2Y - 46, 20, 20);    ellipse(tree2X + 28, tree2Y - 51, 20, 20);    ellipse(tree2X + 18, tree2Y - 51, 20, 20);    ellipse(tree2X + 8, tree2Y - 51, 20, 20);    ellipse(tree2X - 2, tree2Y - 46, 20, 20);    ellipse(tree2X - 12, tree2Y - 36, 20, 20);    ellipse(tree2X - 17, tree2Y - 26, 20, 20);    ellipse(tree2X - 17, tree2Y - 16, 20, 20);    ellipse(tree2X - 2, tree2Y - 11, 20, 20);    ellipse(tree2X + 8, tree2Y - 1, 20, 20);    ellipse(tree2X + 18, tree2Y - 11, 20, 20);    ellipse(tree2X + 28, tree2Y - 11, 20, 20);    ellipse(tree2X - 2, tree2Y - 26, 20, 20);    ellipse(tree2X + 8, tree2Y - 26, 20, 20);    ellipse(tree2X + 18, tree2Y - 26, 20, 20);    ellipse(tree2X + 28, tree2Y - 26, 20, 20);    ellipse(tree2X + 38, tree2Y - 21, 20, 20);    ellipse(tree2X + 3, tree2Y - 36, 20, 20);    ellipse(tree2X + 13, tree2Y - 36, 20, 20);    ellipse(tree2X + 23, tree2Y - 36, 20, 20);    ellipse(tree2X, tree2Y - 18, 20, 20);    // flower    fill(flower1);    // inside    ellipse(flX, flY, 10, 10);    fill(flower2);    ellipse(flX, flY + 8, 8, 8);    ellipse(flX + 6, flY + 5, 8, 8);    ellipse(flX + 8, flY, 8, 8);    ellipse(flX + 6, flY - 5, 8, 8);    ellipse(flX, flY - 8, 8, 8);    ellipse(flX - 6, flY + 5, 8, 8);    ellipse(flX - 8, flY, 8, 8);    ellipse(flX - 6, flY - 5, 8, 8);}',LongMethodRule
'strokeWeight(10);',correct
'ellipse(treeX - 2, treeY - 26, 20, 20)',correct
'fish2Y + 343',correct
'// inside ear rightellipse(bearX + 15, bearY - 70, 11, 11);',correct
'waterBlue = color(173, 0, 0)',correct
'// face',correct
'fill(eyeColor)',correct
'cloudY = height / 8.2f',correct
'ellipse(treeX - 12, treeY - 36, 20, 20);',correct
'cloudY = height / 8.2f;',correct
'// eye leftellipse(bearX - 9, bearY - 53, 10, 10);',correct
'ellipse(treeX - 2, treeY + 4, 20, 20)',correct
'ellipse(tree2X + 28, tree2Y + 4, 20, 20)',correct
'ellipse(tree2X + 23, tree2Y - 36, 20, 20)',correct
'skyBlue',correct
'fill(eyeF)',correct
'// bodyellipse(bearX, bearY - 10, 45, 60);',correct
'fishX = fishX + 0.7f',correct
'{    // blue    bodyColorB = color(191, 252, 255);    // lighter blue    inside = color(214, 253, 255);    // white    eyeColor = color(255);    // black    faceColor = color(0);    bearX = width / 2;    bearY = height / 2;}',correct
'float fish3Y;',correct
'bearY + 10',correct
'ellipse(tree2X + 8, tree2Y - 1, 20, 20)',correct
'treeY = height / 2.5f',correct
'// sun light beamline(725, 150, 675, 150);',correct
'color(214, 253, 255)',correct
'// fish 2',correct
'random(0, 1000)',correct
'fill(moonShaper)',correct
'// tailtriangle(fishX - 85, fishY + 300, fishX - 92, fishY + 307, fishX - 92, fishY + 293);',correct
'// orangeleafs = color(255, 111, 0);',correct
'ellipse(tree2X - 17, tree2Y - 26, 20, 20);',correct
'// white , yellowishmoonColor = color(252, 251, 199);',correct
'ellipse(flX - 8, flY, 8, 8);',correct
'tree2Y - 26',correct
'fishX - 92',correct
'rect(-2, 650, 1002, 600)',correct
'ellipse(tree2X + 18, tree2Y - 26, 20, 20);',correct
'faceColor = color(255)',correct
'ellipse(flX + 6, flY - 5, 8, 8);',correct
'fish2X = random(0, 1000);',correct
'// eyeellipse(fishX - 62, fishY + 298, 4, 4);',correct
'void mousePressed() {    // red    eyeColor = color(255, 0, 0);    // black    bodyColorB = color(0);    // white    inside = color(255);    // white    faceColor = color(255);    // black    bodyColorF = color(0);    // white    eyeF = color(255);    // orange    leafs = color(255, 111, 0);    // dark grey    treeBrown = color(77, 76, 75);    // dark red    waterBlue = color(173, 0, 0);    // light grey    grassGreen = color(193, 190, 187);    // dark blue    skyBlue = color(0, 17, 121);    // light grey    flower1 = color(193, 190, 187);    // light grey    flower2 = color(193, 190, 187);}',correct
'tree2Y - 21',correct
'1.8f',correct
'bearX = width / 2;',correct
'starY + 25',correct
'height / 1.8f',correct
'skyBlue = color(0, 202, 255)',correct
'// eyeellipse(fish2X - 62, fish2Y + 348, 4, 4);',correct
'color(0, 17, 121)',correct
'rect(tree2X, tree2Y, 30, 90);',correct
'// outside ear leftellipse(bearX - 15, bearY - 70, 20, 20);',correct
'tree2Y - 36',correct
'ellipse(tree2X + 23, tree2Y - 36, 20, 20);',correct
'bearX + 6',correct
'// greybodyColorF = color(185, 185, 185);',correct
'cloudWhite',correct
'bearX + 2',correct
'bearX + 3',correct
'bearX + 9',correct
'starY + 35',correct
'ellipse(cloudX, cloudY + 30, 50, 50)',correct
'fish3X - 77',correct
'starY + 45',correct
'{    fishX = 0;}',correct
'ellipse(cloudX + 20, cloudY + 10, 50, 50);',correct
'fish3X = fish3X - 1.8f;',correct
'ellipse(treeX + 38, treeY - 46, 20, 20)',correct
'mouseReleased',correct
'drawDaySky',LongMethodRule
'ellipse(treeX + 43, treeY - 36, 20, 20);',correct
'tree2X + 28',correct
'tree2X + 23',correct
'fish2X = fish2X + 1.3f;',correct
'fill(waterBlue)',correct
'cloudX < -50',correct
'Fish',correct
'fish3X - 70',correct
'ellipse(tree2X + 3, tree2Y - 36, 20, 20);',correct
'bodyColorF = color(0)',correct
'ellipse(tree2X + 28, tree2Y - 26, 20, 20)',correct
'float flY;',correct
'tree2Y - 16',correct
'ellipse(fishX - 62, fishY + 298, 4, 4)',correct
'ellipse(tree2X + 18, tree2Y + 4, 20, 20)',correct
'tree2Y - 18',correct
'tree2Y - 11',correct
'tree2X + 13',correct
'tree2X + 18',correct
'ellipse(treeX + 48, treeY - 16, 20, 20);',correct
'fill(leafs);',correct
'starY = random(0, 250);',correct
'float flX;',correct
'ellipse(cloudX, cloudY + 30, 50, 50);',correct
'// fish 3// greyfill(bodyColorF);',correct
'fish3Y + 348',correct
'tree2X + 48',correct
'fish3Y + 357',correct
'tree2X + 43',correct
'triangle(starX + 80, starY - 35, starX + 100, starY - 2, starX + 60, starY - 2);',correct
'fill(skyBlue)',correct
'fish3Y + 350',correct
'ellipse(bearX - 18, bearY + 10, 15, 15)',correct
'ellipse(treeX - 17, treeY - 26, 20, 20)',correct
'ellipse(tree2X - 2, tree2Y - 11, 20, 20);',correct
'treeY = height / 2.5f;',correct
'// blackfaceColor = color(0);',correct
'ellipse(treeX + 28, treeY - 26, 20, 20);',correct
'ellipse(750, 650, 600, 400);',correct
'leafs = color(0, 88, 15)',correct
'bodyColorF',correct
'bearX - 3',correct
'tree2X + 38',correct
'DaySky skyD;',correct
'treeY - 6',correct
'bearX - 6',correct
'fish2Y',correct
'// blackeyeF = color(0);',correct
'rect(-2, -2, 1005, 1005)',correct
'treeY - 1',correct
'bodyColorB',correct
'fish2X',correct
'ellipse(tree2X + 18, tree2Y - 51, 20, 20);',correct
'bearX - 2',correct
'ellipse(treeX + 8, treeY - 51, 20, 20)',correct
'bearX - 9',correct
'color(252, 251, 199)',correct
'ellipse(tree2X + 48, tree2Y - 16, 20, 20);',correct
'// bodyellipse(fish2X - 70, fish2Y + 350, 30, 15);',correct
'moonShaper = color(0, 17, 121)',correct
'DaySky() {    // white    cloudWhite = color(255);    // yellow    sun = color(255, 235, 3);    cloudX = width / 6;    cloudY = height / 8.2f;}',correct
'starX',correct
'starY',correct
'// cloud movingcloudX = cloudX - 0.12f;',correct
'ellipse(tree2X - 2, tree2Y + 4, 20, 20)',correct
'ellipse(fishX - 70, fishY + 300, 30, 15)',correct
'5.2f',correct
'faceColor = color(0)',correct
'fish3Y',correct
'fish3X',correct
'ellipse(tree2X, tree2Y - 18, 20, 20);',correct
'ellipse(tree2X + 8, tree2Y - 1, 20, 20);',correct
'int faceColor;',correct
'starY + 12',correct
'fishY = random(370, 600);',correct
'starY + 10',correct
'noFill()',correct
'ellipse(bearX, bearY - 10, 30, 40)',correct
'cloudWhite = color(255)',correct
'printArray(f)',correct
'ellipse(tree2X + 28, tree2Y + 4, 20, 20);',correct
'leafs',correct
'ellipse(flX + 6, flY + 5, 8, 8);',correct
'fish3Y + 343',correct
'ellipse(treeX - 2, treeY - 46, 20, 20)',correct
'ellipse(tree2X + 13, tree2Y - 36, 20, 20);',correct
'// yellowsun = color(255, 235, 3);',correct
'bearX = mouseX;',correct
'cloudX + 55',correct
'// black dot rightellipse(bearX + 9, bearY - 53, 4, 4);',correct
'float treeX;',correct
'color(255)',correct
'// filling leg leftellipse(bearX - 18, bearY + 10, 15, 15);',correct
'ellipse(treeX + 18, treeY + 4, 20, 20);',correct
'fish3X = random(0, 1000);',correct
'{ 0.1f, 0.2f, 0.3f, 0.4f, 0.5f }',correct
'drawFish',LongMethodRule
'ellipse(tree2X, tree2Y - 18, 20, 20)',correct
'ellipse(tree2X + 8, tree2Y + 4, 20, 20)',correct
'{    // ears    stroke(0);    strokeWeight(1);    // blue    fill(bodyColorB);    // outside ear left    ellipse(bearX - 15, bearY - 70, 20, 20);    // outside ear right    ellipse(bearX + 15, bearY - 70, 20, 20);    // lighter blue    fill(inside);    // inside ear left    ellipse(bearX - 15, bearY - 70, 11, 11);    // inside ear right    ellipse(bearX + 15, bearY - 70, 11, 11);    // arms    // blue    fill(bodyColorB);    // arm left    ellipse(bearX - 25, bearY - 25, 30, 15);    // arm right    ellipse(bearX + 25, bearY - 25, 30, 15);    // body    // blue    fill(bodyColorB);    // body    ellipse(bearX, bearY - 10, 45, 60);    // lighter blue    fill(inside);    // filling body    ellipse(bearX, bearY - 10, 30, 40);    // head    // blue    fill(bodyColorB);    // head    ellipse(bearX, bearY - 50, 45, 45);    // legs    // blue    fill(bodyColorB);    // left leg    ellipse(bearX - 18, bearY + 10, 25, 25);    // right leg    ellipse(bearX + 18, bearY + 10, 25, 25);    // lighter blue    fill(inside);    // filling leg left    ellipse(bearX - 18, bearY + 10, 15, 15);    // filling leg right    ellipse(bearX + 18, bearY + 10, 15, 15);    // face    // mouth, left    arc(bearX - 3, bearY - 42, 6, 6, 0, PI);    // mouth, right    arc(bearX + 3, bearY - 42, 6, 6, 0, PI);    // white    fill(eyeColor);    // eye left    ellipse(bearX - 9, bearY - 53, 10, 10);    // eye right    ellipse(bearX + 9, bearY - 53, 10, 10);    // black    fill(0);    // black dot left    ellipse(bearX - 9, bearY - 53, 4, 4);    // black dot right    ellipse(bearX + 9, bearY - 53, 4, 4);    // empty    noFill();    curve(bearX - 6, bearY - 48, bearX - 2, bearY - 44, bearX + 2, bearY - 44, bearX + 6, bearY - 48);}',LongMethodRule
'ellipse(treeX + 28, treeY - 11, 20, 20)',correct
'flower1 = color(193, 190, 187)',correct
'float treeY;',correct
'// redflower1 = color(255, 0, 0);',correct
'ellipse(830, 150, 100, 100)',correct
'tree2X - 17',correct
'moon',correct
'tree2X - 12',correct
'int skyBlue;',correct
'ellipse(treeX + 13, treeY - 36, 20, 20);',correct
'treeBrown = color(77, 76, 75)',correct
'cloudX + 40',correct
'sunC',correct
'ellipse(150, 600, 600, 400)',correct
'// headellipse(bearX, bearY - 50, 45, 45);',correct
'flY - 8',correct
'// body// bluefill(bodyColorB);',correct
'flY - 5',correct
'fishX + 0.7f',correct
'class DaySky {    int cloudWhite;    int sun;    float cloudX;    float cloudY;    DaySky() {        // white        cloudWhite = color(255);        // yellow        sun = color(255, 235, 3);        cloudX = width / 6;        cloudY = height / 8.2f;    }    void drawDaySky() {        // sun        fill(sun);        noStroke();        // sun middle        ellipse(800, 150, 100, 100);        stroke(255, 235, 3);        strokeWeight(10);        // sun light beam        line(725, 150, 675, 150);        line(750, 195, 710, 235);        line(800, 220, 800, 270);        line(850, 195, 890, 235);        line(875, 150, 925, 150);        line(850, 100, 885, 65);        line(800, 80, 800, 30);        line(750, 100, 700, 60);        // cloud        noStroke();        fill(cloudWhite);        ellipse(cloudX, cloudY, 50, 50);        ellipse(cloudX - 15, cloudY + 15, 50, 50);        ellipse(cloudX, cloudY + 30, 50, 50);        ellipse(cloudX + 20, cloudY + 40, 50, 50);        ellipse(cloudX + 40, cloudY + 30, 50, 50);        ellipse(cloudX + 55, cloudY + 15, 50, 50);        ellipse(cloudX + 40, cloudY, 50, 50);        ellipse(cloudX, cloudY, 50, 50);        ellipse(cloudX + 20, cloudY + 10, 50, 50);        // cloud moving        cloudX = cloudX - 0.12f;        if (cloudX < -50) {            cloudX = 1050;        }    }}',correct
'ellipse(bearX - 9, bearY - 53, 10, 10)',correct
'fill(inside)',correct
'flX = width / 5.2f;',correct
'treeY - 11',correct
'color(255, 235, 3)',correct
'treeY - 18',correct
'class Fish {    float fishX;    float fishY;    float fish2X;    float fish2Y;    float fish3X;    float fish3Y;    Fish() {        // grey        bodyColorF = color(185, 185, 185);        // black        eyeF = color(0);        fishX = random(0, 1000);        fishY = random(370, 600);        fish2X = random(0, 1000);        fish2Y = random(370, 600);        fish3X = random(0, 1000);        fish3Y = random(370, 600);    }    void drawFish() {        // fish 1        // body        noStroke();        // grey        fill(bodyColorF);        // body        ellipse(fishX - 70, fishY + 300, 30, 15);        // tail        triangle(fishX - 85, fishY + 300, fishX - 92, fishY + 307, fishX - 92, fishY + 293);        // face        fill(eyeF);        // eye        ellipse(fishX - 62, fishY + 298, 4, 4);        fishX = fishX + 0.7f;        if (fishX > 1050) {            fishX = 0;        }        // fish 2        // grey        fill(bodyColorF);        // body        ellipse(fish2X - 70, fish2Y + 350, 30, 15);        // tail        triangle(fish2X - 85, fish2Y + 350, fish2X - 92, fish2Y + 357, fish2X - 92, fish2Y + 343);        // face        fill(eyeF);        // eye        ellipse(fish2X - 62, fish2Y + 348, 4, 4);        fish2X = fish2X + 1.3f;        if (fish2X > 1050) {            fish2X = 0;        }        // fish 3        // grey        fill(bodyColorF);        // body        ellipse(fish3X - 70, fish3Y + 350, 32, 18);        // tail        triangle(fish3X - 55, fish3Y + 350, fish3X - 42, fish3Y + 357, fish3X - 42, fish3Y + 343);        // face        fill(eyeF);        // eye        ellipse(fish3X - 77, fish3Y + 348, 4, 4);        fish3X = fish3X - 1.8f;        if (fish3X < 0) {            fish3X = 1050;        }    }}',correct
'treeY - 16',correct
'// head',correct
'cloudX + 20',correct
'bearX - 25',correct
'// light greyflower1 = color(193, 190, 187);',correct
'fill(treeBrown)',correct
'color(173, 0, 0)',correct
'// sun',correct
'flower1',correct
'flower2',correct
'// blackbodyColorB = color(0);',correct
'triangle(starX + 80, starY - 35, starX + 100, starY - 2, starX + 60, starY - 2)',correct
'// bodyellipse(fish3X - 70, fish3Y + 350, 32, 18);',correct
'fish3X - 55',correct
'bearX - 18',correct
'fish2X - 85',correct
'bearX - 15',correct
'color(193, 190, 187)',correct
'fishX > 1050',correct
'skyBlue = color(0, 17, 121)',correct
'// earsstroke(0);',correct
'fish2X = 0',correct
'// outside ear rightellipse(bearX + 15, bearY - 70, 20, 20);',correct
'treeY - 36',correct
'ellipse(flX + 8, flY, 8, 8);',correct
'day',correct
'ellipse(treeX + 8, treeY - 26, 20, 20);',correct
'starX - 100',correct
'starY - 10',correct
'fishX - 62',correct
'ellipse(fish2X - 62, fish2Y + 348, 4, 4)',correct
'ellipse(treeX + 8, treeY + 4, 20, 20)',correct
'ellipse(treeX + 28, treeY - 51, 20, 20);',correct
'treeY - 21',correct
'triangle(fishX - 85, fishY + 300, fishX - 92, fishY + 307, fishX - 92, fishY + 293)',correct
'teddy.drawBear()',correct
'ellipse(tree2X - 12, tree2Y - 36, 20, 20);',correct
'grassGreen = color(193, 190, 187)',correct
'void drawDayLandscape() {    // sky    fill(skyBlue);    strokeWeight(1);    rect(-2, -2, 1005, 1005);    // grass , hills    noStroke();    fill(grassGreen);    ellipse(500, 590, 600, 400);    ellipse(750, 650, 600, 400);    ellipse(250, 650, 600, 400);    ellipse(150, 600, 600, 400);    ellipse(850, 600, 600, 400);    stroke(0);    // river    fill(waterBlue);    rect(-2, 650, 1002, 600);    // tree    noStroke();    fill(treeBrown);    rect(treeX, treeY, 30, 90);    fill(leafs);    ellipse(treeX - 12, treeY - 6, 20, 20);    ellipse(treeX - 2, treeY + 4, 20, 20);    ellipse(treeX - 2, treeY + 4, 20, 20);    ellipse(treeX + 8, treeY + 4, 20, 20);    ellipse(treeX + 18, treeY + 4, 20, 20);    ellipse(treeX + 28, treeY + 4, 20, 20);    ellipse(treeX + 38, treeY - 6, 20, 20);    ellipse(treeX + 48, treeY - 16, 20, 20);    ellipse(treeX + 48, treeY - 26, 20, 20);    ellipse(treeX + 43, treeY - 36, 20, 20);    ellipse(treeX + 38, treeY - 46, 20, 20);    ellipse(treeX + 28, treeY - 51, 20, 20);    ellipse(treeX + 18, treeY - 51, 20, 20);    ellipse(treeX + 8, treeY - 51, 20, 20);    ellipse(treeX - 2, treeY - 46, 20, 20);    ellipse(treeX - 12, treeY - 36, 20, 20);    ellipse(treeX - 17, treeY - 26, 20, 20);    ellipse(treeX - 17, treeY - 16, 20, 20);    ellipse(treeX - 2, treeY - 11, 20, 20);    ellipse(treeX + 8, treeY - 1, 20, 20);    ellipse(treeX + 18, treeY - 11, 20, 20);    ellipse(treeX + 28, treeY - 11, 20, 20);    ellipse(treeX - 2, treeY - 26, 20, 20);    ellipse(treeX + 8, treeY - 26, 20, 20);    ellipse(treeX + 18, treeY - 26, 20, 20);    ellipse(treeX + 28, treeY - 26, 20, 20);    ellipse(treeX + 38, treeY - 21, 20, 20);    ellipse(treeX + 3, treeY - 36, 20, 20);    ellipse(treeX + 13, treeY - 36, 20, 20);    ellipse(treeX + 23, treeY - 36, 20, 20);    ellipse(treeX, treeY - 18, 20, 20);    // tree 2    noStroke();    fill(treeBrown);    rect(tree2X, tree2Y, 30, 90);    fill(leafs);    ellipse(tree2X - 12, tree2Y - 6, 20, 20);    ellipse(tree2X - 2, tree2Y + 4, 20, 20);    ellipse(tree2X - 2, tree2Y + 4, 20, 20);    ellipse(tree2X + 8, tree2Y + 4, 20, 20);    ellipse(tree2X + 18, tree2Y + 4, 20, 20);    ellipse(tree2X + 28, tree2Y + 4, 20, 20);    ellipse(tree2X + 38, tree2Y - 6, 20, 20);    ellipse(tree2X + 48, tree2Y - 16, 20, 20);    ellipse(tree2X + 48, tree2Y - 26, 20, 20);    ellipse(tree2X + 43, tree2Y - 36, 20, 20);    ellipse(tree2X + 38, tree2Y - 46, 20, 20);    ellipse(tree2X + 28, tree2Y - 51, 20, 20);    ellipse(tree2X + 18, tree2Y - 51, 20, 20);    ellipse(tree2X + 8, tree2Y - 51, 20, 20);    ellipse(tree2X - 2, tree2Y - 46, 20, 20);    ellipse(tree2X - 12, tree2Y - 36, 20, 20);    ellipse(tree2X - 17, tree2Y - 26, 20, 20);    ellipse(tree2X - 17, tree2Y - 16, 20, 20);    ellipse(tree2X - 2, tree2Y - 11, 20, 20);    ellipse(tree2X + 8, tree2Y - 1, 20, 20);    ellipse(tree2X + 18, tree2Y - 11, 20, 20);    ellipse(tree2X + 28, tree2Y - 11, 20, 20);    ellipse(tree2X - 2, tree2Y - 26, 20, 20);    ellipse(tree2X + 8, tree2Y - 26, 20, 20);    ellipse(tree2X + 18, tree2Y - 26, 20, 20);    ellipse(tree2X + 28, tree2Y - 26, 20, 20);    ellipse(tree2X + 38, tree2Y - 21, 20, 20);    ellipse(tree2X + 3, tree2Y - 36, 20, 20);    ellipse(tree2X + 13, tree2Y - 36, 20, 20);    ellipse(tree2X + 23, tree2Y - 36, 20, 20);    ellipse(tree2X, tree2Y - 18, 20, 20);    // flower    fill(flower1);    // inside    ellipse(flX, flY, 10, 10);    fill(flower2);    ellipse(flX, flY + 8, 8, 8);    ellipse(flX + 6, flY + 5, 8, 8);    ellipse(flX + 8, flY, 8, 8);    ellipse(flX + 6, flY - 5, 8, 8);    ellipse(flX, flY - 8, 8, 8);    ellipse(flX - 6, flY + 5, 8, 8);    ellipse(flX - 8, flY, 8, 8);    ellipse(flX - 6, flY - 5, 8, 8);}',correct
'cloudX = width / 6;',correct
'ellipse(cloudX + 20, cloudY + 40, 50, 50);',correct
'fish2X - 70',correct
'treeY - 26',correct
'starY - 25',correct
'ellipse(treeX - 2, treeY - 46, 20, 20);',correct
'fish2X - 62',correct
'fishX = random(0, 1000);',correct
'// colors',correct
'fish3X = 1050',correct
'skyD.drawDaySky();',correct
'cloudX = 1050',correct
'fishX - 70',correct
'ellipse(flX, flY + 8, 8, 8)',correct
'new DaySky()',correct
'class DayLandscape {    float treeX;    float treeY;    float tree2X;    float tree2Y;    float flX;    float flY;    DayLandscape() {        // green        grassGreen = color(10, 180, 2);        // blue        skyBlue = color(0, 202, 255);        // blue        waterBlue = color(21, 218, 255);        // brown        treeBrown = color(118, 61, 6);        // green        leafs = color(0, 88, 15);        // red        flower1 = color(255, 0, 0);        // yellow        flower2 = color(255, 213, 0);        treeX = width / 4.3f;        treeY = height / 2.5f;        tree2X = width / 1.3f;        tree2Y = height / 2.8f;        flX = width / 5.2f;        flY = height / 1.8f;    }    void drawDayLandscape() {        // sky        fill(skyBlue);        strokeWeight(1);        rect(-2, -2, 1005, 1005);        // grass , hills        noStroke();        fill(grassGreen);        ellipse(500, 590, 600, 400);        ellipse(750, 650, 600, 400);        ellipse(250, 650, 600, 400);        ellipse(150, 600, 600, 400);        ellipse(850, 600, 600, 400);        stroke(0);        // river        fill(waterBlue);        rect(-2, 650, 1002, 600);        // tree        noStroke();        fill(treeBrown);        rect(treeX, treeY, 30, 90);        fill(leafs);        ellipse(treeX - 12, treeY - 6, 20, 20);        ellipse(treeX - 2, treeY + 4, 20, 20);        ellipse(treeX - 2, treeY + 4, 20, 20);        ellipse(treeX + 8, treeY + 4, 20, 20);        ellipse(treeX + 18, treeY + 4, 20, 20);        ellipse(treeX + 28, treeY + 4, 20, 20);        ellipse(treeX + 38, treeY - 6, 20, 20);        ellipse(treeX + 48, treeY - 16, 20, 20);        ellipse(treeX + 48, treeY - 26, 20, 20);        ellipse(treeX + 43, treeY - 36, 20, 20);        ellipse(treeX + 38, treeY - 46, 20, 20);        ellipse(treeX + 28, treeY - 51, 20, 20);        ellipse(treeX + 18, treeY - 51, 20, 20);        ellipse(treeX + 8, treeY - 51, 20, 20);        ellipse(treeX - 2, treeY - 46, 20, 20);        ellipse(treeX - 12, treeY - 36, 20, 20);        ellipse(treeX - 17, treeY - 26, 20, 20);        ellipse(treeX - 17, treeY - 16, 20, 20);        ellipse(treeX - 2, treeY - 11, 20, 20);        ellipse(treeX + 8, treeY - 1, 20, 20);        ellipse(treeX + 18, treeY - 11, 20, 20);        ellipse(treeX + 28, treeY - 11, 20, 20);        ellipse(treeX - 2, treeY - 26, 20, 20);        ellipse(treeX + 8, treeY - 26, 20, 20);        ellipse(treeX + 18, treeY - 26, 20, 20);        ellipse(treeX + 28, treeY - 26, 20, 20);        ellipse(treeX + 38, treeY - 21, 20, 20);        ellipse(treeX + 3, treeY - 36, 20, 20);        ellipse(treeX + 13, treeY - 36, 20, 20);        ellipse(treeX + 23, treeY - 36, 20, 20);        ellipse(treeX, treeY - 18, 20, 20);        // tree 2        noStroke();        fill(treeBrown);        rect(tree2X, tree2Y, 30, 90);        fill(leafs);        ellipse(tree2X - 12, tree2Y - 6, 20, 20);        ellipse(tree2X - 2, tree2Y + 4, 20, 20);        ellipse(tree2X - 2, tree2Y + 4, 20, 20);        ellipse(tree2X + 8, tree2Y + 4, 20, 20);        ellipse(tree2X + 18, tree2Y + 4, 20, 20);        ellipse(tree2X + 28, tree2Y + 4, 20, 20);        ellipse(tree2X + 38, tree2Y - 6, 20, 20);        ellipse(tree2X + 48, tree2Y - 16, 20, 20);        ellipse(tree2X + 48, tree2Y - 26, 20, 20);        ellipse(tree2X + 43, tree2Y - 36, 20, 20);        ellipse(tree2X + 38, tree2Y - 46, 20, 20);        ellipse(tree2X + 28, tree2Y - 51, 20, 20);        ellipse(tree2X + 18, tree2Y - 51, 20, 20);        ellipse(tree2X + 8, tree2Y - 51, 20, 20);        ellipse(tree2X - 2, tree2Y - 46, 20, 20);        ellipse(tree2X - 12, tree2Y - 36, 20, 20);        ellipse(tree2X - 17, tree2Y - 26, 20, 20);        ellipse(tree2X - 17, tree2Y - 16, 20, 20);        ellipse(tree2X - 2, tree2Y - 11, 20, 20);        ellipse(tree2X + 8, tree2Y - 1, 20, 20);        ellipse(tree2X + 18, tree2Y - 11, 20, 20);        ellipse(tree2X + 28, tree2Y - 11, 20, 20);        ellipse(tree2X - 2, tree2Y - 26, 20, 20);        ellipse(tree2X + 8, tree2Y - 26, 20, 20);        ellipse(tree2X + 18, tree2Y - 26, 20, 20);        ellipse(tree2X + 28, tree2Y - 26, 20, 20);        ellipse(tree2X + 38, tree2Y - 21, 20, 20);        ellipse(tree2X + 3, tree2Y - 36, 20, 20);        ellipse(tree2X + 13, tree2Y - 36, 20, 20);        ellipse(tree2X + 23, tree2Y - 36, 20, 20);        ellipse(tree2X, tree2Y - 18, 20, 20);        // flower        fill(flower1);        // inside        ellipse(flX, flY, 10, 10);        fill(flower2);        ellipse(flX, flY + 8, 8, 8);        ellipse(flX + 6, flY + 5, 8, 8);        ellipse(flX + 8, flY, 8, 8);        ellipse(flX + 6, flY - 5, 8, 8);        ellipse(flX, flY - 8, 8, 8);        ellipse(flX - 6, flY + 5, 8, 8);        ellipse(flX - 8, flY, 8, 8);        ellipse(flX - 6, flY - 5, 8, 8);    }}',correct
'ellipse(250, 650, 600, 400)',correct
'treeY - 51',correct
'DayLandscape',correct
'ellipse(treeX + 38, treeY - 6, 20, 20);',correct
'ellipse(flX - 6, flY - 5, 8, 8)',correct
'ellipse(cloudX + 40, cloudY, 50, 50);',correct
'moon = new Moon()',correct
'starY - 35',correct
'fish3X - 42',correct
'fishX - 85',correct
'{    // grey    bodyColorF = color(185, 185, 185);    // black    eyeF = color(0);    fishX = random(0, 1000);    fishY = random(370, 600);    fish2X = random(0, 1000);    fish2Y = random(370, 600);    fish3X = random(0, 1000);    fish3Y = random(370, 600);}',correct
'ellipse(cloudX + 20, cloudY + 10, 50, 50)',correct
'treeY - 46',correct
'triangle(starX + 80, starY + 10, starX + 60, starY - 25, starX + 100, starY - 25)',correct
'drawDayLandscape',LongMethodRule
'fill(bodyColorF)',correct
'flY = height / 1.8f',correct
'height / 8.2f',correct
'treeX + 38',correct
'treeX + 48',correct
'treeX + 43',correct
'// light greyflower2 = color(193, 190, 187);',correct
'treeX = width / 4.3f',correct
'// whiteeyeF = color(255);',correct
'// blueskyBlue = color(0, 202, 255);',correct
'triangle(starX + 80, starY + 10, starX + 60, starY - 25, starX + 100, starY - 25);',correct
'ellipse(treeX + 28, treeY + 4, 20, 20);',correct
'eyeF',correct
'// arms',correct
'ellipse(treeX + 18, treeY - 26, 20, 20)',correct
'teddy = new Bear()',correct
'rect(-2, -2, 1005, 1005);',correct
'ellipse(cloudX - 15, cloudY + 15, 50, 50);',correct
'stroke(0)',correct
'fishX = fishX + 0.7f;',correct
'ellipse(800, 150, 100, 100);',PixelHardcodeIgnoranceRule
'day = new DayLandscape()',correct
'treeX + 28',correct
'ellipse(tree2X + 28, tree2Y - 11, 20, 20);',correct
'bearX = width / 2',correct
'fish3Y = random(370, 600);',correct
'void draw() {    day.drawDayLandscape();    fish.drawFish();    if (mousePressed) {        moon.drawMoon();    } else {        skyD.drawDaySky();    }    teddy.drawBear();}',correct
'fish = new Fish();',correct
'// eyeellipse(fish3X - 77, fish3Y + 348, 4, 4);',correct
'starX + 100',correct
'ellipse(tree2X + 38, tree2Y - 46, 20, 20)',correct
'int bearY;',correct
'// blackfill(0);',correct
'treeX + 18',correct
'flY',correct
'treeX + 23',correct
'flX',correct
'ellipse(bearX + 25, bearY - 25, 30, 15)',correct
'tree2Y - 1',correct
'starX = random(200, 600)',correct
'flX + 8',correct
'tree2Y - 6',correct
'void drawDaySky() {    // sun    fill(sun);    noStroke();    // sun middle    ellipse(800, 150, 100, 100);    stroke(255, 235, 3);    strokeWeight(10);    // sun light beam    line(725, 150, 675, 150);    line(750, 195, 710, 235);    line(800, 220, 800, 270);    line(850, 195, 890, 235);    line(875, 150, 925, 150);    line(850, 100, 885, 65);    line(800, 80, 800, 30);    line(750, 100, 700, 60);    // cloud    noStroke();    fill(cloudWhite);    ellipse(cloudX, cloudY, 50, 50);    ellipse(cloudX - 15, cloudY + 15, 50, 50);    ellipse(cloudX, cloudY + 30, 50, 50);    ellipse(cloudX + 20, cloudY + 40, 50, 50);    ellipse(cloudX + 40, cloudY + 30, 50, 50);    ellipse(cloudX + 55, cloudY + 15, 50, 50);    ellipse(cloudX + 40, cloudY, 50, 50);    ellipse(cloudX, cloudY, 50, 50);    ellipse(cloudX + 20, cloudY + 10, 50, 50);    // cloud moving    cloudX = cloudX - 0.12f;    if (cloudX < -50) {        cloudX = 1050;    }}',correct
'flX + 6',correct
'ellipse(tree2X - 2, tree2Y - 26, 20, 20);',correct
'{    fish2X = 0;}',correct
'starX - 20',correct
'ellipse(tree2X + 18, tree2Y - 51, 20, 20)',correct
'Fish() {    // grey    bodyColorF = color(185, 185, 185);    // black    eyeF = color(0);    fishX = random(0, 1000);    fishY = random(370, 600);    fish2X = random(0, 1000);    fish2Y = random(370, 600);    fish3X = random(0, 1000);    fish3Y = random(370, 600);}',correct
'treeX + 13',correct
'ellipse(tree2X - 17, tree2Y - 16, 20, 20);',correct
'eyeColor = color(255)',correct
'ellipse(treeX + 28, treeY - 51, 20, 20)',correct
'float fishY;',correct
'ellipse(tree2X - 2, tree2Y + 4, 20, 20);',correct
'color(255, 213, 0)',correct
'fish2X - 92',correct
'starX + 80',correct
'ellipse(treeX + 23, treeY - 36, 20, 20)',correct
'ellipse(treeX + 18, treeY + 4, 20, 20)',correct
'ellipse(cloudX + 20, cloudY + 40, 50, 50)',correct
'// whiteinside = color(255);',correct
'teddy = new Bear();',correct
'arc(bearX + 3, bearY - 42, 6, 6, 0, PI)',correct
'stroke(255, 235, 3)',correct
'fill(cloudWhite)',correct
'bodyColorB = color(0)',correct
'float fishX;',correct
'color(185, 185, 185)',correct
'ellipse(tree2X + 48, tree2Y - 26, 20, 20)',correct
'ellipse(bearX + 9, bearY - 53, 4, 4)',correct
'teddy.drawBear();',correct
'bearY = mouseY',correct
'fill(flower2);',correct
'ellipse(treeX, treeY - 18, 20, 20)',correct
'treeX - 17',correct
'starX + 60',correct
'flX = width / 5.2f',correct
'ellipse(tree2X - 2, tree2Y - 11, 20, 20)',correct
'// right legellipse(bearX + 18, bearY + 10, 25, 25);',correct
'treeX - 12',correct
'line(725, 150, 675, 150)',correct
'fill(cloudWhite);',correct
'0.1f',correct
'cloudX - 15',correct
'flY + 8',correct
'ellipse(cloudX, cloudY, 50, 50);',correct
'ellipse(treeX + 48, treeY - 16, 20, 20)',correct
'{    noStroke();    fill(moonColor);    ellipse(800, 150, 100, 100);    // star    triangle(starX, starY, starX + 20, starY + 35, starX - 20, starY + 35);    triangle(starX, starY + 45, starX - 20, starY + 12, starX + 20, starY + 12);    triangle(starX - 80, starY - 10, starX - 60, starY + 25, starX - 100, starY + 25);    triangle(starX - 80, starY + 35, starX - 100, starY + 2, starX - 60, starY + 2);    triangle(starX + 80, starY + 10, starX + 60, starY - 25, starX + 100, starY - 25);    triangle(starX + 80, starY - 35, starX + 100, starY - 2, starX + 60, starY - 2);    fill(moonShaper);    ellipse(830, 150, 100, 100);    fill(moonColor);}',correct
'Processing',correct
'flY + 5',correct
'grassGreen = color(10, 180, 2)',correct
'new Moon()',correct
'drawMoon',correct
'flX - 8',correct
'flX - 6',correct
'width / 5.2f',correct
'0.2f',correct
'fish2X > 1050',correct
'ellipse(bearX + 15, bearY - 70, 11, 11)',correct
'ellipse(cloudX + 40, cloudY + 30, 50, 50)',correct
'float[]',correct
'{    // red    eyeColor = color(255, 0, 0);    // black    bodyColorB = color(0);    // white    inside = color(255);    // white    faceColor = color(255);    // black    bodyColorF = color(0);    // white    eyeF = color(255);    // orange    leafs = color(255, 111, 0);    // dark grey    treeBrown = color(77, 76, 75);    // dark red    waterBlue = color(173, 0, 0);    // light grey    grassGreen = color(193, 190, 187);    // dark blue    skyBlue = color(0, 17, 121);    // light grey    flower1 = color(193, 190, 187);    // light grey    flower2 = color(193, 190, 187);}',correct
'{    // sun    fill(sun);    noStroke();    // sun middle    ellipse(800, 150, 100, 100);    stroke(255, 235, 3);    strokeWeight(10);    // sun light beam    line(725, 150, 675, 150);    line(750, 195, 710, 235);    line(800, 220, 800, 270);    line(850, 195, 890, 235);    line(875, 150, 925, 150);    line(850, 100, 885, 65);    line(800, 80, 800, 30);    line(750, 100, 700, 60);    // cloud    noStroke();    fill(cloudWhite);    ellipse(cloudX, cloudY, 50, 50);    ellipse(cloudX - 15, cloudY + 15, 50, 50);    ellipse(cloudX, cloudY + 30, 50, 50);    ellipse(cloudX + 20, cloudY + 40, 50, 50);    ellipse(cloudX + 40, cloudY + 30, 50, 50);    ellipse(cloudX + 55, cloudY + 15, 50, 50);    ellipse(cloudX + 40, cloudY, 50, 50);    ellipse(cloudX, cloudY, 50, 50);    ellipse(cloudX + 20, cloudY + 10, 50, 50);    // cloud moving    cloudX = cloudX - 0.12f;    if (cloudX < -50) {        cloudX = 1050;    }}',LongMethodRule
'ellipse(flX - 6, flY + 5, 8, 8);',correct
'// river',correct
'bodyColorF = color(185, 185, 185)',correct
'ellipse(bearX - 9, bearY - 53, 4, 4)',correct
'day.drawDayLandscape()',correct
'triangle(starX - 80, starY + 35, starX - 100, starY + 2, starX - 60, starY + 2)',correct
'starX = random(200, 600);',correct
'ellipse(tree2X + 18, tree2Y - 11, 20, 20);',correct
'ellipse(bearX + 18, bearY + 10, 25, 25)',correct
'treeX - 2',correct
'flY = height / 1.8f;',correct
'0.3f',correct
'treeBrown = color(118, 61, 6)',correct
'int eyeColor;',correct
'triangle(fish2X - 85, fish2Y + 350, fish2X - 92, fish2Y + 357, fish2X - 92, fish2Y + 343)',correct
'// startriangle(starX, starY, starX + 20, starY + 35, starX - 20, starY + 35);',correct
'0.12f',correct
'float fish2Y;',correct
'class Bear {    Bear() {        // blue        bodyColorB = color(191, 252, 255);        // lighter blue        inside = color(214, 253, 255);        // white        eyeColor = color(255);        // black        faceColor = color(0);        bearX = width / 2;        bearY = height / 2;    }    void drawBear() {        // ears        stroke(0);        strokeWeight(1);        // blue        fill(bodyColorB);        // outside ear left        ellipse(bearX - 15, bearY - 70, 20, 20);        // outside ear right        ellipse(bearX + 15, bearY - 70, 20, 20);        // lighter blue        fill(inside);        // inside ear left        ellipse(bearX - 15, bearY - 70, 11, 11);        // inside ear right        ellipse(bearX + 15, bearY - 70, 11, 11);        // arms        // blue        fill(bodyColorB);        // arm left        ellipse(bearX - 25, bearY - 25, 30, 15);        // arm right        ellipse(bearX + 25, bearY - 25, 30, 15);        // body        // blue        fill(bodyColorB);        // body        ellipse(bearX, bearY - 10, 45, 60);        // lighter blue        fill(inside);        // filling body        ellipse(bearX, bearY - 10, 30, 40);        // head        // blue        fill(bodyColorB);        // head        ellipse(bearX, bearY - 50, 45, 45);        // legs        // blue        fill(bodyColorB);        // left leg        ellipse(bearX - 18, bearY + 10, 25, 25);        // right leg        ellipse(bearX + 18, bearY + 10, 25, 25);        // lighter blue        fill(inside);        // filling leg left        ellipse(bearX - 18, bearY + 10, 15, 15);        // filling leg right        ellipse(bearX + 18, bearY + 10, 15, 15);        // face        // mouth, left        arc(bearX - 3, bearY - 42, 6, 6, 0, PI);        // mouth, right        arc(bearX + 3, bearY - 42, 6, 6, 0, PI);        // white        fill(eyeColor);        // eye left        ellipse(bearX - 9, bearY - 53, 10, 10);        // eye right        ellipse(bearX + 9, bearY - 53, 10, 10);        // black        fill(0);        // black dot left        ellipse(bearX - 9, bearY - 53, 4, 4);        // black dot right        ellipse(bearX + 9, bearY - 53, 4, 4);        // empty        noFill();        curve(bearX - 6, bearY - 48, bearX - 2, bearY - 44, bearX + 2, bearY - 44, bearX + 6, bearY - 48);    }}',correct
'waterBlue',correct
'ellipse(tree2X + 8, tree2Y - 51, 20, 20)',correct
'curve(bearX - 6, bearY - 48, bearX - 2, bearY - 44, bearX + 2, bearY - 44, bearX + 6, bearY - 48)',correct
'0.4f',correct
'{    // white    eyeColor = color(255);    // blue    bodyColorB = color(191, 252, 255);    // light blue    inside = color(214, 253, 255);    // black    faceColor = color(0);    // grey    bodyColorF = color(185, 185, 185);    // black    eyeF = color(0);    // green    leafs = color(0, 88, 15);    // brown    treeBrown = color(118, 61, 6);    // white    cloudWhite = color(255);    // blue    waterBlue = color(21, 218, 255);    // green    grassGreen = color(10, 180, 2);    // blue    skyBlue = color(0, 202, 255);    // red    flower1 = color(255, 0, 0);    // yellow    flower2 = color(255, 213, 0);}',correct
'triangle(starX - 80, starY + 35, starX - 100, starY + 2, starX - 60, starY + 2);',correct
'treeY + 4',correct
'line(850, 100, 885, 65);',PixelHardcodeIgnoranceRule
'width / 1.3f',correct
'fill(grassGreen)',correct
'eyeColor = color(255, 0, 0)',correct
'ellipse(tree2X + 8, tree2Y - 26, 20, 20);',correct
'tree2X + 8',correct
'tree2X + 3',correct
'ellipse(tree2X + 38, tree2Y - 6, 20, 20)',correct
'int moonShaper;',correct
'cloudX = cloudX - 0.12f',correct
'if (fish3X < 0) {    fish3X = 1050;}',correct
'0.5f',correct
'ellipse(flX, flY + 8, 8, 8);',correct
'sun = color(255, 235, 3)',correct
'// arm rightellipse(bearX + 25, bearY - 25, 30, 15);',correct
'// greenleafs = color(0, 88, 15);',correct
'leafs = color(255, 111, 0)',correct
'teddy',correct
'ellipse(tree2X + 48, tree2Y - 16, 20, 20)',correct
'treeX + 8',correct
'treeX + 3',correct
'ellipse(tree2X + 28, tree2Y - 51, 20, 20);',correct
'// cloudnoStroke();',correct
'// grass , hillsnoStroke();',correct
'0.7f',correct
'// lighter blueinside = color(214, 253, 255);',correct
'// mouth, rightarc(bearX + 3, bearY - 42, 6, 6, 0, PI);',correct
'ellipse(treeX - 17, treeY - 16, 20, 20)',correct
'int inside;',correct
'starY + 2',correct
'printArray(f);',correct
'-2',correct
'// sunfill(sun);',correct
'int bearX;',correct
'moonColor = color(252, 251, 199)',correct
'ellipse(tree2X + 8, tree2Y + 4, 20, 20);',correct
'fill(bodyColorB)',correct
'cloudX = 1050;',correct
'drawBear',LongMethodRule
'ellipse(treeX + 8, treeY - 1, 20, 20)',correct
'starY = random(0, 250)',correct
'Moon moon;',correct
'// fish 3',correct
'int waterBlue;',correct
'ellipse(tree2X + 8, tree2Y - 26, 20, 20)',correct
'starX - 80',correct
'float fish2X;',correct
'tree2X - 2',correct
'ellipse(tree2X + 18, tree2Y - 11, 20, 20)',correct
'tree2Y - 46',correct
'// body',correct
'fish3Y = random(370, 600)',correct
'tree2Y + 4',correct
'triangle(fish3X - 55, fish3Y + 350, fish3X - 42, fish3Y + 357, fish3X - 42, fish3Y + 343)',correct
'// greyfill(bodyColorF);',correct
'bodyColorB = color(191, 252, 255)',correct
'ellipse(treeX - 2, treeY - 26, 20, 20);',correct
'rect(treeX, treeY, 30, 90)',correct
'tree2Y - 51',correct
'fishY + 293',correct
'ellipse(treeX + 13, treeY - 36, 20, 20)',correct
'ellipse(bearX - 25, bearY - 25, 30, 15)',correct
'fishY + 298',correct
'triangle(starX - 80, starY - 10, starX - 60, starY + 25, starX - 100, starY + 25)',correct
'starX - 60',correct
'line(750, 100, 700, 60);',PixelHardcodeIgnoranceRule
'eyeF = color(0)',correct
'int flower2;',correct
'ellipse(tree2X + 3, tree2Y - 36, 20, 20)',correct
'ellipse(500, 590, 600, 400)',correct
'// bluefill(bodyColorB);',correct
'flower2 = color(193, 190, 187)',correct
'color(10, 180, 2)',correct
'ellipse(cloudX - 15, cloudY + 15, 50, 50)',correct
'new DayLandscape()',correct
'fill(moonShaper);',correct
'2.5f',correct
'ellipse(flX, flY - 8, 8, 8)',correct
'{    // white    cloudWhite = color(255);    // yellow    sun = color(255, 235, 3);    cloudX = width / 6;    cloudY = height / 8.2f;}',correct
'int flower1;',correct
'height / 2.5f',correct
'fill(leafs)',correct
'starY - 2',correct
'strokeWeight(1);',correct
'ellipse(tree2X + 43, tree2Y - 36, 20, 20)',correct
'fill(grassGreen);',correct
'ellipse(flX - 8, flY, 8, 8)',correct
'fill(moonColor)',correct
'// fish 1',correct
'moon = new Moon();',correct
'sun',correct
'// bodyellipse(fishX - 70, fishY + 300, 30, 15);',correct
'ellipse(treeX + 8, treeY + 4, 20, 20);',correct
'color(118, 61, 6)',correct
'ellipse(treeX - 17, treeY - 26, 20, 20);',correct
'moon.drawMoon();',correct
'// dark redwaterBlue = color(173, 0, 0);',correct
'// flowerfill(flower1);',correct
'float starX;',correct
'ellipse(850, 600, 600, 400)',correct
'fish3X = fish3X - 1.8f',correct
'fish.drawFish()',correct
'triangle(starX, starY + 45, starX - 20, starY + 12, starX + 20, starY + 12);',correct
'ellipse(treeX + 18, treeY - 11, 20, 20)',correct
'ellipse(tree2X + 38, tree2Y - 21, 20, 20);',correct
'tree2Y = height / 2.8f',correct
'// tree 2noStroke();',correct
'{    cloudX = 1050;}',correct
'fish',correct
'ellipse(treeX - 12, treeY - 6, 20, 20);',correct
'{    fish3X = 1050;}',correct
'2.8f',correct
'// flower',correct
'noStroke()',correct
'// tree 2',correct
'height / 2.8f',correct
'treeX = width / 4.3f;',correct
'// arm leftellipse(bearX - 25, bearY - 25, 30, 15);',correct
'color(0, 88, 15)',correct
'inside',correct
'4.3f',correct
'ellipse(treeX + 18, treeY - 51, 20, 20);',correct
'fishY = random(370, 600)',correct
'// emptynoFill();',correct
'fish.drawFish();',correct
'triangle(starX - 80, starY - 10, starX - 60, starY + 25, starX - 100, starY + 25);',correct
'// fish 1// bodynoStroke();',correct
'ellipse(tree2X - 2, tree2Y - 46, 20, 20)',correct
'bearX',correct
'// black dot leftellipse(bearX - 9, bearY - 53, 4, 4);',correct
'// fish 2// greyfill(bodyColorF);',correct
'ellipse(850, 600, 600, 400);',correct
'bearY',correct
'fill(0)',correct
'cloudY + 15',correct
'height / 2',correct
'ellipse(treeX + 3, treeY - 36, 20, 20)',correct
'cloudY + 10',correct
'float cloudY;',correct
'ellipse(750, 650, 600, 400)',correct
'ellipse(tree2X - 17, tree2Y - 26, 20, 20)',correct
'cloudY + 40',correct
'cloudX = width / 6',correct
'ellipse(treeX + 8, treeY - 26, 20, 20)',correct
'triangle(starX, starY, starX + 20, starY + 35, starX - 20, starY + 35)',correct
'treeX',correct
'if (fish2X > 1050) {    fish2X = 0;}',correct
'fishX = 0;',correct
'treeY',correct
'float cloudX;',correct
'cloudY + 30',correct
'ellipse(tree2X + 13, tree2Y - 36, 20, 20)',correct
'tree2X',correct
'tree2Y',correct
'line(850, 195, 890, 235);',PixelHardcodeIgnoranceRule
'// colorsint bodyColorB;',correct
'arc(bearX - 3, bearY - 42, 6, 6, 0, PI)',correct
'grassGreen',correct
'// browntreeBrown = color(118, 61, 6);',correct
'DayLandscape() {    // green    grassGreen = color(10, 180, 2);    // blue    skyBlue = color(0, 202, 255);    // blue    waterBlue = color(21, 218, 255);    // brown    treeBrown = color(118, 61, 6);    // green    leafs = color(0, 88, 15);    // red    flower1 = color(255, 0, 0);    // yellow    flower2 = color(255, 213, 0);    treeX = width / 4.3f;    treeY = height / 2.5f;    tree2X = width / 1.3f;    tree2Y = height / 2.8f;    flX = width / 5.2f;    flY = height / 1.8f;}',correct
'void mouseReleased() {    // white    eyeColor = color(255);    // blue    bodyColorB = color(191, 252, 255);    // light blue    inside = color(214, 253, 255);    // black    faceColor = color(0);    // grey    bodyColorF = color(185, 185, 185);    // black    eyeF = color(0);    // green    leafs = color(0, 88, 15);    // brown    treeBrown = color(118, 61, 6);    // white    cloudWhite = color(255);    // blue    waterBlue = color(21, 218, 255);    // green    grassGreen = color(10, 180, 2);    // blue    skyBlue = color(0, 202, 255);    // red    flower1 = color(255, 0, 0);    // yellow    flower2 = color(255, 213, 0);}',correct
'ellipse(treeX + 3, treeY - 36, 20, 20);',correct
'color(255, 111, 0)',correct
'rect(-2, 650, 1002, 600);',correct
'Moon',correct
'int leafs;',correct
'ellipse(tree2X + 38, tree2Y - 46, 20, 20);',correct
'void mouseDragged() {    bearX = mouseX;    bearY = mouseY;}',correct
'rect(tree2X, tree2Y, 30, 90)',correct
'ellipse(cloudX + 55, cloudY + 15, 50, 50)',correct
'ellipse(treeX + 28, treeY - 26, 20, 20)',correct
'DayLandscape day;',correct
'ellipse(tree2X + 28, tree2Y - 51, 20, 20)',correct
'ellipse(flX + 8, flY, 8, 8)',correct
'fishX = random(0, 1000)',correct
'Moon() {    // white , yellowish    moonColor = color(252, 251, 199);    // darkblue    moonShaper = color(0, 17, 121);    starX = random(200, 600);    starY = random(0, 250);}',correct
'// light greygrassGreen = color(193, 190, 187);',correct
'ellipse(treeX - 12, treeY - 36, 20, 20)',correct
'fish2Y = random(370, 600)',correct
'int sun;',correct
'starX + 20',correct
'moon.drawMoon()',correct
'ellipse(tree2X + 38, tree2Y - 6, 20, 20);',correct
'ellipse(150, 600, 600, 400);',correct
'if (mousePressed) {    moon.drawMoon();} else {    skyD.drawDaySky();}',DecentralizedEventHandlingRule
'ellipse(bearX - 15, bearY - 70, 11, 11)',correct
'ellipse(tree2X + 18, tree2Y - 26, 20, 20)',correct
'ellipse(treeX, treeY - 18, 20, 20);',correct
'curve(bearX - 6, bearY - 48, bearX - 2, bearY - 44, bearX + 2, bearY - 44, bearX + 6, bearY - 48);',correct
'eyeColor',correct
'cloudX - 0.12f',correct
'color(0)',correct
'day.drawDayLandscape();',correct
'bearX = mouseX',correct
'// blackbodyColorF = color(0);',correct
'// tailtriangle(fish2X - 85, fish2Y + 350, fish2X - 92, fish2Y + 357, fish2X - 92, fish2Y + 343);',correct
'waterBlue = color(21, 218, 255)',correct
'// sun middleellipse(800, 150, 100, 100);',correct
'ellipse(bearX - 18, bearY + 10, 25, 25)',correct
'ellipse(treeX + 38, treeY - 21, 20, 20);',correct
'ellipse(treeX + 48, treeY - 26, 20, 20);',correct
'strokeWeight(10)',correct
'if (cloudX < -50) {    cloudX = 1050;}',correct
'skyD',correct
'// legs',correct
'ellipse(treeX + 28, treeY - 11, 20, 20);',correct
'ellipse(treeX + 43, treeY - 36, 20, 20)',correct
'ellipse(flX - 6, flY - 5, 8, 8);',correct
'Bear teddy;',correct
'ellipse(800, 150, 100, 100)',correct
'-50',correct
'// dark blueskyBlue = color(0, 17, 121);',correct
'// lighter bluefill(inside);',correct
'fish2X = random(0, 1000)',correct
'// eye rightellipse(bearX + 9, bearY - 53, 10, 10);',correct
'ellipse(tree2X + 48, tree2Y - 26, 20, 20);',correct
'fish2X = fish2X + 1.3f',correct
'line(800, 220, 800, 270);',correct
'ellipse(treeX + 28, treeY + 4, 20, 20)',correct
'rect(treeX, treeY, 30, 90);',correct
'// tailtriangle(fish3X - 55, fish3Y + 350, fish3X - 42, fish3Y + 357, fish3X - 42, fish3Y + 343);',correct
'// treenoStroke();',correct
'line(800, 80, 800, 30)',correct
'ellipse(bearX, bearY - 10, 45, 60)',correct
'line(875, 150, 925, 150)',correct
'eyeF = color(255)',correct
'float starY;',correct
'float[] f = { 0.1f, 0.2f, 0.3f, 0.4f, 0.5f };',ShortVariable
'ellipse(treeX + 18, treeY - 26, 20, 20);',correct
'ellipse(tree2X + 18, tree2Y + 4, 20, 20);',correct
'ellipse(tree2X - 2, tree2Y - 26, 20, 20)',correct
'day = new DayLandscape();',correct
'Bear',correct
'ellipse(treeX + 38, treeY - 46, 20, 20);',correct
'ellipse(fish3X - 70, fish3Y + 350, 32, 18)',correct
'moonColor',correct
'cloudY',correct
'line(800, 80, 800, 30);',PixelHardcodeIgnoranceRule
'// insideellipse(flX, flY, 10, 10);',correct
'// inside ear leftellipse(bearX - 15, bearY - 70, 11, 11);',correct
'ellipse(fish2X - 70, fish2Y + 350, 30, 15)',correct
'cloudX',correct
'fish3X - 1.8f',correct
'faceColor',correct
'random(0, 250)',correct
'ellipse(bearX, bearY - 50, 45, 45)',correct
'class Moon {    float starX;    float starY;    Moon() {        // white , yellowish        moonColor = color(252, 251, 199);        // darkblue        moonShaper = color(0, 17, 121);        starX = random(200, 600);        starY = random(0, 250);    }    void drawMoon() {        noStroke();        fill(moonColor);        ellipse(800, 150, 100, 100);        // star        triangle(starX, starY, starX + 20, starY + 35, starX - 20, starY + 35);        triangle(starX, starY + 45, starX - 20, starY + 12, starX + 20, starY + 12);        triangle(starX - 80, starY - 10, starX - 60, starY + 25, starX - 100, starY + 25);        triangle(starX - 80, starY + 35, starX - 100, starY + 2, starX - 60, starY + 2);        triangle(starX + 80, starY + 10, starX + 60, starY - 25, starX + 100, starY - 25);        triangle(starX + 80, starY - 35, starX + 100, starY - 2, starX + 60, starY - 2);        fill(moonShaper);        ellipse(830, 150, 100, 100);        fill(moonColor);    }}',correct
'tree2X = width / 1.3f;',correct
'ellipse(treeX + 18, treeY - 51, 20, 20)',correct
'// tree',correct
'8.2f',correct
'width / 2',correct
'// filling bodyellipse(bearX, bearY - 10, 30, 40);',correct
'{    day.drawDayLandscape();    fish.drawFish();    if (mousePressed) {        moon.drawMoon();    } else {        skyD.drawDaySky();    }    teddy.drawBear();}',correct
'// greengrassGreen = color(10, 180, 2);',correct
'tree2X = width / 1.3f',correct
'ellipse(treeX + 38, treeY - 21, 20, 20)',correct
'width / 6',correct
'void drawBear() {    // ears    stroke(0);    strokeWeight(1);    // blue    fill(bodyColorB);    // outside ear left    ellipse(bearX - 15, bearY - 70, 20, 20);    // outside ear right    ellipse(bearX + 15, bearY - 70, 20, 20);    // lighter blue    fill(inside);    // inside ear left    ellipse(bearX - 15, bearY - 70, 11, 11);    // inside ear right    ellipse(bearX + 15, bearY - 70, 11, 11);    // arms    // blue    fill(bodyColorB);    // arm left    ellipse(bearX - 25, bearY - 25, 30, 15);    // arm right    ellipse(bearX + 25, bearY - 25, 30, 15);    // body    // blue    fill(bodyColorB);    // body    ellipse(bearX, bearY - 10, 45, 60);    // lighter blue    fill(inside);    // filling body    ellipse(bearX, bearY - 10, 30, 40);    // head    // blue    fill(bodyColorB);    // head    ellipse(bearX, bearY - 50, 45, 45);    // legs    // blue    fill(bodyColorB);    // left leg    ellipse(bearX - 18, bearY + 10, 25, 25);    // right leg    ellipse(bearX + 18, bearY + 10, 25, 25);    // lighter blue    fill(inside);    // filling leg left    ellipse(bearX - 18, bearY + 10, 15, 15);    // filling leg right    ellipse(bearX + 18, bearY + 10, 15, 15);    // face    // mouth, left    arc(bearX - 3, bearY - 42, 6, 6, 0, PI);    // mouth, right    arc(bearX + 3, bearY - 42, 6, 6, 0, PI);    // white    fill(eyeColor);    // eye left    ellipse(bearX - 9, bearY - 53, 10, 10);    // eye right    ellipse(bearX + 9, bearY - 53, 10, 10);    // black    fill(0);    // black dot left    ellipse(bearX - 9, bearY - 53, 4, 4);    // black dot right    ellipse(bearX + 9, bearY - 53, 4, 4);    // empty    noFill();    curve(bearX - 6, bearY - 48, bearX - 2, bearY - 44, bearX + 2, bearY - 44, bearX + 6, bearY - 48);}',StatelessClassRule
'rect(-laserWidth / 2, -laserHeight / 2, laserWidth, laserHeight);',correct
'{    background(255);    // shoot a laser when space is pressed    if (space) {        laser.setStartLocation(manBodyX, manBodyY - 60);    // file.play();    }    // make de man and laser appear and update    man1.display();    man1.update();    laser.update();    laser.display();}',correct
'laser = new Laser()',correct
'manColor = color(random(0, 255), random(0, 255), random(0, 255));',correct
'Man man1;',correct
'// set starting position of the man and define manColorMan(int initX, int initY) {    manBodyX = initX;    manBodyY = initY;    manColor = color(random(0, 255), random(0, 255), random(0, 255));// irisColor= color(random(0, 255), random(0, 255), random(0, 255));}',correct
'// define starting location of the laservoid setStartLocation(float startX, float startY) {    if (firing == false) {        laserX = startX;        laserY = startY;        // once it starts, firing becomes true and has speed        firing = true;        speed = 5;    }}',correct
'// nipsfill(219, 105, 147);',correct
'// color irisColor;',correct
'random(0, 255)',correct
'man1.update()',correct
'laser = new Laser();',correct
'up = false',correct
'rotation = 0',correct
'up = true',correct
'laserY += sin(rotation) * speed;',correct
'left = true;',correct
'manBodyX = initX;',correct
'manBodyY',correct
'translate(laserX, laserY);',correct
'manBodyX',correct
'sin(rotation)',correct
'// SoundFile file;',correct
'// make new man and laserman1 = new Man(width / 2, height / 2);',correct
'laserX = startX',correct
'// eyefill(255);',correct
'man1',correct
'rotate(rotation)',correct
'pushMatrix();',correct
'laserX = startX;',correct
'ellipse(manBodyX + 10, manBodyY - 20, 5, 5);',correct
'{    switch(keyCode) {        case // left        37:            left = false;            break;        case // right        39:            right = false;            break;        case // up        38:            up = false;            break;        case // down        40:            down = false;            break;        case // space        32:            space = false;            break;    }}',correct
'color(random(0, 255), random(0, 255), random(0, 255))',correct
'background(255);',correct
'-laserWidth',correct
'left',correct
'laserX > width || X < 0 || Y < 0',correct
'case // up38:    up = false;    break;',correct
'ellipse(manBodyX, manBodyY - 60, 10, 10)',correct
'class Laser {    // declare variables for the laser    float laserWidth, laserHeight, laserX, laserY;    float speed, rotation, maxSpeed, minSpeed;    boolean firing;    // make the laser    Laser() {        laserX = 100;        laserY = -100;        laserWidth = 20;        laserHeight = 10;        // give laser speed and set boundaries. it starts of with not firing        speed = 0;        rotation = 0;        maxSpeed = 15;        minSpeed = 5;        firing = false;    }    // define starting location of the laser    void setStartLocation(float startX, float startY) {        if (firing == false) {            laserX = startX;            laserY = startY;            // once it starts, firing becomes true and has speed            firing = true;            speed = 5;        }    }    // make the laser have different speeds    void update() {        if (firing == true) {            if (speed < maxSpeed) {                speed += 1;            }            if (speed > minSpeed) {                speed -= 0.3f;            }            // rotation of laser for future upgrade of the program            // speed = maxSpeed;            laserX += cos(rotation) * speed;            laserY += sin(rotation) * speed;            // check for moving out of bounds            if (laserX > width || X < 0 || Y < 0) {                reset();            }        }    }    // if out of bounds remove laser and make it not firing and remove speed    void reset() {        speed = 0;        firing = false;        laserY = -100;    }    // make the laser move    void display() {        pushMatrix();        translate(laserX, laserY);        rotate(rotation);        fill(random(0, 255), random(0, 255), random(0, 255));        rect(-laserWidth / 2, -laserHeight / 2, laserWidth, laserHeight);        popMatrix();    }}',correct
'space = true',correct
'speed < maxSpeed',correct
'cos(rotation) * speed',correct
'if (right) {    manBodyX = manBodyX + 1;}',correct
'fill(0);',correct
'laserWidth = 20',correct
'// make the laser movevoid display() {    pushMatrix();    translate(laserX, laserY);    rotate(rotation);    fill(random(0, 255), random(0, 255), random(0, 255));    rect(-laserWidth / 2, -laserHeight / 2, laserWidth, laserHeight);    popMatrix();}',correct
'i = -18',correct
'// down40',correct
'left = true',correct
'rect(manBodyX - 2, manBodyY - 45, 4, 4)',correct
'case // down40:    down = true;    break;',correct
'// make the laserLaser() {    laserX = 100;    laserY = -100;    laserWidth = 20;    laserHeight = 10;    // give laser speed and set boundaries. it starts of with not firing    speed = 0;    rotation = 0;    maxSpeed = 15;    minSpeed = 5;    firing = false;}',correct
'fill(random(0, 255), random(0, 255), random(0, 255));',correct
'firing = false',correct
'down = true',correct
'int initY',correct
'manBodyY - 1',correct
'laserY = startY;',correct
'manBodyX = width / 2;',correct
'fill(234, 37, 99)',correct
'right',correct
'space = false',correct
'int initX',correct
'popMatrix();',correct
'if (left) {    manBodyX = manBodyX - 1;}',correct
'laserX > width || X < 0',correct
'// check for moving out of boundsif (laserX > width || X < 0 || Y < 0) {    reset();}',correct
'rect(manBodyX - 2, manBodyY - 45, 4, 4);',correct
'{    speed = 0;    firing = false;    laserY = -100;}',correct
'laserY += sin(rotation) * speed',correct
'{    laser.setStartLocation(manBodyX, manBodyY - 60);// file.play();}',correct
'maxSpeed = 15;',correct
'cos(rotation)',correct
'fill(234, 37, 99);',correct
'// import processing.sound.*;',correct
'noStroke()',correct
'right = false;',correct
'ellipse(manBodyX + 10, manBodyY - 20, 5, 5)',correct
'{    if (speed < maxSpeed) {        speed += 1;    }    if (speed > minSpeed) {        speed -= 0.3f;    }    // rotation of laser for future upgrade of the program    // speed = maxSpeed;    laserX += cos(rotation) * speed;    laserY += sin(rotation) * speed;    // check for moving out of bounds    if (laserX > width || X < 0 || Y < 0) {        reset();    }}',SimplifyBooleanExpressions
'i + 10',correct
'laserX > width',correct
'// headrect(manBodyX - 20, manBodyY - 75, 40, 40);',correct
'// fill(irisColor);fill(random(0, 255), random(0, 255), random(0, 255));',correct
'down',correct
'laser.setStartLocation(manBodyX, manBodyY - 60);',correct
'{    switch(keyCode) {        case // left        37:            left = true;            break;        case // right        39:            right = true;            break;        case // up        38:            up = true;            break;        case // down        40:            down = true;            break;        case // space        32:            space = true;            break;    }}',correct
'ellipse(manBodyX, manBodyY, 50, 75)',correct
'rect(manBodyX + i, manBodyY - 80, 5, 10);',correct
'manBodyX - 50',correct
'case // right39:    right = false;    break;',correct
'class Man {    // irisColor is commented out in this class because i like the rapid chaninging more    // it can be brought back for a static color    // same for manColor but i like a static body more    // the body has a different color everytime the program is started    int manColor;    // set starting position of the man and define manColor    Man(int initX, int initY) {        manBodyX = initX;        manBodyY = initY;        manColor = color(random(0, 255), random(0, 255), random(0, 255));    // irisColor= color(random(0, 255), random(0, 255), random(0, 255));    }    // draw the man with colors    void display() {        fill(manColor);        noStroke();        // body        ellipse(manBodyX, manBodyY, 50, 75);        // legs        rect(manBodyX - 20, manBodyY + 20, 10, 50);        rect(manBodyX + 10, manBodyY + 20, 10, 50);        // arms        rect(manBodyX - 50, manBodyY - 20, 100, 10);        // nips        fill(219, 105, 147);        ellipse(manBodyX - 10, manBodyY - 20, 5, 5);        ellipse(manBodyX + 10, manBodyY - 20, 5, 5);        fill(manColor);        // head        rect(manBodyX - 20, manBodyY - 75, 40, 40);        fill(234, 37, 99);        arc(manBodyX, manBodyY - 45, 20, 15, 0, PI, CHORD);        fill(255);        rect(manBodyX - 2, manBodyY - 45, 4, 4);        fill(0);        // for loop for making multiple hairs        for (int i = -18; i <= 20; i = i + 10) {            rect(manBodyX + i, manBodyY - 80, 5, 10);        }        // eye        fill(255);        ellipse(manBodyX, manBodyY - 60, 30, 15);        // fill(irisColor);        fill(random(0, 255), random(0, 255), random(0, 255));        ellipse(manBodyX, manBodyY - 60, 15, 15);        fill(0);        ellipse(manBodyX, manBodyY - 60, 10, 10);    }    // make the man move according to the arrowkeys    void update() {        if (left) {            manBodyX = manBodyX - 1;        }        if (right) {            manBodyX = manBodyX + 1;        }        if (up) {            manBodyY = manBodyY - 1;        }        if (down) {            manBodyY = manBodyY + 1;        }    }}',correct
'new Man(width / 2, height / 2)',correct
'up',correct
'up = false;',correct
'manBodyY = manBodyY - 1',correct
'if (speed < maxSpeed) {    speed += 1;}',correct
'break;',correct
'if (speed > minSpeed) {    speed -= 0.3f;}',correct
'manBodyY - 45',correct
'-100',correct
'fill(0)',correct
'if (down) {    manBodyY = manBodyY + 1;}',correct
'height / 2',correct
'i <= 20',correct
'manBodyY = manBodyY - 1;',DrawingStateChangeRule
'reset();',correct
'laser.display()',correct
'// bodyellipse(manBodyX, manBodyY, 50, 75);',correct
'left = false',correct
'-laserWidth / 2',correct
'manBodyX = initX',correct
'// this makes certain keys link to a boolean variable and makes them false when releasedvoid keyReleased() {    switch(keyCode) {        case // left        37:            left = false;            break;        case // right        39:            right = false;            break;        case // up        38:            up = false;            break;        case // down        40:            down = false;            break;        case // space        32:            space = false;            break;    }}',correct
'fill(219, 105, 147)',correct
'speed += 1;',correct
'update',correct
'{    if (firing == false) {        laserX = startX;        laserY = startY;        // once it starts, firing becomes true and has speed        firing = true;        speed = 5;    }}',correct
'fill(255)',correct
'laser.setStartLocation(manBodyX, manBodyY - 60)',correct
'speed',correct
'Processing',correct
'background(255)',correct
'laserWidth',correct
'{    manBodyY = manBodyY - 1;}',correct
'laser',correct
'rect(manBodyX + i, manBodyY - 80, 5, 10)',correct
'{    ellipseMode(CENTER);    manBodyX = width / 2;    manBodyY = height / 2;    // make new man and laser    man1 = new Man(width / 2, height / 2);    laser = new Laser();// file =  new SoundFile(this, "boem.mp3");}',correct
'// irisColor is commented out in this class because i like the rapid chaninging more// it can be brought back for a static color// same for manColor but i like a static body more// the body has a different color everytime the program is startedint manColor;',correct
'boolean firing;',correct
'pushMatrix()',correct
'// make the laser have different speedsvoid update() {    if (firing == true) {        if (speed < maxSpeed) {            speed += 1;        }        if (speed > minSpeed) {            speed -= 0.3f;        }        // rotation of laser for future upgrade of the program        // speed = maxSpeed;        laserX += cos(rotation) * speed;        laserY += sin(rotation) * speed;        // check for moving out of bounds        if (laserX > width || X < 0 || Y < 0) {            reset();        }    }}',correct
'// shoot a laser when space is pressedif (space) {    laser.setStartLocation(manBodyX, manBodyY - 60);// file.play();}',correct
'boolean left, right, up, down, space;',correct
'float startX',correct
'minSpeed',correct
'float startY',correct
'down = false;',correct
'arc(manBodyX, manBodyY - 45, 20, 15, 0, PI, CHORD)',correct
'{    speed += 1;}',correct
'{    reset();}',correct
'speed > minSpeed',correct
'laserX = 100;',correct
'manBodyY + 1',correct
'rotation',correct
'false',correct
'man1.update();',correct
'laser.update();',correct
'manBodyX - 2',correct
'maxSpeed',correct
'manBodyX - 1',correct
'manBodyY - 20',correct
'left = false;',correct
'-laserHeight / 2',correct
'ellipseMode(CENTER);',correct
'case // up38:    up = true;    break;',correct
'minSpeed = 5',correct
'// irisColor is commented out in this class because i like the rapid chaninging more',correct
'Laser',correct
'// for loop for making multiple hairsfor (int i = -18; i <= 20; i = i + 10) {    rect(manBodyX + i, manBodyY - 80, 5, 10);}',correct
'setup',correct
'{    rect(manBodyX + i, manBodyY - 80, 5, 10);}',correct
'ellipse(manBodyX, manBodyY - 60, 15, 15)',correct
'fill(manColor);',correct
'// Lars Hartogsveld',correct
'rotate(rotation);',correct
'case // space32:    space = false;    break;',correct
'down = true;',correct
'int manBodyY;',correct
'{    manBodyY = manBodyY + 1;}',correct
'right = false',correct
'0.3f',correct
'case // left37:    left = true;    break;',correct
'ellipse(manBodyX - 10, manBodyY - 20, 5, 5);',correct
'man1.display()',correct
'// declare variables for the laserfloat laserWidth, laserHeight, laserX, laserY;',correct
'ellipse(manBodyX - 10, manBodyY - 20, 5, 5)',correct
'-18',correct
'manBodyY = initY;',correct
'manBodyX - 10',correct
'rect(manBodyX - 50, manBodyY - 20, 100, 10)',correct
'// make de man and laser appear and updateman1.display();',correct
'speed = 0;',correct
'void draw() {    background(255);    // shoot a laser when space is pressed    if (space) {        laser.setStartLocation(manBodyX, manBodyY - 60);    // file.play();    }    // make de man and laser appear and update    man1.display();    man1.update();    laser.update();    laser.display();}',correct
'manColor = color(random(0, 255), random(0, 255), random(0, 255))',correct
'laserHeight = 10',correct
'// SoundFile file;void setup() {    ellipseMode(CENTER);    manBodyX = width / 2;    manBodyY = height / 2;    // make new man and laser    man1 = new Man(width / 2, height / 2);    laser = new Laser();// file =  new SoundFile(this, "boem.mp3");}',correct
'{    laserX = startX;    laserY = startY;    // once it starts, firing becomes true and has speed    firing = true;    speed = 5;}',SimplifyBooleanExpressions
'manBodyY = manBodyY + 1',correct
'rect(manBodyX - 20, manBodyY + 20, 10, 50)',correct
'manBodyX + i',correct
'manBodyX = manBodyX - 1',correct
'speed += 1',correct
'laserX',correct
'laserY',correct
'manBodyY - 80',correct
'manBodyX - 20',correct
'noStroke();',correct
'right = true',correct
'reset',correct
'{    speed -= 0.3f;}',correct
'rect(-laserWidth / 2, -laserHeight / 2, laserWidth, laserHeight)',correct
'Man',correct
'// draw the man with colorsvoid display() {    fill(manColor);    noStroke();    // body    ellipse(manBodyX, manBodyY, 50, 75);    // legs    rect(manBodyX - 20, manBodyY + 20, 10, 50);    rect(manBodyX + 10, manBodyY + 20, 10, 50);    // arms    rect(manBodyX - 50, manBodyY - 20, 100, 10);    // nips    fill(219, 105, 147);    ellipse(manBodyX - 10, manBodyY - 20, 5, 5);    ellipse(manBodyX + 10, manBodyY - 20, 5, 5);    fill(manColor);    // head    rect(manBodyX - 20, manBodyY - 75, 40, 40);    fill(234, 37, 99);    arc(manBodyX, manBodyY - 45, 20, 15, 0, PI, CHORD);    fill(255);    rect(manBodyX - 2, manBodyY - 45, 4, 4);    fill(0);    // for loop for making multiple hairs    for (int i = -18; i <= 20; i = i + 10) {        rect(manBodyX + i, manBodyY - 80, 5, 10);    }    // eye    fill(255);    ellipse(manBodyX, manBodyY - 60, 30, 15);    // fill(irisColor);    fill(random(0, 255), random(0, 255), random(0, 255));    ellipse(manBodyX, manBodyY - 60, 15, 15);    fill(0);    ellipse(manBodyX, manBodyY - 60, 10, 10);}',correct
'firing = true',correct
'{    fill(manColor);    noStroke();    // body    ellipse(manBodyX, manBodyY, 50, 75);    // legs    rect(manBodyX - 20, manBodyY + 20, 10, 50);    rect(manBodyX + 10, manBodyY + 20, 10, 50);    // arms    rect(manBodyX - 50, manBodyY - 20, 100, 10);    // nips    fill(219, 105, 147);    ellipse(manBodyX - 10, manBodyY - 20, 5, 5);    ellipse(manBodyX + 10, manBodyY - 20, 5, 5);    fill(manColor);    // head    rect(manBodyX - 20, manBodyY - 75, 40, 40);    fill(234, 37, 99);    arc(manBodyX, manBodyY - 45, 20, 15, 0, PI, CHORD);    fill(255);    rect(manBodyX - 2, manBodyY - 45, 4, 4);    fill(0);    // for loop for making multiple hairs    for (int i = -18; i <= 20; i = i + 10) {        rect(manBodyX + i, manBodyY - 80, 5, 10);    }    // eye    fill(255);    ellipse(manBodyX, manBodyY - 60, 30, 15);    // fill(irisColor);    fill(random(0, 255), random(0, 255), random(0, 255));    ellipse(manBodyX, manBodyY - 60, 15, 15);    fill(0);    ellipse(manBodyX, manBodyY - 60, 10, 10);}',LongMethodRule
'// space32',correct
'manBodyY - 75',correct
'{    if (left) {        manBodyX = manBodyX - 1;    }    if (right) {        manBodyX = manBodyX + 1;    }    if (up) {        manBodyY = manBodyY - 1;    }    if (down) {        manBodyY = manBodyY + 1;    }}',correct
'firing == true',SimplifyBooleanExpressions
'minSpeed = 5;',correct
'arc(manBodyX, manBodyY - 45, 20, 15, 0, PI, CHORD);',correct
'firing == false',correct
'float speed, rotation, maxSpeed, minSpeed;',correct
'keyReleased',correct
'if (up) {    manBodyY = manBodyY - 1;}',correct
'laser.update()',correct
'manBodyX = manBodyX + 1',correct
'// rotation of laser for future upgrade of the program// speed = maxSpeed;laserX += cos(rotation) * speed;',correct
'{    manBodyX = initX;    manBodyY = initY;    manColor = color(random(0, 255), random(0, 255), random(0, 255));// irisColor= color(random(0, 255), random(0, 255), random(0, 255));}',correct
'X < 0',correct
'space = true;',correct
'display',correct
'manBodyY - 60',correct
'case // right39:    right = true;    break;',correct
'manBodyX + 1',correct
'draw',correct
'// give laser speed and set boundaries. it starts of with not firingspeed = 0;',correct
'case // left37:    left = false;    break;',correct
'manBodyX = manBodyX + 1;',DrawingStateChangeRule
'manBodyY = manBodyY + 1;',DrawingStateChangeRule
'firing',correct
'// irisColor= color(random(0, 255), random(0, 255), random(0, 255));',correct
'case // down40:    down = false;    break;',correct
'ellipse(manBodyX, manBodyY - 60, 15, 15);',correct
'// right39',correct
'right = true;',correct
'case // space32:    space = true;    break;',correct
'rect(manBodyX + 10, manBodyY + 20, 10, 50)',correct
'// import processing.sound.*;// Lars Hartogsveld// Cyclops(man) that shoots lasers.int manBodyX;',correct
'down = false',correct
'{    manBodyX = manBodyX + 1;}',correct
'i = i + 10',correct
'rect(manBodyX + 10, manBodyY + 20, 10, 50);',correct
'manBodyY = initY',correct
'space',correct
'{    pushMatrix();    translate(laserX, laserY);    rotate(rotation);    fill(random(0, 255), random(0, 255), random(0, 255));    rect(-laserWidth / 2, -laserHeight / 2, laserWidth, laserHeight);    popMatrix();}',correct
'fill(255);',correct
'ellipseMode(CENTER)',correct
'manBodyY = height / 2;',correct
'maxSpeed = 15',correct
'// up38',correct
'laserX = 100',correct
'manColor',correct
'{    laserX = 100;    laserY = -100;    laserWidth = 20;    laserHeight = 10;    // give laser speed and set boundaries. it starts of with not firing    speed = 0;    rotation = 0;    maxSpeed = 15;    minSpeed = 5;    firing = false;}',correct
'// file =  new SoundFile(this, "boem.mp3");',correct
'// armsrect(manBodyX - 50, manBodyY - 20, 100, 10);',correct
'manBodyY + 20',correct
'Laser laser;',correct
'void',correct
'keyPressed',correct
'sin(rotation) * speed',correct
'laserY = -100;',correct
'ellipse(manBodyX, manBodyY - 60, 30, 15)',correct
'rotation = 0;',correct
'rect(manBodyX - 20, manBodyY - 75, 40, 40)',correct
'// this makes certain keys link to a boolean variable and makes them false when released',correct
'keyCode',correct
'fill(manColor)',correct
'speed = 0',correct
'manBodyX = manBodyX - 1;',DrawingStateChangeRule
'true',correct
'fill(random(0, 255), random(0, 255), random(0, 255))',correct
'ellipse(manBodyX, manBodyY - 60, 30, 15);',correct
'speed = 5',correct
'speed -= 0.3f',correct
'speed = 5;',correct
'// legsrect(manBodyX - 20, manBodyY + 20, 10, 50);',correct
'// if out of bounds remove laser and make it not firing and remove speedvoid reset() {    speed = 0;    firing = false;    laserY = -100;}',correct
'popMatrix()',correct
'-laserHeight',correct
'// rotation of laser for future upgrade of the program',correct
'firing = false;',correct
'laserHeight = 10;',correct
'// once it starts, firing becomes true and has speedfiring = true;',correct
'laserHeight',correct
'space = false;',correct
'// left37',correct
'manBodyX + 10',correct
'speed -= 0.3f;',correct
'{    manBodyX = manBodyX - 1;}',correct
'laserY = startY',correct
'manBodyX = width / 2',correct
'laserY = -100',correct
'// file.play();',correct
'translate(laserX, laserY)',correct
'// it can be brought back for a static color',correct
'{    if (firing == true) {        if (speed < maxSpeed) {            speed += 1;        }        if (speed > minSpeed) {            speed -= 0.3f;        }        // rotation of laser for future upgrade of the program        // speed = maxSpeed;        laserX += cos(rotation) * speed;        laserY += sin(rotation) * speed;        // check for moving out of bounds        if (laserX > width || X < 0 || Y < 0) {            reset();        }    }}',correct
'ellipse(manBodyX, manBodyY - 60, 10, 10);',correct
'laser.display();',correct
'// same for manColor but i like a static body more',correct
'setStartLocation',correct
'laserWidth = 20;',correct
'Y < 0',correct
'manBodyY = height / 2',correct
'int i = -18',correct
'// make the man move according to the arrowkeysvoid update() {    if (left) {        manBodyX = manBodyX - 1;    }    if (right) {        manBodyX = manBodyX + 1;    }    if (up) {        manBodyY = manBodyY - 1;    }    if (down) {        manBodyY = manBodyY + 1;    }}',correct
'width / 2',correct
'up = true;',correct
'reset()',correct
'// this makes certain keys link to a boolean variable and makes them true when pressedvoid keyPressed() {    switch(keyCode) {        case // left        37:            left = true;            break;        case // right        39:            right = true;            break;        case // up        38:            up = true;            break;        case // down        40:            down = true;            break;        case // space        32:            space = true;            break;    }}',correct
'new Laser()',correct
'laserX += cos(rotation) * speed',correct
'man1 = new Man(width / 2, height / 2)',correct
'void draw() {    isDay = true;    if (isDay) {        background(204, 255, 255);        fill(255, 255, 0);        stroke(255, 255, 0);        ellipse(600, 200, 155, 155);        line(760, 200, 450, 200);        line(740, 250, 470, 150);        line(710, 290, 490, 100);        line(600, 50, 600, 350);        line(670, 330, 530, 70);        line(670, 70, 530, 330);        line(720, 95, 480, 290);        line(735, 150, 460, 240);        fill(0);        ellipse(570, 180, 25, 25);        ellipse(630, 180, 25, 25);        stroke(0);        curve(570, 200, 590, 230, 610, 230, 630, 200);    }    if (isNight) {        background(0, 51, 102);        fill(starColor);        stroke(starColor);        star1.display();        for (int i = 0; i < starfield.length; i++) {            starfield[i].display();        }        fill(moonColor);        stroke(moonColor);        ellipse(630, 150, 155, 155);    }    Jan.display();    Henk.display();}',LongMethodRule
'fill(starColor)',correct
'if (popY > height - 300 || popY < rad) {    ydir *= -1;    bodyColor = color(random(0, 255), random(0, 255), random(0, 255));    bounce = bounce += 1;}',correct
'ydir *= -1;',correct
'popY - 107',correct
'value + 1',correct
'random(0, 255)',correct
'popX',correct
'int moonColor;',correct
'[25]',correct
'popY',correct
'line(popX - 30, popY, popX - 50, popY + 280);',correct
'stroke(0);',correct
'stroke(0)',correct
'popY - 110',correct
'value = 0;',correct
'starX - 47',correct
'xspeed = 4',correct
'popY + 10',correct
'color(random(0, 255), random(0, 255), random(0, 255))',correct
'if (popX > width - rad || popX < rad) {    xdir *= -1;    bodyColor = color(random(0, 255), random(0, 255), random(0, 255));    bounce = bounce += 1;}',correct
'vertex(starX, starY + 25);',correct
'popY = popY - 10;',correct
'Jan = new Pop(200, 500, color(0, 255, 100));',correct
'popY > height - 300 || popY < rad',correct
'fill(moonColor);',correct
'popY - 120',correct
'Henk.moveHenkKey()',correct
'popY - 125',correct
'stroke(bodyColor)',correct
'for (int i = 0; i < starfield.length; i++) {    starfield[i] = new Star(random(0, width), random(0, height), starColor);}',correct
'starX - 14',correct
'fill(0);',correct
'moonColor = color(195)',correct
'ellipse(600, 200, 155, 155)',correct
'{    Jan = new Pop(200, 500, color(0, 255, 100));    Henk = new Pop(600, 500, color(0, 255, 183));}',correct
'background(0, 51, 102);',correct
'if (key == z) {    isBouncing = true;}',correct
'a',correct
'vertex(starX, starY + 25)',correct
'void movePopMouse() {    popX = mouseX;    popY = mouseY;}',TooManyFields
'Jan.display()',correct
'{    Jan.processKey();    Henk.processKey();    Jan.movePopMouse();}',correct
'i',correct
'vertex(starX - 29, starY + 40)',correct
'random(0, width)',correct
'line(popX - 87, popY - 97, popX - 97, popY - 107);',correct
'j',correct
'k',correct
'l',correct
'star1 = new Star(400, 400, starColor);',correct
'Henk = new Pop(600, 500, color(0, 255, 183));',correct
'starX - 29',correct
'ellipse(popX + 60, popY - 80, 50, 50)',correct
'line(600, 50, 600, 350)',correct
'float text;',TooManyFields
's',correct
'popX = popX + (xspeed * xdir * 3)',correct
'starX - 23',correct
'if (key == s) {    Jan = new Pop(200, 500, color(0, 255, 100));    Henk = new Pop(600, 500, color(0, 255, 183));}',correct
'eyeColor = color(255)',correct
'line(760, 200, 450, 200);',PixelHardcodeIgnoranceRule
'isNight = false;',correct
'z',correct
'bodyColor = color(random(0, 255), random(0, 255), random(0, 255))',correct
'popY = popY + 10',correct
'line(710, 290, 490, 100);',PixelHardcodeIgnoranceRule
'ydir = 1',correct
'frameCount / +30.0f',correct
'{    bodyColor = (value);    value = value + 1;    if (value > 255) {        value = 0;    }}',correct
'popX = initX',correct
'stroke(moonColor);',correct
'line(popX + 77, popY - 107, popX + 83, popY - 120)',correct
'line(popX - 63, popY - 110, popX - 63, popY - 125)',correct
'void display() {    // head    fill(bodyColor);    stroke(bodyColor);    ellipse(popX, popY, 200, 200);    // eyes    fill(eyeColor);    stroke(bodyColor);    ellipse(popX - 60, popY - 80, 55, 55);    ellipse(popX + 60, popY - 80, 55, 55);    // eye iris    fill(0);    strokeWeight(0);    ellipse(popX - 60, popY - 80, 12, 12);    ellipse(popX + 60, popY - 80, 12, 12);    // eye lashes    stroke(0);    strokeWeight(5);    line(popX - 87, popY - 97, popX - 97, popY - 107);    line(popX - 77, popY - 107, popX - 83, popY - 120);    line(popX - 63, popY - 110, popX - 63, popY - 125);    line(popX + 87, popY - 97, popX + 97, popY - 107);    line(popX + 77, popY - 107, popX + 83, popY - 120);    line(popX + 63, popY - 110, popX + 63, popY - 125);    // legs    stroke(bodyColor);    strokeWeight(10);    line(popX - 30, popY, popX - 50, popY + 280);    line(popX + 30, popY, popX + 50, popY + 280);    if (isNight) {        fill(bodyColor);        stroke(bodyColor);        // eyes        ellipse(popX - 60, popY - 80, 50, 50);        ellipse(popX + 60, popY - 80, 50, 50);        // head        fill(bodyColor);        ellipse(popX, popY, 200, 200);        // eyelashes        stroke(0);        strokeWeight(5);        line(popX - 87, popY - 97, popX - 97, popY - 107);        line(popX - 77, popY - 107, popX - 83, popY - 120);        line(popX - 63, popY - 110, popX - 63, popY - 125);        line(popX + 87, popY - 97, popX + 97, popY - 107);        line(popX + 77, popY - 107, popX + 83, popY - 120);        line(popX + 63, popY - 110, popX + 63, popY - 125);        // legs        stroke(bodyColor);        strokeWeight(10);        line(popX - 30, popY, popX - 50, popY + 280);        line(popX + 30, popY, popX + 50, popY + 280);    }    if (isBouncing) {        popX = popX + (xspeed * xdir * 3);        popY = popY + (yspeed * ydir * 3);        if (popX > width - rad || popX < rad) {            xdir *= -1;            bodyColor = color(random(0, 255), random(0, 255), random(0, 255));            bounce = bounce += 1;        }        if (popY > height - 300 || popY < rad) {            ydir *= -1;            bodyColor = color(random(0, 255), random(0, 255), random(0, 255));            bounce = bounce += 1;        }        // bouncecounter        fill(0);        textSize(30);        text(bounce, popX, popY);    }}',TooManyFields
'void processKey() {    fill(bodyColor);    if (key == z) {        isBouncing = true;    }}',correct
'starfield[i]',correct
'fill(bodyColor)',correct
'popY = popY - 10',correct
'Henk.moveHenkKey();',correct
'curve(570, 200, 590, 230, 610, 230, 630, 200);',PixelHardcodeIgnoranceRule
'textSize(30);',correct
'ellipse(600, 200, 155, 155);',PixelHardcodeIgnoranceRule
'vertex(starX, starY - 50);',correct
'fill(bodyColor);',correct
'int initColor',correct
'if (value > 255) {    value = 0;}',correct
'star1.display()',correct
'vertex(starX - 23, starY + 7)',correct
'popX = popX + 10',correct
'// left and rightint xdir = 1;',TooManyFields
'new Pop(600, 500, color(0, 255, 183))',correct
'Processing',correct
'starY = initY',correct
'pushMatrix()',correct
'xdir *= -1',correct
'color(195)',correct
'Jan = new Pop(200, 500, color(0, 255, 100))',correct
'vertex(starX - 23, starY + 7);',correct
'Henk.changeColor();',correct
'color(255, 247, 135)',correct
'0.2f',correct
'false',correct
'starX + 47',correct
'popY - 10',correct
'endShape(CLOSE);',correct
'ellipse(630, 180, 25, 25)',correct
'value > 255',correct
'starColor = initColor',correct
'class Star {    float starX;    float starY;    int starColor;    // left and right    int xdir = 1;    // top to bottom    int ydir = 1;    Star(float initX, float initY, int initColor) {        starX = initX;        starY = initY;        starColor = initColor;    }    void display() {        pushMatrix();        translate(width * 0.8f, height * 0.2f);        rotate(frameCount / +30.0f);        stroke(255);        strokeWeight(2);        beginShape();        vertex(starX, starY - 50);        vertex(starX + 14, starY - 20);        vertex(starX + 47, starY - 15);        vertex(starX + 23, starY + 7);        vertex(starX + 29, starY + 40);        vertex(starX, starY + 25);        vertex(starX - 29, starY + 40);        vertex(starX - 23, starY + 7);        vertex(starX - 47, starY - 15);        vertex(starX - 14, starY - 20);        endShape(CLOSE);        popMatrix();    }}',correct
'vertex(starX + 29, starY + 40);',correct
'stroke(bodyColor);',correct
'// speedfloat xspeed = 4;',TooManyFields
'starColor = color(255, 247, 135);',correct
'starX = initX;',correct
'i = 0',correct
'line(popX + 30, popY, popX + 50, popY + 280);',correct
'if (key == i) {    popY = popY - 10;}',correct
'rad = 100',correct
'Jan.display();',correct
'popX - 97',correct
'Henk.changeColor()',correct
'Henk.processKey();',correct
'int eyeColor;',TooManyFields
'isDay = true',correct
'popY = popY + 10;',correct
'{    popY = popY + 10;}',correct
'width - rad',correct
'ellipse(630, 150, 155, 155)',correct
'text',correct
'popX = initX;',correct
'moonColor = color(195);',correct
'Jan.movePopMouse()',correct
'popX = popX + (xspeed * xdir * 3);',correct
'strokeWeight(5);',correct
'beginShape()',correct
'{    pushMatrix();    translate(width * 0.8f, height * 0.2f);    rotate(frameCount / +30.0f);    stroke(255);    strokeWeight(2);    beginShape();    vertex(starX, starY - 50);    vertex(starX + 14, starY - 20);    vertex(starX + 47, starY - 15);    vertex(starX + 23, starY + 7);    vertex(starX + 29, starY + 40);    vertex(starX, starY + 25);    vertex(starX - 29, starY + 40);    vertex(starX - 23, starY + 7);    vertex(starX - 47, starY - 15);    vertex(starX - 14, starY - 20);    endShape(CLOSE);    popMatrix();}',correct
'Star(float initX, float initY, int initColor) {    starX = initX;    starY = initY;    starColor = initColor;}',correct
'line(popX + 30, popY, popX + 50, popY + 280)',correct
'void keyPressed() {    Jan.processKey();    Henk.processKey();    Henk.moveHenkKey();    if (key == a) {        isNight = true;        isDay = false;    }}',correct
'popX - 77',correct
'color(0, 255, 100)',correct
'starfield[i].display()',correct
'line(popX + 63, popY - 110, popX + 63, popY - 125)',correct
'{    popX = popX + 10;}',correct
'starfield[i] = new Star(random(0, width), random(0, height), starColor);',correct
'stroke(starColor)',correct
'// headfill(bodyColor);',correct
'popX - 87',correct
'// SIMONE LUITEN s2075407Pop Jan;',correct
'line(760, 200, 450, 200)',correct
'Star[]',correct
'popX - 83',correct
'strokeWeight(0)',correct
'{    Jan.processKey();    Henk.processKey();    Henk.moveHenkKey();    if (key == a) {        isNight = true;        isDay = false;    }}',correct
'ellipse(popX - 60, popY - 80, 12, 12)',correct
'{    isBouncing = true;}',correct
'ellipse(popX - 60, popY - 80, 55, 55)',correct
'int value = 0;',TooManyFields
'30.0f',correct
'height * 0.2f',correct
'{    isNight = true;    isDay = false;}',correct
'fill(255, 255, 0)',correct
'{    isDay = true;    if (isDay) {        background(204, 255, 255);        fill(255, 255, 0);        stroke(255, 255, 0);        ellipse(600, 200, 155, 155);        line(760, 200, 450, 200);        line(740, 250, 470, 150);        line(710, 290, 490, 100);        line(600, 50, 600, 350);        line(670, 330, 530, 70);        line(670, 70, 530, 330);        line(720, 95, 480, 290);        line(735, 150, 460, 240);        fill(0);        ellipse(570, 180, 25, 25);        ellipse(630, 180, 25, 25);        stroke(0);        curve(570, 200, 590, 230, 610, 230, 630, 200);    }    if (isNight) {        background(0, 51, 102);        fill(starColor);        stroke(starColor);        star1.display();        for (int i = 0; i < starfield.length; i++) {            starfield[i].display();        }        fill(moonColor);        stroke(moonColor);        ellipse(630, 150, 155, 155);    }    Jan.display();    Henk.display();}',correct
'popX < rad',correct
'bodyColor = (value)',correct
'new Star(400, 400, starColor)',correct
'void',correct
'-1',correct
'bodyColor = initColor;',correct
'text(bounce, popX, popY);',correct
'width * 0.8f',correct
'vertex(starX + 23, starY + 7);',correct
'starY + 7',correct
'strokeWeight(10);',correct
'Henk = new Pop(600, 500, color(0, 255, 183))',correct
'Henk.Reset();',correct
'strokeWeight(2)',correct
'true',correct
'0.8f',correct
'fill(eyeColor)',correct
'new Star[25]',correct
'ydir *= -1',correct
'popMatrix()',correct
'ellipse(popX, popY, 200, 200)',correct
'line(popX + 87, popY - 97, popX + 97, popY - 107);',correct
'popY = mouseY',correct
'beginShape();',correct
'{    starX = initX;    starY = initY;    starColor = initColor;}',correct
'vertex(starX + 47, starY - 15)',correct
'// eyesfill(eyeColor);',correct
'strokeWeight(5)',correct
'void mouseClicked() {    Jan.processKey();    Henk.processKey();    Jan.movePopMouse();}',correct
'line(popX + 87, popY - 97, popX + 97, popY - 107)',correct
'yspeed = 4',correct
'background(0, 51, 102)',correct
'line(popX - 30, popY, popX - 50, popY + 280)',correct
'line(670, 330, 530, 70);',PixelHardcodeIgnoranceRule
'Star[] starfield = new Star[25];',correct
'{    background(0, 51, 102);    fill(starColor);    stroke(starColor);    star1.display();    for (int i = 0; i < starfield.length; i++) {        starfield[i].display();    }    fill(moonColor);    stroke(moonColor);    ellipse(630, 150, 155, 155);}',correct
'{    popX = popX + (xspeed * xdir * 3);    popY = popY + (yspeed * ydir * 3);    if (popX > width - rad || popX < rad) {        xdir *= -1;        bodyColor = color(random(0, 255), random(0, 255), random(0, 255));        bounce = bounce += 1;    }    if (popY > height - 300 || popY < rad) {        ydir *= -1;        bodyColor = color(random(0, 255), random(0, 255), random(0, 255));        bounce = bounce += 1;    }    // bouncecounter    fill(0);    textSize(30);    text(bounce, popX, popY);}',correct
'Jan',correct
'void changeColor() {    bodyColor = (value);    value = value + 1;    if (value > 255) {        value = 0;    }}',correct
'ellipse(570, 180, 25, 25)',correct
'boolean isNight;',correct
'isDay = false;',correct
'popX = popX + 10;',correct
'popX + 77',correct
'line(720, 95, 480, 290)',correct
'popX - 10',correct
'class Pop {    float popX;    float popY;    int bodyColor;    int eyeColor;    // speed    float xspeed = 4;    float yspeed = 4;    int rad = 100;    // left and right    int xdir = 1;    // top to bottom    int ydir = 1;    int bounce = 0;    boolean isBouncing;    int value = 0;    float text;    Pop(float initX, float initY, int initColor) {        popX = initX;        popY = initY;        bodyColor = initColor;        eyeColor = color(255);    }    void display() {        // head        fill(bodyColor);        stroke(bodyColor);        ellipse(popX, popY, 200, 200);        // eyes        fill(eyeColor);        stroke(bodyColor);        ellipse(popX - 60, popY - 80, 55, 55);        ellipse(popX + 60, popY - 80, 55, 55);        // eye iris        fill(0);        strokeWeight(0);        ellipse(popX - 60, popY - 80, 12, 12);        ellipse(popX + 60, popY - 80, 12, 12);        // eye lashes        stroke(0);        strokeWeight(5);        line(popX - 87, popY - 97, popX - 97, popY - 107);        line(popX - 77, popY - 107, popX - 83, popY - 120);        line(popX - 63, popY - 110, popX - 63, popY - 125);        line(popX + 87, popY - 97, popX + 97, popY - 107);        line(popX + 77, popY - 107, popX + 83, popY - 120);        line(popX + 63, popY - 110, popX + 63, popY - 125);        // legs        stroke(bodyColor);        strokeWeight(10);        line(popX - 30, popY, popX - 50, popY + 280);        line(popX + 30, popY, popX + 50, popY + 280);        if (isNight) {            fill(bodyColor);            stroke(bodyColor);            // eyes            ellipse(popX - 60, popY - 80, 50, 50);            ellipse(popX + 60, popY - 80, 50, 50);            // head            fill(bodyColor);            ellipse(popX, popY, 200, 200);            // eyelashes            stroke(0);            strokeWeight(5);            line(popX - 87, popY - 97, popX - 97, popY - 107);            line(popX - 77, popY - 107, popX - 83, popY - 120);            line(popX - 63, popY - 110, popX - 63, popY - 125);            line(popX + 87, popY - 97, popX + 97, popY - 107);            line(popX + 77, popY - 107, popX + 83, popY - 120);            line(popX + 63, popY - 110, popX + 63, popY - 125);            // legs            stroke(bodyColor);            strokeWeight(10);            line(popX - 30, popY, popX - 50, popY + 280);            line(popX + 30, popY, popX + 50, popY + 280);        }        if (isBouncing) {            popX = popX + (xspeed * xdir * 3);            popY = popY + (yspeed * ydir * 3);            if (popX > width - rad || popX < rad) {                xdir *= -1;                bodyColor = color(random(0, 255), random(0, 255), random(0, 255));                bounce = bounce += 1;            }            if (popY > height - 300 || popY < rad) {                ydir *= -1;                bodyColor = color(random(0, 255), random(0, 255), random(0, 255));                bounce = bounce += 1;            }            // bouncecounter            fill(0);            textSize(30);            text(bounce, popX, popY);        }    }    void processKey() {        fill(bodyColor);        if (key == z) {            isBouncing = true;        }    }    void Reset() {        if (key == s) {            Jan = new Pop(200, 500, color(0, 255, 100));            Henk = new Pop(600, 500, color(0, 255, 183));        }        eyeColor = color(255);        isBouncing = false;    }    void movePopMouse() {        popX = mouseX;        popY = mouseY;    }    void changeColor() {        bodyColor = (value);        value = value + 1;        if (value > 255) {            value = 0;        }    }    void moveHenkKey() {        if (key == l) {            popX = popX + 10;        }        if (key == k) {            popY = popY + 10;        }        if (key == j) {            popX = popX - 10;        }        if (key == i) {            popY = popY - 10;        }    }}',correct
'// top to bottomint ydir = 1;',TooManyFields
'popY = initY;',correct
'if (key == a) {    isNight = true;    isDay = false;}',correct
'starY = initY;',correct
'isNight = true',correct
'Henk.display()',correct
'starX = initX',correct
'starY + 25',correct
'popY = popY + (yspeed * ydir * 3)',correct
'void keyReleased() {    Jan.Reset();    Henk.Reset();    isNight = false;}',correct
'{    xdir *= -1;    bodyColor = color(random(0, 255), random(0, 255), random(0, 255));    bounce = bounce += 1;}',correct
'popX + 87',correct
'vertex(starX - 47, starY - 15)',correct
'isNight',correct
'popX + 83',correct
'vertex(starX + 14, starY - 20)',correct
'line(popX - 77, popY - 107, popX - 83, popY - 120);',correct
'pushMatrix();',correct
'line(600, 50, 600, 350);',PixelHardcodeIgnoranceRule
'xdir *= -1;',correct
'new Pop(200, 500, color(0, 255, 100))',correct
'isBouncing',correct
'int starColor;',correct
'Pop',correct
'{    background(204, 255, 255);    fill(255, 255, 0);    stroke(255, 255, 0);    ellipse(600, 200, 155, 155);    line(760, 200, 450, 200);    line(740, 250, 470, 150);    line(710, 290, 490, 100);    line(600, 50, 600, 350);    line(670, 330, 530, 70);    line(670, 70, 530, 330);    line(720, 95, 480, 290);    line(735, 150, 460, 240);    fill(0);    ellipse(570, 180, 25, 25);    ellipse(630, 180, 25, 25);    stroke(0);    curve(570, 200, 590, 230, 610, 230, 630, 200);}',correct
'fill(moonColor)',correct
'{    popX = mouseX;    popY = mouseY;}',correct
'star1 = new Star(400, 400, starColor)',correct
'curve(570, 200, 590, 230, 610, 230, 630, 200)',correct
'popY > height - 300',correct
'for (int i = 0; i < starfield.length; i++) {    starfield[i].display();}',correct
'height - 300',correct
'int bounce = 0;',correct
'if (key == j) {    popX = popX - 10;}',correct
'frameRate(30);',correct
'{    value = 0;}',correct
'{    popX = initX;    popY = initY;    bodyColor = initColor;    eyeColor = color(255);}',correct
'popY = popY + (yspeed * ydir * 3);',correct
'void Reset() {    if (key == s) {        Jan = new Pop(200, 500, color(0, 255, 100));        Henk = new Pop(600, 500, color(0, 255, 183));    }    eyeColor = color(255);    isBouncing = false;}',TooManyFields
'starY + 40',correct
'starColor = initColor;',correct
'{    // head    fill(bodyColor);    stroke(bodyColor);    ellipse(popX, popY, 200, 200);    // eyes    fill(eyeColor);    stroke(bodyColor);    ellipse(popX - 60, popY - 80, 55, 55);    ellipse(popX + 60, popY - 80, 55, 55);    // eye iris    fill(0);    strokeWeight(0);    ellipse(popX - 60, popY - 80, 12, 12);    ellipse(popX + 60, popY - 80, 12, 12);    // eye lashes    stroke(0);    strokeWeight(5);    line(popX - 87, popY - 97, popX - 97, popY - 107);    line(popX - 77, popY - 107, popX - 83, popY - 120);    line(popX - 63, popY - 110, popX - 63, popY - 125);    line(popX + 87, popY - 97, popX + 97, popY - 107);    line(popX + 77, popY - 107, popX + 83, popY - 120);    line(popX + 63, popY - 110, popX + 63, popY - 125);    // legs    stroke(bodyColor);    strokeWeight(10);    line(popX - 30, popY, popX - 50, popY + 280);    line(popX + 30, popY, popX + 50, popY + 280);    if (isNight) {        fill(bodyColor);        stroke(bodyColor);        // eyes        ellipse(popX - 60, popY - 80, 50, 50);        ellipse(popX + 60, popY - 80, 50, 50);        // head        fill(bodyColor);        ellipse(popX, popY, 200, 200);        // eyelashes        stroke(0);        strokeWeight(5);        line(popX - 87, popY - 97, popX - 97, popY - 107);        line(popX - 77, popY - 107, popX - 83, popY - 120);        line(popX - 63, popY - 110, popX - 63, popY - 125);        line(popX + 87, popY - 97, popX + 97, popY - 107);        line(popX + 77, popY - 107, popX + 83, popY - 120);        line(popX + 63, popY - 110, popX + 63, popY - 125);        // legs        stroke(bodyColor);        strokeWeight(10);        line(popX - 30, popY, popX - 50, popY + 280);        line(popX + 30, popY, popX + 50, popY + 280);    }    if (isBouncing) {        popX = popX + (xspeed * xdir * 3);        popY = popY + (yspeed * ydir * 3);        if (popX > width - rad || popX < rad) {            xdir *= -1;            bodyColor = color(random(0, 255), random(0, 255), random(0, 255));            bounce = bounce += 1;        }        if (popY > height - 300 || popY < rad) {            ydir *= -1;            bodyColor = color(random(0, 255), random(0, 255), random(0, 255));            bounce = bounce += 1;        }        // bouncecounter        fill(0);        textSize(30);        text(bounce, popX, popY);    }}',LongMethodRule
'popX + 50',correct
'popY + (yspeed * ydir * 3)',correct
'void setup() {    frameRate(30);    Jan = new Pop(200, 500, color(0, 255, 100));    Henk = new Pop(600, 500, color(0, 255, 183));    starColor = color(255, 247, 135);    moonColor = color(195);    star1 = new Star(400, 400, starColor);    for (int i = 0; i < starfield.length; i++) {        starfield[i] = new Star(random(0, width), random(0, height), starColor);    }}',correct
'vertex(starX - 14, starY - 20);',correct
'line(popX + 77, popY - 107, popX + 83, popY - 120);',correct
'ellipse(630, 150, 155, 155);',PixelHardcodeIgnoranceRule
'void moveHenkKey() {    if (key == l) {        popX = popX + 10;    }    if (key == k) {        popY = popY + 10;    }    if (key == j) {        popX = popX - 10;    }    if (key == i) {        popY = popY - 10;    }}',correct
'if (key == l) {    popX = popX + 10;}',correct
'Star',correct
'popY + 280',correct
'// eyelashesstroke(0);',correct
'+30.0f',correct
'bounce = 0',correct
'Star star1;',correct
'starColor',correct
'float starX;',correct
'vertex(starX - 47, starY - 15);',correct
'isBouncing = false',correct
'popX + 63',correct
'popX + 60',correct
'Pop(float initX, float initY, int initColor) {    popX = initX;    popY = initY;    bodyColor = initColor;    eyeColor = color(255);}',TooManyFields
'popMatrix();',correct
'star1.display();',correct
'strokeWeight(2);',correct
'popY < rad',correct
'stroke(255, 255, 0)',correct
'starColor = color(255, 247, 135)',correct
'Henk.display();',correct
'stroke(moonColor)',correct
'textSize(30)',correct
'rotate(frameCount / +30.0f)',correct
'bodyColor = color(random(0, 255), random(0, 255), random(0, 255));',correct
'popX - 50',correct
'starfield.length',correct
'// eye irisfill(0);',correct
'ellipse(570, 180, 25, 25);',PixelHardcodeIgnoranceRule
'// bouncecounterfill(0);',correct
'ellipse(popX - 60, popY - 80, 55, 55);',correct
'star1',correct
'line(670, 70, 530, 330)',correct
'stroke(255, 255, 0);',correct
'frameRate(30)',correct
'ellipse(630, 180, 25, 25);',PixelHardcodeIgnoranceRule
'popX - 63',correct
'popX - 60',correct
'// legsstroke(bodyColor);',correct
'value = value + 1',correct
'{    Jan.Reset();    Henk.Reset();    isNight = false;}',correct
'background(204, 255, 255)',correct
'Pop Henk;',VariableNamingConventions
'fill(0)',correct
'ellipse(popX + 60, popY - 80, 12, 12)',correct
'ellipse(popX - 60, popY - 80, 50, 50)',correct
'// eyesellipse(popX - 60, popY - 80, 50, 50);',correct
'ellipse(popX + 60, popY - 80, 50, 50);',correct
'popX + 97',correct
'int bodyColor;',correct
'popX - 30',correct
'{    popX = popX - 10;}',correct
'value = value + 1;',correct
'random(0, height)',correct
'{    frameRate(30);    Jan = new Pop(200, 500, color(0, 255, 100));    Henk = new Pop(600, 500, color(0, 255, 183));    starColor = color(255, 247, 135);    moonColor = color(195);    star1 = new Star(400, 400, starColor);    for (int i = 0; i < starfield.length; i++) {        starfield[i] = new Star(random(0, width), random(0, height), starColor);    }}',correct
'starX',correct
'starY',correct
'isBouncing = true',correct
'line(735, 150, 460, 240);',PixelHardcodeIgnoranceRule
'starfield = new Star[25]',correct
'bounce = bounce += 1;',IdempotentOperations
'bodyColor = (value);',correct
'float yspeed = 4;',TooManyFields
'{    starfield[i].display();}',correct
'popX = popX - 10;',correct
'line(740, 250, 470, 150);',PixelHardcodeIgnoranceRule
'vertex(starX + 14, starY - 20);',correct
'ellipse(popX - 60, popY - 80, 12, 12);',correct
'line(720, 95, 480, 290);',PixelHardcodeIgnoranceRule
'int i = 0',correct
'new Star(random(0, width), random(0, height), starColor)',correct
'stroke(255)',correct
'endShape(CLOSE)',correct
'stroke(starColor);',correct
'line(740, 250, 470, 150)',correct
'int rad = 100;',correct
'{    if (key == l) {        popX = popX + 10;    }    if (key == k) {        popY = popY + 10;    }    if (key == j) {        popX = popX - 10;    }    if (key == i) {        popY = popY - 10;    }}',correct
'color(255)',correct
'starX + 14',correct
'{    if (key == s) {        Jan = new Pop(200, 500, color(0, 255, 100));        Henk = new Pop(600, 500, color(0, 255, 183));    }    eyeColor = color(255);    isBouncing = false;}',correct
'Jan.Reset()',correct
'{    popY = popY - 10;}',correct
'isDay = true;',DrawingStateChangeRule
'i < starfield.length',correct
'if (key == k) {    popY = popY + 10;}',correct
'popX > width - rad || popX < rad',correct
'ellipse(popX + 60, popY - 80, 55, 55)',correct
'if (isNight) {    fill(bodyColor);    stroke(bodyColor);    // eyes    ellipse(popX - 60, popY - 80, 50, 50);    ellipse(popX + 60, popY - 80, 50, 50);    // head    fill(bodyColor);    ellipse(popX, popY, 200, 200);    // eyelashes    stroke(0);    strokeWeight(5);    line(popX - 87, popY - 97, popX - 97, popY - 107);    line(popX - 77, popY - 107, popX - 83, popY - 120);    line(popX - 63, popY - 110, popX - 63, popY - 125);    line(popX + 87, popY - 97, popX + 97, popY - 107);    line(popX + 77, popY - 107, popX + 83, popY - 120);    line(popX + 63, popY - 110, popX + 63, popY - 125);    // legs    stroke(bodyColor);    strokeWeight(10);    line(popX - 30, popY, popX - 50, popY + 280);    line(popX + 30, popY, popX + 50, popY + 280);}',correct
'starY - 50',correct
'starX + 23',correct
'boolean isDay;',correct
'float popY;',TooManyFields
'line(670, 70, 530, 330);',PixelHardcodeIgnoranceRule
'starX + 29',correct
'Jan.Reset();',correct
'ellipse(popX + 60, popY - 80, 55, 55);',correct
'starfield[i] = new Star(random(0, width), random(0, height), starColor)',correct
'line(710, 290, 490, 100)',correct
'line(popX - 87, popY - 97, popX - 97, popY - 107)',correct
'text(bounce, popX, popY)',correct
'bounce += 1',correct
'popY = mouseY;',correct
'key == l',correct
'key == k',correct
'fill(starColor);',correct
'translate(width * 0.8f, height * 0.2f)',correct
'key == j',correct
'key == i',correct
'starfield[i].display();',correct
'popX = mouseX;',correct
'{    Henk.changeColor();    Jan.changeColor();}',correct
'key == a',correct
'eyeColor',correct
'float popX;',TooManyFields
'{    ydir *= -1;    bodyColor = color(random(0, 255), random(0, 255), random(0, 255));    bounce = bounce += 1;}',correct
'key == z',correct
'key == s',correct
'background(204, 255, 255);',correct
'eyeColor = color(255);',correct
'isBouncing = true;',correct
'rotate(frameCount / +30.0f);',correct
'display',LongMethodRule
'vertex(starX - 29, starY + 40);',correct
'void display() {    pushMatrix();    translate(width * 0.8f, height * 0.2f);    rotate(frameCount / +30.0f);    stroke(255);    strokeWeight(2);    beginShape();    vertex(starX, starY - 50);    vertex(starX + 14, starY - 20);    vertex(starX + 47, starY - 15);    vertex(starX + 23, starY + 7);    vertex(starX + 29, starY + 40);    vertex(starX, starY + 25);    vertex(starX - 29, starY + 40);    vertex(starX - 23, starY + 7);    vertex(starX - 47, starY - 15);    vertex(starX - 14, starY - 20);    endShape(CLOSE);    popMatrix();}',correct
'Henk.Reset()',correct
'ellipse(popX + 60, popY - 80, 12, 12);',correct
'strokeWeight(10)',correct
'xdir = 1',correct
'ellipse(popX, popY, 200, 200);',correct
'popX + 30',correct
'if (isNight) {    background(0, 51, 102);    fill(starColor);    stroke(starColor);    star1.display();    for (int i = 0; i < starfield.length; i++) {        starfield[i].display();    }    fill(moonColor);    stroke(moonColor);    ellipse(630, 150, 155, 155);}',correct
'float initX',correct
'float initY',correct
'i++',correct
'{    fill(bodyColor);    stroke(bodyColor);    // eyes    ellipse(popX - 60, popY - 80, 50, 50);    ellipse(popX + 60, popY - 80, 50, 50);    // head    fill(bodyColor);    ellipse(popX, popY, 200, 200);    // eyelashes    stroke(0);    strokeWeight(5);    line(popX - 87, popY - 97, popX - 97, popY - 107);    line(popX - 77, popY - 107, popX - 83, popY - 120);    line(popX - 63, popY - 110, popX - 63, popY - 125);    line(popX + 87, popY - 97, popX + 97, popY - 107);    line(popX + 77, popY - 107, popX + 83, popY - 120);    line(popX + 63, popY - 110, popX + 63, popY - 125);    // legs    stroke(bodyColor);    strokeWeight(10);    line(popX - 30, popY, popX - 50, popY + 280);    line(popX + 30, popY, popX + 50, popY + 280);}',correct
'line(670, 330, 530, 70)',correct
'line(popX + 63, popY - 110, popX + 63, popY - 125);',correct
'vertex(starX - 14, starY - 20)',correct
'popX = popX - 10',correct
'popX = mouseX',correct
'value = 0',correct
'Jan.changeColor();',correct
'Jan.changeColor()',correct
'{    starfield[i] = new Star(random(0, width), random(0, height), starColor);}',correct
'translate(width * 0.8f, height * 0.2f);',correct
'line(popX - 63, popY - 110, popX - 63, popY - 125);',correct
'bodyColor = initColor',correct
'isDay = false',correct
'vertex(starX + 29, starY + 40)',correct
'{    fill(bodyColor);    if (key == z) {        isBouncing = true;    }}',correct
'Henk',correct
'fill(255, 255, 0);',correct
'Jan.movePopMouse();',correct
'float starY;',correct
'starY - 15',correct
'isNight = true;',correct
'bodyColor',correct
'isNight = false',correct
'popX + 10',correct
'starY - 20',correct
'line(popX - 77, popY - 107, popX - 83, popY - 120)',correct
'popY - 80',correct
'if (isDay) {    background(204, 255, 255);    fill(255, 255, 0);    stroke(255, 255, 0);    ellipse(600, 200, 155, 155);    line(760, 200, 450, 200);    line(740, 250, 470, 150);    line(710, 290, 490, 100);    line(600, 50, 600, 350);    line(670, 330, 530, 70);    line(670, 70, 530, 330);    line(720, 95, 480, 290);    line(735, 150, 460, 240);    fill(0);    ellipse(570, 180, 25, 25);    ellipse(630, 180, 25, 25);    stroke(0);    curve(570, 200, 590, 230, 610, 230, 630, 200);}',correct
'stroke(255);',correct
'popY = initY',correct
'Henk.processKey()',correct
'moonColor',correct
'vertex(starX, starY - 50)',correct
'// eye lashesstroke(0);',correct
'color(0, 255, 183)',correct
'isBouncing = false;',correct
'Jan.processKey()',correct
'bounce = bounce += 1',correct
'Jan.processKey();',correct
'strokeWeight(0);',correct
'vertex(starX + 23, starY + 7)',correct
'popY - 97',correct
'popX > width - rad',correct
'popX + (xspeed * xdir * 3)',correct
'isDay',correct
'line(735, 150, 460, 240)',correct
'if (isBouncing) {    popX = popX + (xspeed * xdir * 3);    popY = popY + (yspeed * ydir * 3);    if (popX > width - rad || popX < rad) {        xdir *= -1;        bodyColor = color(random(0, 255), random(0, 255), random(0, 255));        bounce = bounce += 1;    }    if (popY > height - 300 || popY < rad) {        ydir *= -1;        bodyColor = color(random(0, 255), random(0, 255), random(0, 255));        bounce = bounce += 1;    }    // bouncecounter    fill(0);    textSize(30);    text(bounce, popX, popY);}',correct
'void mouseDragged() {    Henk.changeColor();    Jan.changeColor();}',correct
'vertex(starX + 47, starY - 15);',correct
'boolean isBouncing;',correct
'void setup() {    turtleA = new Turtle(random(width / 2, width), random(0, height));    darkCoralA = new DarkCoral(5, height);    coralA = new Coral(0, height);    for (int i = 0; i < fishy.length; i++) {        fishy[i] = new Fish(random(width, width * 2), random(0, height));    }    for (int i = 0; i < bubble.length; i++) {        bubble[i] = new Bubbles(random(0, width), random(height, height * 2));    }}',correct
'{    line(secondXPos + 20, secondYPos, secondXPos + 20, secondYPos - 65);    line(secondXPos + 20, secondYPos - 35, secondXPos + 30, secondYPos - 40);    line(secondXPos + 20, secondYPos - 50, secondXPos + 10, secondYPos - 55);    line(secondXPos - 5, secondYPos, secondXPos - 5, secondYPos - 80);    line(secondXPos - 5, secondYPos - 40, secondXPos + 5, secondYPos - 55);    line(secondXPos - 5, secondYPos - 65, secondXPos - 15, secondYPos - 70);    line(secondXPos - 5, secondYPos - 35, secondXPos - 20, secondYPos - 50);    secondXPos = secondXPos + 50;}',correct
'secondXPos + 50',correct
'Fish(float initX, float initY) {    xpos = initX;    ypos = initY;}',correct
'for (int i = 0; i < bubble.length; i++) {    bubble[i] = new Bubbles(random(0, width), random(height, height * 2));}',correct
'{    background(12, 100, 207);    for (int i = 0; i < fishy.length; i++) {        fishy[i].display();    }    for (int i = 0; i < bubble.length; i++) {        bubble[i].display();    }    turtleA.display();    darkCoralA.display();    coralA.display();}',correct
'class Turtle {    int legLength = 70;    int legWidth = 15;    float xpos;    float ypos;    int speedX = 25;    int greenColour = color(15, 196, 29, 255);    int eyeColour = color(0, 0, 0, 255);    Turtle(float initX, float initY) {        xpos = initX;        ypos = initY;    }    void display() {        noStroke();        // head        fill(greenColour);        rectMode(CENTER);        rect(xpos - 60, ypos, 20, 20);        ellipse(xpos - 80, ypos, 35, 35);        // eye        fill(eyeColour);        ellipse(xpos - 87, ypos - 5, 10, 10);        // shell        fill(255, 200, 0);        arc(xpos, ypos, 120, 80, PI, TWO_PI, CHORD);        fill(251, 215, 11);        arc(xpos, ypos, 120, 40, 0, PI, CHORD);        // legs        fill(greenColour);        ellipseMode(CORNER);        ellipse(xpos + 10, ypos, legLength, legWidth);        ellipse(xpos - 40, ypos, legLength, legWidth);        ellipse(xpos + 13, ypos, 15, 15);        ellipse(xpos - 38, ypos, 15, 15);    }    void move() {        legWidth = 70;        legLength = 15;        xpos = xpos - speedX;        ypos = ypos - 5;        if (xpos <= -50) {            xpos = width + 50;        }        if ((ypos > height + 50) || (ypos < -50)) {            ypos = random(0, height - 50);            xpos = width + 50;        }    }    void move_back() {        legWidth = 15;        legLength = 70;    }}',correct
'xpos - 80',correct
'secondXPos + 5',correct
'{    fishy[i] = new Fish(random(width, width * 2), random(0, height));}',correct
'ypos - 20',correct
'ypos + 85',correct
'{    legWidth = 15;    legLength = 70;}',correct
'xpos - 87',correct
'line(xpos - 5, ypos - 35, xpos - 20, ypos - 50)',correct
'{    bubble[i] = new Bubbles(random(0, width), random(height, height * 2));}',correct
'height - 50',correct
'ypos - 25',correct
'turtleA.display()',correct
'xpos = xpos - speedX',correct
'line(xpos - 5, ypos - 65, xpos - 15, ypos - 70);',correct
'int secondYPos = height;',correct
'xpos + 5',correct
'DarkCoral(float initX, float initY) {    xpos = initX;    ypos = initY;}',correct
'ellipseMode(CORNER)',correct
'ypos - 30',correct
'line(xpos + 20, ypos - 50, xpos + 10, ypos - 55);',correct
'xpos = xpos - 1',correct
'random(width / 2, width)',correct
'ellipse(xpos + 13, ypos, 15, 15)',correct
'darkCoralA = new DarkCoral(5, height);',correct
'xpos = xpos + 50;',correct
'line(secondXPos + 20, secondYPos - 50, secondXPos + 10, secondYPos - 55);',correct
'line(xpos + 20, ypos - 25, xpos + 10, ypos - 30)',correct
'ypos = random(0, height - 50)',correct
'xpos = xpos - speedX;',correct
'turtleA = new Turtle(random(width / 2, width), random(0, height));',correct
'line(xpos - 5, ypos - 40, xpos + 5, ypos - 55)',correct
'ypos - 35',correct
'// coralint xpos = 0;',correct
'secondXPos - 15',correct
'line(secondXPos - 5, secondYPos - 40, secondXPos + 5, secondYPos - 55)',correct
'[4]',correct
'// eyefill(eyeColour);',correct
'random(width, width * 2)',correct
'fill(0);',correct
'{    xpos = width + 50;}',correct
'while (xpos <= width) {    line(xpos + 20, ypos, xpos + 20, ypos - 65);    line(xpos + 20, ypos - 35, xpos + 30, ypos - 40);    line(xpos + 20, ypos - 50, xpos + 10, ypos - 55);    line(xpos - 5, ypos, xpos - 5, ypos - 80);    line(xpos - 5, ypos - 40, xpos + 5, ypos - 55);    line(xpos - 5, ypos - 65, xpos - 15, ypos - 70);    line(xpos - 5, ypos - 35, xpos - 20, ypos - 50);    xpos = xpos + 50;}',correct
'line(xpos - 5, ypos - 65, xpos - 15, ypos - 70)',correct
'line(xpos + 20, ypos - 10, xpos + 30, ypos - 15);',correct
'{    // fish    ellipseMode(CENTER);    fill(255, 127, 39);    noStroke();    ellipse(xpos + 90, ypos + 70, 50, 20);    triangle(xpos + 110, ypos + 70, xpos + 145, ypos + 55, xpos + 145, ypos + 85);    fill(0);    ellipse(xpos + 75, ypos + 70, 5, 5);    xpos = xpos - 1;    if (xpos <= -200) {        xpos = width + 200;    }}',correct
'secondYPos - 80',correct
'ypos <= -100',correct
'Fish',correct
'secondXPos = 25',correct
'ellipse(xpos + 13, ypos, 15, 15);',correct
'fill(0, 255, 255);',correct
'rectMode(CENTER)',correct
'line(secondXPos - 5, secondYPos, secondXPos - 5, secondYPos - 80);',correct
'class Bubbles {    float xpos;    float ypos;    Bubbles(float initX, float initY) {        xpos = initX;        ypos = initY;    }    void display() {        stroke(255);        ellipseMode(CENTER);        fill(0, 255, 255);        ellipse(xpos, ypos, 20, 20);        fill(255);        ellipse(xpos - 4, ypos - 5, 8, 4);        ypos = ypos - 2;        if (ypos <= -100) {            ypos = height + 100;        }    }}',correct
'fill(255, 127, 39);',correct
'secondXPos - 20',correct
'xpos = width + 50;',correct
'fishy.length',correct
'random(0, width)',correct
'bubbleA',correct
'darkCoralA = new DarkCoral(5, height)',correct
'rect(xpos - 60, ypos, 20, 20)',correct
'line(secondXPos - 5, secondYPos - 65, secondXPos - 15, secondYPos - 70);',correct
'void move_back() {    legWidth = 15;    legLength = 70;}',correct
'-200',correct
'strokeWeight(8)',correct
'turtleA.display();',correct
'ypos - 10',correct
'{    xpos = initX;    ypos = initY;}',correct
'line(xpos + 20, ypos - 50, xpos + 10, ypos - 55)',correct
'ypos + 70',correct
'for (int i = 0; i < fishy.length; i++) {    fishy[i].display();}',correct
'float ypos;',correct
'ypos - 15',correct
'xpos = xpos + 60;',correct
'rectMode(CENTER);',correct
'noStroke()',correct
'secondXPos + 10',correct
'greenColour = color(15, 196, 29, 255)',correct
'arc(xpos, ypos, 120, 80, PI, TWO_PI, CHORD)',correct
'darkCoralA',correct
'int legWidth = 15;',correct
'xpos + 13',correct
'fill(251, 215, 11)',correct
'line(secondXPos - 5, secondYPos, secondXPos - 5, secondYPos - 80)',correct
'xpos + 10',correct
'ypos = height + 100;',correct
'{    line(xpos + 20, ypos, xpos + 20, ypos - 65);    line(xpos + 20, ypos - 35, xpos + 30, ypos - 40);    line(xpos + 20, ypos - 50, xpos + 10, ypos - 55);    line(xpos - 5, ypos, xpos - 5, ypos - 80);    line(xpos - 5, ypos - 40, xpos + 5, ypos - 55);    line(xpos - 5, ypos - 65, xpos - 15, ypos - 70);    line(xpos - 5, ypos - 35, xpos - 20, ypos - 50);    xpos = xpos + 50;}',correct
'ellipse(xpos + 10, ypos, legLength, legWidth)',correct
'line(xpos - 5, ypos - 15, xpos - 20, ypos - 20);',correct
'secondXPos = secondXPos + 50;',correct
'stroke(30, 132, 68)',correct
'void draw() {    background(12, 100, 207);    for (int i = 0; i < fishy.length; i++) {        fishy[i].display();    }    for (int i = 0; i < bubble.length; i++) {        bubble[i].display();    }    turtleA.display();    darkCoralA.display();    coralA.display();}',correct
'secondYPos - 55',correct
'{    ypos = height + 100;}',correct
'{    noStroke();    // head    fill(greenColour);    rectMode(CENTER);    rect(xpos - 60, ypos, 20, 20);    ellipse(xpos - 80, ypos, 35, 35);    // eye    fill(eyeColour);    ellipse(xpos - 87, ypos - 5, 10, 10);    // shell    fill(255, 200, 0);    arc(xpos, ypos, 120, 80, PI, TWO_PI, CHORD);    fill(251, 215, 11);    arc(xpos, ypos, 120, 40, 0, PI, CHORD);    // legs    fill(greenColour);    ellipseMode(CORNER);    ellipse(xpos + 10, ypos, legLength, legWidth);    ellipse(xpos - 40, ypos, legLength, legWidth);    ellipse(xpos + 13, ypos, 15, 15);    ellipse(xpos - 38, ypos, 15, 15);}',correct
'rect(xpos - 60, ypos, 20, 20);',correct
'ellipse(xpos + 90, ypos + 70, 50, 20)',correct
'if ((ypos > height + 50) || (ypos < -50)) {    ypos = random(0, height - 50);    xpos = width + 50;}',correct
'xpos - 40',correct
'secondXPos - 5',correct
'i < fishy.length',correct
'line(xpos + 20, ypos, xpos + 20, ypos - 65);',correct
'xpos = xpos - 1;',correct
'if (xpos <= -50) {    xpos = width + 50;}',correct
'color(15, 196, 29, 255)',correct
'line(secondXPos - 5, secondYPos - 65, secondXPos - 15, secondYPos - 70)',correct
'height + 100',correct
'Turtle',correct
'Turtle(float initX, float initY) {    xpos = initX;    ypos = initY;}',correct
'width + 200',correct
'background(12, 100, 207)',correct
'secondXPos + 20',correct
'ellipse(xpos, ypos, 20, 20)',correct
'legWidth = 15',correct
'secondYPos - 65',correct
'Fish[]',correct
'strokeWeight(3);',correct
'ypos = height',correct
'bubble.length',correct
'stroke(30, 132, 68);',correct
'-100',correct
'fill(0)',correct
'fishy[i] = new Fish(random(width, width * 2), random(0, height));',correct
'secondYPos - 70',correct
'Bubbles bubbleA;',correct
'width * 2',correct
'while (secondXPos <= width) {    line(secondXPos + 20, secondYPos, secondXPos + 20, secondYPos - 65);    line(secondXPos + 20, secondYPos - 35, secondXPos + 30, secondYPos - 40);    line(secondXPos + 20, secondYPos - 50, secondXPos + 10, secondYPos - 55);    line(secondXPos - 5, secondYPos, secondXPos - 5, secondYPos - 80);    line(secondXPos - 5, secondYPos - 40, secondXPos + 5, secondYPos - 55);    line(secondXPos - 5, secondYPos - 65, secondXPos - 15, secondYPos - 70);    line(secondXPos - 5, secondYPos - 35, secondXPos - 20, secondYPos - 50);    secondXPos = secondXPos + 50;}',correct
'line(xpos - 5, ypos, xpos - 5, ypos - 60);',correct
'void mousePressed() {    turtleA.move();}',correct
'ypos + 55',correct
'arc(xpos, ypos, 120, 40, 0, PI, CHORD);',correct
'fill(0, 255, 255)',correct
'xpos - speedX',correct
'legLength = 15;',correct
'secondXPos + 30',correct
'turtleA.move_back()',correct
'xpos = xpos + 50',correct
'{    stroke(255);    ellipseMode(CENTER);    fill(0, 255, 255);    ellipse(xpos, ypos, 20, 20);    fill(255);    ellipse(xpos - 4, ypos - 5, 8, 4);    ypos = ypos - 2;    if (ypos <= -100) {        ypos = height + 100;    }}',correct
'ellipse(xpos - 38, ypos, 15, 15)',correct
'random(0, height)',correct
'DarkCoral darkCoralA;',correct
'fill(255)',correct
'line(xpos + 20, ypos, xpos + 20, ypos - 65)',correct
'int secondXPos = 25;',correct
'secondYPos - 35',correct
'Processing',correct
'xpos = width + 200',correct
'int xpos = 0',correct
'ypos = ypos - 5',correct
'xpos - 60',correct
'{    int xpos = 8;    int ypos = height;    stroke(30, 132, 68);    strokeWeight(8);    while (xpos <= width) {        line(xpos + 20, ypos, xpos + 20, ypos - 65);        line(xpos + 20, ypos - 35, xpos + 30, ypos - 40);        line(xpos + 20, ypos - 50, xpos + 10, ypos - 55);        line(xpos - 5, ypos, xpos - 5, ypos - 80);        line(xpos - 5, ypos - 40, xpos + 5, ypos - 55);        line(xpos - 5, ypos - 65, xpos - 15, ypos - 70);        line(xpos - 5, ypos - 35, xpos - 20, ypos - 50);        xpos = xpos + 50;    }    int secondXPos = 25;    int secondYPos = height;    while (secondXPos <= width) {        line(secondXPos + 20, secondYPos, secondXPos + 20, secondYPos - 65);        line(secondXPos + 20, secondYPos - 35, secondXPos + 30, secondYPos - 40);        line(secondXPos + 20, secondYPos - 50, secondXPos + 10, secondYPos - 55);        line(secondXPos - 5, secondYPos, secondXPos - 5, secondYPos - 80);        line(secondXPos - 5, secondYPos - 40, secondXPos + 5, secondYPos - 55);        line(secondXPos - 5, secondYPos - 65, secondXPos - 15, secondYPos - 70);        line(secondXPos - 5, secondYPos - 35, secondXPos - 20, secondYPos - 50);        secondXPos = secondXPos + 50;    }}',correct
'fishy = new Fish[4]',correct
'color(0, 0, 0, 255)',correct
'ypos = ypos - 2',correct
'line(xpos + 20, ypos - 35, xpos + 30, ypos - 40)',correct
'ypos = height + 100',correct
'void display() {    int xpos = 8;    int ypos = height;    stroke(30, 132, 68);    strokeWeight(8);    while (xpos <= width) {        line(xpos + 20, ypos, xpos + 20, ypos - 65);        line(xpos + 20, ypos - 35, xpos + 30, ypos - 40);        line(xpos + 20, ypos - 50, xpos + 10, ypos - 55);        line(xpos - 5, ypos, xpos - 5, ypos - 80);        line(xpos - 5, ypos - 40, xpos + 5, ypos - 55);        line(xpos - 5, ypos - 65, xpos - 15, ypos - 70);        line(xpos - 5, ypos - 35, xpos - 20, ypos - 50);        xpos = xpos + 50;    }    int secondXPos = 25;    int secondYPos = height;    while (secondXPos <= width) {        line(secondXPos + 20, secondYPos, secondXPos + 20, secondYPos - 65);        line(secondXPos + 20, secondYPos - 35, secondXPos + 30, secondYPos - 40);        line(secondXPos + 20, secondYPos - 50, secondXPos + 10, secondYPos - 55);        line(secondXPos - 5, secondYPos, secondXPos - 5, secondYPos - 80);        line(secondXPos - 5, secondYPos - 40, secondXPos + 5, secondYPos - 55);        line(secondXPos - 5, secondYPos - 65, secondXPos - 15, secondYPos - 70);        line(secondXPos - 5, secondYPos - 35, secondXPos - 20, secondYPos - 50);        secondXPos = secondXPos + 50;    }}',LongMethodRule
'i < bubble.length',correct
'line(secondXPos - 5, secondYPos - 35, secondXPos - 20, secondYPos - 50)',correct
'line(xpos + 20, ypos, xpos + 20, ypos - 40)',correct
'turtleA.move()',correct
'xpos',correct
'secondYPos - 40',correct
'fishy[i].display();',correct
'int xpos = 8',correct
'xpos = xpos + 60',correct
'legLength = 70',correct
'class Fish {    float xpos;    float ypos;    Fish(float initX, float initY) {        xpos = initX;        ypos = initY;    }    void display() {        // fish        ellipseMode(CENTER);        fill(255, 127, 39);        noStroke();        ellipse(xpos + 90, ypos + 70, 50, 20);        triangle(xpos + 110, ypos + 70, xpos + 145, ypos + 55, xpos + 145, ypos + 85);        fill(0);        ellipse(xpos + 75, ypos + 70, 5, 5);        xpos = xpos - 1;        if (xpos <= -200) {            xpos = width + 200;        }    }}',correct
'// fishellipseMode(CENTER);',correct
'line(secondXPos - 5, secondYPos - 35, secondXPos - 20, secondYPos - 50);',correct
'int xpos = 8;',correct
'int i = 0',correct
'ypos = initY',correct
'ellipseMode(CENTER);',correct
'bubble[i] = new Bubbles(random(0, width), random(height, height * 2));',correct
'turtleA',correct
'ellipse(xpos - 87, ypos - 5, 10, 10)',correct
'secondYPos - 50',correct
'bubble[i].display()',correct
'stroke(255)',correct
'line(xpos - 5, ypos - 15, xpos - 20, ypos - 20)',correct
'legLength = 70;',correct
'i = 0',correct
'{    turtleA.move();}',correct
'ypos',correct
'int ypos = height;',correct
'coralA = new Coral(0, height)',correct
'secondXPos <= width',correct
'width + 50',correct
'ellipse(xpos, ypos, 20, 20);',correct
'void display() {    // coral    int xpos = 0;    int ypos = height;    stroke(34, 177, 76);    strokeWeight(3);    while (xpos <= width) {        line(xpos + 20, ypos, xpos + 20, ypos - 40);        line(xpos + 20, ypos - 10, xpos + 30, ypos - 15);        line(xpos + 20, ypos - 25, xpos + 10, ypos - 30);        line(xpos - 5, ypos, xpos - 5, ypos - 60);        line(xpos - 5, ypos - 30, xpos + 5, ypos - 35);        line(xpos - 5, ypos - 45, xpos - 15, ypos - 50);        line(xpos - 5, ypos - 15, xpos - 20, ypos - 20);        xpos = xpos + 60;    }}',correct
'new Coral(0, height)',correct
'ellipse(xpos + 90, ypos + 70, 50, 20);',correct
'xpos + 50',correct
'Fish[] fishy = new Fish[4];',correct
'line(xpos - 5, ypos - 45, xpos - 15, ypos - 50)',correct
'Turtle turtleA;',correct
'new Bubbles(random(0, width), random(height, height * 2))',correct
'line(xpos - 5, ypos - 40, xpos + 5, ypos - 55);',correct
'line(xpos + 20, ypos, xpos + 20, ypos - 40);',correct
'ellipse(xpos - 38, ypos, 15, 15);',correct
'Coral coralA;',correct
'new Fish(random(width, width * 2), random(0, height))',correct
'// headfill(greenColour);',correct
'secondXPos = secondXPos + 50',correct
'xpos = width + 50',correct
'void move() {    legWidth = 70;    legLength = 15;    xpos = xpos - speedX;    ypos = ypos - 5;    if (xpos <= -50) {        xpos = width + 50;    }    if ((ypos > height + 50) || (ypos < -50)) {        ypos = random(0, height - 50);        xpos = width + 50;    }}',correct
'random(0, height - 50)',correct
'fishy[i] = new Fish(random(width, width * 2), random(0, height))',correct
'xpos + 110',correct
'ellipse(xpos - 4, ypos - 5, 8, 4);',correct
'fill(greenColour)',correct
'ypos = ypos - 5;',correct
'background(12, 100, 207);',correct
'{    // coral    int xpos = 0;    int ypos = height;    stroke(34, 177, 76);    strokeWeight(3);    while (xpos <= width) {        line(xpos + 20, ypos, xpos + 20, ypos - 40);        line(xpos + 20, ypos - 10, xpos + 30, ypos - 15);        line(xpos + 20, ypos - 25, xpos + 10, ypos - 30);        line(xpos - 5, ypos, xpos - 5, ypos - 60);        line(xpos - 5, ypos - 30, xpos + 5, ypos - 35);        line(xpos - 5, ypos - 45, xpos - 15, ypos - 50);        line(xpos - 5, ypos - 15, xpos - 20, ypos - 20);        xpos = xpos + 60;    }}',correct
'noStroke();',correct
'ellipse(xpos - 80, ypos, 35, 35)',correct
'bubble[i]',correct
'xpos - 15',correct
'ypos = random(0, height - 50);',correct
'{    turtleA = new Turtle(random(width / 2, width), random(0, height));    darkCoralA = new DarkCoral(5, height);    coralA = new Coral(0, height);    for (int i = 0; i < fishy.length; i++) {        fishy[i] = new Fish(random(width, width * 2), random(0, height));    }    for (int i = 0; i < bubble.length; i++) {        bubble[i] = new Bubbles(random(0, width), random(height, height * 2));    }}',correct
'fill(255, 200, 0)',correct
'line(xpos - 5, ypos, xpos - 5, ypos - 60)',correct
'random(height, height * 2)',correct
'ellipse(xpos - 40, ypos, legLength, legWidth);',correct
'xpos + 30',correct
'line(secondXPos + 20, secondYPos - 50, secondXPos + 10, secondYPos - 55)',correct
'ellipse(xpos - 80, ypos, 35, 35);',correct
'xpos = initX;',correct
'int legLength = 70;',correct
'line(secondXPos + 20, secondYPos, secondXPos + 20, secondYPos - 65)',correct
'line(xpos + 20, ypos - 25, xpos + 10, ypos - 30);',correct
'line(xpos - 5, ypos - 35, xpos - 20, ypos - 50);',correct
'ypos - 80',correct
'darkCoralA.display();',correct
'xpos - 20',correct
'line(xpos - 5, ypos - 45, xpos - 15, ypos - 50);',correct
'coralA = new Coral(0, height);',correct
'Bubbles[] bubble = new Bubbles[10];',correct
'arc(xpos, ypos, 120, 80, PI, TWO_PI, CHORD);',correct
'class DarkCoral {    float xpos;    float ypos;    DarkCoral(float initX, float initY) {        xpos = initX;        ypos = initY;    }    void display() {        int xpos = 8;        int ypos = height;        stroke(30, 132, 68);        strokeWeight(8);        while (xpos <= width) {            line(xpos + 20, ypos, xpos + 20, ypos - 65);            line(xpos + 20, ypos - 35, xpos + 30, ypos - 40);            line(xpos + 20, ypos - 50, xpos + 10, ypos - 55);            line(xpos - 5, ypos, xpos - 5, ypos - 80);            line(xpos - 5, ypos - 40, xpos + 5, ypos - 55);            line(xpos - 5, ypos - 65, xpos - 15, ypos - 70);            line(xpos - 5, ypos - 35, xpos - 20, ypos - 50);            xpos = xpos + 50;        }        int secondXPos = 25;        int secondYPos = height;        while (secondXPos <= width) {            line(secondXPos + 20, secondYPos, secondXPos + 20, secondYPos - 65);            line(secondXPos + 20, secondYPos - 35, secondXPos + 30, secondYPos - 40);            line(secondXPos + 20, secondYPos - 50, secondXPos + 10, secondYPos - 55);            line(secondXPos - 5, secondYPos, secondXPos - 5, secondYPos - 80);            line(secondXPos - 5, secondYPos - 40, secondXPos + 5, secondYPos - 55);            line(secondXPos - 5, secondYPos - 65, secondXPos - 15, secondYPos - 70);            line(secondXPos - 5, secondYPos - 35, secondXPos - 20, secondYPos - 50);            secondXPos = secondXPos + 50;        }    }}',correct
'legWidth = 70',correct
'fill(eyeColour)',correct
'ellipse(xpos + 10, ypos, legLength, legWidth);',correct
'display',correct
'int speedX = 25;',correct
'xpos + 20',correct
'ypos - 5',correct
'void display() {    stroke(255);    ellipseMode(CENTER);    fill(0, 255, 255);    ellipse(xpos, ypos, 20, 20);    fill(255);    ellipse(xpos - 4, ypos - 5, 8, 4);    ypos = ypos - 2;    if (ypos <= -100) {        ypos = height + 100;    }}',correct
'fill(251, 215, 11);',correct
'ellipse(xpos - 4, ypos - 5, 8, 4)',correct
'ypos - 2',correct
'coralA',correct
'coralA.display();',correct
'ellipseMode(CORNER);',correct
'turtleA = new Turtle(random(width / 2, width), random(0, height))',correct
'{    fishy[i].display();}',correct
'speedX = 25',correct
'xpos - 38',correct
'{    xpos = width + 200;}',correct
'for (int i = 0; i < fishy.length; i++) {    fishy[i] = new Fish(random(width, width * 2), random(0, height));}',correct
'fishy[i].display()',correct
'arc(xpos, ypos, 120, 40, 0, PI, CHORD)',correct
'new DarkCoral(5, height)',correct
'ellipse(xpos + 75, ypos + 70, 5, 5);',correct
'float initX',correct
'line(secondXPos + 20, secondYPos, secondXPos + 20, secondYPos - 65);',correct
'float initY',correct
'Coral(float initX, float initY) {    xpos = initX;    ypos = initY;}',correct
'i++',correct
'-50',correct
'turtleA.move();',correct
'legWidth = 15;',correct
'// shellfill(255, 200, 0);',correct
'{    turtleA.move_back();}',correct
'bubble = new Bubbles[10]',correct
'xpos + 90',correct
'fill(255);',correct
'xpos <= -50',correct
'ellipseMode(CENTER)',correct
'ypos - 65',correct
'xpos <= -200',correct
'new Fish[4]',correct
'strokeWeight(3)',correct
'ypos - 60',correct
'class Coral {    float xpos;    float ypos;    Coral(float initX, float initY) {        xpos = initX;        ypos = initY;    }    void display() {        // coral        int xpos = 0;        int ypos = height;        stroke(34, 177, 76);        strokeWeight(3);        while (xpos <= width) {            line(xpos + 20, ypos, xpos + 20, ypos - 40);            line(xpos + 20, ypos - 10, xpos + 30, ypos - 15);            line(xpos + 20, ypos - 25, xpos + 10, ypos - 30);            line(xpos - 5, ypos, xpos - 5, ypos - 60);            line(xpos - 5, ypos - 30, xpos + 5, ypos - 35);            line(xpos - 5, ypos - 45, xpos - 15, ypos - 50);            line(xpos - 5, ypos - 15, xpos - 20, ypos - 20);            xpos = xpos + 60;        }    }}',correct
'ellipse(xpos - 87, ypos - 5, 10, 10);',correct
'line(xpos - 5, ypos - 30, xpos + 5, ypos - 35)',correct
'void',correct
'fill(255, 127, 39)',correct
'(ypos > height + 50) || (ypos < -50)',correct
'xpos - 4',correct
'stroke(34, 177, 76)',correct
'xpos - 5',correct
'ypos = initY;',correct
'xpos - 1',correct
'legWidth = 70;',correct
'int secondYPos = height',correct
'triangle(xpos + 110, ypos + 70, xpos + 145, ypos + 55, xpos + 145, ypos + 85)',correct
'// legsfill(greenColour);',correct
'stroke(34, 177, 76);',correct
'line(xpos + 20, ypos - 10, xpos + 30, ypos - 15)',correct
'ypos - 70',correct
'Bubbles(float initX, float initY) {    xpos = initX;    ypos = initY;}',correct
'legLength = 15',correct
'line(secondXPos + 20, secondYPos - 35, secondXPos + 30, secondYPos - 40);',correct
'triangle(xpos + 110, ypos + 70, xpos + 145, ypos + 55, xpos + 145, ypos + 85);',correct
'DarkCoral',correct
'fishy[i]',correct
'int ypos = height',correct
'line(xpos - 5, ypos - 30, xpos + 5, ypos - 35);',correct
'line(xpos + 20, ypos - 35, xpos + 30, ypos - 40);',correct
'ellipse(xpos - 40, ypos, legLength, legWidth)',correct
'void mouseReleased() {    turtleA.move_back();}',correct
'ypos = ypos - 2;',correct
'if (ypos <= -100) {    ypos = height + 100;}',correct
'xpos = 8',correct
'xpos + 75',correct
'[10]',correct
'{    legWidth = 70;    legLength = 15;    xpos = xpos - speedX;    ypos = ypos - 5;    if (xpos <= -50) {        xpos = width + 50;    }    if ((ypos > height + 50) || (ypos < -50)) {        ypos = random(0, height - 50);        xpos = width + 50;    }}',correct
'stroke(255);',correct
'void display() {    noStroke();    // head    fill(greenColour);    rectMode(CENTER);    rect(xpos - 60, ypos, 20, 20);    ellipse(xpos - 80, ypos, 35, 35);    // eye    fill(eyeColour);    ellipse(xpos - 87, ypos - 5, 10, 10);    // shell    fill(255, 200, 0);    arc(xpos, ypos, 120, 80, PI, TWO_PI, CHORD);    fill(251, 215, 11);    arc(xpos, ypos, 120, 40, 0, PI, CHORD);    // legs    fill(greenColour);    ellipseMode(CORNER);    ellipse(xpos + 10, ypos, legLength, legWidth);    ellipse(xpos - 40, ypos, legLength, legWidth);    ellipse(xpos + 13, ypos, 15, 15);    ellipse(xpos - 38, ypos, 15, 15);}',correct
'float xpos;',correct
'xpos + 145',correct
'ypos - 40',correct
'int greenColour = color(15, 196, 29, 255);',correct
'new Turtle(random(width / 2, width), random(0, height))',correct
'ellipse(xpos + 75, ypos + 70, 5, 5)',correct
'{    bubble[i].display();}',correct
'Bubbles',correct
'eyeColour = color(0, 0, 0, 255)',correct
'secondYPos = height',correct
'ypos - 45',correct
'xpos = 0',correct
'xpos = initX',correct
'new Bubbles[10]',correct
'{    ypos = random(0, height - 50);    xpos = width + 50;}',correct
'line(secondXPos - 5, secondYPos - 40, secondXPos + 5, secondYPos - 55);',correct
'Bubbles[]',correct
'for (int i = 0; i < bubble.length; i++) {    bubble[i].display();}',correct
'coralA.display()',correct
'xpos = width + 200;',correct
'xpos + 60',correct
'if (xpos <= -200) {    xpos = width + 200;}',correct
'line(secondXPos + 20, secondYPos - 35, secondXPos + 30, secondYPos - 40)',correct
'int eyeColour = color(0, 0, 0, 255);',correct
'turtleA.move_back();',correct
'width / 2',correct
'{    line(xpos + 20, ypos, xpos + 20, ypos - 40);    line(xpos + 20, ypos - 10, xpos + 30, ypos - 15);    line(xpos + 20, ypos - 25, xpos + 10, ypos - 30);    line(xpos - 5, ypos, xpos - 5, ypos - 60);    line(xpos - 5, ypos - 30, xpos + 5, ypos - 35);    line(xpos - 5, ypos - 45, xpos - 15, ypos - 50);    line(xpos - 5, ypos - 15, xpos - 20, ypos - 20);    xpos = xpos + 60;}',correct
'strokeWeight(8);',correct
'void display() {    // fish    ellipseMode(CENTER);    fill(255, 127, 39);    noStroke();    ellipse(xpos + 90, ypos + 70, 50, 20);    triangle(xpos + 110, ypos + 70, xpos + 145, ypos + 55, xpos + 145, ypos + 85);    fill(0);    ellipse(xpos + 75, ypos + 70, 5, 5);    xpos = xpos - 1;    if (xpos <= -200) {        xpos = width + 200;    }}',correct
'Coral',correct
'darkCoralA.display()',correct
'bubble[i] = new Bubbles(random(0, width), random(height, height * 2))',correct
'int secondXPos = 25',correct
'ypos - 50',correct
'ypos - 55',correct
'bubble[i].display();',correct
'line(xpos - 5, ypos, xpos - 5, ypos - 80);',correct
'line(xpos - 5, ypos, xpos - 5, ypos - 80)',correct
'while (xpos <= width) {    line(xpos + 20, ypos, xpos + 20, ypos - 40);    line(xpos + 20, ypos - 10, xpos + 30, ypos - 15);    line(xpos + 20, ypos - 25, xpos + 10, ypos - 30);    line(xpos - 5, ypos, xpos - 5, ypos - 60);    line(xpos - 5, ypos - 30, xpos + 5, ypos - 35);    line(xpos - 5, ypos - 45, xpos - 15, ypos - 50);    line(xpos - 5, ypos - 15, xpos - 20, ypos - 20);    xpos = xpos + 60;}',correct
'xpos <= width',correct
'height * 2',correct
'cyclopsY - 2',correct
'leftArmRad = -2',correct
'rightArmRad = -5;',correct
'rotate(rightArmRad);',correct
'arc(cyclopsX + 20, cyclopsY + 42, 14, 10, PI, 2 * PI)',correct
'rotate(rightArmRad)',correct
'PApplet.parseInt(random(0, height))',correct
'int leftHandX = 41;',TooManyFields
'void mouseReleased() {    for (int i = 0; i < cyclopses.length; i++) {        cyclopses[i].cycReleased();    }}',correct
'pupilColor',correct
'{    cyclopses[i] = new cyclops(PApplet.parseInt(random(0, width)), PApplet.parseInt(random(0, height)));}',correct
'rightArmPosX = 34;',correct
'cyclops[]',correct
'cyclopsX - 20',correct
'ellipse(cyclopsX, cyclopsY - 15, 30, 25);',correct
'int posY',correct
'int posX',correct
'int cyclopsY;',TooManyFields
'cyclopses[i] = new cyclops(PApplet.parseInt(random(0, width)), PApplet.parseInt(random(0, height)));',correct
'background(255);',correct
'rect(cyclopsX, cyclopsY, 50, 50)',correct
'cyclopsY + rightHandY',correct
'cyclopsX',correct
'cyclopsY',correct
'cyclops[] cyclopses = new cyclops[cyclopsCount];',correct
'cyclopses[i]',correct
'rightHandY = 6',correct
'// armLeftpushMatrix();',correct
'{    cyclopsX = posX;    cyclopsY = posY;    // orange    bodyColor = color(255, 110, 0);    // grey    eyeColor = color(235, 240, 240);    // blue    pupilColor = color(150, 100, 255);}',correct
'int cyclopsX;',correct
'stroke(bodyColor)',correct
'fill(0);',correct
'int leftArmPosX = -34;',TooManyFields
'cyclopses[i] = new cyclops(PApplet.parseInt(random(0, width)), PApplet.parseInt(random(0, height)))',correct
'fill(pupilColor);',correct
'for (int i = 0; i < cyclopses.length; i++) {    cyclopses[i].cycReleased();}',correct
'rectMode(CENTER)',correct
'leftHandX = 41',correct
'random(0, width)',correct
'// set bodycolorsstroke(bodyColor);',correct
'fill(pupilColor)',correct
'popMatrix();',correct
'int rightArmPosY = 3;',correct
'rotate(leftArmRad)',correct
'rightHandY = 6;',correct
'ellipse(cyclopsX + leftHandX, cyclopsY + leftHandY, 9, 9)',correct
'color(235, 240, 240)',correct
'translate(cyclopsX + leftArmPosX, cyclopsY + leftArmPosY);',correct
'// bodyrect(cyclopsX, cyclopsY, 50, 50);',correct
'rectMode(CENTER);',correct
'for (int i = 0; i < cyclopses.length; i++) {    cyclopses[i] = new cyclops(PApplet.parseInt(random(0, width)), PApplet.parseInt(random(0, height)));}',correct
'rightArmPosY = 3',correct
'cyclopses[i].cycPressed();',correct
'ellipse(cyclopsX, cyclopsY - 15, 3, 3);',correct
'rightArmPosY = 3;',correct
'arc(cyclopsX - 20, cyclopsY + 42, 14, 10, PI, 2 * PI);',correct
'color(150, 100, 255)',correct
'color(255, 110, 0)',correct
'int rightArmRad = 2;',correct
'ellipse(cyclopsX - 17, cyclopsY - 2, 25, 25)',correct
'void cycPressed() {    leftArmRad = 5;    leftArmPosX = -34;    leftArmPosY = -3;    leftHandX = 41;    leftHandY = -5;    rightArmRad = -5;    rightArmPosX = 34;    rightArmPosY = -3;    rightHandX = -41;    rightHandY = -5;}',TooManyFields
'fill(bodyColor)',correct
'cyclopsX + rightArmPosX',correct
'rightHandX = -41',correct
'translate(cyclopsX + rightArmPosX, cyclopsY + rightArmPosY);',correct
'new cyclops(PApplet.parseInt(random(0, width)), PApplet.parseInt(random(0, height)))',correct
'{    rectMode(CENTER);    ellipseMode(CENTER);    for (int i = 0; i < cyclopses.length; i++) {        cyclopses[i] = new cyclops(PApplet.parseInt(random(0, width)), PApplet.parseInt(random(0, height)));    }}',correct
'{    background(255);    for (int i = 0; i < cyclopses.length; i++) {        cyclopses[i].display();    }}',correct
'[cyclopsCount]',correct
'ellipse(cyclopsX, cyclopsY - 15, 3, 3)',correct
'cyclopsY + rightArmPosY',correct
'fill(0)',correct
'fill(bodyColor);',correct
'// armRightpushMatrix();',correct
'cyclopsX + rightHandX',correct
'cyclopses[i].display()',correct
'rightArmRad = 2',correct
'int bodyColor;',TooManyFields
'rightHandX = -41;',correct
'random(0, height)',correct
'eyeColor = color(235, 240, 240)',correct
'for (int i = 0; i < cyclopses.length; i++) {    cyclopses[i].display();}',correct
'background(255)',correct
'cyclopsY + 42',correct
'Processing',correct
'cyclopsX = posX',correct
'pupilColor = color(150, 100, 255)',correct
'int rightHandY = 6;',TooManyFields
'// greyeyeColor = color(235, 240, 240);',correct
'new cyclops[cyclopsCount]',correct
'pushMatrix()',correct
'leftArmPosX = -34',correct
'leftHandY = -5',correct
'ellipse(cyclopsX, cyclopsY - 15, 10, 10)',correct
'translate(cyclopsX + rightArmPosX, cyclopsY + rightArmPosY)',correct
'rightArmPosY = -3;',correct
'cyclopsX - 17',correct
'int leftHandY = 6;',TooManyFields
'rightHandY = -5;',correct
'i < cyclopses.length',correct
'// bluepupilColor = color(150, 100, 255);',correct
'cyclopsY + 33',correct
'ellipse(cyclopsX + 17, cyclopsY - 2, 25, 25);',correct
'leftArmPosY = -3',correct
'int i = 0',correct
'ellipseMode(CENTER);',correct
'leftArmPosY = -3;',correct
'ellipse(cyclopsX, cyclopsY - 15, 10, 10);',correct
'i = 0',correct
'cyclopsX + leftHandX',correct
'leftArmRad = 5;',correct
'cyclopsY + leftHandY',correct
'rightHandY = -5',correct
'ellipse(cyclopsX + rightHandX, cyclopsY + rightHandY, 9, 9)',correct
'int eyeColor;',TooManyFields
'ellipse(cyclopsX - 17, cyclopsY - 2, 25, 25);',correct
'cyclopsX + 17',correct
'{    for (int i = 0; i < cyclopses.length; i++) {        cyclopses[i].cycPressed();    }}',correct
'cyclopsY + leftArmPosY',correct
'int pupilColor;',TooManyFields
'rect(cyclopsX + 20, cyclopsY + 33, 10, 16)',correct
'void display() {    // set bodycolors    stroke(bodyColor);    fill(bodyColor);    // body    rect(cyclopsX, cyclopsY, 50, 50);    ellipse(cyclopsX, cyclopsY - 13, 55, 55);    ellipse(cyclopsX - 17, cyclopsY - 2, 25, 25);    ellipse(cyclopsX + 17, cyclopsY - 2, 25, 25);    // legs    rect(cyclopsX - 20, cyclopsY + 33, 10, 16);    rect(cyclopsX + 20, cyclopsY + 33, 10, 16);    arc(cyclopsX - 20, cyclopsY + 42, 14, 10, PI, 2 * PI);    arc(cyclopsX + 20, cyclopsY + 42, 14, 10, PI, 2 * PI);    // eye    strokeWeight(0);    fill(eyeColor);    ellipse(cyclopsX, cyclopsY - 15, 30, 25);    fill(pupilColor);    ellipse(cyclopsX, cyclopsY - 15, 10, 10);    fill(0);    ellipse(cyclopsX, cyclopsY - 15, 3, 3);    fill(60);    fill(bodyColor);    // armLeft    pushMatrix();    translate(cyclopsX + leftArmPosX, cyclopsY + leftArmPosY);    rotate(leftArmRad);    rect(0, 0, 10, 15);    popMatrix();    ellipse(cyclopsX + leftHandX, cyclopsY + leftHandY, 9, 9);    // armRight    pushMatrix();    translate(cyclopsX + rightArmPosX, cyclopsY + rightArmPosY);    rotate(rightArmRad);    rect(0, 0, 10, 15);    popMatrix();    ellipse(cyclopsX + rightHandX, cyclopsY + rightHandY, 9, 9);}',TooManyFields
'leftArmPosX = -34;',correct
'{    leftArmRad = 5;    leftArmPosX = -34;    leftArmPosY = -3;    leftHandX = 41;    leftHandY = -5;    rightArmRad = -5;    rightArmPosX = 34;    rightArmPosY = -3;    rightHandX = -41;    rightHandY = -5;}',correct
'// legsrect(cyclopsX - 20, cyclopsY + 33, 10, 16);',correct
'leftHandX = 41;',correct
'leftHandY = 6;',correct
'ellipse(cyclopsX, cyclopsY - 13, 55, 55);',correct
'cyclopses.length',correct
'rect(0, 0, 10, 15)',correct
'rightArmRad = 2;',correct
'rotate(leftArmRad);',correct
'// orangebodyColor = color(255, 110, 0);',correct
'-34',correct
'// eyestrokeWeight(0);',correct
'PApplet.parseInt(random(0, width))',correct
'cyclopsY = posY',correct
'eyeColor',correct
'arc(cyclopsX + 20, cyclopsY + 42, 14, 10, PI, 2 * PI);',correct
'int rightArmPosX = 34;',TooManyFields
'cyclopsY = posY;',correct
'int rightHandX = -41;',TooManyFields
'cyclopsX + 20',correct
'display',LongMethodRule
'int cyclopsCount = 3;',correct
'strokeWeight(0)',correct
'-41',correct
'ellipse(cyclopsX, cyclopsY - 15, 30, 25)',correct
'rightArmPosX = 34',correct
'cyclopsY - 13',correct
'cyclopsY - 15',correct
'leftArmRad = 5',correct
'ellipse(cyclopsX + 17, cyclopsY - 2, 25, 25)',correct
'bodyColor = color(255, 110, 0)',correct
'fill(eyeColor);',correct
'{    for (int i = 0; i < cyclopses.length; i++) {        cyclopses[i].cycReleased();    }}',correct
'{    leftArmRad = -2;    leftArmPosX = -34;    leftArmPosY = 3;    leftHandX = 41;    leftHandY = 6;    rightArmRad = 2;    rightArmPosX = 34;    rightArmPosY = 3;    rightHandX = -41;    rightHandY = 6;}',correct
'void cycReleased() {    leftArmRad = -2;    leftArmPosX = -34;    leftArmPosY = 3;    leftHandX = 41;    leftHandY = 6;    rightArmRad = 2;    rightArmPosX = 34;    rightArmPosY = 3;    rightHandX = -41;    rightHandY = 6;}',TooManyFields
'ellipse(cyclopsX + rightHandX, cyclopsY + rightHandY, 9, 9);',correct
'cyclopsX = posX;',correct
'i++',correct
'leftHandY = -5;',correct
'int leftArmPosY = 3;',TooManyFields
'ellipseMode(CENTER)',correct
'void mousePressed() {    for (int i = 0; i < cyclopses.length; i++) {        cyclopses[i].cycPressed();    }}',correct
'cyclopses = new cyclops[cyclopsCount]',correct
'{    // set bodycolors    stroke(bodyColor);    fill(bodyColor);    // body    rect(cyclopsX, cyclopsY, 50, 50);    ellipse(cyclopsX, cyclopsY - 13, 55, 55);    ellipse(cyclopsX - 17, cyclopsY - 2, 25, 25);    ellipse(cyclopsX + 17, cyclopsY - 2, 25, 25);    // legs    rect(cyclopsX - 20, cyclopsY + 33, 10, 16);    rect(cyclopsX + 20, cyclopsY + 33, 10, 16);    arc(cyclopsX - 20, cyclopsY + 42, 14, 10, PI, 2 * PI);    arc(cyclopsX + 20, cyclopsY + 42, 14, 10, PI, 2 * PI);    // eye    strokeWeight(0);    fill(eyeColor);    ellipse(cyclopsX, cyclopsY - 15, 30, 25);    fill(pupilColor);    ellipse(cyclopsX, cyclopsY - 15, 10, 10);    fill(0);    ellipse(cyclopsX, cyclopsY - 15, 3, 3);    fill(60);    fill(bodyColor);    // armLeft    pushMatrix();    translate(cyclopsX + leftArmPosX, cyclopsY + leftArmPosY);    rotate(leftArmRad);    rect(0, 0, 10, 15);    popMatrix();    ellipse(cyclopsX + leftHandX, cyclopsY + leftHandY, 9, 9);    // armRight    pushMatrix();    translate(cyclopsX + rightArmPosX, cyclopsY + rightArmPosY);    rotate(rightArmRad);    rect(0, 0, 10, 15);    popMatrix();    ellipse(cyclopsX + rightHandX, cyclopsY + rightHandY, 9, 9);}',LongMethodRule
'void',correct
'-2',correct
'-3',correct
'-5',correct
'cyclops(int posX, int posY) {    cyclopsX = posX;    cyclopsY = posY;    // orange    bodyColor = color(255, 110, 0);    // grey    eyeColor = color(235, 240, 240);    // blue    pupilColor = color(150, 100, 255);}',TooManyFields
'fill(60);',correct
'leftHandY = 6',correct
'translate(cyclopsX + leftArmPosX, cyclopsY + leftArmPosY)',correct
'leftArmPosY = 3;',correct
'rect(cyclopsX + 20, cyclopsY + 33, 10, 16);',correct
'arc(cyclopsX - 20, cyclopsY + 42, 14, 10, PI, 2 * PI)',correct
'cyclopses[i].display();',correct
'fill(eyeColor)',correct
'cyclopsX + leftArmPosX',correct
'void setup() {    rectMode(CENTER);    ellipseMode(CENTER);    for (int i = 0; i < cyclopses.length; i++) {        cyclopses[i] = new cyclops(PApplet.parseInt(random(0, width)), PApplet.parseInt(random(0, height)));    }}',correct
'bodyColor',correct
'popMatrix()',correct
'rightArmPosY = -3',correct
'cyclopses[i].cycPressed()',correct
'cyclopses[i].cycReleased()',correct
'ellipse(cyclopsX, cyclopsY - 13, 55, 55)',correct
'cyclopses[i].cycReleased();',correct
'{    cyclopses[i].cycReleased();}',correct
'{    cyclopses[i].display();}',correct
'cyclops',correct
'for (int i = 0; i < cyclopses.length; i++) {    cyclopses[i].cycPressed();}',correct
'{    cyclopses[i].cycPressed();}',correct
'ellipse(cyclopsX + leftHandX, cyclopsY + leftHandY, 9, 9);',correct
'rightArmRad = -5',correct
'cyclopsCount = 3',correct
'void draw() {    background(255);    for (int i = 0; i < cyclopses.length; i++) {        cyclopses[i].display();    }}',correct
'int leftArmRad = -2;',TooManyFields
'leftArmRad = -2;',correct
'2 * PI',correct
'leftArmPosY = 3',correct
'rect(cyclopsX - 20, cyclopsY + 33, 10, 16)',correct
'fill(60)',correct
'class cyclops {    int cyclopsX;    int cyclopsY;    int bodyColor;    int eyeColor;    int pupilColor;    int leftArmRad = -2;    int leftArmPosX = -34;    int leftArmPosY = 3;    int leftHandX = 41;    int leftHandY = 6;    int rightArmRad = 2;    int rightArmPosX = 34;    int rightArmPosY = 3;    int rightHandX = -41;    int rightHandY = 6;    cyclops(int posX, int posY) {        cyclopsX = posX;        cyclopsY = posY;        // orange        bodyColor = color(255, 110, 0);        // grey        eyeColor = color(235, 240, 240);        // blue        pupilColor = color(150, 100, 255);    }    void display() {        // set bodycolors        stroke(bodyColor);        fill(bodyColor);        // body        rect(cyclopsX, cyclopsY, 50, 50);        ellipse(cyclopsX, cyclopsY - 13, 55, 55);        ellipse(cyclopsX - 17, cyclopsY - 2, 25, 25);        ellipse(cyclopsX + 17, cyclopsY - 2, 25, 25);        // legs        rect(cyclopsX - 20, cyclopsY + 33, 10, 16);        rect(cyclopsX + 20, cyclopsY + 33, 10, 16);        arc(cyclopsX - 20, cyclopsY + 42, 14, 10, PI, 2 * PI);        arc(cyclopsX + 20, cyclopsY + 42, 14, 10, PI, 2 * PI);        // eye        strokeWeight(0);        fill(eyeColor);        ellipse(cyclopsX, cyclopsY - 15, 30, 25);        fill(pupilColor);        ellipse(cyclopsX, cyclopsY - 15, 10, 10);        fill(0);        ellipse(cyclopsX, cyclopsY - 15, 3, 3);        fill(60);        fill(bodyColor);        // armLeft        pushMatrix();        translate(cyclopsX + leftArmPosX, cyclopsY + leftArmPosY);        rotate(leftArmRad);        rect(0, 0, 10, 15);        popMatrix();        ellipse(cyclopsX + leftHandX, cyclopsY + leftHandY, 9, 9);        // armRight        pushMatrix();        translate(cyclopsX + rightArmPosX, cyclopsY + rightArmPosY);        rotate(rightArmRad);        rect(0, 0, 10, 15);        popMatrix();        ellipse(cyclopsX + rightHandX, cyclopsY + rightHandY, 9, 9);    }    void cycPressed() {        leftArmRad = 5;        leftArmPosX = -34;        leftArmPosY = -3;        leftHandX = 41;        leftHandY = -5;        rightArmRad = -5;        rightArmPosX = 34;        rightArmPosY = -3;        rightHandX = -41;        rightHandY = -5;    }    void cycReleased() {        leftArmRad = -2;        leftArmPosX = -34;        leftArmPosY = 3;        leftHandX = 41;        leftHandY = 6;        rightArmRad = 2;        rightArmPosX = 34;        rightArmPosY = 3;        rightHandX = -41;        rightHandY = 6;    }}',correct
'rect(0, 0, 10, 15);',correct
'hatX = unitX;',correct
'light1.coloryellow()',correct
'vlokken = new Vlok[200]',correct
'ellipse(xpos + 180, ypos + 56, 12, 12)',correct
'ellipse(xpos, ypos, size, size);',correct
'ypos + 80',correct
'ypos = ypos_;',correct
'stroke(0);',correct
'creatureY = unitY',correct
'stroke(0)',correct
'fill(color1)',correct
'triangle(creatureX - 4, creatureY - 42, creatureX, creatureY - 48, creatureX + 4, creatureY - 42)',correct
'i < vlokken.length',correct
'float ypos_',correct
'ellipse(xpos, ypos, size, size)',correct
'float treeY',correct
'float treeX',correct
'ellipse(xpos + 180, ypos - 33, 12, 12);',correct
'light2 = new Lights(550, 200, 0xffF2254A)',correct
'size',correct
'hatY - speed',correct
'float size_',correct
'ellipse(xpos + 145, ypos + 53, 12, 12);',correct
'ypos - 39',correct
'xpos + 190',correct
'ypos - 33',correct
'rect(0, 350, width * 2, 100)',correct
'// armsfill(183, 109, 25);',correct
'ypos - 36',correct
'xpos + 180',correct
'triangle(xpos + 80, ypos + 70, xpos + 280, ypos + 70, xpos + 180, ypos - 10);',correct
'tree1.display();',correct
'Hat hat1;',correct
'creatureX',correct
'triangle(xpos + 120, ypos - 10, xpos + 240, ypos - 10, xpos + 180, ypos - 90);',correct
'{    c = c_;    xpos = xpos_;    ypos = ypos_;    speed = speed_;    size = size_;}',correct
'random(1, 4)',correct
'xpos = xpos_',correct
'creatureY',correct
'stroke(242, 245, 249);',correct
'{    ellipseMode(CENTER);    fill(c);    ellipse(xpos, ypos, size, size);}',correct
'Lights(float treeX, float treeY, int cc_) {    color1 = cc_;    xpos = treeX;    ypos = treeY;}',correct
'random(3, 9)',correct
'void draw() {    background(27, 14, 152);    snowman1.display();    hat1.display();    tree1.display();    light1.display();    tree2.display();    light2.display();    for (int i = 0; i < vlokken.length; i++) {        vlokken[i].move();        vlokken[i].display();    }    stroke(242, 245, 249);    fill(253, 252, 255);    rect(0, 350, width * 2, 100);}',correct
'creatureX + 4',correct
'{    color1 = color(0xffF9FA3F);}',correct
'light1 = new Lights(300, 200, 0xffFA1C45)',correct
'void move() {    ypos = ypos + speed;    if (ypos > height) {        ypos = 0;    }}',correct
'Tree(float treeX, float treeY) {    xpos = treeX;    // xpos=width/2;    ypos = treeY;}',correct
'line(creatureX - 70, creatureY - 25, creatureX - 30, creatureY)',correct
'vlokken[i].display();',correct
'triangle(creatureX - 4, creatureY - 42, creatureX, creatureY - 48, creatureX + 4, creatureY - 42);',correct
'tree2 = new Tree(550, 200)',correct
'rectMode(CENTER)',correct
'c',correct
'speed = speed_;',correct
'j',correct
'ypos > height',correct
'triangle(xpos + 100, ypos + 30, xpos + 260, ypos + 30, xpos + 180, ypos - 50)',correct
'stroke(183, 109, 25)',correct
'ellipse(creatureX, creatureY + 55, 90, 90);',correct
'r',correct
'ypos - 10',correct
'if (ypos > height) {    ypos = 0;}',correct
'ypos = ypos + speed',correct
'u',correct
'ypos + 70',correct
'line(creatureX + 20, creatureY - 30, creatureX + 20, creatureY + 5);',correct
'float ypos;',correct
'y',correct
'rectMode(CENTER);',correct
'int color1;',correct
'{    snowman1 = new Snowman1(200, 200);    hat1 = new Hat(200, 200, 3);    tree1 = new Tree(300, 200);    light1 = new Lights(300, 200, 0xffFA1C45);    tree2 = new Tree(550, 200);    light2 = new Lights(550, 200, 0xffF2254A);    for (int i = 0; i < vlokken.length; i++) {        vlokken[i] = new Vlok(color(255), random(0, 800), random(0, 400), random(1, 4), random(3, 9));    }}',correct
'vlokken[i]',correct
'snowman1.display()',correct
'light1.coloryellow();',correct
'ellipse(xpos + 125, ypos + 50, 12, 12);',correct
'class Tree {    float xpos, ypos;    Tree(float treeX, float treeY) {        xpos = treeX;        // xpos=width/2;        ypos = treeY;    }    void display() {        // tree        fill(88, 63, 11);        stroke(100, 70, 3);        rect(xpos + 180, ypos + 80, 20, 40);        fill(26, 132, 17);        stroke(26, 132, 17);        triangle(xpos + 80, ypos + 70, xpos + 280, ypos + 70, xpos + 180, ypos - 10);        triangle(xpos + 100, ypos + 30, xpos + 260, ypos + 30, xpos + 180, ypos - 50);        triangle(xpos + 120, ypos - 10, xpos + 240, ypos - 10, xpos + 180, ypos - 90);    }}',correct
'ellipse(xpos + 215, ypos + 53, 12, 12)',correct
'hatY = unitY',correct
'light1.colorred();',correct
'background(27, 14, 152)',correct
'void display() {    // hat    fill(0);    stroke(0);    strokeWeight(2);    rect(hatX, hatY - 75, 100, 7);    rect(hatX, hatY - 100, 50, 50);    strokeWeight(0);}',correct
'creatureY + 15',correct
'xpos = treeX;',correct
'snowman1 = new Snowman1(200, 200)',correct
'light2.display()',correct
'vlokken.length',correct
'ypos + 50',correct
'width * 2',correct
'ellipse(xpos + 160, ypos + 16, 12, 12)',correct
'float creatureX;',correct
'stroke(235, 137, 33)',correct
'ypos + 53',correct
'ypos + 56',correct
'triangle(xpos + 120, ypos - 10, xpos + 240, ypos - 10, xpos + 180, ypos - 90)',correct
'hat1',correct
'class Lights {    float xpos;    float ypos;    int color1;    Lights(float treeX, float treeY, int cc_) {        color1 = cc_;        xpos = treeX;        ypos = treeY;    }    void display() {        // lights        fill(color1);        stroke(color1);        ellipse(xpos + 215, ypos + 10, 12, 12);        ellipse(xpos + 160, ypos + 16, 12, 12);        ellipse(xpos + 190, ypos + 16, 12, 12);        ellipse(xpos + 140, ypos + 13, 12, 12);        ellipse(xpos + 150, ypos - 39, 12, 12);        ellipse(xpos + 180, ypos - 33, 12, 12);        ellipse(xpos + 210, ypos - 36, 12, 12);        ellipse(xpos + 125, ypos + 50, 12, 12);        ellipse(xpos + 145, ypos + 53, 12, 12);        ellipse(xpos + 180, ypos + 56, 12, 12);        ellipse(xpos + 215, ypos + 53, 12, 12);        ellipse(xpos + 240, ypos + 50, 12, 12);    }    void coloryellow() {        color1 = color(0xffF9FA3F);    }    void colorred() {        color1 = color(0xffFA1C45);    }}',correct
'{    ypos = 0;}',correct
'hatY + speed',correct
'ellipse(creatureX, creatureY - 55, 60, 60)',correct
'void hatMoveUp() {    hatY = hatY - speed;}',correct
'creatureY + 5',correct
'Processing',correct
'creatureX - 4',correct
'color1 = color(0xffFA1C45)',correct
'int cc_',correct
'float creatureY;',correct
'{    light1.coloryellow();    light2.coloryellow();}',correct
'// eyesellipse(creatureX - 10, creatureY - 57, 6, 6);',correct
'if (key == j) {    hat1.hatMoveDown();}',correct
'creatureY + 30',correct
'fill(c)',correct
'ypos = ypos_',correct
'color(0xffFA1C45)',correct
'fill(253, 252, 255)',correct
'{    color1 = color(0xffFA1C45);}',correct
'{    if (key == y) {        light1.colorred();        light2.colorred();    }    if (key == r) {        light1.coloryellow();        light2.coloryellow();    }}',correct
'ypos + 30',correct
'background(27, 14, 152);',correct
'float hatY;',correct
'ellipse(creatureX, creatureY, 7, 7);',correct
'light1.colorred()',correct
'{    vlokken[i].move();    vlokken[i].display();}',correct
'xpos + 240',correct
'i = 0',correct
'size = size_',correct
'xpos + 120',correct
'ellipse(creatureX, creatureY - 55, 60, 60);',correct
'vlokken[i].display()',correct
'ellipse(creatureX, creatureY, 70, 70);',correct
'xpos + 125',correct
'new Lights(300, 200, 0xffFA1C45)',correct
'hatY = unitY;',correct
'{    hatY = hatY - speed;}',correct
'fill(235, 137, 33)',correct
'creatureY + 55',correct
'{    vlokken[i] = new Vlok(color(255), random(0, 800), random(0, 400), random(1, 4), random(3, 9));}',correct
'hatX',correct
'hatY',correct
'if (key == y) {    light1.coloryellow();    light2.colorred();} else if (key == r) {    light1.colorred();    light2.coloryellow();}',correct
'line(creatureX + 20, creatureY - 30, creatureX + 20, creatureY + 5)',correct
'new Tree(300, 200)',correct
'float unitY',correct
'float unitX',correct
'stroke(26, 132, 17)',correct
'creatureY - 25',correct
'ypos = ypos + speed;',correct
'xpos + 100',correct
'{    hatY = hatY + speed;}',correct
'hat1.hatMoveUp()',correct
'tree1 = new Tree(300, 200);',correct
'void display() {    // lights    fill(color1);    stroke(color1);    ellipse(xpos + 215, ypos + 10, 12, 12);    ellipse(xpos + 160, ypos + 16, 12, 12);    ellipse(xpos + 190, ypos + 16, 12, 12);    ellipse(xpos + 140, ypos + 13, 12, 12);    ellipse(xpos + 150, ypos - 39, 12, 12);    ellipse(xpos + 180, ypos - 33, 12, 12);    ellipse(xpos + 210, ypos - 36, 12, 12);    ellipse(xpos + 125, ypos + 50, 12, 12);    ellipse(xpos + 145, ypos + 53, 12, 12);    ellipse(xpos + 180, ypos + 56, 12, 12);    ellipse(xpos + 215, ypos + 53, 12, 12);    ellipse(xpos + 240, ypos + 50, 12, 12);}',correct
'ellipse(xpos + 160, ypos + 16, 12, 12);',correct
'ellipse(xpos + 210, ypos - 36, 12, 12);',correct
'{    ypos = ypos + speed;    if (ypos > height) {        ypos = 0;    }}',correct
'Vlok(int c_, float xpos_, float ypos_, float speed_, float size_) {    c = c_;    xpos = xpos_;    ypos = ypos_;    speed = speed_;    size = size_;}',ShortVariable
'creatureX = unitX;',correct
'if (key == r) {    light1.coloryellow();    light2.coloryellow();}',correct
'strokeWeight(0)',correct
'xpos + 215',correct
'ypos - 90',correct
'xpos + 210',correct
'class Snowman1 {    float creatureX;    float creatureY;    Snowman1(float unitX, float unitY) {        ellipseMode(CENTER);        rectMode(CENTER);        creatureX = unitX;        // creatureX=width /2;        creatureY = unitY;    }    void display() {        // body        stroke(255);        fill(255);        ellipse(creatureX, creatureY - 55, 60, 60);        ellipse(creatureX, creatureY, 70, 70);        ellipse(creatureX, creatureY + 55, 90, 90);        // arms        fill(183, 109, 25);        stroke(183, 109, 25);        strokeWeight(7);        line(creatureX + 30, creatureY, creatureX + 70, creatureY - 25);        line(creatureX - 70, creatureY - 25, creatureX - 30, creatureY);        // buttons        fill(0);        stroke(0);        strokeWeight(3);        ellipse(creatureX, creatureY, 7, 7);        ellipse(creatureX, creatureY + 15, 7, 7);        ellipse(creatureX, creatureY + 30, 7, 7);        // eyes        ellipse(creatureX - 10, creatureY - 57, 6, 6);        ellipse(creatureX + 10, creatureY - 57, 6, 6);        fill(235, 137, 33);        stroke(235, 137, 33);        triangle(creatureX - 4, creatureY - 42, creatureX, creatureY - 48, creatureX + 4, creatureY - 42);        // scarf        fill(255, 0, 0);        stroke(255, 0, 0);        strokeWeight(8);        line(creatureX - 25, creatureY - 30, creatureX + 25, creatureY - 30);        line(creatureX + 20, creatureY - 30, creatureX + 20, creatureY + 5);        strokeWeight(0);    }}',correct
'if (key == y) {    light1.colorred();    light2.colorred();}',correct
'hat1.hatMoveUp();',correct
'speed = speed_',correct
'creatureX + 10',correct
'creatureY - 48',correct
'fill(255, 0, 0)',correct
'line(creatureX - 25, creatureY - 30, creatureX + 25, creatureY - 30);',correct
'{    light1.coloryellow();    light2.colorred();}',correct
'xpos + 280',correct
'xpos + 160',correct
'snowman1 = new Snowman1(200, 200);',correct
'// lightsfill(color1);',correct
'creatureY - 42',correct
'ellipseMode(CENTER)',correct
'Lights',correct
'strokeWeight(3)',correct
'light1.display();',correct
'void keyPressed() {    if (key == y) {        light1.coloryellow();        light2.colorred();    } else if (key == r) {        light1.colorred();        light2.coloryellow();    }    if (key == u) {        hat1.hatMoveUp();    }    if (key == j) {        hat1.hatMoveDown();    }}',correct
'light2.colorred();',correct
'{    hat1.hatMoveUp();}',correct
'ellipse(creatureX, creatureY, 7, 7)',correct
'void',correct
'rect(0, 350, width * 2, 100);',PixelHardcodeIgnoranceRule
'// hatfill(0);',correct
'xpos + 150',correct
'snowman1.display();',correct
'creatureY - 30',correct
'hatY = hatY - speed;',correct
'xpos + 80',correct
'strokeWeight(7);',correct
'ellipse(xpos + 140, ypos + 13, 12, 12)',correct
'ellipse(xpos + 180, ypos + 56, 12, 12);',correct
'strokeWeight(2)',correct
'ypos + speed',correct
'xpos + 140',correct
'xpos + 260',correct
'color1 = cc_',correct
'xpos + 145',correct
'{    background(27, 14, 152);    snowman1.display();    hat1.display();    tree1.display();    light1.display();    tree2.display();    light2.display();    for (int i = 0; i < vlokken.length; i++) {        vlokken[i].move();        vlokken[i].display();    }    stroke(242, 245, 249);    fill(253, 252, 255);    rect(0, 350, width * 2, 100);}',correct
'if (key == r) {    light1.colorred();    light2.coloryellow();}',correct
'stroke(242, 245, 249)',correct
'fill(253, 252, 255);',correct
'for (int i = 0; i < vlokken.length; i++) {    vlokken[i] = new Vlok(color(255), random(0, 800), random(0, 400), random(1, 4), random(3, 9));}',correct
'stroke(255, 0, 0)',correct
'creatureY - 55',correct
'creatureY - 57',correct
'{    // lights    fill(color1);    stroke(color1);    ellipse(xpos + 215, ypos + 10, 12, 12);    ellipse(xpos + 160, ypos + 16, 12, 12);    ellipse(xpos + 190, ypos + 16, 12, 12);    ellipse(xpos + 140, ypos + 13, 12, 12);    ellipse(xpos + 150, ypos - 39, 12, 12);    ellipse(xpos + 180, ypos - 33, 12, 12);    ellipse(xpos + 210, ypos - 36, 12, 12);    ellipse(xpos + 125, ypos + 50, 12, 12);    ellipse(xpos + 145, ypos + 53, 12, 12);    ellipse(xpos + 180, ypos + 56, 12, 12);    ellipse(xpos + 215, ypos + 53, 12, 12);    ellipse(xpos + 240, ypos + 50, 12, 12);}',correct
'random(0, 400)',correct
'c = c_;',correct
'color1 = color(0xffF9FA3F);',correct
'strokeWeight(8);',correct
'xpos = xpos_;',correct
'ypos - 50',correct
'color1 = color(0xffFA1C45);',correct
'line(creatureX - 70, creatureY - 25, creatureX - 30, creatureY);',correct
'fill(26, 132, 17);',correct
'color1 = color(0xffF9FA3F)',correct
'{    light1.colorred();    light2.colorred();}',correct
'color1',correct
'strokeWeight(7)',correct
'{    // hat    fill(0);    stroke(0);    strokeWeight(2);    rect(hatX, hatY - 75, 100, 7);    rect(hatX, hatY - 100, 50, 50);    strokeWeight(0);}',correct
'// bodystroke(255);',correct
'fill(235, 137, 33);',correct
'vlokken[i].move();',correct
'color(0xffF9FA3F)',correct
'ellipse(creatureX, creatureY + 55, 90, 90)',correct
'for (int i = 0; i < vlokken.length; i++) {    vlokken[i].move();    vlokken[i].display();}',correct
'ellipse(creatureX, creatureY + 30, 7, 7);',correct
'ellipse(creatureX, creatureY + 15, 7, 7);',correct
'hat1.hatMoveDown()',correct
'ellipse(xpos + 215, ypos + 53, 12, 12);',correct
'light2.display();',correct
'creatureX + 70',correct
'rect(hatX, hatY - 75, 100, 7);',correct
'ellipse(xpos + 150, ypos - 39, 12, 12);',correct
'creatureX - 10',correct
'class Hat {    float hatX;    float hatY;    float speed;    Hat(float unitX, float unitY, float speed_) {        rectMode(CENTER);        hatX = unitX;        speed = speed_;        hatY = unitY;    }    void display() {        // hat        fill(0);        stroke(0);        strokeWeight(2);        rect(hatX, hatY - 75, 100, 7);        rect(hatX, hatY - 100, 50, 50);        strokeWeight(0);    }    void hatMoveUp() {        hatY = hatY - speed;    }    void hatMoveDown() {        hatY = hatY + speed;    }}',correct
'fill(26, 132, 17)',correct
'vlokken[i].move()',correct
'rect(xpos + 180, ypos + 80, 20, 40);',correct
'rect(hatX, hatY - 100, 50, 50);',correct
'// buttonsfill(0);',correct
'hatX = unitX',correct
'new Snowman1(200, 200)',correct
'class Vlok {    int c;    float xpos, ypos, speed, size;    Vlok(int c_, float xpos_, float ypos_, float speed_, float size_) {        c = c_;        xpos = xpos_;        ypos = ypos_;        speed = speed_;        size = size_;    }    void display() {        ellipseMode(CENTER);        fill(c);        ellipse(xpos, ypos, size, size);    }    void move() {        ypos = ypos + speed;        if (ypos > height) {            ypos = 0;        }    }}',correct
'creatureX - 25',correct
'rect(xpos + 180, ypos + 80, 20, 40)',correct
'ypos = 0;',correct
'void display() {    // tree    fill(88, 63, 11);    stroke(100, 70, 3);    rect(xpos + 180, ypos + 80, 20, 40);    fill(26, 132, 17);    stroke(26, 132, 17);    triangle(xpos + 80, ypos + 70, xpos + 280, ypos + 70, xpos + 180, ypos - 10);    triangle(xpos + 100, ypos + 30, xpos + 260, ypos + 30, xpos + 180, ypos - 50);    triangle(xpos + 120, ypos - 10, xpos + 240, ypos - 10, xpos + 180, ypos - 90);}',correct
'strokeWeight(2);',correct
'void hatMoveDown() {    hatY = hatY + speed;}',correct
'light2 = new Lights(550, 200, 0xffF2254A);',correct
'hat1.display();',correct
'creatureX - 30',correct
'strokeWeight(8)',correct
'c = c_',correct
'stroke(color1)',correct
'tree2.display();',correct
'Hat',correct
'ellipse(creatureX, creatureY + 30, 7, 7)',correct
'void colorred() {    color1 = color(0xffFA1C45);}',correct
'ellipse(xpos + 215, ypos + 10, 12, 12)',correct
'Snowman1 snowman1;',correct
'void coloryellow() {    color1 = color(0xffF9FA3F);}',correct
'void setup() {    snowman1 = new Snowman1(200, 200);    hat1 = new Hat(200, 200, 3);    tree1 = new Tree(300, 200);    light1 = new Lights(300, 200, 0xffFA1C45);    tree2 = new Tree(550, 200);    light2 = new Lights(550, 200, 0xffF2254A);    for (int i = 0; i < vlokken.length; i++) {        vlokken[i] = new Vlok(color(255), random(0, 800), random(0, 400), random(1, 4), random(3, 9));    }}',correct
'creatureX + 25',correct
'light1 = new Lights(300, 200, 0xffFA1C45);',correct
'{    rectMode(CENTER);    hatX = unitX;    speed = speed_;    hatY = unitY;}',correct
'creatureX + 20',correct
'ellipse(xpos + 150, ypos - 39, 12, 12)',correct
'hatY = hatY + speed;',correct
'strokeWeight(3);',correct
'triangle(xpos + 100, ypos + 30, xpos + 260, ypos + 30, xpos + 180, ypos - 50);',correct
'ellipse(xpos + 145, ypos + 53, 12, 12)',correct
'fill(0)',correct
'stroke(100, 70, 3)',correct
'creatureX + 30',correct
'Hat(float unitX, float unitY, float speed_) {    rectMode(CENTER);    hatX = unitX;    speed = speed_;    hatY = unitY;}',correct
'light1.display()',correct
'line(creatureX + 30, creatureY, creatureX + 70, creatureY - 25)',correct
'tree1',correct
'fill(255)',correct
'tree2',correct
'Tree tree2;',correct
'speed',correct
'ellipse(creatureX, creatureY, 70, 70)',correct
'[200]',correct
'xpos',correct
'ellipse(xpos + 190, ypos + 16, 12, 12);',correct
'void display() {    // body    stroke(255);    fill(255);    ellipse(creatureX, creatureY - 55, 60, 60);    ellipse(creatureX, creatureY, 70, 70);    ellipse(creatureX, creatureY + 55, 90, 90);    // arms    fill(183, 109, 25);    stroke(183, 109, 25);    strokeWeight(7);    line(creatureX + 30, creatureY, creatureX + 70, creatureY - 25);    line(creatureX - 70, creatureY - 25, creatureX - 30, creatureY);    // buttons    fill(0);    stroke(0);    strokeWeight(3);    ellipse(creatureX, creatureY, 7, 7);    ellipse(creatureX, creatureY + 15, 7, 7);    ellipse(creatureX, creatureY + 30, 7, 7);    // eyes    ellipse(creatureX - 10, creatureY - 57, 6, 6);    ellipse(creatureX + 10, creatureY - 57, 6, 6);    fill(235, 137, 33);    stroke(235, 137, 33);    triangle(creatureX - 4, creatureY - 42, creatureX, creatureY - 48, creatureX + 4, creatureY - 42);    // scarf    fill(255, 0, 0);    stroke(255, 0, 0);    strokeWeight(8);    line(creatureX - 25, creatureY - 30, creatureX + 25, creatureY - 30);    line(creatureX + 20, creatureY - 30, creatureX + 20, creatureY + 5);    strokeWeight(0);}',correct
'tree1 = new Tree(300, 200)',correct
'stroke(26, 132, 17);',correct
'new Tree(550, 200)',correct
'ellipseMode(CENTER);',correct
'int i = 0',correct
'Vlok[]',correct
'stroke(255)',correct
'ellipse(xpos + 240, ypos + 50, 12, 12);',correct
'stroke(100, 70, 3);',correct
'ellipse(xpos + 140, ypos + 13, 12, 12);',correct
'ypos',correct
'color(255)',correct
'hatY - 100',correct
'ellipse(xpos + 125, ypos + 50, 12, 12)',correct
'// xpos=width/2;ypos = treeY;',correct
'stroke(235, 137, 33);',correct
'float hatX;',correct
'size = size_;',correct
'Vlok',correct
'ellipse(creatureX - 10, creatureY - 57, 6, 6)',correct
'hat1 = new Hat(200, 200, 3);',correct
'Snowman1',correct
'void keyReleased() {    if (key == y) {        light1.colorred();        light2.colorred();    }    if (key == r) {        light1.coloryellow();        light2.coloryellow();    }}',correct
'// treefill(88, 63, 11);',correct
'ypos = treeY',correct
'snowman1',correct
'{    color1 = cc_;    xpos = treeX;    ypos = treeY;}',correct
'rect(hatX, hatY - 100, 50, 50)',correct
'fill(183, 109, 25)',correct
'new Vlok(color(255), random(0, 800), random(0, 400), random(1, 4), random(3, 9))',correct
'Tree tree1;',correct
'line(creatureX - 25, creatureY - 30, creatureX + 25, creatureY - 30)',correct
'new Vlok[200]',correct
'color1 = cc_;',correct
'ypos + 13',correct
'ypos + 16',correct
'ypos + 10',correct
'{    ellipseMode(CENTER);    rectMode(CENTER);    creatureX = unitX;    // creatureX=width /2;    creatureY = unitY;}',correct
'key == j',correct
'float speed_',correct
'key == y',correct
'{    // body    stroke(255);    fill(255);    ellipse(creatureX, creatureY - 55, 60, 60);    ellipse(creatureX, creatureY, 70, 70);    ellipse(creatureX, creatureY + 55, 90, 90);    // arms    fill(183, 109, 25);    stroke(183, 109, 25);    strokeWeight(7);    line(creatureX + 30, creatureY, creatureX + 70, creatureY - 25);    line(creatureX - 70, creatureY - 25, creatureX - 30, creatureY);    // buttons    fill(0);    stroke(0);    strokeWeight(3);    ellipse(creatureX, creatureY, 7, 7);    ellipse(creatureX, creatureY + 15, 7, 7);    ellipse(creatureX, creatureY + 30, 7, 7);    // eyes    ellipse(creatureX - 10, creatureY - 57, 6, 6);    ellipse(creatureX + 10, creatureY - 57, 6, 6);    fill(235, 137, 33);    stroke(235, 137, 33);    triangle(creatureX - 4, creatureY - 42, creatureX, creatureY - 48, creatureX + 4, creatureY - 42);    // scarf    fill(255, 0, 0);    stroke(255, 0, 0);    strokeWeight(8);    line(creatureX - 25, creatureY - 30, creatureX + 25, creatureY - 30);    line(creatureX + 20, creatureY - 30, creatureX + 20, creatureY + 5);    strokeWeight(0);}',LongMethodRule
'light2.coloryellow();',correct
'hatY - 75',correct
'key == u',correct
'int c_',correct
'ypos = 0',correct
'key == r',correct
'Snowman1(float unitX, float unitY) {    ellipseMode(CENTER);    rectMode(CENTER);    creatureX = unitX;    // creatureX=width /2;    creatureY = unitY;}',correct
'{    hat1.hatMoveDown();}',correct
'display',correct
'float xpos, ypos;',correct
'float speed;',correct
'triangle(xpos + 80, ypos + 70, xpos + 280, ypos + 70, xpos + 180, ypos - 10)',correct
'random(0, 800)',correct
'if (key == u) {    hat1.hatMoveUp();}',correct
'{    light1.colorred();    light2.coloryellow();}',correct
'vlokken[i] = new Vlok(color(255), random(0, 800), random(0, 400), random(1, 4), random(3, 9))',correct
'int c;',ShortVariable
'new Lights(550, 200, 0xffF2254A)',correct
'Vlok[] vlokken = new Vlok[200];',correct
'// scarffill(255, 0, 0);',correct
'i++',correct
'xpos = treeX',correct
'rect(hatX, hatY - 75, 100, 7)',correct
'vlokken[i] = new Vlok(color(255), random(0, 800), random(0, 400), random(1, 4), random(3, 9));',correct
'fill(255);',correct
'Lights light1;',correct
'fill(88, 63, 11)',correct
'light2.coloryellow()',correct
'light1',correct
'Tree',correct
'ypos = treeY;',correct
'ellipse(creatureX + 10, creatureY - 57, 6, 6);',correct
'light2',correct
'{    if (key == y) {        light1.coloryellow();        light2.colorred();    } else if (key == r) {        light1.colorred();        light2.coloryellow();    }    if (key == u) {        hat1.hatMoveUp();    }    if (key == j) {        hat1.hatMoveDown();    }}',correct
'hat1.hatMoveDown();',correct
'ellipse(creatureX, creatureY + 15, 7, 7)',correct
'hatY = hatY - speed',correct
'stroke(183, 109, 25);',correct
'Lights light2;',correct
'hat1.display()',correct
'ellipse(xpos + 210, ypos - 36, 12, 12)',correct
'stroke(255, 0, 0);',correct
'tree2.display()',correct
'tree2 = new Tree(550, 200);',correct
'{    // tree    fill(88, 63, 11);    stroke(100, 70, 3);    rect(xpos + 180, ypos + 80, 20, 40);    fill(26, 132, 17);    stroke(26, 132, 17);    triangle(xpos + 80, ypos + 70, xpos + 280, ypos + 70, xpos + 180, ypos - 10);    triangle(xpos + 100, ypos + 30, xpos + 260, ypos + 30, xpos + 180, ypos - 50);    triangle(xpos + 120, ypos - 10, xpos + 240, ypos - 10, xpos + 180, ypos - 90);}',correct
'fill(c);',correct
'float xpos;',correct
'light2.colorred()',correct
'{    xpos = treeX;    // xpos=width/2;    ypos = treeY;}',correct
'ellipse(xpos + 180, ypos - 33, 12, 12)',correct
'ellipse(xpos + 190, ypos + 16, 12, 12)',correct
'tree1.display()',correct
'hat1 = new Hat(200, 200, 3)',correct
'creatureX = unitX',correct
'ellipse(xpos + 215, ypos + 10, 12, 12);',correct
'stroke(color1);',correct
'// creatureX=width /2;creatureY = unitY;',correct
'new Hat(200, 200, 3)',correct
'line(creatureX + 30, creatureY, creatureX + 70, creatureY - 25);',correct
'float xpos_',correct
'strokeWeight(0);',correct
'float xpos, ypos, speed, size;',correct
'void display() {    ellipseMode(CENTER);    fill(c);    ellipse(xpos, ypos, size, size);}',correct
'creatureX - 70',correct
'ellipse(xpos + 240, ypos + 50, 12, 12)',correct
'hatY = hatY + speed',correct
'ellipse(creatureX + 10, creatureY - 57, 6, 6)',correct
'random(width)',correct
'for (int i = 0; i < dinos.length; i++) {    dinos[i] = new Dino(random(width), random(height));    stars[i] = new Star(color(255), random(width), random(height));}',correct
'{    if (isOver(mouseX, mouseY)) {        isSelected = true;    }}',correct
'mouseDragged',correct
'dinoY = dinoY + speedY',correct
'for (int i = 0; i < total; i++) {    dinos[i].changeBack();    dinos[i].letDinoGo();}',correct
'// 2 smallest teethfor (float i = 88; i <= 96; i += 4) {    triangle(i, 17, i + 2, 19, i + 4, 17);}',correct
'fill(starColor)',correct
'// 2 smaller teethfor (float i = 80; i <= 88; i += 4) {    triangle(i, 17, i + 2, 20, i + 4, 17);}',correct
'triangle(i, 17, i + 2, 22, i + 4, 17);',correct
'rotate(turn)',correct
'// rotationfloat angle;',TooManyFields
'dinos[i].mouseOverDino();',correct
'color(dinoColor)',correct
'spikeCounter = 0',correct
'{    dinos[i].mouseOverDino();    if (dinos[i].isSelected) {        // got this from ansgars example in week 5        break;    }}',correct
'dinos[i].changeBack();',correct
'int spikeCounter = 0',correct
'i = 88',correct
'startColorDino = color(dinoColor)',correct
'{    isSelected = false;}',correct
'triangle(i, 0, i + 6, -8, i + 12, 0)',correct
'// attributesint starColor;',correct
'i = 80',correct
'// make size randomfloat dinoSize;',TooManyFields
'starX = startX',correct
'ellipse(62, 8, 7, 7)',correct
'dinoY = startY;',correct
'speedY = speedY * -1',correct
'dinos[i].display()',correct
'// attributesfloat startX = width / 2;',TooManyFields
'for (int i = 0; i < 100; i++) {    // stars are there from the beginning    stars[i].display();}',correct
'void mousePressed() {    for (int i = 0; i < total; i++) {        dinos[i].mouseOverDino();        if (dinos[i].isSelected) {            // got this from ansgars example in week 5            break;        }    }}',correct
'// display spikes with for loop right to leftfor (int spikeCounter = 0; spikeCounter < 6; spikeCounter++) {    float xOffset = 62 - spikeCounter * 12;    float yOffset = 25 - 5 * spikeCounter;    // tri(right,right,middle,middle,left,left)    triangle(-xOffset + 5, yOffset, -xOffset - 4, yOffset - 5, -xOffset - 8, yOffset + 5);}',correct
'getMoved',correct
'dinos[i] = new Dino(random(width), random(height))',correct
'fill(startColorSpikes)',correct
'{    total = total + 1;}',correct
'color(spikesColor)',correct
'dinos[i].checkEdges()',correct
'dinoX = startX',correct
'// display teeth',correct
'size',correct
'size = 60',correct
'triangle(i, 17, i + 2, 19, i + 4, 17);',correct
'yOffset + 5',correct
'fill(startColorSpikes);',correct
'triangle(60, 17, 100, 17, 60, 30)',correct
'float yOffset = 25 - 5 * spikeCounter;',correct
'void getMoved() {    // if mouse is dragged    if (isSelected) {        dinoX = mouseX;        dinoY = mouseY;    }}',TooManyFields
'background(0, 0, 70)',correct
'dinos[i].changeBack()',correct
'{    fill(starColor);    // created at random place    ellipse(starX, starY, 3, 3);}',correct
'size = 60;',correct
'speedX = 0.1f',correct
'background(0, 0, 70);',correct
'boolean isSelected = false;',correct
'// tri(right,right,middle,middle,left,left)triangle(-xOffset + 5, yOffset, -xOffset - 4, yOffset - 5, -xOffset - 8, yOffset + 5);',correct
'dinoColor = color(124, 252, 0)',correct
'turn',correct
'int irisColor = color(255);',correct
'void draw() {    background(0, 0, 70);    for (int i = 0; i < 100; i++) {        // stars are there from the beginning        stars[i].display();    }    for (int i = 0; i < total; i++) {        dinos[i].display();        dinos[i].move();        dinos[i].checkEdges();        dinos[i].rotateDino();    }}',correct
'changeBack',correct
'isSelected = false;',correct
'Star',correct
'startColorSpikes = color(spikesColor)',correct
'isSelected',correct
'{    float xOffset = 62 - spikeCounter * 12;    float yOffset = 25 - 5 * spikeCounter;    // tri(right,right,middle,middle,left,left)    triangle(-xOffset + 5, yOffset, -xOffset - 4, yOffset - 5, -xOffset - 8, yOffset + 5);}',correct
'// constructorDino(float startX, float startY) {    dinoX = startX;    dinoY = startY;    size = 60;}',TooManyFields
'spikeCounter < 6',correct
'starColor = actualColor;',correct
'starColor',correct
'fill(irisColor);',correct
'ellipse(starX, starY, 3, 3)',correct
'int eyeColor = color(0);',TooManyFields
'float starX;',correct
'dinoY + 17 > height || dinoY < 0',correct
'// draw spaceclass Star {    // attributes    int starColor;    float starX;    float starY;    Star(int actualColor, float startX, float startY) {        // constructor        starX = startX;        starY = startY;        starColor = actualColor;    }    void display() {        fill(starColor);        // created at random place        ellipse(starX, starY, 3, 3);    }}',correct
'random(height)',correct
'angle + 0.001f',correct
'popMatrix();',correct
'{    // only the one clicked    dinos[i].getMoved();}',correct
'triangle(60, 17, 100, 17, 60, 30);',correct
'{    angle = angle + 0.001f;    turn = -angle;}',correct
'dinos[i].letDinoGo();',correct
'dinoSize',correct
'void display() {    // Display body    pushMatrix();    translate(dinoX, dinoY);    rotate(turn);    stroke(startColorDino);    fill(startColorDino);    rect(0, 0, 60, 30);    triangle(-74, 30, 0, 30, 0, 0);    // Display Legs    rect(0, 30, 15, 8);    rect(44, 30, 15, 8);    // Display Head    triangle(60, 0, 100, 17, 60, 17);    triangle(60, 17, 100, 17, 60, 30);    // draw eye    fill(eyeColor);    ellipse(62, 8, 7, 7);    fill(irisColor);    ellipse(63, 8, 1, 1);    // display Spikes    // draw spikes on body with for loop    noStroke();    fill(startColorSpikes);    for (float i = X; i < 60; i += 12) {        triangle(i, 0, i + 6, -8, i + 12, 0);    }    // display spikes with for loop right to left    for (int spikeCounter = 0; spikeCounter < 6; spikeCounter++) {        float xOffset = 62 - spikeCounter * 12;        float yOffset = 25 - 5 * spikeCounter;        // tri(right,right,middle,middle,left,left)        triangle(-xOffset + 5, yOffset, -xOffset - 4, yOffset - 5, -xOffset - 8, yOffset + 5);    }    // 3 biggest teeth with for loop    for (float i = 60; i < 72; i += 4) {        noStroke();        fill(255);        triangle(i, 17, i + 2, 22, i + 4, 17);    }    // 2 medium sized teeth    for (float i = 72; i <= 80; i += 4) {        triangle(i, 17, i + 2, 21, i + 4, 17);    }    // 2 smaller teeth    for (float i = 80; i <= 88; i += 4) {        triangle(i, 17, i + 2, 20, i + 4, 17);    }    // 2 smallest teeth    for (float i = 88; i <= 96; i += 4) {        triangle(i, 17, i + 2, 19, i + 4, 17);    }    popMatrix();}',TooManyFields
'noStroke()',correct
'dinoX = startX;',correct
'int actualColor',correct
'{    background(0, 0, 70);    for (int i = 0; i < 100; i++) {        // stars are there from the beginning        stars[i].display();    }    for (int i = 0; i < total; i++) {        dinos[i].display();        dinos[i].move();        dinos[i].checkEdges();        dinos[i].rotateDino();    }}',correct
'fill(irisColor)',correct
'triangle(i, 17, i + 2, 21, i + 4, 17)',correct
'starColor = actualColor',correct
'25 - 5 * spikeCounter',correct
'dinoX = mouseX',correct
'// spawn new dino when mouse is clickedvoid mouseClicked() {    total = total + 1;}',correct
'{    for (int i = 0; i < dinos.length; i++) {        dinos[i] = new Dino(random(width), random(height));        stars[i] = new Star(color(255), random(width), random(height));    }}',correct
'dinoY = mouseY;',correct
'speedX * -1',correct
'total = total + 1;',correct
'i + 12',correct
'dinoX = mouseX;',correct
'i + 2',correct
'speedY * -1',correct
'startY = height / 2',correct
'ellipse(62, 8, 7, 7);',correct
'-angle',correct
'// the newest one always has a different colorint startColorDino = color(32, 178, 170);',TooManyFields
'{    // if mouse is dragged    if (isSelected) {        dinoX = mouseX;        dinoY = mouseY;    }}',correct
'stars[i].display()',correct
'isSelected = true',correct
'color(0, 128, 128)',correct
'// display Spikes',correct
'spikeCounter++',correct
'i += 12',correct
'i + 6',correct
'i + 4',correct
'{    triangle(i, 0, i + 6, -8, i + 12, 0);}',correct
'angle = angle + 0.001f;',correct
'startX = width / 2',correct
'dinos[i].letDinoGo()',correct
'{    // but only when mouse touches dino    for (int i = 0; i < total; i++) {        // only the one clicked        dinos[i].getMoved();    }}',correct
'// 2 medium sized teethfor (float i = 72; i <= 80; i += 4) {    triangle(i, 17, i + 2, 21, i + 4, 17);}',correct
'dinoX + 100 > width',correct
'float speedY = 0.1f;',TooManyFields
'dinos[i].mouseOverDino()',correct
'int size;',TooManyFields
'translate(dinoX, dinoY)',correct
'dinoY = mouseY',correct
'dinoX = dinoX + speedX',correct
'height / 2',correct
'// Display Legsrect(0, 30, 15, 8);',correct
'float dinoY;',TooManyFields
'yOffset - 5',correct
'void mouseOverDino() {    if (isOver(mouseX, mouseY)) {        isSelected = true;    }}',TooManyFields
'void display() {    fill(starColor);    // created at random place    ellipse(starX, starY, 3, 3);}',correct
'{    speedY = speedY * -1;}',correct
'0.1f',correct
'fill(255)',correct
'starX',correct
'starY',correct
'for (int i = 0; i < total; i++) {    dinos[i].display();    dinos[i].move();    dinos[i].checkEdges();    dinos[i].rotateDino();}',correct
'turn = -angle;',correct
'Processing',correct
'{    // constructor    starX = startX;    starY = startY;    starColor = actualColor;}',correct
'stars[i]',correct
'startColorDino = color(32, 178, 170)',correct
'dinos[i].isSelected',correct
'speedX = speedX * -1',correct
'dinoY = startY',correct
'62 - spikeCounter * 12',correct
'pushMatrix()',correct
'color(32, 178, 170)',correct
'dinos[i].rotateDino();',correct
'ellipse(63, 8, 1, 1);',correct
'{    if (dinoX + 100 > width || dinoX - 74 < 0) {        // move in other direction when you reach a wall        speedX = speedX * -1;    }    if (dinoY + 17 > height || dinoY < 0) {        speedY = speedY * -1;    }}',correct
'dinoY < 0',correct
'float startX',correct
'float startY',correct
'[200]',correct
'{    triangle(i, 17, i + 2, 21, i + 4, 17);}',correct
'fill(startColorDino);',correct
'dinos[i].move();',correct
'float i = X',correct
'dinoX - 74 < 0',correct
'{    // Display body    pushMatrix();    translate(dinoX, dinoY);    rotate(turn);    stroke(startColorDino);    fill(startColorDino);    rect(0, 0, 60, 30);    triangle(-74, 30, 0, 30, 0, 0);    // Display Legs    rect(0, 30, 15, 8);    rect(44, 30, 15, 8);    // Display Head    triangle(60, 0, 100, 17, 60, 17);    triangle(60, 17, 100, 17, 60, 30);    // draw eye    fill(eyeColor);    ellipse(62, 8, 7, 7);    fill(irisColor);    ellipse(63, 8, 1, 1);    // display Spikes    // draw spikes on body with for loop    noStroke();    fill(startColorSpikes);    for (float i = X; i < 60; i += 12) {        triangle(i, 0, i + 6, -8, i + 12, 0);    }    // display spikes with for loop right to left    for (int spikeCounter = 0; spikeCounter < 6; spikeCounter++) {        float xOffset = 62 - spikeCounter * 12;        float yOffset = 25 - 5 * spikeCounter;        // tri(right,right,middle,middle,left,left)        triangle(-xOffset + 5, yOffset, -xOffset - 4, yOffset - 5, -xOffset - 8, yOffset + 5);    }    // 3 biggest teeth with for loop    for (float i = 60; i < 72; i += 4) {        noStroke();        fill(255);        triangle(i, 17, i + 2, 22, i + 4, 17);    }    // 2 medium sized teeth    for (float i = 72; i <= 80; i += 4) {        triangle(i, 17, i + 2, 21, i + 4, 17);    }    // 2 smaller teeth    for (float i = 80; i <= 88; i += 4) {        triangle(i, 17, i + 2, 20, i + 4, 17);    }    // 2 smallest teeth    for (float i = 88; i <= 96; i += 4) {        triangle(i, 17, i + 2, 19, i + 4, 17);    }    popMatrix();}',LongMethodRule
'false',correct
'stroke(startColorDino)',correct
'startColorSpikes = color(spikesColor);',correct
'new Dino(random(width), random(height))',correct
'rect(0, 0, 60, 30)',correct
'void setup() {    for (int i = 0; i < dinos.length; i++) {        dinos[i] = new Dino(random(width), random(height));        stars[i] = new Star(color(255), random(width), random(height));    }}',correct
'int i = 0',correct
'{    return (dist(xPos, yPos, dinoX, dinoY) <= size);}',correct
'// add attributesfloat dinoX;',TooManyFields
'i < total',correct
'{    noStroke();    fill(255);    triangle(i, 17, i + 2, 22, i + 4, 17);}',correct
'// display Spikes// draw spikes on body with for loopnoStroke();',correct
'void mouseReleased() {    for (int i = 0; i < total; i++) {        dinos[i].changeBack();        dinos[i].letDinoGo();    }}',correct
'if (dinoX + 100 > width || dinoX - 74 < 0) {    // move in other direction when you reach a wall    speedX = speedX * -1;}',correct
'dinoY = dinoY + speedY;',correct
'{    // move in other direction when you reach a wall    speedX = speedX * -1;}',correct
'i = 0',correct
'{    for (int i = 0; i < total; i++) {        dinos[i].changeBack();        dinos[i].letDinoGo();    }}',correct
'color(255)',correct
'Dino',correct
'int spikesColor = color(30, 205, 50);',correct
'-xOffset - 8',correct
'dinos[i]',correct
'dinoX + speedX',correct
'turn = -angle',correct
'rect(0, 30, 15, 8)',correct
'dinos[i].checkEdges();',correct
'Dino[]',correct
'isSelected = true;',correct
'if (isOver(mouseX, mouseY)) {    isSelected = true;}',correct
'dinoY + 17',correct
'stroke(startColorDino);',correct
'triangle(-74, 30, 0, 30, 0, 0);',correct
'i = X',correct
'dinoX = dinoX + speedX;',correct
'// 3 biggest teeth with for loopfor (float i = 60; i < 72; i += 4) {    noStroke();    fill(255);    triangle(i, 17, i + 2, 22, i + 4, 17);}',correct
'{    for (int i = 0; i < total; i++) {        dinos[i].mouseOverDino();        if (dinos[i].isSelected) {            // got this from ansgars example in week 5            break;        }    }}',correct
'triangle(-74, 30, 0, 30, 0, 0)',correct
'yOffset = 25 - 5 * spikeCounter',correct
'Star(int actualColor, float startX, float startY) {    // constructor    starX = startX;    starY = startY;    starColor = actualColor;}',correct
'float yOffset = 25 - 5 * spikeCounter',correct
'[150]',correct
'noStroke();',correct
'rect(0, 0, 60, 30);',correct
'float turn;',correct
'dinoY + 17 > height',correct
'speedY = 0.1f',correct
'fill(starColor);',correct
'-xOffset',correct
'dinoX + 100',correct
'starY = startY',correct
'boolean isOver(float xPos, float yPos) {    return (dist(xPos, yPos, dinoX, dinoY) <= size);}',TooManyFields
'dinos = new Dino[150]',correct
'total = 0',correct
'xOffset = 62 - spikeCounter * 12',correct
'void move() {    dinoX = dinoX + speedX;    dinoY = dinoY + speedY;}',TooManyFields
'// draw eyefill(eyeColor);',correct
'triangle(i, 17, i + 2, 19, i + 4, 17)',correct
'if (dinos[i].isSelected) {    // got this from ansgars example in week 5    break;}',correct
'{    triangle(i, 17, i + 2, 19, i + 4, 17);}',correct
'{    dinos[i] = new Dino(random(width), random(height));    stars[i] = new Star(color(255), random(width), random(height));}',correct
'i += 4',correct
'angle',correct
'color(30, 205, 50)',correct
'color(0)',correct
'i < dinos.length',correct
'{    // if mouse is released    startColorDino = color(dinoColor);    startColorSpikes = color(spikesColor);}',correct
'{    dinos[i].display();    dinos[i].move();    dinos[i].checkEdges();    dinos[i].rotateDino();}',correct
'// created at random placeellipse(starX, starY, 3, 3);',correct
'// how many dinos are thereint total = 0;',correct
'stars[i] = new Star(color(255), random(width), random(height));',correct
'rect(44, 30, 15, 8);',correct
'fill(startColorDino)',correct
'dinos[i] = new Dino(random(width), random(height));',correct
'Star[]',correct
'display',correct
'float speedX = 0.1f;',TooManyFields
'draw',correct
'triangle(i, 0, i + 6, -8, i + 12, 0);',correct
'float xOffset = 62 - spikeCounter * 12',correct
'// move dino when mouse is draggedvoid mouseDragged() {    // but only when mouse touches dino    for (int i = 0; i < total; i++) {        // only the one clicked        dinos[i].getMoved();    }}',correct
'void checkEdges() {    if (dinoX + 100 > width || dinoX - 74 < 0) {        // move in other direction when you reach a wall        speedX = speedX * -1;    }    if (dinoY + 17 > height || dinoY < 0) {        speedY = speedY * -1;    }}',TooManyFields
'stars[i] = new Star(color(255), random(width), random(height))',correct
'-xOffset - 4',correct
'// color settingsint dinoColor = color(124, 252, 0);',TooManyFields
'return (dist(xPos, yPos, dinoX, dinoY) <= size);',correct
'startColorSpikes = color(0, 128, 128)',correct
'new Star(color(255), random(width), random(height))',correct
'i < 60',correct
'triangle(i, 17, i + 2, 20, i + 4, 17);',correct
'triangle(i, 17, i + 2, 22, i + 4, 17)',correct
'dinos[i].display();',correct
'i++',correct
'starY = startY;',correct
'triangle(i, 17, i + 2, 20, i + 4, 17)',correct
'// Display Headtriangle(60, 0, 100, 17, 60, 17);',correct
'float startY = height / 2;',TooManyFields
'checkEdges',correct
'mousePressed',correct
'void changeBack() {    // if mouse is released    startColorDino = color(dinoColor);    startColorSpikes = color(spikesColor);}',TooManyFields
'fill(255);',correct
'// array for  objectsStar[] stars = new Star[200];',correct
'{    // got this from ansgars example in week 5    break;}',correct
'int startColorSpikes = color(0, 128, 128);',TooManyFields
'dinos[i].getMoved()',correct
'triangle(-xOffset + 5, yOffset, -xOffset - 4, yOffset - 5, -xOffset - 8, yOffset + 5)',correct
'i < 72',correct
'new Dino[150]',correct
'dinoX',correct
'{    // stars are there from the beginning    stars[i].display();}',correct
'dinoY',correct
'void',correct
'irisColor = color(255)',correct
'isOver(mouseX, mouseY)',correct
'-1',correct
'stars = new Star[200]',correct
'dinoX - 74',correct
'eyeColor = color(0)',correct
'-8',correct
'{    isSelected = true;}',correct
'color(124, 252, 0)',correct
'float yPos',correct
'float i = 80',correct
'ellipse(63, 8, 1, 1)',correct
'speedY = speedY * -1;',correct
'void letDinoGo() {    isSelected = false;}',correct
'mouseClicked',correct
'{    triangle(i, 17, i + 2, 20, i + 4, 17);}',correct
'5 * spikeCounter',correct
'true',correct
'float i = 88',correct
'fill(eyeColor)',correct
'float starY;',correct
'for (float i = X; i < 60; i += 12) {    triangle(i, 0, i + 6, -8, i + 12, 0);}',correct
'{    dinoX = startX;    dinoY = startY;    size = 60;}',correct
'spikeCounter * 12',correct
'dinoX + 100 > width || dinoX - 74 < 0',correct
'// creature Nathalie KampDino[] dinos = new Dino[150];',correct
'popMatrix()',correct
'rect(44, 30, 15, 8)',correct
'triangle(i, 17, i + 2, 21, i + 4, 17);',correct
'dinos.length',correct
'{    dinoX = dinoX + speedX;    dinoY = dinoY + speedY;}',correct
'-74',correct
'dinoY + speedY',correct
'0.001f',correct
'angle = angle + 0.001f',correct
'float xOffset = 62 - spikeCounter * 12;',correct
'i <= 96',correct
'i = 60',correct
'// constructorstarX = startX;',correct
'float i = 72',correct
'total + 1',correct
'class Dino {    // add attributes    float dinoX;    float dinoY;    // make size random    float dinoSize;    float speedX = 0.1f;    float speedY = 0.1f;    // rotation    float angle;    float turn;    // color settings    int dinoColor = color(124, 252, 0);    int spikesColor = color(30, 205, 50);    int eyeColor = color(0);    int irisColor = color(255);    // the newest one always has a different color    int startColorDino = color(32, 178, 170);    int startColorSpikes = color(0, 128, 128);    boolean isSelected = false;    int size;    // attributes    float startX = width / 2;    float startY = height / 2;    // constructor    Dino(float startX, float startY) {        dinoX = startX;        dinoY = startY;        size = 60;    }    void display() {        // Display body        pushMatrix();        translate(dinoX, dinoY);        rotate(turn);        stroke(startColorDino);        fill(startColorDino);        rect(0, 0, 60, 30);        triangle(-74, 30, 0, 30, 0, 0);        // Display Legs        rect(0, 30, 15, 8);        rect(44, 30, 15, 8);        // Display Head        triangle(60, 0, 100, 17, 60, 17);        triangle(60, 17, 100, 17, 60, 30);        // draw eye        fill(eyeColor);        ellipse(62, 8, 7, 7);        fill(irisColor);        ellipse(63, 8, 1, 1);        // display Spikes        // draw spikes on body with for loop        noStroke();        fill(startColorSpikes);        for (float i = X; i < 60; i += 12) {            triangle(i, 0, i + 6, -8, i + 12, 0);        }        // display spikes with for loop right to left        for (int spikeCounter = 0; spikeCounter < 6; spikeCounter++) {            float xOffset = 62 - spikeCounter * 12;            float yOffset = 25 - 5 * spikeCounter;            // tri(right,right,middle,middle,left,left)            triangle(-xOffset + 5, yOffset, -xOffset - 4, yOffset - 5, -xOffset - 8, yOffset + 5);        }        // 3 biggest teeth with for loop        for (float i = 60; i < 72; i += 4) {            noStroke();            fill(255);            triangle(i, 17, i + 2, 22, i + 4, 17);        }        // 2 medium sized teeth        for (float i = 72; i <= 80; i += 4) {            triangle(i, 17, i + 2, 21, i + 4, 17);        }        // 2 smaller teeth        for (float i = 80; i <= 88; i += 4) {            triangle(i, 17, i + 2, 20, i + 4, 17);        }        // 2 smallest teeth        for (float i = 88; i <= 96; i += 4) {            triangle(i, 17, i + 2, 19, i + 4, 17);        }        popMatrix();    }    void changeBack() {        // if mouse is released        startColorDino = color(dinoColor);        startColorSpikes = color(spikesColor);    }    void move() {        dinoX = dinoX + speedX;        dinoY = dinoY + speedY;    }    void rotateDino() {        angle = angle + 0.001f;        turn = -angle;    }    void checkEdges() {        if (dinoX + 100 > width || dinoX - 74 < 0) {            // move in other direction when you reach a wall            speedX = speedX * -1;        }        if (dinoY + 17 > height || dinoY < 0) {            speedY = speedY * -1;        }    }    boolean isOver(float xPos, float yPos) {        return (dist(xPos, yPos, dinoX, dinoY) <= size);    }    void mouseOverDino() {        if (isOver(mouseX, mouseY)) {            isSelected = true;        }    }    void letDinoGo() {        isSelected = false;    }    void getMoved() {        // if mouse is dragged        if (isSelected) {            dinoX = mouseX;            dinoY = mouseY;        }    }}',correct
'rotate(turn);',correct
'new Star[200]',correct
'translate(dinoX, dinoY);',correct
'spikesColor = color(30, 205, 50)',correct
'{    dinos[i].changeBack();    dinos[i].letDinoGo();}',correct
'// if mouse is releasedstartColorDino = color(dinoColor);',correct
'float xPos',correct
'triangle(60, 0, 100, 17, 60, 17)',correct
'i < 100',correct
'if (dinoY + 17 > height || dinoY < 0) {    speedY = speedY * -1;}',correct
'width / 2',correct
'void rotateDino() {    angle = angle + 0.001f;    turn = -angle;}',correct
'i <= 80',correct
'total = total + 1',correct
'// Display bodypushMatrix();',correct
'-xOffset + 5',correct
'isSelected = false',correct
'dinos[i].rotateDino()',correct
'dinos[i].move()',correct
'i = 72',correct
'{    dinoX = mouseX;    dinoY = mouseY;}',correct
'i <= 88',correct
'float i = 60',correct
'robotY + 18',correct
'// Ren\u00e9 van Koolwijk, s1944045Robot[] r = new Robot[5];',correct
'for (int i = 0; i < r.length; i++) {    r[i].display();    r[i].moveRobot();    r[i].edge();}',correct
'random(width)',correct
'ellipse(robotX, robotY - 50, 45, 45)',correct
'rect(robotX, robotY - 35, 5, 30)',correct
'robotX = random(width)',correct
'{    r[i].wifiOn();}',correct
'ellipse(robotX, robotY - 50, 10, 10);',correct
'ellipse(robotX + 15, robotY - 5, 20, 20);',correct
'robotX - 25',correct
'ellipse(robotX + 15, robotY - 5, 10, 10)',correct
'ellipse(robotX + 30, robotY + 25, 10, 10);',correct
'r[i] = new Robot();',correct
'robotX < 0',correct
'rect(robotX, robotY - 35, 7, 32)',correct
'robotY + 25.5f',correct
'stroke(0)',correct
'rect(robotX, robotY + 25, 60, 10);',correct
'line(robotX - 25, robotY + 18, robotX + 25, robotY + 18)',correct
'robotY + 25',correct
'float xspeed = random(-5, 5);',correct
'fill(0, 0, 0)',correct
'// outline headstrokeWeight(1);',correct
'fill(200, 200, 200)',correct
'r[i].moveRobot();',correct
'rect(robotX, robotY + 18, 50, 15);',correct
'background(255);',correct
'line(robotX, robotY + 25.5f, robotX, robotY + 10.5f);',correct
'robotX - 30',correct
'{    wifiColor = color(255, 255, 255);}',correct
'rect(robotX, robotY - 30, 50, 30);',correct
'void mousePressed() {    for (int i = 0; i < r.length; i++) {        r[i].wifiOn();    }}',correct
'// Ren\u00e9 van Koolwijk, s1944045',correct
'// outline antennafill(0, 0, 0);',correct
'r.length',correct
'robotY > height',correct
'wifiColor = color(255, 255, 255)',correct
'rectMode(CENTER)',correct
'for (int i = 0; i < r.length; i++) {    r[i] = new Robot();}',correct
'[5]',correct
'{    wifiColor = color(0, 0, 0);}',correct
'robotY > height || robotY < 0',correct
'random(height)',correct
'{    robotX = random(width);    robotY = random(height);}',correct
'void mouseReleased() {    for (int i = 0; i < r.length; i++) {        r[i].wifiOff();    }}',correct
'robotX - 15',correct
'r[i].wifiOff();',correct
'ellipse(robotX + 15, robotY - 5, 20, 20)',correct
'robotX + xspeed',correct
'ellipse(robotX - 30, robotY - 25, 10, 10);',correct
'rect(robotX, robotY + 25, 60, 10)',correct
'rectMode(CENTER);',correct
'rect(robotX, robotY - 25, 60, 10)',correct
'noStroke()',correct
'25.5f',correct
'void draw() {    background(255);    for (int i = 0; i < r.length; i++) {        r[i].display();        r[i].moveRobot();        r[i].edge();    }}',correct
'if (robotY > height || robotY < 0) {    yspeed = yspeed * -1;}',correct
'robotX - 12.5f',correct
'rect(robotX, robotY - 35, 7, 32);',correct
'new Robot[5]',correct
'ellipse(robotX, robotY - 50, 10, 10)',correct
'r[i].moveRobot()',correct
'rect(robotX, robotY - 25, 60, 10);',correct
'wifiColor = color(0, 0, 0)',correct
'rect(robotX, robotY + 25, 60, 12);',correct
'wifiColor = color(0, 0, 0);',correct
'robotX = random(width);',correct
'ellipse(robotX - 30, robotY - 25, 12, 12)',correct
'ellipse(robotX - 30, robotY + 25, 12, 12)',correct
'ellipse(robotX + 15, robotY - 5, 10, 10);',correct
'i < r.length',correct
'wifiColor',correct
'// antennafill(200, 200, 200);',correct
'robotX > width',correct
'ellipse(robotX + 30, robotY + 25, 12, 12);',correct
'ellipse(robotX - 15, robotY - 5, 10, 10);',correct
'if (robotX > width || robotX < 0) {    xspeed = xspeed * -1;}',correct
'r[i]',correct
'line(robotX - 12.5f, robotY + 25.5f, robotX - 12.5f, robotY + 10.5f);',correct
'Processing',correct
'background(255)',correct
'robotX + 25',correct
'class Robot {    float robotX;    float robotY;    float xspeed = random(-5, 5);    float yspeed = random(-5, 5);    int wifiColor;    Robot() {        robotX = random(width);        robotY = random(height);    }    void moveRobot() {        robotX = robotX + xspeed;        robotY = robotY + yspeed;    }    void edge() {        if (robotX > width || robotX < 0) {            xspeed = xspeed * -1;        }        if (robotY > height || robotY < 0) {            yspeed = yspeed * -1;        }    }    void wifiOn() {        wifiColor = color(0, 0, 0);    }    void wifiOff() {        wifiColor = color(255, 255, 255);    }    void display() {        // wifi signal        fill(wifiColor);        noStroke();        ellipse(robotX, robotY - 50, 50, 50);        fill(255, 255, 255);        ellipse(robotX, robotY - 50, 45, 45);        rect(robotX, robotY - 30, 50, 30);        // outline head        strokeWeight(1);        noStroke();        fill(0, 0, 0);        rect(robotX, robotY, 72, 50);        ellipse(robotX - 30, robotY + 25, 12, 12);        ellipse(robotX + 30, robotY + 25, 12, 12);        ellipse(robotX - 30, robotY - 25, 12, 12);        ellipse(robotX + 30, robotY - 25, 12, 12);        rect(robotX, robotY + 25, 60, 12);        rect(robotX, robotY - 25, 60, 12);        // outline antenna        fill(0, 0, 0);        rect(robotX, robotY - 35, 7, 32);        ellipse(robotX, robotY - 50, 12, 12);        // head        noStroke();        fill(200, 200, 200);        rect(robotX, robotY, 70, 50);        ellipse(robotX - 30, robotY + 25, 10, 10);        ellipse(robotX + 30, robotY + 25, 10, 10);        ellipse(robotX - 30, robotY - 25, 10, 10);        ellipse(robotX + 30, robotY - 25, 10, 10);        rect(robotX, robotY + 25, 60, 10);        rect(robotX, robotY - 25, 60, 10);        // antenna        fill(200, 200, 200);        rect(robotX, robotY - 35, 5, 30);        ellipse(robotX, robotY - 50, 10, 10);        // eyes        stroke(0);        fill(255, 255, 0);        ellipse(robotX - 15, robotY - 5, 20, 20);        ellipse(robotX + 15, robotY - 5, 20, 20);        // pupils        noStroke();        fill(0, 0, 0);        ellipse(robotX - 15, robotY - 5, 10, 10);        ellipse(robotX + 15, robotY - 5, 10, 10);        // mouth        stroke(0);        fill(255, 255, 255);        rect(robotX, robotY + 18, 50, 15);        // teeth        line(robotX - 25, robotY + 18, robotX + 25, robotY + 18);        line(robotX, robotY + 25.5f, robotX, robotY + 10.5f);        line(robotX + 12.5f, robotY + 25.5f, robotX + 12.5f, robotY + 10.5f);        line(robotX - 12.5f, robotY + 25.5f, robotX - 12.5f, robotY + 10.5f);    }}',correct
'ellipse(robotX, robotY - 50, 12, 12);',correct
'robotY + 10.5f',correct
'yspeed * -1',correct
'// pupilsnoStroke();',correct
'for (int i = 0; i < r.length; i++) {    r[i].wifiOff();}',correct
'wifiColor = color(255, 255, 255);',correct
'void setup() {    rectMode(CENTER);    for (int i = 0; i < r.length; i++) {        r[i] = new Robot();    }}',correct
'{    r[i] = new Robot();}',correct
'int i = 0',correct
'{    if (robotX > width || robotX < 0) {        xspeed = xspeed * -1;    }    if (robotY > height || robotY < 0) {        yspeed = yspeed * -1;    }}',correct
'// teethline(robotX - 25, robotY + 18, robotX + 25, robotY + 18);',correct
'// headnoStroke();',correct
'r[i] = new Robot()',correct
'robotX + 30',correct
'{    // wifi signal    fill(wifiColor);    noStroke();    ellipse(robotX, robotY - 50, 50, 50);    fill(255, 255, 255);    ellipse(robotX, robotY - 50, 45, 45);    rect(robotX, robotY - 30, 50, 30);    // outline head    strokeWeight(1);    noStroke();    fill(0, 0, 0);    rect(robotX, robotY, 72, 50);    ellipse(robotX - 30, robotY + 25, 12, 12);    ellipse(robotX + 30, robotY + 25, 12, 12);    ellipse(robotX - 30, robotY - 25, 12, 12);    ellipse(robotX + 30, robotY - 25, 12, 12);    rect(robotX, robotY + 25, 60, 12);    rect(robotX, robotY - 25, 60, 12);    // outline antenna    fill(0, 0, 0);    rect(robotX, robotY - 35, 7, 32);    ellipse(robotX, robotY - 50, 12, 12);    // head    noStroke();    fill(200, 200, 200);    rect(robotX, robotY, 70, 50);    ellipse(robotX - 30, robotY + 25, 10, 10);    ellipse(robotX + 30, robotY + 25, 10, 10);    ellipse(robotX - 30, robotY - 25, 10, 10);    ellipse(robotX + 30, robotY - 25, 10, 10);    rect(robotX, robotY + 25, 60, 10);    rect(robotX, robotY - 25, 60, 10);    // antenna    fill(200, 200, 200);    rect(robotX, robotY - 35, 5, 30);    ellipse(robotX, robotY - 50, 10, 10);    // eyes    stroke(0);    fill(255, 255, 0);    ellipse(robotX - 15, robotY - 5, 20, 20);    ellipse(robotX + 15, robotY - 5, 20, 20);    // pupils    noStroke();    fill(0, 0, 0);    ellipse(robotX - 15, robotY - 5, 10, 10);    ellipse(robotX + 15, robotY - 5, 10, 10);    // mouth    stroke(0);    fill(255, 255, 255);    rect(robotX, robotY + 18, 50, 15);    // teeth    line(robotX - 25, robotY + 18, robotX + 25, robotY + 18);    line(robotX, robotY + 25.5f, robotX, robotY + 10.5f);    line(robotX + 12.5f, robotY + 25.5f, robotX + 12.5f, robotY + 10.5f);    line(robotX - 12.5f, robotY + 25.5f, robotX - 12.5f, robotY + 10.5f);}',LongMethodRule
'r[i].wifiOn()',correct
'Robot',correct
'r[i].wifiOff()',correct
'{    robotX = robotX + xspeed;    robotY = robotY + yspeed;}',correct
'i = 0',correct
'void display() {    // wifi signal    fill(wifiColor);    noStroke();    ellipse(robotX, robotY - 50, 50, 50);    fill(255, 255, 255);    ellipse(robotX, robotY - 50, 45, 45);    rect(robotX, robotY - 30, 50, 30);    // outline head    strokeWeight(1);    noStroke();    fill(0, 0, 0);    rect(robotX, robotY, 72, 50);    ellipse(robotX - 30, robotY + 25, 12, 12);    ellipse(robotX + 30, robotY + 25, 12, 12);    ellipse(robotX - 30, robotY - 25, 12, 12);    ellipse(robotX + 30, robotY - 25, 12, 12);    rect(robotX, robotY + 25, 60, 12);    rect(robotX, robotY - 25, 60, 12);    // outline antenna    fill(0, 0, 0);    rect(robotX, robotY - 35, 7, 32);    ellipse(robotX, robotY - 50, 12, 12);    // head    noStroke();    fill(200, 200, 200);    rect(robotX, robotY, 70, 50);    ellipse(robotX - 30, robotY + 25, 10, 10);    ellipse(robotX + 30, robotY + 25, 10, 10);    ellipse(robotX - 30, robotY - 25, 10, 10);    ellipse(robotX + 30, robotY - 25, 10, 10);    rect(robotX, robotY + 25, 60, 10);    rect(robotX, robotY - 25, 60, 10);    // antenna    fill(200, 200, 200);    rect(robotX, robotY - 35, 5, 30);    ellipse(robotX, robotY - 50, 10, 10);    // eyes    stroke(0);    fill(255, 255, 0);    ellipse(robotX - 15, robotY - 5, 20, 20);    ellipse(robotX + 15, robotY - 5, 20, 20);    // pupils    noStroke();    fill(0, 0, 0);    ellipse(robotX - 15, robotY - 5, 10, 10);    ellipse(robotX + 15, robotY - 5, 10, 10);    // mouth    stroke(0);    fill(255, 255, 255);    rect(robotX, robotY + 18, 50, 15);    // teeth    line(robotX - 25, robotY + 18, robotX + 25, robotY + 18);    line(robotX, robotY + 25.5f, robotX, robotY + 10.5f);    line(robotX + 12.5f, robotY + 25.5f, robotX + 12.5f, robotY + 10.5f);    line(robotX - 12.5f, robotY + 25.5f, robotX - 12.5f, robotY + 10.5f);}',correct
'robotY - 35',correct
'xspeed = xspeed * -1;',correct
'color(255, 255, 255)',correct
'robotY - 30',correct
'rect(robotX, robotY, 70, 50)',correct
'line(robotX + 12.5f, robotY + 25.5f, robotX + 12.5f, robotY + 10.5f)',correct
'fill(255, 255, 255);',correct
'fill(200, 200, 200);',correct
'robotX > width || robotX < 0',correct
'rect(robotX, robotY, 72, 50)',correct
'{    r[i].wifiOff();}',correct
'rect(robotX, robotY - 25, 60, 12);',correct
'int wifiColor;',correct
'{    rectMode(CENTER);    for (int i = 0; i < r.length; i++) {        r[i] = new Robot();    }}',correct
'ellipse(robotX - 30, robotY + 25, 12, 12);',correct
'robotY - 50',correct
'Robot() {    robotX = random(width);    robotY = random(height);}',correct
'robotX + 15',correct
'void wifiOff() {    wifiColor = color(255, 255, 255);}',correct
'float yspeed = random(-5, 5);',correct
'robotX = robotX + xspeed',correct
'noStroke();',correct
'fill(wifiColor)',correct
'ellipse(robotX + 30, robotY + 25, 12, 12)',correct
'robotX = robotX + xspeed;',correct
'ellipse(robotX, robotY - 50, 50, 50)',correct
'ellipse(robotX - 30, robotY + 25, 10, 10)',correct
'// eyesstroke(0);',correct
'yspeed = yspeed * -1',correct
'xspeed * -1',correct
'{    xspeed = xspeed * -1;}',correct
'ellipse(robotX - 30, robotY - 25, 10, 10)',correct
'ellipse(robotX + 30, robotY - 25, 12, 12)',correct
'line(robotX + 12.5f, robotY + 25.5f, robotX + 12.5f, robotY + 10.5f);',correct
'rect(robotX, robotY - 35, 5, 30);',correct
'strokeWeight(1)',correct
'r[i].wifiOn();',correct
'ellipse(robotX + 30, robotY - 25, 10, 10)',correct
'robotX + 12.5f',correct
'random(-5, 5)',correct
'ellipse(robotX + 30, robotY + 25, 10, 10)',correct
'yspeed = random(-5, 5)',correct
'// wifi signalfill(wifiColor);',correct
'rect(robotX, robotY - 30, 50, 30)',correct
'display',LongMethodRule
'{    r[i].display();    r[i].moveRobot();    r[i].edge();}',correct
'{    for (int i = 0; i < r.length; i++) {        r[i].wifiOn();    }}',correct
'12.5f',correct
'rect(robotX, robotY, 72, 50);',correct
'ellipse(robotX, robotY - 50, 12, 12)',correct
'ellipse(robotX - 30, robotY + 25, 10, 10);',correct
'rect(robotX, robotY + 18, 50, 15)',correct
'{    yspeed = yspeed * -1;}',correct
'i++',correct
'ellipse(robotX, robotY - 50, 50, 50);',correct
'r[i].display();',correct
'fill(255, 255, 0)',correct
'r = new Robot[5]',correct
'robotY < 0',correct
'ellipse(robotX + 30, robotY - 25, 10, 10);',correct
'{    background(255);    for (int i = 0; i < r.length; i++) {        r[i].display();        r[i].moveRobot();        r[i].edge();    }}',correct
'ellipse(robotX - 15, robotY - 5, 20, 20);',correct
'void moveRobot() {    robotX = robotX + xspeed;    robotY = robotY + yspeed;}',correct
'fill(255, 255, 255)',correct
'r[i].edge();',correct
'void',correct
'ellipse(robotX - 30, robotY - 25, 12, 12);',correct
'-1',correct
'ellipse(robotX, robotY - 50, 45, 45);',correct
'-5',correct
'color(0, 0, 0)',correct
'robotY = random(height)',correct
'void wifiOn() {    wifiColor = color(0, 0, 0);}',correct
'r[i].display()',correct
'rect(robotX, robotY + 25, 60, 12)',correct
'rect(robotX, robotY, 70, 50);',correct
'line(robotX, robotY + 25.5f, robotX, robotY + 10.5f)',correct
'r[i].edge()',correct
'yspeed = yspeed * -1;',correct
'void edge() {    if (robotX > width || robotX < 0) {        xspeed = xspeed * -1;    }    if (robotY > height || robotY < 0) {        yspeed = yspeed * -1;    }}',correct
'robotY + yspeed',correct
'fill(255, 255, 0);',correct
'rect(robotX, robotY - 25, 60, 12)',correct
'new Robot()',correct
'xspeed = random(-5, 5)',correct
'// mouthstroke(0);',correct
'ellipse(robotX + 30, robotY - 25, 12, 12);',correct
'for (int i = 0; i < r.length; i++) {    r[i].wifiOn();}',correct
'{    for (int i = 0; i < r.length; i++) {        r[i].wifiOff();    }}',correct
'10.5f',correct
'fill(0, 0, 0);',correct
'float robotX;',correct
'robotY = robotY + yspeed',correct
'robotY - 5',correct
'robotY - 25',correct
'robotY = random(height);',correct
'line(robotX - 12.5f, robotY + 25.5f, robotX - 12.5f, robotY + 10.5f)',correct
'robotY = robotY + yspeed;',correct
'Robot[]',correct
'ellipse(robotX - 15, robotY - 5, 20, 20)',correct
'ellipse(robotX - 15, robotY - 5, 10, 10)',correct
'xspeed = xspeed * -1',correct
'robotX',correct
'robotY',correct
'float robotY;',correct
'width - 75',correct
'MorgX - 150',correct
'Black = (0)',correct
'triangle(MorgX + 80, MorgY, MorgX - 160, MorgY - 400, MorgX - 240, MorgY)',correct
'ellipse(MorgX - 28, MorgY - 13, 35, 45);',correct
'strokeWeight(1.8f);',correct
'ellipse(MorgX - 38, MorgY - 13, 18, 5);',correct
'headA = new Head(100, 200)',correct
'stroke(0);',correct
'stroke(0)',correct
'int White = (255);',TooManyFields
'arc(MorgX - 14, MorgY + 30, 30, 40, 0 + PI / 8, PI - PI / 6);',correct
'MorgX = width / 2',correct
'triangle(MorgX + 80, MorgY, MorgX - 160, MorgY - 400, MorgX - 240, MorgY);',correct
'sleepTime = false;',correct
'Mouth = color(0);',correct
'PFont',correct
'color(255, 0, 0)',correct
'ydirection1 *= -1;',correct
'new Head(100, 200)',correct
'fill(Red)',correct
'// Earsfill(Black);',correct
'void keyReleased() {    sleepTime = false;}',correct
'ellipse(MorgX + 60, MorgY - 60, 85, 10);',correct
'Red = color(255, 0, 0);',correct
'MorgY + 40',correct
'int Black = (0);',TooManyFields
'sleep',correct
'ellipse(MorgX - 150, MorgY - 60, 85, 10);',correct
'textAlign(CENTER)',correct
'ellipse(MorgX - 105, MorgY - 50, 10, 30)',correct
'{    ydirection2 *= -1;}',correct
'xdirection2 = -2',correct
'// Making the creature bounce in a different direction as bounce1void bounce2() {    MorgX += (xspeed * xdirection2);    MorgY += (yspeed * ydirection2);    if (MorgX > width - 75 || MorgX < 75) {        xdirection2 *= -1;    }    if (MorgY > height - 75 || MorgY < 75) {        ydirection2 *= -1;    }}',TooManyFields
'rectMode(CENTER)',correct
'// Headfill(White);',correct
'MorgX - 240',correct
'ellipse(MorgX - 28, MorgY - 13, 50, 60)',correct
'Blue',correct
'fill(Black);',correct
'void draw() {    background(150);    if (sleepTime) {        sleep.display();    } else {        headA.display();        headB.display();        headC.display();        headD.display();        headA.move(5, 0);        headB.move(5, 0);        headC.bounce1();        headD.bounce2();    }}',correct
'ellipse(MorgX + 28, MorgY - 13, 15, 20);',correct
'MorgX = MorgX + MoveX',correct
'if (MorgX > width - 75 || MorgX < 75) {    xdirection2 *= -1;}',correct
'MorgY += (yspeed * ydirection1);',correct
'font = createFont("BloodLust.ttf", 100);',correct
'Red',correct
'MorgY + 30',correct
'MorgY = MorgY + MoveY',correct
'ellipse(MorgX - 105, MorgY - 50, 150, 200)',correct
'triangle(MorgX - 10, MorgY, MorgX + 50, MorgY - 112, MorgX + 73, MorgY);',correct
'rectMode(CENTER);',correct
'float yspeed;',TooManyFields
'font',correct
'// Mouth colors return to normal so that his mouth is closed againMouth = color(255);',correct
'headC.bounce1()',correct
'MorgX - 230',correct
'MorgY > 750',correct
'MorgY > height - 75 || MorgY < 75',correct
'arc(MorgX, MorgY, 150, 150, PI - PI / 9, 2 * PI + PI / 9, CHORD);',correct
'headA.move(5, 0);',correct
'MorgX = (0);',correct
'void keyPressed() {    sleepTime = true;}',correct
'MorgX - 105',correct
'if (MorgY > height - 75 || MorgY < 75) {    ydirection2 *= -1;}',correct
'new Sleep()',correct
'ydirection2 *= -1',correct
'sleepTime = false',correct
'headA.move(5, 0)',correct
'xdirection2 *= -1;',correct
'MorgY += (yspeed * ydirection2);',correct
'headC.bounce1();',correct
'MorgY + 95',correct
'ydirection1',correct
'triangle(MorgX + 10, MorgY, MorgX - 50, MorgY - 112, MorgX - 73, MorgY);',correct
'ydirection2',correct
'headB.openMouth()',correct
'fill(Black)',correct
'textSize(80)',correct
'headD.openMouth()',correct
'headA.display();',correct
'MorgX + MoveX',correct
'text("Go to sleep", MorgX, 670)',correct
'Blue = color(50, 50, 255);',correct
'ellipse(MorgX + 18, MorgY - 13, 18, 5);',correct
'Processing',correct
'Mouth',correct
'ellipse(MorgX, MorgY, 500, 500);',correct
'ellipse(MorgX + 105, MorgY - 50, 150, 200)',correct
'// A linear movenment of the creaturevoid move(int MoveX, int MoveY) {    MorgX = MorgX + MoveX;    MorgY = MorgY + MoveY;    if (MorgX > 1250) {        MorgX = (0);    }    if (MorgY > 750) {        MorgY = (0);    }}',TooManyFields
'font = createFont("BloodLust.ttf", 100)',correct
'int xdirection2;',TooManyFields
'// Eye pupilfill(Black);',correct
'ellipse(MorgX + 28, MorgY - 13, 15, 20)',correct
'ellipse(MorgX - 150, MorgY - 60, 85, 10)',correct
'false',correct
'MorgY > height - 75',correct
'MorgY - 13',correct
'{    MorgX = initX;    MorgY = initY;    Blue = color(50, 50, 255);    Mouth = color(255);    Tong = color(255);    xspeed = 2.8f;    yspeed = 2.2f;    xdirection1 = 1;    ydirection1 = -1;    xdirection2 = -2;    ydirection2 = -1;}',correct
'background(150);',correct
'MorgX < 75',correct
'ydirection2 = -1;',correct
'{    MorgX = width / 2;    MorgY = height / 2;    Red = color(255, 0, 0);    Mouth = color(0);    Tong = color(232, 143, 143);    font = createFont("BloodLust.ttf", 100);}',correct
'triangle(MorgX - 80, MorgY, MorgX + 160, MorgY - 400, MorgX + 240, MorgY)',correct
'ellipse(MorgX + 60, MorgY - 60, 85, 10)',correct
'int xdirection1;',TooManyFields
'MorgX + 50',correct
'headC.display()',correct
'MorgX += (xspeed * xdirection2);',correct
'// Making the creature bounce against the edgesvoid bounce1() {    MorgX += (xspeed * xdirection1);    MorgY += (yspeed * ydirection1);    if (MorgX > width - 75 || MorgX < 75) {        xdirection1 *= -1;    }    if (MorgY > height - 75 || MorgY < 75) {        ydirection1 *= -1;    }}',TooManyFields
'MorgX += (xspeed * xdirection2)',correct
'Mouth = color(255);',correct
'sleepTime = true',correct
'MorgX = MorgX + MoveX;',correct
'MorgX + 150',correct
'MorgY + 120',correct
'triangle(MorgX - 80, MorgY, MorgX + 160, MorgY - 400, MorgX + 240, MorgY);',correct
'sleepTime = true;',correct
'arc(MorgX, MorgY + 120, 100, 200, 0 + PI / 8, PI - PI / 8)',correct
'int MoveX',VariableNamingConventions
'int MoveY',VariableNamingConventions
'// Eyes// Eye whitefill(White);',correct
'White = (255)',correct
'headB.display()',correct
'noStroke();',correct
'MorgX + 47',correct
'triangle(MorgX - 5, MorgY, MorgX + 50, MorgY - 100, MorgX + 65, MorgY);',correct
'ellipse(MorgX - 105, MorgY - 50, 150, 200);',correct
'text("Go to sleep", MorgX, 670);',correct
'headA.display()',correct
'{    sleepTime = true;}',correct
'PI / 6',correct
'MorgY - 60',correct
'{    xdirection2 *= -1;}',correct
'ellipse(MorgX - 105, MorgY - 50, 190, 240)',correct
'// Eye shinyfill(White);',correct
'// To color the mouth so it is openMouth = color(0);',correct
'color(50, 50, 255)',correct
'float MorgX;',TooManyFields
'xdirection1 *= -1;',correct
'{    // To color the mouth so it is open    Mouth = color(0);    Tong = color(232, 143, 143);}',correct
'headD.display()',correct
'MorgX - 14',correct
'sleep.display();',correct
'MorgX + 73',correct
'MorgX - 10',correct
'int Red;',VariableNamingConventions
'headC.openMouth();',correct
'new Head(100, 500)',correct
'MorgX + 60',correct
'Mouth = color(0)',correct
'fill(Mouth)',correct
'ellipse(MorgX + 28, MorgY - 13, 35, 45);',correct
'MorgY - 50',correct
'arc(MorgX, MorgY + 40, 30, 50, 0 + PI / 8, PI - PI / 8);',correct
'background(25);',correct
'{    sleepTime = false;}',correct
'ellipse(MorgX + 28, MorgY - 13, 35, 45)',correct
'float MorgY;',TooManyFields
'void display() {    background(25);    // Ears    fill(Black);    triangle(MorgX + 80, MorgY, MorgX - 160, MorgY - 400, MorgX - 240, MorgY);    triangle(MorgX - 80, MorgY, MorgX + 160, MorgY - 400, MorgX + 240, MorgY);    fill(White);    triangle(MorgX + 50, MorgY, MorgX - 150, MorgY - 350, MorgX - 230, MorgY);    triangle(MorgX - 50, MorgY, MorgX + 150, MorgY - 350, MorgX + 230, MorgY);    // Head    fill(White);    noStroke();    ellipse(MorgX, MorgY, 500, 500);    fill(Black);    arc(MorgX, MorgY, 500, 500, PI - PI / 9, 2 * PI + PI / 9, CHORD);    // Eyes    // Eye white    fill(White);    ellipse(MorgX - 105, MorgY - 50, 190, 240);    ellipse(MorgX + 105, MorgY - 50, 190, 240);    // Eye iris    fill(Red);    ellipse(MorgX - 105, MorgY - 50, 150, 200);    ellipse(MorgX + 105, MorgY - 50, 150, 200);    // Eye pupil    fill(Black);    ellipse(MorgX - 105, MorgY - 50, 10, 30);    ellipse(MorgX + 105, MorgY - 50, 10, 30);    // Eye shiny    fill(White);    ellipse(MorgX - 150, MorgY - 60, 85, 10);    ellipse(MorgX + 60, MorgY - 60, 85, 10);    // Mouth    // Open mouth    fill(Mouth);    noStroke();    arc(MorgX, MorgY + 120, 100, 200, 0 + PI / 8, PI - PI / 8);    fill(Tong);    arc(MorgX, MorgY + 120, 50, 140, 0 + PI / 8, PI - PI / 8);    // Whiskers    fill(White);    stroke(0);    strokeWeight(4);    arc(MorgX - 47, MorgY + 95, 100, 140, 0 + PI / 8, PI - PI / 6);    arc(MorgX + 47, MorgY + 95, 100, 140, 0 + PI / 6, PI - PI / 8);    // Text displayed    fill(255, 0, 0);    textSize(80);    textFont(font);    text("Go to sleep", MorgX, 670);}',correct
'MorgX += (xspeed * xdirection1)',correct
'PI / 9',correct
'PI / 8',correct
'color(232, 143, 143)',correct
'"BloodLust.ttf"',correct
'Sleep sleep;',correct
'MorgX + 240',correct
'MorgX + 65',correct
'xspeed',correct
'MorgY = height / 2',correct
'MorgX + 105',correct
'fill(255, 0, 0)',correct
'ellipse(MorgX - 38, MorgY - 13, 18, 5)',correct
'Blue = color(50, 50, 255)',correct
'{    headA.closedMouth();    headB.closedMouth();    headC.closedMouth();    headD.closedMouth();}',correct
'arc(MorgX, MorgY + 40, 30, 50, 0 + PI / 8, PI - PI / 8)',correct
'ellipseMode(CENTER)',correct
'headB.openMouth();',correct
'{    xdirection1 *= -1;}',correct
'MorgX + 18',correct
'ellipse(MorgX - 28, MorgY - 13, 15, 20);',correct
'{    background(150);    if (sleepTime) {        sleep.display();    } else {        headA.display();        headB.display();        headC.display();        headD.display();        headA.move(5, 0);        headB.move(5, 0);        headC.bounce1();        headD.bounce2();    }}',correct
'MorgX + 230',correct
'MorgX + 14',correct
'MorgY = MorgY + MoveY;',correct
'headD = new Head(width / 2, height / 2);',correct
'MorgX + 10',correct
'arc(MorgX, MorgY, 150, 150, PI - PI / 9, 2 * PI + PI / 9, CHORD)',correct
'void',correct
'-1',correct
'arc(MorgX + 14, MorgY + 30, 30, 40, 0 + PI / 6, PI - PI / 8);',correct
'-2',correct
'2.2f',correct
'Tong',correct
'headC.openMouth()',correct
'"Go to sleep"',correct
'headA.closedMouth();',correct
'ellipse(MorgX + 18, MorgY - 13, 18, 5)',correct
'true',correct
'headD = new Head(width / 2, height / 2)',correct
'headB = new Head(100, 500)',correct
'{    sleep.display();}',correct
'// Mouth',correct
'ellipse(MorgX, MorgY, 150, 150)',correct
'background(150)',correct
'int Mouth;',TooManyFields
'// Closed/normal mouthfill(White);',correct
'xdirection2 *= -1',correct
'height - 75',correct
'// Mouth// Open mouth, covered up in whitefill(Mouth);',correct
'{    background(25);    // Ears    fill(Black);    triangle(MorgX + 80, MorgY, MorgX - 160, MorgY - 400, MorgX - 240, MorgY);    triangle(MorgX - 80, MorgY, MorgX + 160, MorgY - 400, MorgX + 240, MorgY);    fill(White);    triangle(MorgX + 50, MorgY, MorgX - 150, MorgY - 350, MorgX - 230, MorgY);    triangle(MorgX - 50, MorgY, MorgX + 150, MorgY - 350, MorgX + 230, MorgY);    // Head    fill(White);    noStroke();    ellipse(MorgX, MorgY, 500, 500);    fill(Black);    arc(MorgX, MorgY, 500, 500, PI - PI / 9, 2 * PI + PI / 9, CHORD);    // Eyes    // Eye white    fill(White);    ellipse(MorgX - 105, MorgY - 50, 190, 240);    ellipse(MorgX + 105, MorgY - 50, 190, 240);    // Eye iris    fill(Red);    ellipse(MorgX - 105, MorgY - 50, 150, 200);    ellipse(MorgX + 105, MorgY - 50, 150, 200);    // Eye pupil    fill(Black);    ellipse(MorgX - 105, MorgY - 50, 10, 30);    ellipse(MorgX + 105, MorgY - 50, 10, 30);    // Eye shiny    fill(White);    ellipse(MorgX - 150, MorgY - 60, 85, 10);    ellipse(MorgX + 60, MorgY - 60, 85, 10);    // Mouth    // Open mouth    fill(Mouth);    noStroke();    arc(MorgX, MorgY + 120, 100, 200, 0 + PI / 8, PI - PI / 8);    fill(Tong);    arc(MorgX, MorgY + 120, 50, 140, 0 + PI / 8, PI - PI / 8);    // Whiskers    fill(White);    stroke(0);    strokeWeight(4);    arc(MorgX - 47, MorgY + 95, 100, 140, 0 + PI / 8, PI - PI / 6);    arc(MorgX + 47, MorgY + 95, 100, 140, 0 + PI / 6, PI - PI / 8);    // Text displayed    fill(255, 0, 0);    textSize(80);    textFont(font);    text("Go to sleep", MorgX, 670);}',LongMethodRule
'ellipse(MorgX - 28, MorgY - 13, 50, 60);',correct
'ellipse(MorgX + 105, MorgY - 50, 150, 200);',correct
'MorgX - 160',correct
'Tong = color(232, 143, 143)',correct
'headD.display();',correct
'xspeed = 2.8f;',correct
'ellipse(MorgX, MorgY, 500, 500)',correct
'strokeWeight(4)',correct
'MorgX + 28',correct
'ydirection2 *= -1;',correct
'MorgX > 1250',correct
'xdirection1 *= -1',correct
'{    MorgX = (0);}',correct
'MorgX - 73',correct
'int Blue;',TooManyFields
'ellipse(MorgX + 28, MorgY - 13, 50, 60)',correct
'{    rectMode(CENTER);    ellipseMode(CENTER);    textAlign(CENTER);    headA = new Head(100, 200);    headB = new Head(100, 500);    headC = new Head(width / 2, height / 2);    headD = new Head(width / 2, height / 2);    sleep = new Sleep();}',correct
'// Eye irisfill(Blue);',correct
'xdirection1 = 1;',correct
'{    MorgX += (xspeed * xdirection1);    MorgY += (yspeed * ydirection1);    if (MorgX > width - 75 || MorgX < 75) {        xdirection1 *= -1;    }    if (MorgY > height - 75 || MorgY < 75) {        ydirection1 *= -1;    }}',correct
'Tong = color(255);',correct
'1.8f',correct
'void mousePressed() {    headA.openMouth();    headB.openMouth();    headC.openMouth();    headD.openMouth();}',correct
'Head',TooManyFields
'MorgY - 112',correct
'headD.bounce2()',correct
'headB.closedMouth();',correct
'2 * PI + PI / 9',correct
'ellipse(MorgX + 105, MorgY - 50, 190, 240)',correct
'if (MorgY > 750) {    MorgY = (0);}',correct
'xspeed = 2.8f',correct
'ellipse(MorgX, MorgY, 150, 150);',correct
'strokeWeight(1.8f)',correct
'{    MorgX += (xspeed * xdirection2);    MorgY += (yspeed * ydirection2);    if (MorgX > width - 75 || MorgX < 75) {        xdirection2 *= -1;    }    if (MorgY > height - 75 || MorgY < 75) {        ydirection2 *= -1;    }}',correct
'MorgX - 65',correct
'class Sleep {    float MorgX;    float MorgY;    int White = (255);    int Black = (0);    int Red;    int Mouth;    int Tong;    PFont font;    Sleep() {        MorgX = width / 2;        MorgY = height / 2;        Red = color(255, 0, 0);        Mouth = color(0);        Tong = color(232, 143, 143);        font = createFont("BloodLust.ttf", 100);    }    void display() {        background(25);        // Ears        fill(Black);        triangle(MorgX + 80, MorgY, MorgX - 160, MorgY - 400, MorgX - 240, MorgY);        triangle(MorgX - 80, MorgY, MorgX + 160, MorgY - 400, MorgX + 240, MorgY);        fill(White);        triangle(MorgX + 50, MorgY, MorgX - 150, MorgY - 350, MorgX - 230, MorgY);        triangle(MorgX - 50, MorgY, MorgX + 150, MorgY - 350, MorgX + 230, MorgY);        // Head        fill(White);        noStroke();        ellipse(MorgX, MorgY, 500, 500);        fill(Black);        arc(MorgX, MorgY, 500, 500, PI - PI / 9, 2 * PI + PI / 9, CHORD);        // Eyes        // Eye white        fill(White);        ellipse(MorgX - 105, MorgY - 50, 190, 240);        ellipse(MorgX + 105, MorgY - 50, 190, 240);        // Eye iris        fill(Red);        ellipse(MorgX - 105, MorgY - 50, 150, 200);        ellipse(MorgX + 105, MorgY - 50, 150, 200);        // Eye pupil        fill(Black);        ellipse(MorgX - 105, MorgY - 50, 10, 30);        ellipse(MorgX + 105, MorgY - 50, 10, 30);        // Eye shiny        fill(White);        ellipse(MorgX - 150, MorgY - 60, 85, 10);        ellipse(MorgX + 60, MorgY - 60, 85, 10);        // Mouth        // Open mouth        fill(Mouth);        noStroke();        arc(MorgX, MorgY + 120, 100, 200, 0 + PI / 8, PI - PI / 8);        fill(Tong);        arc(MorgX, MorgY + 120, 50, 140, 0 + PI / 8, PI - PI / 8);        // Whiskers        fill(White);        stroke(0);        strokeWeight(4);        arc(MorgX - 47, MorgY + 95, 100, 140, 0 + PI / 8, PI - PI / 6);        arc(MorgX + 47, MorgY + 95, 100, 140, 0 + PI / 6, PI - PI / 8);        // Text displayed        fill(255, 0, 0);        textSize(80);        textFont(font);        text("Go to sleep", MorgX, 670);    }}',correct
'ellipse(MorgX - 28, MorgY - 13, 15, 20)',correct
'MorgY - 100',correct
'void openMouth() {    // To color the mouth so it is open    Mouth = color(0);    Tong = color(232, 143, 143);}',TooManyFields
'float xspeed;',TooManyFields
'void mouseReleased() {    headA.closedMouth();    headB.closedMouth();    headC.closedMouth();    headD.closedMouth();}',correct
'arc(MorgX, MorgY + 40, 15, 30, 0 + PI / 8, PI - PI / 8);',correct
'MorgX - 5',correct
'background(25)',correct
'arc(MorgX, MorgY + 120, 50, 140, 0 + PI / 8, PI - PI / 8);',correct
'headA.openMouth();',correct
'headC = new Head(width / 2, height / 2)',correct
'{    MorgY = (0);}',correct
'arc(MorgX, MorgY, 500, 500, PI - PI / 9, 2 * PI + PI / 9, CHORD);',correct
'MorgY - 350',correct
'boolean sleepTime = false;',correct
'int initY',correct
'MorgX - 80',correct
'int initX',correct
'yspeed',correct
'Sleep',correct
'ydirection1 = -1',correct
'triangle(MorgX + 5, MorgY, MorgX - 50, MorgY - 100, MorgX - 65, MorgY);',correct
'2.8f',correct
'noStroke()',correct
'headA = new Head(100, 200);',correct
'fill(Blue)',correct
'MorgY < 75',correct
'triangle(MorgX - 5, MorgY, MorgX + 50, MorgY - 100, MorgX + 65, MorgY)',correct
'headA.closedMouth()',correct
'headD.closedMouth();',correct
'bounce1',correct
'bounce2',correct
'MorgX - 38',correct
'triangle(MorgX + 50, MorgY, MorgX - 150, MorgY - 350, MorgX - 230, MorgY);',correct
'ellipse(MorgX - 105, MorgY - 50, 10, 30);',correct
'textSize(80);',correct
'MorgX + 80',correct
'ellipse(MorgX + 105, MorgY - 50, 10, 30)',correct
'ellipse(MorgX + 105, MorgY - 50, 10, 30);',correct
'triangle(MorgX - 50, MorgY, MorgX + 150, MorgY - 350, MorgX + 230, MorgY);',correct
'{    MorgX = MorgX + MoveX;    MorgY = MorgY + MoveY;    if (MorgX > 1250) {        MorgX = (0);    }    if (MorgY > 750) {        MorgY = (0);    }}',correct
'ydirection1 = -1;',correct
'// Eye irisfill(Red);',correct
'textFont(font);',correct
'headD.bounce2();',correct
'height / 2',correct
'MorgX - 28',correct
'headD.closedMouth()',correct
'// Whiskersfill(White);',correct
'headC = new Head(width / 2, height / 2);',correct
'MorgX - 50',correct
'MorgX += (xspeed * xdirection1);',correct
'MorgX + 5',correct
'headC.closedMouth();',correct
'Sleep() {    MorgX = width / 2;    MorgY = height / 2;    Red = color(255, 0, 0);    Mouth = color(0);    Tong = color(232, 143, 143);    font = createFont("BloodLust.ttf", 100);}',correct
'headC.display();',correct
'void display() {    // Ears    fill(Black);    triangle(MorgX + 10, MorgY, MorgX - 50, MorgY - 112, MorgX - 73, MorgY);    triangle(MorgX - 10, MorgY, MorgX + 50, MorgY - 112, MorgX + 73, MorgY);    fill(White);    triangle(MorgX + 5, MorgY, MorgX - 50, MorgY - 100, MorgX - 65, MorgY);    triangle(MorgX - 5, MorgY, MorgX + 50, MorgY - 100, MorgX + 65, MorgY);    // Head    fill(White);    noStroke();    ellipse(MorgX, MorgY, 150, 150);    fill(Black);    arc(MorgX, MorgY, 150, 150, PI - PI / 9, 2 * PI + PI / 9, CHORD);    // Eyes    // Eye white    fill(White);    ellipse(MorgX - 28, MorgY - 13, 50, 60);    ellipse(MorgX + 28, MorgY - 13, 50, 60);    // Eye iris    fill(Blue);    ellipse(MorgX - 28, MorgY - 13, 35, 45);    ellipse(MorgX + 28, MorgY - 13, 35, 45);    // Eye pupil    fill(Black);    ellipse(MorgX - 28, MorgY - 13, 15, 20);    ellipse(MorgX + 28, MorgY - 13, 15, 20);    // Eye shiny    fill(White);    ellipse(MorgX - 38, MorgY - 13, 18, 5);    ellipse(MorgX + 18, MorgY - 13, 18, 5);    // Mouth    // Open mouth, covered up in white    fill(Mouth);    noStroke();    arc(MorgX, MorgY + 40, 30, 50, 0 + PI / 8, PI - PI / 8);    fill(Tong);    arc(MorgX, MorgY + 40, 15, 30, 0 + PI / 8, PI - PI / 8);    // Closed/normal mouth    fill(White);    stroke(0);    strokeWeight(1.8f);    arc(MorgX - 14, MorgY + 30, 30, 40, 0 + PI / 8, PI - PI / 6);    arc(MorgX + 14, MorgY + 30, 30, 40, 0 + PI / 6, PI - PI / 8);}',TooManyFields
'headC.closedMouth()',correct
'if (sleepTime) {    sleep.display();} else {    headA.display();    headB.display();    headC.display();    headD.display();    headA.move(5, 0);    headB.move(5, 0);    headC.bounce1();    headD.bounce2();}',correct
'headB.closedMouth()',correct
'{    // Ears    fill(Black);    triangle(MorgX + 10, MorgY, MorgX - 50, MorgY - 112, MorgX - 73, MorgY);    triangle(MorgX - 10, MorgY, MorgX + 50, MorgY - 112, MorgX + 73, MorgY);    fill(White);    triangle(MorgX + 5, MorgY, MorgX - 50, MorgY - 100, MorgX - 65, MorgY);    triangle(MorgX - 5, MorgY, MorgX + 50, MorgY - 100, MorgX + 65, MorgY);    // Head    fill(White);    noStroke();    ellipse(MorgX, MorgY, 150, 150);    fill(Black);    arc(MorgX, MorgY, 150, 150, PI - PI / 9, 2 * PI + PI / 9, CHORD);    // Eyes    // Eye white    fill(White);    ellipse(MorgX - 28, MorgY - 13, 50, 60);    ellipse(MorgX + 28, MorgY - 13, 50, 60);    // Eye iris    fill(Blue);    ellipse(MorgX - 28, MorgY - 13, 35, 45);    ellipse(MorgX + 28, MorgY - 13, 35, 45);    // Eye pupil    fill(Black);    ellipse(MorgX - 28, MorgY - 13, 15, 20);    ellipse(MorgX + 28, MorgY - 13, 15, 20);    // Eye shiny    fill(White);    ellipse(MorgX - 38, MorgY - 13, 18, 5);    ellipse(MorgX + 18, MorgY - 13, 18, 5);    // Mouth    // Open mouth, covered up in white    fill(Mouth);    noStroke();    arc(MorgX, MorgY + 40, 30, 50, 0 + PI / 8, PI - PI / 8);    fill(Tong);    arc(MorgX, MorgY + 40, 15, 30, 0 + PI / 8, PI - PI / 8);    // Closed/normal mouth    fill(White);    stroke(0);    strokeWeight(1.8f);    arc(MorgX - 14, MorgY + 30, 30, 40, 0 + PI / 8, PI - PI / 6);    arc(MorgX + 14, MorgY + 30, 30, 40, 0 + PI / 6, PI - PI / 8);}',LongMethodRule
'headB = new Head(100, 500);',correct
'triangle(MorgX - 50, MorgY, MorgX + 150, MorgY - 350, MorgX + 230, MorgY)',correct
'arc(MorgX, MorgY, 500, 500, PI - PI / 9, 2 * PI + PI / 9, CHORD)',correct
'// Mouth// Open mouthfill(Mouth);',correct
'textAlign(CENTER);',correct
'strokeWeight(4);',correct
'if (MorgY > height - 75 || MorgY < 75) {    ydirection1 *= -1;}',correct
'ellipseMode(CENTER);',correct
'Red = color(255, 0, 0)',correct
'arc(MorgX + 47, MorgY + 95, 100, 140, 0 + PI / 6, PI - PI / 8);',correct
'MorgX + 160',correct
'MorgX = initX;',correct
'MorgX - 47',correct
'Tong = color(232, 143, 143);',correct
'yspeed = 2.2f;',correct
'{    headA.openMouth();    headB.openMouth();    headC.openMouth();    headD.openMouth();}',correct
'MorgY - 400',correct
'sleep.display()',correct
'fill(White);',correct
'color(255)',correct
'headB.display();',correct
'if (MorgX > 1250) {    MorgX = (0);}',correct
'Tong = color(255)',correct
'Head headB;',correct
'headD.openMouth();',correct
'MorgY += (yspeed * ydirection2)',correct
'arc(MorgX + 47, MorgY + 95, 100, 140, 0 + PI / 6, PI - PI / 8)',correct
'MorgX > width - 75',correct
'int Tong;',TooManyFields
'sleep = new Sleep()',correct
'MorgY = (0)',correct
'void setup() {    rectMode(CENTER);    ellipseMode(CENTER);    textAlign(CENTER);    headA = new Head(100, 200);    headB = new Head(100, 500);    headC = new Head(width / 2, height / 2);    headD = new Head(width / 2, height / 2);    sleep = new Sleep();}',correct
'int ydirection2;',TooManyFields
'sleep = new Sleep();',correct
'Head headA;',correct
'triangle(MorgX - 10, MorgY, MorgX + 50, MorgY - 112, MorgX + 73, MorgY)',correct
'MorgY += (yspeed * ydirection1)',correct
'MorgX = (0)',correct
'{    // Mouth colors return to normal so that his mouth is closed again    Mouth = color(255);    Tong = color(255);}',correct
'void closedMouth() {    // Mouth colors return to normal so that his mouth is closed again    Mouth = color(255);    Tong = color(255);}',TooManyFields
'ydirection1 *= -1',correct
'textFont(font)',correct
'Head(int initX, int initY) {    MorgX = initX;    MorgY = initY;    Blue = color(50, 50, 255);    Mouth = color(255);    Tong = color(255);    xspeed = 2.8f;    yspeed = 2.2f;    xdirection1 = 1;    ydirection1 = -1;    xdirection2 = -2;    ydirection2 = -1;}',TooManyFields
'ellipse(MorgX + 105, MorgY - 50, 190, 240);',correct
'color(0)',correct
'MorgX > width - 75 || MorgX < 75',correct
'Head headD;',correct
'MorgY = initY;',correct
'display',LongMethodRule
'xdirection1 = 1',correct
'arc(MorgX, MorgY + 120, 50, 140, 0 + PI / 8, PI - PI / 8)',correct
'arc(MorgX + 14, MorgY + 30, 30, 40, 0 + PI / 6, PI - PI / 8)',correct
'createFont("BloodLust.ttf", 100)',correct
'arc(MorgX - 47, MorgY + 95, 100, 140, 0 + PI / 8, PI - PI / 6)',correct
'triangle(MorgX + 10, MorgY, MorgX - 50, MorgY - 112, MorgX - 73, MorgY)',correct
'Head headC;',correct
'MorgY = initY',correct
'new Head(width / 2, height / 2)',correct
'triangle(MorgX + 50, MorgY, MorgX - 150, MorgY - 350, MorgX - 230, MorgY)',correct
'headB.move(5, 0);',correct
'if (MorgX > width - 75 || MorgX < 75) {    xdirection1 *= -1;}',correct
'headA',correct
'MorgY + MoveY',correct
'MorgY = (0);',correct
'headB',correct
'headC',correct
'headD',correct
'PI - PI / 8',correct
'closedMouth',correct
'PI - PI / 9',correct
'PFont font;',correct
'xdirection2 = -2;',correct
'PI - PI / 6',correct
'ellipse(MorgX - 28, MorgY - 13, 35, 45)',correct
'// Eyes',correct
'ellipse(MorgX + 28, MorgY - 13, 50, 60);',correct
'xdirection1',correct
'xdirection2',correct
'triangle(MorgX + 5, MorgY, MorgX - 50, MorgY - 100, MorgX - 65, MorgY)',correct
'ydirection2 = -1',correct
'class Head {    float MorgX;    float MorgY;    int White = (255);    int Black = (0);    int Blue;    int Mouth;    int Tong;    float xspeed;    float yspeed;    int xdirection1;    int ydirection1;    int xdirection2;    int ydirection2;    Head(int initX, int initY) {        MorgX = initX;        MorgY = initY;        Blue = color(50, 50, 255);        Mouth = color(255);        Tong = color(255);        xspeed = 2.8f;        yspeed = 2.2f;        xdirection1 = 1;        ydirection1 = -1;        xdirection2 = -2;        ydirection2 = -1;    }    void display() {        // Ears        fill(Black);        triangle(MorgX + 10, MorgY, MorgX - 50, MorgY - 112, MorgX - 73, MorgY);        triangle(MorgX - 10, MorgY, MorgX + 50, MorgY - 112, MorgX + 73, MorgY);        fill(White);        triangle(MorgX + 5, MorgY, MorgX - 50, MorgY - 100, MorgX - 65, MorgY);        triangle(MorgX - 5, MorgY, MorgX + 50, MorgY - 100, MorgX + 65, MorgY);        // Head        fill(White);        noStroke();        ellipse(MorgX, MorgY, 150, 150);        fill(Black);        arc(MorgX, MorgY, 150, 150, PI - PI / 9, 2 * PI + PI / 9, CHORD);        // Eyes        // Eye white        fill(White);        ellipse(MorgX - 28, MorgY - 13, 50, 60);        ellipse(MorgX + 28, MorgY - 13, 50, 60);        // Eye iris        fill(Blue);        ellipse(MorgX - 28, MorgY - 13, 35, 45);        ellipse(MorgX + 28, MorgY - 13, 35, 45);        // Eye pupil        fill(Black);        ellipse(MorgX - 28, MorgY - 13, 15, 20);        ellipse(MorgX + 28, MorgY - 13, 15, 20);        // Eye shiny        fill(White);        ellipse(MorgX - 38, MorgY - 13, 18, 5);        ellipse(MorgX + 18, MorgY - 13, 18, 5);        // Mouth        // Open mouth, covered up in white        fill(Mouth);        noStroke();        arc(MorgX, MorgY + 40, 30, 50, 0 + PI / 8, PI - PI / 8);        fill(Tong);        arc(MorgX, MorgY + 40, 15, 30, 0 + PI / 8, PI - PI / 8);        // Closed/normal mouth        fill(White);        stroke(0);        strokeWeight(1.8f);        arc(MorgX - 14, MorgY + 30, 30, 40, 0 + PI / 8, PI - PI / 6);        arc(MorgX + 14, MorgY + 30, 30, 40, 0 + PI / 6, PI - PI / 8);    }    void openMouth() {        // To color the mouth so it is open        Mouth = color(0);        Tong = color(232, 143, 143);    }    void closedMouth() {        // Mouth colors return to normal so that his mouth is closed again        Mouth = color(255);        Tong = color(255);    }    // A linear movenment of the creature    void move(int MoveX, int MoveY) {        MorgX = MorgX + MoveX;        MorgY = MorgY + MoveY;        if (MorgX > 1250) {            MorgX = (0);        }        if (MorgY > 750) {            MorgY = (0);        }    }    // Making the creature bounce against the edges    void bounce1() {        MorgX += (xspeed * xdirection1);        MorgY += (yspeed * ydirection1);        if (MorgX > width - 75 || MorgX < 75) {            xdirection1 *= -1;        }        if (MorgY > height - 75 || MorgY < 75) {            ydirection1 *= -1;        }    }    // Making the creature bounce in a different direction as bounce1    void bounce2() {        MorgX += (xspeed * xdirection2);        MorgY += (yspeed * ydirection2);        if (MorgX > width - 75 || MorgX < 75) {            xdirection2 *= -1;        }        if (MorgY > height - 75 || MorgY < 75) {            ydirection2 *= -1;        }    }}',correct
'// Text displayedfill(255, 0, 0);',correct
'MorgX = width / 2;',correct
'arc(MorgX - 47, MorgY + 95, 100, 140, 0 + PI / 8, PI - PI / 6);',correct
'MorgX',correct
'headA.openMouth()',correct
'MorgY',correct
'openMouth',correct
'arc(MorgX, MorgY + 40, 15, 30, 0 + PI / 8, PI - PI / 8)',correct
'MorgX = initX',correct
'ellipse(MorgX - 105, MorgY - 50, 190, 240);',correct
'fill(Tong);',correct
'fill(Tong)',correct
'{    ydirection1 *= -1;}',correct
'{    headA.display();    headB.display();    headC.display();    headD.display();    headA.move(5, 0);    headB.move(5, 0);    headC.bounce1();    headD.bounce2();}',correct
'int ydirection1;',TooManyFields
'MorgY = height / 2;',correct
'yspeed = 2.2f',correct
'headB.move(5, 0)',correct
'0 + PI / 8',correct
'move',VariableNamingConventions
'arc(MorgX - 14, MorgY + 30, 30, 40, 0 + PI / 8, PI - PI / 6)',correct
'Mouth = color(255)',correct
'0 + PI / 6',correct
'arc(MorgX, MorgY + 120, 100, 200, 0 + PI / 8, PI - PI / 8);',correct
'width / 2',correct
'fill(White)',correct
'2 * PI',correct
'i = 0',correct
'x - 15',correct
'y = initY;',correct
'random_y = -random_y',correct
'x - 55 < 0',correct
'x - 11',correct
'random_x = -random_x',correct
'x - 10',correct
'y + random_y',correct
'text("Press the trackpad to create more penguins!", 50, 100)',correct
'penguins[i] = penguins[i + 1]',correct
'y + 85',correct
'{    penguins[penguinsCreated] = new Pengu(width / 2, height / 2);    penguinsCreated++;}',correct
'x = initX;',correct
'penguins.length',correct
'Pengu(float initX, float initY) {    x = initX;    y = initY;    random_x = random(-2, 2);    random_y = random(-2, 2);}',correct
'y = initY',correct
'random_x',correct
'random_y',correct
'ellipse(x + 50, y + 15, 15, 100);',correct
'int penguinNr = 1;',correct
'y = y + random_y',correct
'penguins[j]',correct
'// armsfill(200, 200, 200);',correct
'random(-2, 2)',correct
'x = x + random_x',correct
'penguins.length - 1',correct
'penguins[i].move()',correct
'penguins[penguinsCreated] = new Pengu(width / 2, height / 2)',correct
'fill(50, 50, 50)',correct
'fill(255, 148, 0);',correct
'ellipse(x + 9, y - 103, 4, 2);',correct
'random_x = random(-2, 2)',correct
'text("Press the trackpad to create more penguins!", 50, 100);',PixelHardcodeIgnoranceRule
'ellipse(x - 10, y - 100, 12, 18)',correct
'fill(200, 200, 200)',correct
'background(181, 218, 255)',correct
'Pengu',correct
'random_x = -random_x;',correct
'textSize(32);',correct
'noStroke();',correct
'penguins[j].createPenguin();',correct
'if (x + 55 > width || x - 55 < 0) {    random_x = -random_x;}',correct
'ellipse(x + 50, y + 15, 15, 100)',correct
'penguins[i]',correct
'ellipse(x, y - 80, 10, 7);',correct
'textSize(32)',correct
'penguinsCreated++',correct
'y - 80',correct
'x + 10',correct
'textSize(15)',correct
'int j = 0',correct
'void draw() {    background(181, 218, 255);    textSize(32);    fill(255, 148, 0);    text("Press the trackpad to create more penguins!", 50, 100);    for (int i = 0; i < penguinsCreated; i++) {        penguins[i].move();    }    for (int j = 0; j < penguinsCreated; j++) {        penguins[j].createPenguin();    }}',correct
'ellipse(x + 9, y - 103, 4, 2)',correct
'{    // head    fill(120, 120, 120);    noStroke();    ellipse(x, y - 90, 50, 50);    // eyes    fill(230, 230, 230);    ellipse(x - 10, y - 100, 12, 18);    ellipse(x + 10, y - 100, 12, 18);    ellipse(x - 11, y - 103, 4, 2);    ellipse(x + 9, y - 103, 4, 2);    // body    fill(50, 50, 50);    ellipse(x, y, 100, 150);    // belly    fill(200, 200, 200);    ellipse(x, y, 90, 120);    // mouth    fill(255, 148, 0);    ellipse(x, y - 80, 10, 7);    // arms    fill(200, 200, 200);    ellipse(x - 50, y + 15, 15, 100);    ellipse(x + 50, y + 15, 15, 100);    // legs    fill(255, 148, 0);    ellipse(x - 15, y + 75, 20, 20);    ellipse(x + 15, y + 75, 20, 20);    fill(1, 1, 1);    textSize(15);    text("Penguins:" + penguinNr, x - 40, y);}',correct
'ellipse(x - 15, y + 75, 20, 20);',correct
'ellipse(x - 11, y - 103, 4, 2);',correct
'j++',correct
'ellipse(x, y, 90, 120);',correct
'x = initX',correct
'penguins = new Pengu[maxPenguins]',correct
'for (int i = 0; i < penguinsCreated; i++) {    penguins[i].move();}',correct
'void mouseClicked() {    if (penguinsCreated < penguins.length) {        penguins[penguinsCreated] = new Pengu(mouseX, mouseY);        penguinsCreated++;    } else {        for (int i = 0; i < penguins.length - 1; i++) penguins[i] = penguins[i + 1];    }    penguins[penguins.length - 1] = new Pengu(mouseX, mouseY);    penguinNr++;}',correct
'x + random_x',correct
'y = y + random_y;',correct
'ellipse(x - 10, y - 100, 12, 18);',correct
'ellipse(x, y, 100, 150)',correct
'"Penguins:" + penguinNr',correct
'ellipse(x - 15, y + 75, 20, 20)',correct
'// bellyfill(200, 200, 200);',correct
'x + 55 > width || x - 55 < 0',correct
'penguins[penguinsCreated] = new Pengu(mouseX, mouseY)',correct
'for (int i = 0; i < penguins.length - 1; i++) penguins[i] = penguins[i + 1];',ForLoopsMustUseBraces
'penguinNr++;',correct
'int maxPenguins = 100;',correct
'float random_x;',correct
'y - 90',correct
'// headfill(120, 120, 120);',correct
'penguins[penguinsCreated] = new Pengu(width / 2, height / 2);',correct
'x - 40',correct
'y + 75',correct
'i < penguinsCreated',correct
'ellipse(x, y, 90, 120)',correct
'fill(1, 1, 1);',correct
'{    background(181, 218, 255);    textSize(32);    fill(255, 148, 0);    text("Press the trackpad to create more penguins!", 50, 100);    for (int i = 0; i < penguinsCreated; i++) {        penguins[i].move();    }    for (int j = 0; j < penguinsCreated; j++) {        penguins[j].createPenguin();    }}',correct
'background(181, 218, 255);',correct
'ellipse(x - 50, y + 15, 15, 100);',correct
'ellipse(x, y - 80, 10, 7)',correct
'x + 9',correct
'ellipse(x - 50, y + 15, 15, 100)',correct
'penguinsCreated++;',correct
'// legsfill(255, 148, 0);',correct
'ellipse(x + 10, y - 100, 12, 18)',correct
'penguins[i].move();',correct
'x',correct
'penguins[i + 1]',correct
'y',correct
'penguins[j].createPenguin()',correct
'penguins[penguins.length - 1] = new Pengu(mouseX, mouseY);',correct
'x + 15',correct
'penguins[penguins.length - 1] = new Pengu(mouseX, mouseY)',correct
'noStroke()',correct
'{    for (int i = 0; i < penguins.length - 1; i++) penguins[i] = penguins[i + 1];}',correct
'random_x = random(-2, 2);',correct
'float random_y;',correct
'text("Penguins:" + penguinNr, x - 40, y)',correct
'penguins[penguinsCreated]',correct
'// eyesfill(230, 230, 230);',correct
'i < penguins.length - 1',correct
'float initX',correct
'x - 55',correct
'float initY',correct
'i++',correct
'"Press the trackpad to create more penguins!"',correct
'penguins[i] = penguins[i + 1];',correct
'void move() {    x = x + random_x;    y = y + random_y;    if (x + 55 > width || x - 55 < 0) {        random_x = -random_x;    }    if (y + 85 > height || y - 115 < 0)        random_y = -random_y;}',correct
'x - 50',correct
'ellipse(x + 10, y - 100, 12, 18);',correct
'// mouthfill(255, 148, 0);',correct
'i + 1',correct
'{    if (penguinsCreated < penguins.length) {        penguins[penguinsCreated] = new Pengu(mouseX, mouseY);        penguinsCreated++;    } else {        for (int i = 0; i < penguins.length - 1; i++) penguins[i] = penguins[i + 1];    }    penguins[penguins.length - 1] = new Pengu(mouseX, mouseY);    penguinNr++;}',correct
'[maxPenguins]',correct
'penguins[penguinsCreated] = new Pengu(mouseX, mouseY);',correct
'new Pengu[maxPenguins]',correct
'void setup() {    penguins[penguinsCreated] = new Pengu(width / 2, height / 2);    penguinsCreated++;}',correct
'text("Penguins:" + penguinNr, x - 40, y);',correct
'void',correct
'-2',correct
'// bodyfill(50, 50, 50);',correct
'for (int j = 0; j < penguinsCreated; j++) {    penguins[j].createPenguin();}',correct
'textSize(15);',correct
'createPenguin',correct
'y + 85 > height || y - 115 < 0',correct
'"Penguins:"',correct
'ellipse(x + 15, y + 75, 20, 20)',correct
'ellipse(x, y - 90, 50, 50)',correct
'{    random_x = -random_x;}',correct
'j = 0',correct
'Pengu[] penguins = new Pengu[maxPenguins];',correct
'new Pengu(mouseX, mouseY)',correct
'penguinsCreated = 0',correct
'ellipse(x + 15, y + 75, 20, 20);',correct
'height / 2',correct
'ellipse(x, y - 90, 50, 50);',correct
'fill(1, 1, 1)',correct
'x + 55',correct
'Pengu[]',correct
'x + 55 > width',correct
'x + 50',correct
'{    penguins[i].move();}',correct
'if (penguinsCreated < penguins.length) {    penguins[penguinsCreated] = new Pengu(mouseX, mouseY);    penguinsCreated++;} else {    for (int i = 0; i < penguins.length - 1; i++) penguins[i] = penguins[i + 1];}',correct
'fill(120, 120, 120)',correct
'penguinNr = 1',correct
'y + 85 > height',correct
'float x;',correct
'y - 115',correct
'Processing',correct
'{    penguins[j].createPenguin();}',correct
'penguinNr++',correct
'y + 15',correct
'random_y = -random_y;',correct
'j < penguinsCreated',correct
'x = x + random_x;',correct
'ellipse(x, y, 100, 150);',correct
'int penguinsCreated = 0;',correct
'random_y = random(-2, 2)',correct
'maxPenguins = 100',correct
'-random_x',correct
'penguinsCreated < penguins.length',correct
'fill(255, 148, 0)',correct
'new Pengu(width / 2, height / 2)',correct
'class Pengu {    float x;    float y;    float random_x;    float random_y;    Pengu(float initX, float initY) {        x = initX;        y = initY;        random_x = random(-2, 2);        random_y = random(-2, 2);    }    void createPenguin() {        // head        fill(120, 120, 120);        noStroke();        ellipse(x, y - 90, 50, 50);        // eyes        fill(230, 230, 230);        ellipse(x - 10, y - 100, 12, 18);        ellipse(x + 10, y - 100, 12, 18);        ellipse(x - 11, y - 103, 4, 2);        ellipse(x + 9, y - 103, 4, 2);        // body        fill(50, 50, 50);        ellipse(x, y, 100, 150);        // belly        fill(200, 200, 200);        ellipse(x, y, 90, 120);        // mouth        fill(255, 148, 0);        ellipse(x, y - 80, 10, 7);        // arms        fill(200, 200, 200);        ellipse(x - 50, y + 15, 15, 100);        ellipse(x + 50, y + 15, 15, 100);        // legs        fill(255, 148, 0);        ellipse(x - 15, y + 75, 20, 20);        ellipse(x + 15, y + 75, 20, 20);        fill(1, 1, 1);        textSize(15);        text("Penguins:" + penguinNr, x - 40, y);    }    void move() {        x = x + random_x;        y = y + random_y;        if (x + 55 > width || x - 55 < 0) {            random_x = -random_x;        }        if (y + 85 > height || y - 115 < 0)            random_y = -random_y;    }}',correct
'-random_y',correct
'fill(230, 230, 230)',correct
'void createPenguin() {    // head    fill(120, 120, 120);    noStroke();    ellipse(x, y - 90, 50, 50);    // eyes    fill(230, 230, 230);    ellipse(x - 10, y - 100, 12, 18);    ellipse(x + 10, y - 100, 12, 18);    ellipse(x - 11, y - 103, 4, 2);    ellipse(x + 9, y - 103, 4, 2);    // body    fill(50, 50, 50);    ellipse(x, y, 100, 150);    // belly    fill(200, 200, 200);    ellipse(x, y, 90, 120);    // mouth    fill(255, 148, 0);    ellipse(x, y - 80, 10, 7);    // arms    fill(200, 200, 200);    ellipse(x - 50, y + 15, 15, 100);    ellipse(x + 50, y + 15, 15, 100);    // legs    fill(255, 148, 0);    ellipse(x - 15, y + 75, 20, 20);    ellipse(x + 15, y + 75, 20, 20);    fill(1, 1, 1);    textSize(15);    text("Penguins:" + penguinNr, x - 40, y);}',correct
'{    penguins[penguinsCreated] = new Pengu(mouseX, mouseY);    penguinsCreated++;}',correct
'y - 100',correct
'if (y + 85 > height || y - 115 < 0)    random_y = -random_y;',IfStmtsMustUseBraces
'float y;',correct
'penguins[penguins.length - 1]',correct
'y - 103',correct
'ellipse(x - 11, y - 103, 4, 2)',correct
'{    x = x + random_x;    y = y + random_y;    if (x + 55 > width || x - 55 < 0) {        random_x = -random_x;    }    if (y + 85 > height || y - 115 < 0)        random_y = -random_y;}',correct
'int i = 0',correct
'width / 2',correct
'random_y = random(-2, 2);',correct
'{    x = initX;    y = initY;    random_x = random(-2, 2);    random_y = random(-2, 2);}',correct
'y - 115 < 0',correct
'RocketXspeed = RocketXspeed - 1',correct
'fill(255, 250, 191)',correct
'i = 0',correct
'random(width)',correct
'RocketXspeed + 1.5f',correct
'{    RocketX = RocketX + (RocketXspeed * xdirection);    RocketY = RocketY + (RocketYspeed * ydirection);}',correct
'float RocketX;',VariableNamingConventions
'// Right bodyfill(255, 250, 191);',correct
'{    for (int i = 0; i < apollo.length; i++) {        apollo[i] = new Rocket(random(0, width - 100), random(0, height - 100));    }    star1 = new Star();}',correct
'triangle(RocketX + 20, RocketY + 32, RocketX + 20, RocketY + 67, RocketX - 20, RocketY + 67)',correct
'quad(RocketX - 50, RocketY + 67, RocketX - 20, RocketY + 32, RocketX - 20, RocketY + 67, RocketX - 50, RocketY + 102);',correct
'Rocket(float tempX, float tempY) {    RocketX = tempX;    RocketY = tempY;    RocketXspeed = 2.8f;    RocketYspeed = RocketXspeed;}',correct
'triangle(RocketX + 20, RocketY + 32, RocketX + 20, RocketY + 67, RocketX - 20, RocketY + 67);',correct
'void display() {    // Left roof    fill(255, 191, 191);    triangle(RocketX, RocketY - 73, RocketX, RocketY - 38, RocketX - 40, RocketY - 38);    // Right roof    fill(191, 200, 255);    triangle(RocketX, RocketY - 73, RocketX, RocketY - 38, RocketX + 40, RocketY - 38);    // Left body    fill(191, 255, 243);    triangle(RocketX - 40, RocketY - 38, RocketX - 40, RocketY + 32, RocketX + 40, RocketY - 38);    // Right body    fill(255, 250, 191);    triangle(RocketX + 40, RocketY - 38, RocketX + 40, RocketY + 32, RocketX - 40, RocketY + 32);    // Bottom triangle left    fill(255, 191, 232);    triangle(RocketX - 20, RocketY + 32, RocketX + 20, RocketY + 32, RocketX - 20, RocketY + 67);    // Bottom triangle right    fill(255, 224, 191);    triangle(RocketX + 20, RocketY + 32, RocketX + 20, RocketY + 67, RocketX - 20, RocketY + 67);    // Left quad    fill(191, 240, 255);    quad(RocketX - 50, RocketY + 67, RocketX - 20, RocketY + 32, RocketX - 20, RocketY + 67, RocketX - 50, RocketY + 102);    // Right quad    fill(228, 191, 255);    quad(RocketX + 20, RocketY + 32, RocketX + 50, RocketY + 67, RocketX + 50, RocketY + 102, RocketX + 20, RocketY + 67);}',correct
'RocketY > height || RocketY < 0',correct
'apollo[i].updatePosition();',correct
'{    // Left roof    fill(255, 191, 191);    triangle(RocketX, RocketY - 73, RocketX, RocketY - 38, RocketX - 40, RocketY - 38);    // Right roof    fill(191, 200, 255);    triangle(RocketX, RocketY - 73, RocketX, RocketY - 38, RocketX + 40, RocketY - 38);    // Left body    fill(191, 255, 243);    triangle(RocketX - 40, RocketY - 38, RocketX - 40, RocketY + 32, RocketX + 40, RocketY - 38);    // Right body    fill(255, 250, 191);    triangle(RocketX + 40, RocketY - 38, RocketX + 40, RocketY + 32, RocketX - 40, RocketY + 32);    // Bottom triangle left    fill(255, 191, 232);    triangle(RocketX - 20, RocketY + 32, RocketX + 20, RocketY + 32, RocketX - 20, RocketY + 67);    // Bottom triangle right    fill(255, 224, 191);    triangle(RocketX + 20, RocketY + 32, RocketX + 20, RocketY + 67, RocketX - 20, RocketY + 67);    // Left quad    fill(191, 240, 255);    quad(RocketX - 50, RocketY + 67, RocketX - 20, RocketY + 32, RocketX - 20, RocketY + 67, RocketX - 50, RocketY + 102);    // Right quad    fill(228, 191, 255);    quad(RocketX + 20, RocketY + 32, RocketX + 50, RocketY + 67, RocketX + 50, RocketY + 102, RocketX + 20, RocketY + 67);}',correct
'RocketX - 50',correct
'{    RocketX = tempX;    RocketY = tempY;    RocketXspeed = 2.8f;    RocketYspeed = RocketXspeed;}',correct
'RocketXspeed - 1',correct
'void updatePosition() {    RocketX = RocketX + (RocketXspeed * xdirection);    RocketY = RocketY + (RocketYspeed * ydirection);}',correct
'{}',correct
'triangle(RocketX + 40, RocketY - 38, RocketX + 40, RocketY + 32, RocketX - 40, RocketY + 32)',correct
'{    if (RocketX > width || RocketX < 0) {        xdirection *= -1;    }    if (RocketY > height || RocketY < 0) {        ydirection *= -1;    }}',correct
'class Rocket {    float RocketX;    float RocketY;    // Rocket movement    // Speed of the Rocket    float RocketXspeed = 2.8f;    // Speed of the Rocket    float RocketYspeed = 2.2f;    float xdirection = 1;    float ydirection = 1;    Rocket(float tempX, float tempY) {        RocketX = tempX;        RocketY = tempY;        RocketXspeed = 2.8f;        RocketYspeed = RocketXspeed;    }    void display() {        // Left roof        fill(255, 191, 191);        triangle(RocketX, RocketY - 73, RocketX, RocketY - 38, RocketX - 40, RocketY - 38);        // Right roof        fill(191, 200, 255);        triangle(RocketX, RocketY - 73, RocketX, RocketY - 38, RocketX + 40, RocketY - 38);        // Left body        fill(191, 255, 243);        triangle(RocketX - 40, RocketY - 38, RocketX - 40, RocketY + 32, RocketX + 40, RocketY - 38);        // Right body        fill(255, 250, 191);        triangle(RocketX + 40, RocketY - 38, RocketX + 40, RocketY + 32, RocketX - 40, RocketY + 32);        // Bottom triangle left        fill(255, 191, 232);        triangle(RocketX - 20, RocketY + 32, RocketX + 20, RocketY + 32, RocketX - 20, RocketY + 67);        // Bottom triangle right        fill(255, 224, 191);        triangle(RocketX + 20, RocketY + 32, RocketX + 20, RocketY + 67, RocketX - 20, RocketY + 67);        // Left quad        fill(191, 240, 255);        quad(RocketX - 50, RocketY + 67, RocketX - 20, RocketY + 32, RocketX - 20, RocketY + 67, RocketX - 50, RocketY + 102);        // Right quad        fill(228, 191, 255);        quad(RocketX + 20, RocketY + 32, RocketX + 50, RocketY + 67, RocketX + 50, RocketY + 102, RocketX + 20, RocketY + 67);    }    void updatePosition() {        RocketX = RocketX + (RocketXspeed * xdirection);        RocketY = RocketY + (RocketYspeed * ydirection);    }    void speed() {        if (keyPressed) {            if (key == s || key == S) {                RocketXspeed = RocketXspeed + 1.5f;            }        }        if (keyPressed) {            if (key == d || key == D) {                RocketXspeed = RocketXspeed - 1;            }        }    }    void move() {        if (RocketX > width || RocketX < 0) {            xdirection *= -1;        }        if (RocketY > height || RocketY < 0) {            ydirection *= -1;        }    }}',correct
'[3]',correct
'float RocketY;',correct
'triangle(RocketX - 40, RocketY - 38, RocketX - 40, RocketY + 32, RocketX + 40, RocketY - 38)',correct
'triangle(RocketX, RocketY - 73, RocketX, RocketY - 38, RocketX + 40, RocketY - 38);',correct
'{    if (keyPressed) {        if (key == s || key == S) {            RocketXspeed = RocketXspeed + 1.5f;        }    }    if (keyPressed) {        if (key == d || key == D) {            RocketXspeed = RocketXspeed - 1;        }    }}',correct
'fill(0, 10);',correct
'RocketX',correct
'RocketY',correct
'RocketXspeed = RocketXspeed - 1;',correct
'// Rocket',correct
'apollo[i].speed()',correct
'{    if (key == d || key == D) {        RocketXspeed = RocketXspeed - 1;    }}',correct
'{    noStroke();    for (int i = 0; i < apollo.length; i++) {        apollo[i].display();        apollo[i].move();        apollo[i].updatePosition();        apollo[i].speed();    }    // Background    star1.display();}',correct
'ydirection = 1',correct
'ellipse(random(width), random(height), 2, 2);',correct
'RocketX + 20',correct
'i < apollo.length',correct
'noStroke();',correct
'RocketX - 40',correct
'apollo[i]',correct
'apollo[i] = new Rocket(random(0, width - 100), random(0, height - 100));',correct
'// Rocket movement// Speed of the Rocketfloat RocketXspeed = 2.8f;',correct
'void display() {    fill(0, 10);    rect(0, 0, width, height);    fill(255);    noStroke();    ellipse(random(width), random(height), 2, 2);}',correct
'xdirection = 1',correct
'RocketY + 32',correct
'triangle(RocketX + 40, RocketY - 38, RocketX + 40, RocketY + 32, RocketX - 40, RocketY + 32);',correct
'D',correct
'void speed() {    if (keyPressed) {        if (key == s || key == S) {            RocketXspeed = RocketXspeed + 1.5f;        }    }    if (keyPressed) {        if (key == d || key == D) {            RocketXspeed = RocketXspeed - 1;        }    }}',correct
'// Left rooffill(255, 191, 191);',correct
'triangle(RocketX, RocketY - 73, RocketX, RocketY - 38, RocketX - 40, RocketY - 38)',correct
'new Star()',correct
'key == d',correct
'RocketX + (RocketXspeed * xdirection)',correct
'RocketX < 0',correct
'RocketX + 50',correct
'RocketXspeed = 2.8f',correct
'triangle(RocketX - 40, RocketY - 38, RocketX - 40, RocketY + 32, RocketX + 40, RocketY - 38);',correct
'S',correct
'if (keyPressed) {    if (key == d || key == D) {        RocketXspeed = RocketXspeed - 1;    }}',DecentralizedEventHandlingRule
'Star',correct
'quad(RocketX + 20, RocketY + 32, RocketX + 50, RocketY + 67, RocketX + 50, RocketY + 102, RocketX + 20, RocketY + 67)',correct
'key == s',correct
'rect(0, 0, width, height)',correct
'Star star1;',correct
'RocketY - 38',correct
'RocketX = RocketX + (RocketXspeed * xdirection)',correct
'd',correct
'random(height)',correct
'void move() {    if (RocketX > width || RocketX < 0) {        xdirection *= -1;    }    if (RocketY > height || RocketY < 0) {        ydirection *= -1;    }}',correct
'fill(191, 240, 255)',correct
'fill(191, 200, 255)',correct
'display',correct
'if (key == d || key == D) {    RocketXspeed = RocketXspeed - 1;}',DecentralizedEventHandlingRule
'draw',correct
'void setup() {    for (int i = 0; i < apollo.length; i++) {        apollo[i] = new Rocket(random(0, width - 100), random(0, height - 100));    }    star1 = new Star();}',correct
'// Right quadfill(228, 191, 255);',correct
'apollo[i].move();',correct
'RocketX + 40',correct
'fill(0, 10)',correct
'// Rocket movement',correct
's',correct
'ydirection *= -1;',correct
'quad(RocketX + 20, RocketY + 32, RocketX + 50, RocketY + 67, RocketX + 50, RocketY + 102, RocketX + 20, RocketY + 67);',correct
'ydirection *= -1',correct
'void draw() {    noStroke();    for (int i = 0; i < apollo.length; i++) {        apollo[i].display();        apollo[i].move();        apollo[i].updatePosition();        apollo[i].speed();    }    // Background    star1.display();}',correct
'// Left quadfill(191, 240, 255);',correct
'width - 100',correct
'RocketYspeed = RocketXspeed',correct
'2.8f',correct
'RocketXspeed = 2.8f;',correct
'noStroke()',correct
'triangle(RocketX, RocketY - 73, RocketX, RocketY - 38, RocketX + 40, RocketY - 38)',correct
'{    apollo[i] = new Rocket(random(0, width - 100), random(0, height - 100));}',correct
'RocketY = RocketY + (RocketYspeed * ydirection);',correct
'ellipse(random(width), random(height), 2, 2)',correct
'RocketX = RocketX + (RocketXspeed * xdirection);',correct
'{    RocketXspeed = RocketXspeed + 1.5f;}',correct
'i++',correct
'{    apollo[i].display();    apollo[i].move();    apollo[i].updatePosition();    apollo[i].speed();}',correct
'key == d || key == D',correct
'RocketYspeed = 2.2f',correct
'RocketX > width',correct
'new Rocket(random(0, width - 100), random(0, height - 100))',correct
'fill(255);',correct
'fill(255, 224, 191)',correct
'for (int i = 0; i < apollo.length; i++) {    apollo[i] = new Rocket(random(0, width - 100), random(0, height - 100));}',correct
'apollo[i].display()',correct
'// Speed of the Rocketfloat RocketYspeed = 2.2f;',correct
'fill(255, 191, 232)',correct
'apollo.length',correct
'star1',correct
'for (int i = 0; i < apollo.length; i++) {    apollo[i].display();    apollo[i].move();    apollo[i].updatePosition();    apollo[i].speed();}',correct
'fill(255, 191, 191)',correct
'key == s || key == S',correct
'fill(228, 191, 255)',correct
'RocketY > height',correct
'{    fill(0, 10);    rect(0, 0, width, height);    fill(255);    noStroke();    ellipse(random(width), random(height), 2, 2);}',correct
'apollo[i].display();',correct
'triangle(RocketX, RocketY - 73, RocketX, RocketY - 38, RocketX - 40, RocketY - 38);',correct
'Rocket[]',correct
'quad(RocketX - 50, RocketY + 67, RocketX - 20, RocketY + 32, RocketX - 20, RocketY + 67, RocketX - 50, RocketY + 102)',correct
'RocketY = tempY;',correct
'void',correct
'-1',correct
'2.2f',correct
'{    xdirection *= -1;}',correct
'triangle(RocketX - 20, RocketY + 32, RocketX + 20, RocketY + 32, RocketX - 20, RocketY + 67)',correct
'key == D',correct
'apollo[i] = new Rocket(random(0, width - 100), random(0, height - 100))',correct
'RocketX > width || RocketX < 0',correct
'{    ydirection *= -1;}',correct
'RocketXspeed = RocketXspeed + 1.5f',correct
'RocketX = tempX',correct
'1.5f',correct
'key == S',correct
'height - 100',correct
'RocketX = tempX;',correct
'apollo[i].move()',correct
'Star() {}',UncommentedEmptyConstructor
'RocketY + 102',correct
'if (RocketY > height || RocketY < 0) {    ydirection *= -1;}',correct
'if (RocketX > width || RocketX < 0) {    xdirection *= -1;}',correct
'star1.display()',correct
'RocketY + 67',correct
'{    RocketXspeed = RocketXspeed - 1;}',correct
'triangle(RocketX - 20, RocketY + 32, RocketX + 20, RocketY + 32, RocketX - 20, RocketY + 67);',correct
'// Katrine Krol',correct
'RocketYspeed = RocketXspeed;',correct
'float ydirection = 1;',correct
'// Bottom triangle leftfill(255, 191, 232);',correct
'// Rocket// Katrine KrolRocket[] apollo = new Rocket[3];',correct
'fill(255)',correct
'Rocket',correct
'apollo[i].speed();',correct
'apollo[i].updatePosition()',correct
'xdirection *= -1;',correct
'Processing',correct
'random(0, width - 100)',correct
'random(0, height - 100)',correct
'float tempY',correct
'if (keyPressed) {    if (key == s || key == S) {        RocketXspeed = RocketXspeed + 1.5f;    }}',DecentralizedEventHandlingRule
'float tempX',correct
'apollo = new Rocket[3]',correct
'RocketY = RocketY + (RocketYspeed * ydirection)',correct
'// Right rooffill(191, 200, 255);',correct
'RocketY + (RocketYspeed * ydirection)',correct
'// Backgroundstar1.display();',correct
'new Rocket[3]',correct
'// Left bodyfill(191, 255, 243);',correct
'// Bottom triangle rightfill(255, 224, 191);',correct
'if (key == s || key == S) {    RocketXspeed = RocketXspeed + 1.5f;}',DecentralizedEventHandlingRule
'xdirection *= -1',correct
'RocketXspeed = RocketXspeed + 1.5f;',correct
'fill(191, 255, 243)',correct
'RocketX - 20',correct
'int i = 0',correct
'float xdirection = 1;',correct
'class Star {    Star() {    }    void display() {        fill(0, 10);        rect(0, 0, width, height);        fill(255);        noStroke();        ellipse(random(width), random(height), 2, 2);    }}',StatelessClassRule
'star1 = new Star();',correct
'RocketY - 73',correct
'star1 = new Star()',correct
'{    if (key == s || key == S) {        RocketXspeed = RocketXspeed + 1.5f;    }}',correct
'RocketY < 0',correct
'rect(0, 0, width, height);',PixelHardcodeIgnoranceRule
'RocketY = tempY',correct
'(int) random(255)',correct
'if (mtOne == mouthType.sad) {// WIP}',correct
'{    // first check if file exist    if (loadStrings(filename) != null) {        // append string from the existing file and new highscore        String[] txtFile = loadStrings(filename);        String[] txtOut = new String[txtFile.length + txtNew.length - 1];        for (int i = 0; i < txtFile.length - 1; i++) {            txtOut[i] = txtFile[i];        }        for (int i = 0; i < txtNew.length; i++) {            txtOut[txtFile.length + i - 1] = txtNew[i];        }        saveStrings(filename, txtOut);    } else {        // create new file        saveStrings(filename, txtNew);    }}',correct
'onGround = false',correct
'String',correct
'mtOne == mouthType.smile',correct
'{    items[i].moveFree();}',correct
'new sombrero[10]',correct
'{    speedX = -speedX;}',correct
'items[i].setAttached(points * 30)',correct
'items[i].x + 30 >= player.x',correct
'moveFree',correct
'"Has ganado!"',correct
'stroke(0);',correct
'if (player.y < height - 70) {    // gravity    speedFall++;    countdownLanding -= 3;    player.y += speedFall;    player.drawBody(mouthType.smile);} else {    // landing    speedFall = 0;    player.y = height - 60;    handleLanding();}',DecentralizedEventHandlingRule
'stroke(0)',correct
'stroke(225, 255, 127)',correct
'ellipse(x, y, 110, 40);',correct
'fill(0, 0, 0)',correct
'void resetRandom() {    // change colour    R = (int) random(255);    G = (int) random(255);    B = (int) random(255);    // change angle    speedX = (int) random(2, 4);    speedY = (int) random(-3, 3);    while (speedY == 0) {        speedY = (int) random(-3, 3);    }    if (x > width / 2) {        speedX = -speedX;    }}',correct
'collectSound.rewind()',correct
'txtOut[txtFile.length + i - 1]',correct
'day()',correct
'items[i].x - 30',correct
'items[i].drawSombrero()',correct
'txtFile = loadStrings(filename)',correct
'// TexttextSize(35);',correct
'nf(month(), 2)',correct
'height - 60',correct
'{    String timestamp = year() + nf(month(), 2) + nf(day(), 2) + "-" + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);    String[] output = new String[1];    output[0] = timestamp + "  |  " + points + "  |  " + time + "\n";    appendTextToFile("highscores.txt", output);    uploaded = true;}',correct
'txtFile.length',correct
'points = 0',correct
'nearMouseY = mouseY;',correct
'int points = 0;',correct
'collectSound.rewind();',correct
'width - 50',correct
'appendTextToFile("highscores.txt", output)',correct
'txtOut[txtFile.length + i - 1] = txtNew[i];',correct
'{    x = newX;    y = newY;}',correct
'collectSound = minim.loadFile("Ole_sound.mp3", 2048)',correct
'second()',correct
'-speedX',correct
'textAlign(CENTER)',correct
'stroke(204, 133, 85)',correct
'points + " / "',correct
'"highscores.txt"',correct
'if (uploaded == false) {    String timestamp = year() + nf(month(), 2) + nf(day(), 2) + "-" + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);    String[] output = new String[1];    output[0] = timestamp + "  |  " + points + "  |  " + time + "\n";    appendTextToFile("highscores.txt", output);    uploaded = true;}',correct
'{    stroke(0);    fill(100, 0, 0);    strokeWeight(5);    ellipse(x, y + 5, 20, 20);    strokeWeight(8);}',correct
'resetRandom(true)',correct
'txtNew[i]',correct
'output[0] = timestamp + "  |  " + points + "  |  " + time + "\n"',correct
'random(height)',correct
'drawSmile()',correct
'arc(x + 60, y - 55, 50, 60, 2.45f, 3.0f);',correct
'random(1, 3)',correct
'countdownLanding = 255;',correct
'int offset',correct
'new avocado(width / 2, height / 2)',correct
'mouthType',correct
'minim.loadFile("Ole_sound.mp3", 2048)',correct
'ellipse(x, y + 5, 20, 20)',correct
'x',correct
'y',correct
'String filename',correct
'mouthType mtOne',correct
'!items[i].getAttached() && items[i].x - 30 <= player.x && items[i].x + 30 >= player.x',correct
'arc(x, y - 10, 30, 40, QUARTER_PI, 3 * QUARTER_PI);',correct
'arc(x, y - 10, 30, 40, QUARTER_PI, 3 * QUARTER_PI)',correct
'drawSmile();',correct
'txtFile[i]',correct
'drawOpen()',correct
'items[i].y + 120 >= player.y',correct
'void updateSombrero() {    for (int i = 0; i < items.length; i++) {        if (checkAttachNeeded(i)) {            items[i].setAttached(points * 30);            collectSound.rewind();            collectSound.play();            points++;        }        // calculate new position        items[i].drawSombrero();        if (items[i].getAttached()) {            items[i].followPlayer(player.x, player.y);        } else {            items[i].moveFree();        }    }}',correct
'void setup() {    // AUDIO    minim = new Minim(this);    bgMusic = minim.loadFile("Mexican_music.mp3", 2048);    bgMusic.loop();    bgMusic.setGain(-5.0f);    collectSound = minim.loadFile("Ole_sound.mp3", 2048);    // VISUAL    player = new avocado(width / 2, height / 2);    for (int i = 0; i < items.length; i++) {        items[i] = new sombrero((int) random(width), (int) random(height));    }}',correct
'{    nearMouseX = mouseX;    nearMouseY = mouseY;}',correct
'// VISUALplayer = new avocado(width / 2, height / 2);',correct
'ellipse(x, y, 60, 60)',correct
'text(time, width - 50, 60)',correct
'{    items[i].setAttached(points * 30);    collectSound.rewind();    collectSound.play();    points++;}',correct
'year() + nf(month(), 2) + nf(day(), 2) + "-" + nf(hour(), 2) + nf(minute(), 2)',correct
'new String[txtFile.length + txtNew.length - 1]',correct
'String timestamp = year() + nf(month(), 2) + nf(day(), 2) + "-" + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2)',correct
'2.45f',correct
'items[i] = new sombrero((int) random(width), (int) random(height));',correct
'arc(x, y - 10, 44, 20, 0, PI);',correct
'player.x',correct
'x - 60',correct
'boolean yPositive',correct
'output[0] = timestamp + "  |  " + points + "  |  " + time + "\n";',correct
'arc(x + 60, y - 55, 50, 60, 2.45f, 3.0f)',correct
'player.y',correct
'this.y -= (this.y - y) / speedDiv',correct
'// upper bodyellipse(x, y, 100, 120);',correct
'y += speedY',correct
'(int) random(-3, -1)',correct
'bgMusic',correct
'random(2, 4)',correct
'// AUDIOminim = new Minim(this);',correct
'if (mtOne == mouthType.smile) {    drawSmile();} else if (mtOne == mouthType.open) {    drawOpen();} else if (mtOne == mouthType.sad) {// WIP}',correct
'bgMusic.loop()',correct
'fill(225, 255, 127)',correct
'txtFile.length + i',correct
'minim',correct
'handleLanding();',correct
'offsetY = offset',correct
'mouthType.smile',correct
'if (x > width / 2) {    speedX = -speedX;}',correct
'if (mtOne == mouthType.open) {    drawOpen();} else if (mtOne == mouthType.sad) {// WIP}',correct
'{    x = newX;    y = newY - 80 - offsetY;}',correct
'stroke(50, 75, 25);',correct
'int nearMouseY;',correct
'Processing',correct
'if (y > height + 50) {    resetRandom(false);}',correct
'items[i]',correct
'player.y = height - 60;',correct
'x = newX;',correct
'void mousePressed() {    nearMouseX = mouseX;    nearMouseY = mouseY;}',correct
'height + 50',correct
'// change colourR = (int) random(255);',correct
'year() + nf(month(), 2)',correct
'txtFile.length + i - 1',correct
'nf(hour(), 2)',correct
'{    return !items[i].getAttached() && items[i].x - 30 <= player.x && items[i].x + 30 >= player.x && items[i].y + 50 <= player.y && items[i].y + 120 >= player.y;}',correct
'{    txtOut[i] = txtFile[i];}',correct
'background(countdownLanding, 0, 0);',correct
'void appendTextToFile(String filename, String[] txtNew) {    // first check if file exist    if (loadStrings(filename) != null) {        // append string from the existing file and new highscore        String[] txtFile = loadStrings(filename);        String[] txtOut = new String[txtFile.length + txtNew.length - 1];        for (int i = 0; i < txtFile.length - 1; i++) {            txtOut[i] = txtFile[i];        }        for (int i = 0; i < txtNew.length; i++) {            txtOut[txtFile.length + i - 1] = txtNew[i];        }        saveStrings(filename, txtOut);    } else {        // create new file        saveStrings(filename, txtNew);    }}',correct
'false',correct
'int nearMouseX;',correct
'mouthType.open',correct
'{    countdownLanding -= 3;    player.drawBody(mouthType.open);}',correct
'textAlign(RIGHT)',correct
'G = (int) random(255)',correct
'setup',correct
'stroke(225, 255, 127);',correct
'y > height + 50',correct
'enum mouthType {    smile, open, sad}',correct
'resetRandom(false);',correct
'while (speedY == 0) {    speedY = (int) random(-3, 3);}',correct
'int offsetY;',correct
'i = 0',correct
'x = newX',correct
'text(points + " / " + items.length, 40, 60);',PixelHardcodeIgnoranceRule
'{    booAttached = true;    offsetY = offset;}',correct
'avocado player;',correct
'ellipse(x, y - 50, 70, 100);',correct
'i < items.length',correct
'width + 50',correct
'{    // new position    player.updatePos(nearMouseX, nearMouseY);    onGround = false;    speedFall = 0;    chooseMouth();}',DecentralizedEventHandlingRule
'if (x > width + 50) {    x -= width + 100;    resetRandom();}',correct
'countdownLanding -= 3',correct
'txtFile.length + txtNew.length',correct
'collectSound = minim.loadFile("Ole_sound.mp3", 2048);',correct
'countdownLanding > 0',correct
'speedY = (int) random(1, 3)',correct
'!items[i].getAttached() && items[i].x - 30 <= player.x && items[i].x + 30 >= player.x && items[i].y + 50 <= player.y',correct
'ellipse(x, y - 50, 70, 100)',correct
'void mouseDragged() {    nearMouseX = mouseX;    nearMouseY = mouseY;}',correct
'items[i] = new sombrero((int) random(width), (int) random(height))',correct
'x -= width + 100',correct
'int B = (int) random(255);',correct
'i < txtNew.length',correct
'String[] txtNew',correct
'onGround = false;',correct
'newY - 80',correct
'int speedDiv = 20;',correct
'// gravityspeedFall++;',correct
'ellipse(x, y + 5, 20, 20);',correct
'strokeWeight(5);',correct
'(int) random(-3, 3)',correct
'stroke(R, G, B)',correct
'items[i].x - 30 <= player.x',correct
'noStroke();',correct
'"-"',correct
'items[i].setAttached(points * 30);',correct
'{    x += width + 100;    resetRandom();}',correct
'txtNew.length',correct
'stroke(50, 75, 25)',correct
'nf(day(), 2)',correct
'return booAttached;',correct
'// connection lower/uppernoFill();',correct
'txtOut[i] = txtFile[i]',correct
'void drawSombrero() {    strokeWeight(4);    stroke(150, 110, 60);    fill(245, 210, 130);    ellipse(x, y, 110, 40);    arc(x, y, 50, 70, PI, 2 * PI);    strokeWeight(8);    stroke(R, G, B);    arc(x, y - 10, 44, 20, 0, PI);    stroke(0);}',correct
'fill(225, 255, 127);',correct
'items[i].x',correct
'items[i].y',correct
'checkAttachNeeded(i)',correct
'saveStrings(filename, txtOut)',correct
'ellipse(x - 20, y - 3, 9, 8);',correct
'{    speedY = (int) random(-3, 3);}',correct
'{    // lower body    strokeWeight(8);    fill(225, 255, 127);    stroke(50, 75, 25);    ellipse(x, y - 50, 70, 100);    // upper body    ellipse(x, y, 100, 120);    // connection lower/upper    noFill();    arc(x + 60, y - 55, 50, 60, 2.45f, 3.0f);    arc(x - 60, y - 55, 50, 60, 0.15f, 0.7f);    fill(225, 255, 127);    stroke(225, 255, 127);    ellipse(x, y - 20, 65, 120);    // pit    fill(204, 133, 85);    stroke(204, 133, 85);    ellipse(x, y, 60, 60);    // face    fill(0, 0, 0);    noStroke();    ellipse(x - 20, y - 3, 9, 8);    ellipse(x + 20, y - 3, 9, 8);    stroke(0);    strokeWeight(8);    if (mtOne == mouthType.smile) {        drawSmile();    } else if (mtOne == mouthType.open) {        drawOpen();    } else if (mtOne == mouthType.sad) {    // WIP    }}',LongMethodRule
'bgMusic.loop();',correct
'text(points + " / " + items.length, 40, 60)',correct
'saveStrings(filename, txtNew)',correct
'String timestamp = year() + nf(month(), 2) + nf(day(), 2) + "-" + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);',correct
'speedX = -speedX',correct
'txtOut[i]',correct
'speedDiv = 20',correct
'stroke(R, G, B);',correct
'player.drawBody(mouthType.smile);',correct
'draw',LongMethodRule
'newY - 80 - offsetY',correct
'this.x -= (this.x - x) / speedDiv',correct
'int y',correct
'updateSombrero',correct
'text("Has ganado!", width / 2, 60)',correct
'{    // win    textAlign(CENTER);    text("Has ganado!", width / 2, 60);    if (uploaded == false) {        String timestamp = year() + nf(month(), 2) + nf(day(), 2) + "-" + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);        String[] output = new String[1];        output[0] = timestamp + "  |  " + points + "  |  " + time + "\n";        appendTextToFile("highscores.txt", output);        uploaded = true;    }}',correct
'int x',correct
'items[i].x + 30',correct
'mtOne == mouthType.open',correct
'bgMusic = minim.loadFile("Mexican_music.mp3", 2048);',correct
'{    speedY = (int) random(-3, -1);}',correct
'B = (int) random(255)',correct
'nearMouseY',correct
'int i',correct
'nearMouseX',correct
'void chooseMouth() {    if (countdownLanding > 0) {        countdownLanding -= 3;        player.drawBody(mouthType.open);    } else {        player.drawBody(mouthType.smile);    }}',correct
'String[]',correct
'fill(100, 0, 0);',correct
'mousePressed',DecentralizedEventHandlingRule
'smile',correct
'ellipse(x - 20, y - 3, 9, 8)',correct
'arc(x - 60, y - 55, 50, 60, 0.15f, 0.7f)',correct
'mtOne == mouthType.sad',correct
'nf(second(), 2)',correct
'booAttached = false',correct
'uploaded = true',correct
'handleLanding()',correct
'offsetY',correct
'x += speedX;',correct
'stroke(150, 110, 60)',correct
'strokeWeight(3)',correct
'nearMouseY = mouseY',correct
'0.7f',correct
'minim.loadFile("Mexican_music.mp3", 2048)',correct
'handleLanding',correct
'items[i].moveFree()',correct
'avocado',correct
'void',correct
'// new positionplayer.updatePos(nearMouseX, nearMouseY);',correct
'-1',correct
'AudioPlayer collectSound;',correct
'-3',correct
'boolean getAttached() {    return booAttached;}',correct
'(int) random(height)',correct
'{    x = newX;    y = newY;    if (newX > width / 2) {        speedX = -speedX;    }}',correct
'{    player.drawBody(mouthType.smile);}',correct
'resetRandom(false)',correct
'items[i].followPlayer(player.x, player.y);',correct
'items[i].followPlayer(player.x, player.y)',correct
'sombrero',correct
'null',correct
'timestamp = year() + nf(month(), 2) + nf(day(), 2) + "-" + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2)',correct
'true',correct
'noFill();',correct
'items[i].y + 120',correct
'year() + nf(month(), 2) + nf(day(), 2)',correct
'minute()',correct
'{    this.x -= (this.x - x) / speedDiv;    this.y -= (this.y - y) / speedDiv;}',correct
'timestamp + "  |  " + points + "  |  " + time + "\n"',correct
'(int) random(1, 3)',correct
'resetRandom',correct
'int y;',correct
'3.0f',correct
'year()',correct
'arc(x, y, 50, 70, PI, 2 * PI)',correct
'items[i].getAttached()',correct
'{    items[i].followPlayer(player.x, player.y);}',correct
'player.y += speedFall',correct
'void drawSmile() {    strokeWeight(3);    noFill();    arc(x, y - 10, 30, 40, QUARTER_PI, 3 * QUARTER_PI);    strokeWeight(8);}',correct
'(int) random(2, 4)',correct
'speedFall = 0',correct
'{    resetRandom(false);}',correct
'strokeWeight(5)',correct
'{    // change colour    R = (int) random(255);    G = (int) random(255);    B = (int) random(255);    // change angle    speedX = (int) random(2, 4);    speedY = (int) random(-3, 3);    while (speedY == 0) {        speedY = (int) random(-3, 3);    }    if (x > width / 2) {        speedX = -speedX;    }}',correct
'return !items[i].getAttached() && items[i].x - 30 <= player.x && items[i].x + 30 >= player.x && items[i].y + 50 <= player.y && items[i].y + 120 >= player.y;',correct
'bgMusic = minim.loadFile("Mexican_music.mp3", 2048)',correct
'time = millis()',correct
'countdownLanding = 0',correct
'height - 70',correct
'text(time, width - 50, 60);',PixelHardcodeIgnoranceRule
'booAttached = true',correct
'speedFall++',correct
'ellipse(x, y - 20, 65, 120)',correct
'int x;',correct
'arc(x, y - 10, 44, 20, 0, PI)',correct
'mouthType.sad',correct
'appendTextToFile',correct
'strokeWeight(8);',correct
'y < -50',correct
'strokeWeight(4)',correct
'// lower bodystrokeWeight(8);',correct
'random(-3, -1)',correct
'y = newY',correct
'random(width)',correct
'txtFile.length + txtNew.length - 1',correct
'ellipse(x, y - 20, 65, 120);',correct
'AudioPlayer',correct
'fill(100, 0, 0)',correct
'player.y = height - 60',correct
'y = newY - 80 - offsetY;',correct
'y - 20',correct
'player.drawBody(mouthType.open)',correct
'ellipse(x, y, 100, 120)',correct
'x < -50',correct
'G = (int) random(255);',correct
'player.y < height - 70',correct
'i < txtFile.length - 1',correct
'speedY = (int) random(-3, -1)',correct
'hour()',correct
'points * 30',correct
'{    // create new file    saveStrings(filename, txtNew);}',correct
'month()',correct
'{    countdownLanding = 255;    // checking if youre on the ground prevents the collectSound from resetting while it is on the ground    onGround = true;}',SimplifyBooleanExpressions
'txtOut = new String[txtFile.length + txtNew.length - 1]',correct
'int speedY = (int) random(-3, 3);',correct
'y += speedY;',correct
'y = newY - 80 - offsetY',correct
'updateSombrero();',correct
'arc(x, y, 50, 70, PI, 2 * PI);',correct
'collectSound',correct
'points++',correct
'chooseMouth()',correct
'stroke(150, 110, 60);',correct
'x += speedX',correct
'collectSound.play();',correct
'arc(x - 60, y - 55, 50, 60, 0.15f, 0.7f);',correct
'points++;',DrawingStateChangeRule
'if (items[i].getAttached()) {    items[i].followPlayer(player.x, player.y);} else {    items[i].moveFree();}',correct
'{    // AUDIO    minim = new Minim(this);    bgMusic = minim.loadFile("Mexican_music.mp3", 2048);    bgMusic.loop();    bgMusic.setGain(-5.0f);    collectSound = minim.loadFile("Ole_sound.mp3", 2048);    // VISUAL    player = new avocado(width / 2, height / 2);    for (int i = 0; i < items.length; i++) {        items[i] = new sombrero((int) random(width), (int) random(height));    }}',correct
'speedX = -speedX;',correct
'onGround == false',correct
'time = millis();',DrawingStateChangeRule
'width + 100',correct
'y - 3',correct
'output = new String[1]',correct
'x + 20',correct
'nf(minute(), 2)',correct
'y - 10',correct
'y = newY;',correct
'strokeWeight(8)',correct
'booAttached = true;',correct
'year() + nf(month(), 2) + nf(day(), 2) + "-" + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2)',correct
'nearMouseX = mouseX;',correct
'int newX',correct
'millis()',correct
'int newY',correct
'random(255)',correct
'ellipse(x + 20, y - 3, 9, 8)',correct
'open',correct
'noStroke()',correct
'{    time = millis();}',correct
'for (int i = 0; i < txtNew.length; i++) {    txtOut[txtFile.length + i - 1] = txtNew[i];}',correct
'year() + nf(month(), 2) + nf(day(), 2) + "-" + nf(hour(), 2)',correct
'output[0]',correct
'String[] output = new String[1];',correct
'{    strokeWeight(4);    stroke(150, 110, 60);    fill(245, 210, 130);    ellipse(x, y, 110, 40);    arc(x, y, 50, 70, PI, 2 * PI);    strokeWeight(8);    stroke(R, G, B);    arc(x, y - 10, 44, 20, 0, PI);    stroke(0);}',correct
'minim = new Minim(this)',correct
'void moveFree() {    x += speedX;    y += speedY;    // change position and angle when hitting the wall    if (x < -50) {        x += width + 100;        resetRandom();    }    if (x > width + 50) {        x -= width + 100;        resetRandom();    }    if (y < -50) {        resetRandom(true);    }    if (y > height + 50) {        resetRandom(false);    }}',correct
'uploaded = true;',DrawingStateChangeRule
'items[i].moveFree();',correct
'this.x -= (this.x - x) / speedDiv;',correct
'5.0f',correct
'text("Has ganado!", width / 2, 60);',PixelHardcodeIgnoranceRule
'new String[1]',correct
'" / "',correct
'{    // landing    speedFall = 0;    player.y = height - 60;    handleLanding();}',correct
'void drawBody(mouthType mtOne) {    // lower body    strokeWeight(8);    fill(225, 255, 127);    stroke(50, 75, 25);    ellipse(x, y - 50, 70, 100);    // upper body    ellipse(x, y, 100, 120);    // connection lower/upper    noFill();    arc(x + 60, y - 55, 50, 60, 2.45f, 3.0f);    arc(x - 60, y - 55, 50, 60, 0.15f, 0.7f);    fill(225, 255, 127);    stroke(225, 255, 127);    ellipse(x, y - 20, 65, 120);    // pit    fill(204, 133, 85);    stroke(204, 133, 85);    ellipse(x, y, 60, 60);    // face    fill(0, 0, 0);    noStroke();    ellipse(x - 20, y - 3, 9, 8);    ellipse(x + 20, y - 3, 9, 8);    stroke(0);    strokeWeight(8);    if (mtOne == mouthType.smile) {        drawSmile();    } else if (mtOne == mouthType.open) {        drawOpen();    } else if (mtOne == mouthType.sad) {    // WIP    }}',correct
'newX > width / 2',correct
'random(-3, 3)',correct
'speedY = (int) random(-3, 3)',correct
'this',correct
'points + " / " + items.length',correct
'String[] output = new String[1]',correct
'strokeWeight(3);',correct
'String[] txtFile = loadStrings(filename)',correct
'-5.0f',correct
'timestamp + "  |  " + points + "  |  " + time',correct
'height / 2',correct
'{    x += speedX;    y += speedY;    // change position and angle when hitting the wall    if (x < -50) {        x += width + 100;        resetRandom();    }    if (x > width + 50) {        x -= width + 100;        resetRandom();    }    if (y < -50) {        resetRandom(true);    }    if (y > height + 50) {        resetRandom(false);    }}',correct
'Minim',correct
'fill(245, 210, 130);',correct
'sombrero[]',correct
'speedY = (int) random(1, 3);',correct
'0.15f',correct
'int speedFall = 0;',correct
'items[i].y + 50 <= player.y',correct
'{    x -= width + 100;    resetRandom();}',correct
'textSize(35)',correct
'{    items[i] = new sombrero((int) random(width), (int) random(height));}',correct
'{// WIP}',EmptyIfStmt
'{    txtOut[txtFile.length + i - 1] = txtNew[i];}',correct
'// change position and angle when hitting the wallif (x < -50) {    x += width + 100;    resetRandom();}',correct
'saveStrings(filename, txtOut);',correct
'countdownLanding -= 3;',DrawingStateChangeRule
'{    return booAttached;}',correct
'// VISUAL',correct
'if (newX > width / 2) {    speedX = -speedX;}',correct
'B = (int) random(255);',correct
'boolean checkAttachNeeded(int i) {    return !items[i].getAttached() && items[i].x - 30 <= player.x && items[i].x + 30 >= player.x && items[i].y + 50 <= player.y && items[i].y + 120 >= player.y;}',ShortVariable
'noFill()',correct
'y - 50',correct
'y - 55',correct
'[txtFile.length + txtNew.length - 1]',correct
'strokeWeight(4);',correct
'items[i].y + 50',correct
'int i = 0',correct
'this.y',correct
'resetRandom(true);',correct
'this.x',correct
'// change anglespeedX = (int) random(2, 4);',correct
'class sombrero {    int x;    int y;    int offsetY;    int R = (int) random(255);    int G = (int) random(255);    int B = (int) random(255);    int speedX = (int) random(2, 4);    int speedY = (int) random(-3, 3);    boolean booAttached = false;    sombrero(int newX, int newY) {        x = newX;        y = newY;        if (newX > width / 2) {            speedX = -speedX;        }    }    void drawSombrero() {        strokeWeight(4);        stroke(150, 110, 60);        fill(245, 210, 130);        ellipse(x, y, 110, 40);        arc(x, y, 50, 70, PI, 2 * PI);        strokeWeight(8);        stroke(R, G, B);        arc(x, y - 10, 44, 20, 0, PI);        stroke(0);    }    void setAttached(int offset) {        booAttached = true;        offsetY = offset;    }    boolean getAttached() {        return booAttached;    }    void moveFree() {        x += speedX;        y += speedY;        // change position and angle when hitting the wall        if (x < -50) {            x += width + 100;            resetRandom();        }        if (x > width + 50) {            x -= width + 100;            resetRandom();        }        if (y < -50) {            resetRandom(true);        }        if (y > height + 50) {            resetRandom(false);        }    }    void followPlayer(int newX, int newY) {        x = newX;        y = newY - 80 - offsetY;    }    void resetRandom() {        // change colour        R = (int) random(255);        G = (int) random(255);        B = (int) random(255);        // change angle        speedX = (int) random(2, 4);        speedY = (int) random(-3, 3);        while (speedY == 0) {            speedY = (int) random(-3, 3);        }        if (x > width / 2) {            speedX = -speedX;        }    }    void resetRandom(boolean yPositive) {        // change colour        R = (int) random(255);        G = (int) random(255);        B = (int) random(255);        // change angle        speedX = (int) random(2, 4);        if (yPositive) {            speedY = (int) random(1, 3);        } else {            speedY = (int) random(-3, -1);        }        while (speedY == 0) {            speedY = (int) random(-3, 3);        }        if (x > width / 2) {            speedX = -speedX;        }    }}',correct
'"Mexican_music.mp3"',correct
'time',correct
'R = (int) random(255)',correct
'(this.y - y) / speedDiv',correct
'if (y < -50) {    resetRandom(true);}',correct
'// <--- EDIT the amount of sombreros here!!!sombrero[] items = new sombrero[10];',correct
'// facefill(0, 0, 0);',correct
'timestamp + "  |  "',correct
'points < items.length',correct
'uploaded = false',correct
'{    if (onGround == false) {        countdownLanding = 255;        // checking if youre on the ground prevents the collectSound from resetting while it is on the ground        onGround = true;    } else if (countdownLanding > 0) {        countdownLanding -= 3;        player.drawBody(mouthType.open);    } else {        player.drawBody(mouthType.smile);    }}',correct
'{    for (int i = 0; i < items.length; i++) {        if (checkAttachNeeded(i)) {            items[i].setAttached(points * 30);            collectSound.rewind();            collectSound.play();            points++;        }        // calculate new position        items[i].drawSombrero();        if (items[i].getAttached()) {            items[i].followPlayer(player.x, player.y);        } else {            items[i].moveFree();        }    }}',correct
'this.y -= (this.y - y) / speedDiv;',correct
'timestamp + "  |  " + points',correct
'appendTextToFile("highscores.txt", output);',correct
'ellipse(x, y, 110, 40)',correct
'x > width / 2',correct
'ellipse(x, y, 60, 60);',correct
'{    if (countdownLanding > 0) {        countdownLanding -= 3;        player.drawBody(mouthType.open);    } else {        player.drawBody(mouthType.smile);    }}',correct
'x - 20',correct
'// If minim is not installed yet --> Sketch -> Import Librairy -> Add Librairy',correct
'// landingspeedFall = 0;',correct
'countdownLanding = 255',correct
'!items[i].getAttached() && items[i].x - 30 <= player.x',correct
'int countdownLanding = 0;',correct
'class avocado {    int x;    int y;    avocado(int newX, int newY) {        x = newX;        y = newY;    }    void drawBody(mouthType mtOne) {        // lower body        strokeWeight(8);        fill(225, 255, 127);        stroke(50, 75, 25);        ellipse(x, y - 50, 70, 100);        // upper body        ellipse(x, y, 100, 120);        // connection lower/upper        noFill();        arc(x + 60, y - 55, 50, 60, 2.45f, 3.0f);        arc(x - 60, y - 55, 50, 60, 0.15f, 0.7f);        fill(225, 255, 127);        stroke(225, 255, 127);        ellipse(x, y - 20, 65, 120);        // pit        fill(204, 133, 85);        stroke(204, 133, 85);        ellipse(x, y, 60, 60);        // face        fill(0, 0, 0);        noStroke();        ellipse(x - 20, y - 3, 9, 8);        ellipse(x + 20, y - 3, 9, 8);        stroke(0);        strokeWeight(8);        if (mtOne == mouthType.smile) {            drawSmile();        } else if (mtOne == mouthType.open) {            drawOpen();        } else if (mtOne == mouthType.sad) {        // WIP        }    }    void drawSmile() {        strokeWeight(3);        noFill();        arc(x, y - 10, 30, 40, QUARTER_PI, 3 * QUARTER_PI);        strokeWeight(8);    }    void drawOpen() {        stroke(0);        fill(100, 0, 0);        strokeWeight(5);        ellipse(x, y + 5, 20, 20);        strokeWeight(8);    }    void updatePos(int x, int y) {        this.x -= (this.x - x) / speedDiv;        this.y -= (this.y - y) / speedDiv;    }}',correct
'// checking if youre on the ground prevents the collectSound from resetting while it is on the groundboolean onGround = false;',correct
'stroke(204, 133, 85);',correct
'{    strokeWeight(3);    noFill();    arc(x, y - 10, 30, 40, QUARTER_PI, 3 * QUARTER_PI);    strokeWeight(8);}',correct
'!items[i].getAttached()',correct
'void draw() {    background(countdownLanding, 0, 0);    // Text    textSize(35);    textAlign(LEFT);    text(points + " / " + items.length, 40, 60);    if (points < items.length) {        time = millis();    } else {        // win        textAlign(CENTER);        text("Has ganado!", width / 2, 60);        if (uploaded == false) {            String timestamp = year() + nf(month(), 2) + nf(day(), 2) + "-" + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);            String[] output = new String[1];            output[0] = timestamp + "  |  " + points + "  |  " + time + "\n";            appendTextToFile("highscores.txt", output);            uploaded = true;        }    }    textAlign(RIGHT);    text(time, width - 50, 60);    // Movement    if (mousePressed) {        // new position        player.updatePos(nearMouseX, nearMouseY);        onGround = false;        speedFall = 0;        chooseMouth();    } else if (player.y < height - 70) {        // gravity        speedFall++;        countdownLanding -= 3;        player.y += speedFall;        player.drawBody(mouthType.smile);    } else {        // landing        speedFall = 0;        player.y = height - 60;        handleLanding();    }    updateSombrero();}',correct
'{    drawSmile();}',correct
'for (int i = 0; i < txtFile.length - 1; i++) {    txtOut[i] = txtFile[i];}',correct
'if (yPositive) {    speedY = (int) random(1, 3);} else {    speedY = (int) random(-3, -1);}',correct
'x > width + 50',correct
'void setAttached(int offset) {    booAttached = true;    offsetY = offset;}',correct
'(int) random(width)',correct
'"Ole_sound.mp3"',correct
'textAlign(LEFT);',correct
'String[] txtOut = new String[txtFile.length + txtNew.length - 1]',correct
'{    if (checkAttachNeeded(i)) {        items[i].setAttached(points * 30);        collectSound.rewind();        collectSound.play();        points++;    }    // calculate new position    items[i].drawSombrero();    if (items[i].getAttached()) {        items[i].followPlayer(player.x, player.y);    } else {        items[i].moveFree();    }}',correct
'// wintextAlign(CENTER);',correct
'// pitfill(204, 133, 85);',correct
'fill(204, 133, 85)',correct
'collectSound.play()',correct
'ellipse(x + 20, y - 3, 9, 8);',correct
'void resetRandom(boolean yPositive) {    // change colour    R = (int) random(255);    G = (int) random(255);    B = (int) random(255);    // change angle    speedX = (int) random(2, 4);    if (yPositive) {        speedY = (int) random(1, 3);    } else {        speedY = (int) random(-3, -1);    }    while (speedY == 0) {        speedY = (int) random(-3, 3);    }    if (x > width / 2) {        speedX = -speedX;    }}',correct
'if (points < items.length) {    time = millis();} else {    // win    textAlign(CENTER);    text("Has ganado!", width / 2, 60);    if (uploaded == false) {        String timestamp = year() + nf(month(), 2) + nf(day(), 2) + "-" + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);        String[] output = new String[1];        output[0] = timestamp + "  |  " + points + "  |  " + time + "\n";        appendTextToFile("highscores.txt", output);        uploaded = true;    }}',correct
'void followPlayer(int newX, int newY) {    x = newX;    y = newY - 80 - offsetY;}',correct
'{    background(countdownLanding, 0, 0);    // Text    textSize(35);    textAlign(LEFT);    text(points + " / " + items.length, 40, 60);    if (points < items.length) {        time = millis();    } else {        // win        textAlign(CENTER);        text("Has ganado!", width / 2, 60);        if (uploaded == false) {            String timestamp = year() + nf(month(), 2) + nf(day(), 2) + "-" + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);            String[] output = new String[1];            output[0] = timestamp + "  |  " + points + "  |  " + time + "\n";            appendTextToFile("highscores.txt", output);            uploaded = true;        }    }    textAlign(RIGHT);    text(time, width - 50, 60);    // Movement    if (mousePressed) {        // new position        player.updatePos(nearMouseX, nearMouseY);        onGround = false;        speedFall = 0;        chooseMouth();    } else if (player.y < height - 70) {        // gravity        speedFall++;        countdownLanding -= 3;        player.y += speedFall;        player.drawBody(mouthType.smile);    } else {        // landing        speedFall = 0;        player.y = height - 60;        handleLanding();    }    updateSombrero();}',LongMethodRule
'boolean uploaded = false;',correct
'offsetY = offset;',correct
'int R = (int) random(255);',ShortVariable
'onGround = true',correct
'3 * QUARTER_PI',correct
'{    drawOpen();}',correct
'if (checkAttachNeeded(i)) {    items[i].setAttached(points * 30);    collectSound.rewind();    collectSound.play();    points++;}',correct
'speedY == 0',correct
'drawOpen();',correct
'"\n"',correct
'new sombrero((int) random(width), (int) random(height))',correct
'speedFall = 0;',correct
'background(countdownLanding, 0, 0)',correct
'i++',correct
'-50',correct
'// audio contextMinim minim;',correct
'speedY = (int) random(-3, 3);',correct
'{    // change colour    R = (int) random(255);    G = (int) random(255);    B = (int) random(255);    // change angle    speedX = (int) random(2, 4);    if (yPositive) {        speedY = (int) random(1, 3);    } else {        speedY = (int) random(-3, -1);    }    while (speedY == 0) {        speedY = (int) random(-3, 3);    }    if (x > width / 2) {        speedX = -speedX;    }}',correct
'avocado(int newX, int newY) {    x = newX;    y = newY;}',correct
'// Movementif (mousePressed) {    // new position    player.updatePos(nearMouseX, nearMouseY);    onGround = false;    speedFall = 0;    chooseMouth();} else if (player.y < height - 70) {    // gravity    speedFall++;    countdownLanding -= 3;    player.y += speedFall;    player.drawBody(mouthType.smile);} else {    // landing    speedFall = 0;    player.y = height - 60;    handleLanding();}',correct
'txtOut[txtFile.length + i - 1] = txtNew[i]',correct
'{    resetRandom(true);}',correct
'new Minim(this)',correct
'x -= width + 100;',correct
'bgMusic.setGain(-5.0f);',correct
'resetRandom()',correct
'player = new avocado(width / 2, height / 2)',correct
'x += width + 100;',correct
'chooseMouth();',correct
'{    speedY = (int) random(1, 3);}',correct
'x += width + 100',correct
'player.updatePos(nearMouseX, nearMouseY)',correct
'String[] txtOut = new String[txtFile.length + txtNew.length - 1];',correct
'!items[i].getAttached() && items[i].x - 30 <= player.x && items[i].x + 30 >= player.x && items[i].y + 50 <= player.y && items[i].y + 120 >= player.y',correct
'fill(245, 210, 130)',correct
'drawBody',LongMethodRule
'loadStrings(filename) != null',correct
'timestamp + "  |  " + points + "  |  "',correct
'if (countdownLanding > 0) {    countdownLanding -= 3;    player.drawBody(mouthType.open);} else {    player.drawBody(mouthType.smile);}',SimplifyBooleanExpressions
'for (int i = 0; i < items.length; i++) {    items[i] = new sombrero((int) random(width), (int) random(height));}',correct
'sombrero(int newX, int newY) {    x = newX;    y = newY;    if (newX > width / 2) {        speedX = -speedX;    }}',correct
'// checking if youre on the ground prevents the collectSound from resetting while it is on the groundonGround = true;',correct
'// append string from the existing file and new highscoreString[] txtFile = loadStrings(filename);',correct
'textAlign(RIGHT);',correct
'txtFile.length - 1',correct
'bgMusic.setGain(-5.0f)',correct
'textAlign(LEFT)',correct
'nearMouseX = mouseX',correct
'void handleLanding() {    if (onGround == false) {        countdownLanding = 255;        // checking if youre on the ground prevents the collectSound from resetting while it is on the ground        onGround = true;    } else if (countdownLanding > 0) {        countdownLanding -= 3;        player.drawBody(mouthType.open);    } else {        player.drawBody(mouthType.smile);    }}',correct
'int time;',correct
'[10]',correct
'resetRandom();',correct
'// calculate new positionitems[i].drawSombrero();',correct
'boolean booAttached = false;',correct
'void drawOpen() {    stroke(0);    fill(100, 0, 0);    strokeWeight(5);    ellipse(x, y + 5, 20, 20);    strokeWeight(8);}',correct
'sad',correct
'speedY = (int) random(-3, -1);',correct
'(this.x - x) / speedDiv',correct
'player',correct
'y + 5',correct
'"  |  "',correct
'speedX = (int) random(2, 4)',correct
'player.drawBody(mouthType.smile)',correct
'year() + nf(month(), 2) + nf(day(), 2) + "-"',correct
'player.drawBody(mouthType.open);',correct
'[1]',correct
'items = new sombrero[10]',correct
'x + 60',correct
'txtOut[i] = txtFile[i];',correct
'int G = (int) random(255);',correct
'void updatePos(int x, int y) {    this.x -= (this.x - x) / speedDiv;    this.y -= (this.y - y) / speedDiv;}',correct
'width / 2',correct
'{    // gravity    speedFall++;    countdownLanding -= 3;    player.y += speedFall;    player.drawBody(mouthType.smile);}',correct
'// If minim is not installed yet --> Sketch -> Import Librairy -> Add LibrairyAudioPlayer bgMusic;',correct
'2 * PI',correct
'{    // append string from the existing file and new highscore    String[] txtFile = loadStrings(filename);    String[] txtOut = new String[txtFile.length + txtNew.length - 1];    for (int i = 0; i < txtFile.length - 1; i++) {        txtOut[i] = txtFile[i];    }    for (int i = 0; i < txtNew.length; i++) {        txtOut[txtFile.length + i - 1] = txtNew[i];    }    saveStrings(filename, txtOut);}',correct
'uploaded == false',correct
'items.length',correct
'int speedX = (int) random(2, 4);',correct
'player.y += speedFall;',DrawingStateChangeRule
'updateSombrero()',correct
'loadStrings(filename)',correct
'if (creaturePosX + 20 > mouseX && creaturePosY - 20 < mouseY && creaturePosY + 20 > mouseY && creaturePosX - 20 < mouseX) {    creaturePosX = mouseX;    creaturePosY = mouseY;    rotationMult = 5;    eyeColor = color(255, 0, 0);    dX = 0;    dY = 0;}',correct
'25 + 7 * sin(bob)',correct
'{    dY = -dY;}',correct
'creatureB.whenClicked();',correct
'while (i < 3) {    fill(255);    rotate(radians(120));    line(5, 25 + 7 * sin(bob), 0, 50 + 7 * sin(bob));    line(5, 25 + 7 * sin(bob), -5, 25 + 7 * sin(bob));    line(-5, 25 + 7 * sin(bob), 0, 50 + 7 * sin(bob));    rotate(radians(120));    ellipse(-0, -30, 10, 10);    fill(eyeColor);    ellipse(-0, -30, 4, 4);    i++;}',correct
'line(-5, 25 + 7 * sin(bob), 0, 50 + 7 * sin(bob))',correct
'creaturePosX > width - 50 / 2',correct
'creaturePosY > height - 50 / 2',correct
'int i = 0;',ShortVariable
'faceColor = color(200);',correct
'creaturePosX + 6',correct
'{    creaturePosX += dX;    creaturePosY += dY;    if (creaturePosX < 50 / 2 && dX < 0) {        dX = -dX;    }    if (creaturePosY < 50 / 2 && dY < 0) {        dY = -dY;    }    if (creaturePosX > width - 50 / 2 && dX > 0) {        dX = -dX;    }    if (creaturePosY > height - 50 / 2 && dY > 0) {        dY = -dY;    }}',correct
'creatureC.whenReleased();',correct
'{    fill(255);    rotate(radians(120));    line(5, 25 + 7 * sin(bob), 0, 50 + 7 * sin(bob));    line(5, 25 + 7 * sin(bob), -5, 25 + 7 * sin(bob));    line(-5, 25 + 7 * sin(bob), 0, 50 + 7 * sin(bob));    rotate(radians(120));    ellipse(-0, -30, 10, 10);    fill(eyeColor);    ellipse(-0, -30, 4, 4);    i++;}',correct
'stroke(0);',correct
'random(-8, -1)',correct
'stroke(0)',correct
'creature creatureC;',correct
'pushMatrix();',correct
'width - 50 / 2',correct
'dX < 0',correct
'line(-5, 25 + 7 * sin(bob), 0, 50 + 7 * sin(bob));',correct
'creatureA.spin();',correct
'creatureC.whenClicked()',correct
'background(255);',correct
'dY = 0;',correct
'void wallBounce() {    creaturePosX += dX;    creaturePosY += dY;    if (creaturePosX < 50 / 2 && dX < 0) {        dX = -dX;    }    if (creaturePosY < 50 / 2 && dY < 0) {        dY = -dY;    }    if (creaturePosX > width - 50 / 2 && dX > 0) {        dX = -dX;    }    if (creaturePosY > height - 50 / 2 && dY > 0) {        dY = -dY;    }}',correct
'{    creaturePosX = mouseX;    creaturePosY = mouseY;    rotationMult = 5;    eyeColor = color(255, 0, 0);    dX = 0;    dY = 0;}',correct
'color(255, 0, 0)',correct
'creaturePosX < 50 / 2',correct
'rotationMult',correct
'creature creatureB;',correct
'ellipse(-0, -30, 10, 10)',correct
'creatureB',correct
'creatureA',correct
'creatureC',correct
'creatureA.display()',correct
'50 / 2',correct
'creatureC.whenClicked();',correct
'fill(faceColor);',correct
'creaturePosY < 50 / 2 && dY < 0',correct
'rectMode(CENTER)',correct
'creature creatureA;',correct
'translate(creaturePosX, creaturePosY)',correct
'creatureC.whenReleased()',correct
'popMatrix();',correct
'void whenClicked() {    if (creaturePosX + 20 > mouseX && creaturePosY - 20 < mouseY && creaturePosY + 20 > mouseY && creaturePosX - 20 < mouseX) {        creaturePosX = mouseX;        creaturePosY = mouseY;        rotationMult = 5;        eyeColor = color(255, 0, 0);        dX = 0;        dY = 0;    }}',correct
'if (creaturePosX + 20 > mouseX && creaturePosY - 20 < mouseY && creaturePosY + 20 > mouseY && creaturePosX - 20 < mouseX) {    dX = random(-8, -1);    dY = random(-8, -1);    rotationMult = 2;    eyeColor = color(255, 255, 0);}',correct
'creatureA.spin()',correct
'creatureA = new creature(100, 100)',correct
'dX',correct
'dY',correct
'eyeColor = color(255, 255, 0);',correct
'rectMode(CENTER);',correct
'creaturePosY += dY',correct
'color(150)',correct
'creaturePosX > width - 50 / 2 && dX > 0',correct
'ellipse(-0, -30, 4, 4);',correct
'void setup() {    creatureA = new creature(100, 100);    creatureB = new creature(600, 600);    creatureC = new creature(600, 200);    rectMode(CENTER);}',correct
'creatureB = new creature(600, 600)',correct
'creaturePosY - 20',correct
'void mousePressed() {    creatureA.whenClicked();    creatureB.whenClicked();    creatureC.whenClicked();}',correct
'creaturePosY - 20 < mouseY',correct
'creatureB.spin();',correct
'float dX;',ShortVariable
'void mouseDragged() {    creatureA.whenClicked();    creatureB.whenClicked();    creatureC.whenClicked();}',correct
'creatureB.wallBounce()',correct
'creaturePosX',correct
'line(5, 25 + 7 * sin(bob), 0, 50 + 7 * sin(bob))',correct
'eyeColor = color(255, 255, 0)',correct
'creaturePosX += dX;',correct
'creaturePosY',correct
'int firstY',correct
'int firstX',correct
'radians(120)',correct
'ellipse(creaturePosX, creaturePosY, 18, 18);',correct
'fill(bodyColor)',correct
'ellipse(creaturePosX - 6, creaturePosY - 6, 5, 5)',correct
'float dY;',ShortVariable
'dX > 0',correct
'faceColor = color(200)',correct
'dX = random(-8, -1)',correct
'height - 50 / 2',correct
'creatureA.whenClicked();',correct
'rotate(radians(120))',correct
'fill(bodyColor);',correct
'rotationMult = 5',correct
'creatureA.whenReleased();',correct
'creaturePosX - 20',correct
'dY < 0',correct
'creature',correct
'new creature(600, 600)',correct
'fill(faceColor)',correct
'creaturePosX + 20 > mouseX && creaturePosY - 20 < mouseY && creaturePosY + 20 > mouseY',correct
'dX = random(-8, -1);',correct
'rotationMult = 2',correct
'int bodyColor;',correct
'{    creatureA.whenReleased();    creatureB.whenReleased();    creatureC.whenReleased();}',correct
'creatureA.wallBounce()',correct
'fill(255)',correct
'Processing',correct
'background(255)',correct
'i < 3',correct
'{    if (creaturePosX + 20 > mouseX && creaturePosY - 20 < mouseY && creaturePosY + 20 > mouseY && creaturePosX - 20 < mouseX) {        dX = random(-8, -1);        dY = random(-8, -1);        rotationMult = 2;        eyeColor = color(255, 255, 0);    }}',correct
'pushMatrix()',correct
'{    dX = random(-8, -1);    dY = random(-8, -1);    rotationMult = 2;    eyeColor = color(255, 255, 0);}',correct
'rotate(radians(frameCount * rotationMult))',correct
'int faceColor;',correct
'color(200)',correct
'creaturePosY = firstY;',correct
'bob = bob + 2 * PI * 300',correct
'if (creaturePosX > width - 50 / 2 && dX > 0) {    dX = -dX;}',correct
'bodyColor = color(150)',correct
'creatureC.display();',correct
'dX = 0',correct
'if (creaturePosX < 50 / 2 && dX < 0) {    dX = -dX;}',correct
'creaturePosX < 50 / 2 && dX < 0',correct
'creatureB.whenReleased()',correct
'int i = 0',correct
'dX = -dX;',correct
'ellipse(creaturePosX + 6, creaturePosY - 6, 5, 5)',correct
'creatureB = new creature(600, 600);',correct
'creaturePosY = firstY',correct
'i = 0',correct
'void spin() {    bob = bob + 2 * PI * 300;    translate(creaturePosX, creaturePosY);    rotate(radians(frameCount * rotationMult));    stroke(0);    int i = 0;    while (i < 3) {        fill(255);        rotate(radians(120));        line(5, 25 + 7 * sin(bob), 0, 50 + 7 * sin(bob));        line(5, 25 + 7 * sin(bob), -5, 25 + 7 * sin(bob));        line(-5, 25 + 7 * sin(bob), 0, 50 + 7 * sin(bob));        rotate(radians(120));        ellipse(-0, -30, 10, 10);        fill(eyeColor);        ellipse(-0, -30, 4, 4);        i++;    }}',correct
'dX = 0;',correct
'creatureA.display();',correct
'ellipse(creaturePosX - 6, creaturePosY + 6, 5, 5);',correct
'{    bob = bob + 2 * PI * 300;    translate(creaturePosX, creaturePosY);    rotate(radians(frameCount * rotationMult));    stroke(0);    int i = 0;    while (i < 3) {        fill(255);        rotate(radians(120));        line(5, 25 + 7 * sin(bob), 0, 50 + 7 * sin(bob));        line(5, 25 + 7 * sin(bob), -5, 25 + 7 * sin(bob));        line(-5, 25 + 7 * sin(bob), 0, 50 + 7 * sin(bob));        rotate(radians(120));        ellipse(-0, -30, 10, 10);        fill(eyeColor);        ellipse(-0, -30, 4, 4);        i++;    }}',correct
'int eyeColor;',correct
'ellipse(-0, -30, 10, 10);',correct
'creaturePosY < 50 / 2',correct
'creatureC = new creature(600, 200);',correct
'creaturePosX + 20 > mouseX && creaturePosY - 20 < mouseY',correct
'void display() {    rectMode(CENTER);    fill(bodyColor);    ellipse(creaturePosX, creaturePosY, 34, 34);    fill(faceColor);    ellipse(creaturePosX, creaturePosY, 18, 18);    fill(eyeColor);    ellipse(creaturePosX - 6, creaturePosY - 6, 5, 5);    ellipse(creaturePosX + 6, creaturePosY - 6, 5, 5);    ellipse(creaturePosX - 6, creaturePosY + 6, 5, 5);    ellipse(creaturePosX + 6, creaturePosY + 6, 5, 5);}',correct
'dY = random(-8, -1)',correct
'creaturePosX = firstX;',correct
'7 * sin(bob)',correct
'creaturePosY - 6',correct
'creaturePosX + 20 > mouseX',correct
'creaturePosX = mouseX;',correct
'creatureB.spin()',correct
'creaturePosX - 20 < mouseX',correct
'new creature(600, 200)',correct
'creatureB.wallBounce();',correct
'{    rectMode(CENTER);    fill(bodyColor);    ellipse(creaturePosX, creaturePosY, 34, 34);    fill(faceColor);    ellipse(creaturePosX, creaturePosY, 18, 18);    fill(eyeColor);    ellipse(creaturePosX - 6, creaturePosY - 6, 5, 5);    ellipse(creaturePosX + 6, creaturePosY - 6, 5, 5);    ellipse(creaturePosX - 6, creaturePosY + 6, 5, 5);    ellipse(creaturePosX + 6, creaturePosY + 6, 5, 5);}',correct
'ellipse(-0, -30, 4, 4)',correct
'if (creaturePosY < 50 / 2 && dY < 0) {    dY = -dY;}',correct
'class creature {    int eyeColor;    int bodyColor;    int faceColor;    float rotationMult;    float bob;    int creaturePosY;    int creaturePosX;    float dX;    float dY;    creature(int firstX, int firstY) {        bodyColor = color(150);        eyeColor = color(255, 255, 0);        faceColor = color(200);        rotationMult = 2;        creaturePosX = firstX;        creaturePosY = firstY;        dX = random(-8, -1);        dY = random(-8, -1);    }    void display() {        rectMode(CENTER);        fill(bodyColor);        ellipse(creaturePosX, creaturePosY, 34, 34);        fill(faceColor);        ellipse(creaturePosX, creaturePosY, 18, 18);        fill(eyeColor);        ellipse(creaturePosX - 6, creaturePosY - 6, 5, 5);        ellipse(creaturePosX + 6, creaturePosY - 6, 5, 5);        ellipse(creaturePosX - 6, creaturePosY + 6, 5, 5);        ellipse(creaturePosX + 6, creaturePosY + 6, 5, 5);    }    void spin() {        bob = bob + 2 * PI * 300;        translate(creaturePosX, creaturePosY);        rotate(radians(frameCount * rotationMult));        stroke(0);        int i = 0;        while (i < 3) {            fill(255);            rotate(radians(120));            line(5, 25 + 7 * sin(bob), 0, 50 + 7 * sin(bob));            line(5, 25 + 7 * sin(bob), -5, 25 + 7 * sin(bob));            line(-5, 25 + 7 * sin(bob), 0, 50 + 7 * sin(bob));            rotate(radians(120));            ellipse(-0, -30, 10, 10);            fill(eyeColor);            ellipse(-0, -30, 4, 4);            i++;        }    }    void wallBounce() {        creaturePosX += dX;        creaturePosY += dY;        if (creaturePosX < 50 / 2 && dX < 0) {            dX = -dX;        }        if (creaturePosY < 50 / 2 && dY < 0) {            dY = -dY;        }        if (creaturePosX > width - 50 / 2 && dX > 0) {            dX = -dX;        }        if (creaturePosY > height - 50 / 2 && dY > 0) {            dY = -dY;        }    }    void whenClicked() {        if (creaturePosX + 20 > mouseX && creaturePosY - 20 < mouseY && creaturePosY + 20 > mouseY && creaturePosX - 20 < mouseX) {            creaturePosX = mouseX;            creaturePosY = mouseY;            rotationMult = 5;            eyeColor = color(255, 0, 0);            dX = 0;            dY = 0;        }    }    void whenReleased() {        if (creaturePosX + 20 > mouseX && creaturePosY - 20 < mouseY && creaturePosY + 20 > mouseY && creaturePosX - 20 < mouseX) {            dX = random(-8, -1);            dY = random(-8, -1);            rotationMult = 2;            eyeColor = color(255, 255, 0);        }    }}',correct
'dY > 0',correct
'eyeColor = color(255, 0, 0)',correct
'ellipse(creaturePosX - 6, creaturePosY + 6, 5, 5)',correct
'creatureA.whenReleased()',correct
'ellipse(creaturePosX - 6, creaturePosY - 6, 5, 5);',correct
'creaturePosX + 20 > mouseX && creaturePosY - 20 < mouseY && creaturePosY + 20 > mouseY && creaturePosX - 20 < mouseX',correct
'creaturePosY + 20',correct
'-30',correct
'{    bodyColor = color(150);    eyeColor = color(255, 255, 0);    faceColor = color(200);    rotationMult = 2;    creaturePosX = firstX;    creaturePosY = firstY;    dX = random(-8, -1);    dY = random(-8, -1);}',correct
'creatureC.spin();',correct
'dX = -dX',correct
'{    dX = -dX;}',correct
'eyeColor',correct
'{    if (creaturePosX + 20 > mouseX && creaturePosY - 20 < mouseY && creaturePosY + 20 > mouseY && creaturePosX - 20 < mouseX) {        creaturePosX = mouseX;        creaturePosY = mouseY;        rotationMult = 5;        eyeColor = color(255, 0, 0);        dX = 0;        dY = 0;    }}',correct
'rotate(radians(frameCount * rotationMult));',correct
'bob + 2 * PI * 300',correct
'int creaturePosY;',correct
'-dX',correct
'-dY',correct
'line(5, 25 + 7 * sin(bob), -5, 25 + 7 * sin(bob));',correct
'translate(creaturePosX, creaturePosY);',correct
'bodyColor = color(150);',correct
'radians(frameCount * rotationMult)',correct
'{    creatureA.whenClicked();    creatureB.whenClicked();    creatureC.whenClicked();}',correct
'new creature(100, 100)',correct
'creaturePosX = mouseX',correct
'ellipse(creaturePosX + 6, creaturePosY + 6, 5, 5);',correct
'creaturePosY = mouseY;',correct
'dY = random(-8, -1);',correct
'dY = 0',correct
'fill(eyeColor);',correct
'ellipse(creaturePosX, creaturePosY, 34, 34);',correct
'creatureA.whenClicked()',correct
'int creaturePosX;',correct
'void whenReleased() {    if (creaturePosX + 20 > mouseX && creaturePosY - 20 < mouseY && creaturePosY + 20 > mouseY && creaturePosX - 20 < mouseX) {        dX = random(-8, -1);        dY = random(-8, -1);        rotationMult = 2;        eyeColor = color(255, 255, 0);    }}',correct
'frameCount * rotationMult',correct
'creaturePosX = firstX',correct
'50 + 7 * sin(bob)',correct
'i++',correct
'float bob;',correct
'fill(255);',correct
'bob = bob + 2 * PI * 300;',correct
'dY = -dY',correct
'rotate(radians(120));',correct
'creatureC.display()',correct
'creatureA.wallBounce();',correct
'creaturePosX += dX',correct
'creaturePosX - 6',correct
'creatureA = new creature(100, 100);',correct
'2 * PI * 300',correct
'creatureB.whenClicked()',correct
'dY = -dY;',correct
'rotationMult = 2;',correct
'ellipse(creaturePosX + 6, creaturePosY - 6, 5, 5);',correct
'void',correct
'ellipse(creaturePosX + 6, creaturePosY + 6, 5, 5)',correct
'-0',correct
'-1',correct
'creaturePosY + 6',correct
'-5',correct
'-8',correct
'void draw() {    background(255);    pushMatrix();    creatureA.display();    creatureA.spin();    creatureA.wallBounce();    popMatrix();    pushMatrix();    creatureB.display();    creatureB.spin();    creatureB.wallBounce();    popMatrix();    creatureC.display();    creatureC.spin();    creatureC.wallBounce();}',correct
'creaturePosY += dY;',correct
'eyeColor = color(255, 0, 0);',correct
'bob',correct
'{    creatureA = new creature(100, 100);    creatureB = new creature(600, 600);    creatureC = new creature(600, 200);    rectMode(CENTER);}',correct
'creaturePosY + 20 > mouseY',correct
'fill(eyeColor)',correct
'void mouseReleased() {    creatureA.whenReleased();    creatureB.whenReleased();    creatureC.whenReleased();}',correct
'creatureB.display()',correct
'creatureB.whenReleased();',correct
'{    background(255);    pushMatrix();    creatureA.display();    creatureA.spin();    creatureA.wallBounce();    popMatrix();    pushMatrix();    creatureB.display();    creatureB.spin();    creatureB.wallBounce();    popMatrix();    creatureC.display();    creatureC.spin();    creatureC.wallBounce();}',correct
'bodyColor',correct
'popMatrix()',correct
'rotationMult = 5;',correct
'ellipse(creaturePosX, creaturePosY, 34, 34)',correct
'float rotationMult;',correct
'sin(bob)',correct
'if (creaturePosY > height - 50 / 2 && dY > 0) {    dY = -dY;}',correct
'creatureC.wallBounce()',correct
'creaturePosY = mouseY',correct
'line(5, 25 + 7 * sin(bob), 0, 50 + 7 * sin(bob));',correct
'creatureB.display();',correct
'color(255, 255, 0)',correct
'creatureC = new creature(600, 200)',correct
'faceColor',correct
'creatureC.wallBounce();',correct
'i++;',correct
'creaturePosX + 20',correct
'ellipse(creaturePosX, creaturePosY, 18, 18)',correct
'line(5, 25 + 7 * sin(bob), -5, 25 + 7 * sin(bob))',correct
'creatureC.spin()',correct
'creature(int firstX, int firstY) {    bodyColor = color(150);    eyeColor = color(255, 255, 0);    faceColor = color(200);    rotationMult = 2;    creaturePosX = firstX;    creaturePosY = firstY;    dX = random(-8, -1);    dY = random(-8, -1);}',correct
'2 * PI',correct
'creaturePosY > height - 50 / 2 && dY > 0',correct
'i = snowY - snowH / 4',correct
'width / 15',correct
'// Display Snowmanvoid display() {    ellipseMode(CENTER);    // Draw Snowmans body    stroke(0xff869598);    strokeWeight(4);    fill(255);    ellipse(snowX, snowY, snowW, snowH);    ellipse(snowX, snowY - 70, snowW / 1.5f, snowH / 1.5f);    // Draw Snowmans buttons    stroke(0xff070808);    fill(0xff070808);    for (float i = snowY - snowH / 4; i < snowY + snowH / 2; i += 27) {        stroke(0xff070808);        fill(0xff070808);        ellipse(snowX, i, 5, 5);    }    // Draw Snowmans arms    stroke(0xffAD7A1C);    strokeWeight(3);    line(snowX + 40, snowY - 30, snowX + 70, snowY - 70);    line(snowX - 40, snowY - 30, snowX - 70, snowY - 70);    // Draw Snowmans nose    image(nose, snowX - 7, snowY - 80, width / 15, height / 15);    // Draw Snowmans eyes    stroke(0xff0F0F0F);    strokeWeight(1);    fill(255);    ellipse(snowX - 15, snowY - 80, 10, 20);    ellipse(snowX + 15, snowY - 80, 10, 20);    fill(0xff0F0F0F);    ellipse(snowX - 15, snowY - 80, 5, 15);    ellipse(snowX + 15, snowY - 80, 5, 15);    stroke(255);    fill(255);    ellipse(snowX - 15, snowY - 85, 2.5f, 2.5f);    ellipse(snowX + 15, snowY - 85, 2.5f, 2.5f);    // Draw Snowmans hat    image(hat, snowX - 30, snowY - 150, width / 10, height / 10);}',correct
'nose = loadImage("carrot.png")',correct
'width / 10',correct
'{    snowflakeX = snowflakeX + random(-10, 10);    snowflakeY = snowflakeY + random(-10, 10);    // Constrain Snowflakes to window    snowflakeX = constrain(snowflakeX, 0, width);    snowflakeY = constrain(snowflakeY, 0, height);}',correct
'nose = loadImage("carrot.png");',correct
'snowflakes[i] = new Snowflake(i * 20, i * 0, 5);',correct
'// Draw Snowmans eyesstroke(0xff0F0F0F);',correct
'mountain',correct
'snowflakes[i].display();',correct
'{    stroke(0xff070808);    fill(0xff070808);    ellipse(snowX, i, 5, 5);}',correct
'2.5f',correct
'// Draw Snowmans buttonsstroke(0xff070808);',correct
'class Snowflake {    // Snowflakes variables    float snowflakeX, snowflakeY, snowflakeRad;    // Snowflake constructor    Snowflake(float snowflakeX_, float snowflakeY_, float snowflakeRad_) {        snowflakeX = snowflakeX_;        snowflakeY = snowflakeY_;        snowflakeRad = snowflakeRad_;    }    // Display Snowflake    void display() {        // Draw Snowflake        stroke(455);        strokeWeight(2);        ellipse(snowflakeX, snowflakeY, snowflakeRad, snowflakeRad);    }    // Let the Snowflakes jiggle around    void jiggle() {        snowflakeX = snowflakeX + random(-10, 10);        snowflakeY = snowflakeY + random(-10, 10);        // Constrain Snowflakes to window        snowflakeX = constrain(snowflakeX, 0, width);        snowflakeY = constrain(snowflakeY, 0, height);    }}',correct
'snowY - 30',correct
'{    // Draw Snowflake    stroke(455);    strokeWeight(2);    ellipse(snowflakeX, snowflakeY, snowflakeRad, snowflakeRad);}',correct
'{    snowman.move(mouseX, mouseY);}',correct
'snowflakeRad = snowflakeRad_;',correct
'{    ellipseMode(CENTER);    // Draw Snowmans body    stroke(0xff869598);    strokeWeight(4);    fill(255);    ellipse(snowX, snowY, snowW, snowH);    ellipse(snowX, snowY - 70, snowW / 1.5f, snowH / 1.5f);    // Draw Snowmans buttons    stroke(0xff070808);    fill(0xff070808);    for (float i = snowY - snowH / 4; i < snowY + snowH / 2; i += 27) {        stroke(0xff070808);        fill(0xff070808);        ellipse(snowX, i, 5, 5);    }    // Draw Snowmans arms    stroke(0xffAD7A1C);    strokeWeight(3);    line(snowX + 40, snowY - 30, snowX + 70, snowY - 70);    line(snowX - 40, snowY - 30, snowX - 70, snowY - 70);    // Draw Snowmans nose    image(nose, snowX - 7, snowY - 80, width / 15, height / 15);    // Draw Snowmans eyes    stroke(0xff0F0F0F);    strokeWeight(1);    fill(255);    ellipse(snowX - 15, snowY - 80, 10, 20);    ellipse(snowX + 15, snowY - 80, 10, 20);    fill(0xff0F0F0F);    ellipse(snowX - 15, snowY - 80, 5, 15);    ellipse(snowX + 15, snowY - 80, 5, 15);    stroke(255);    fill(255);    ellipse(snowX - 15, snowY - 85, 2.5f, 2.5f);    ellipse(snowX + 15, snowY - 85, 2.5f, 2.5f);    // Draw Snowmans hat    image(hat, snowX - 30, snowY - 150, width / 10, height / 10);}',LongMethodRule
'new Snowflake(i * 20, i * 0, 5)',correct
'strokeWeight(1);',correct
'fill(0xff0F0F0F);',correct
'snowY - snowH / 4',correct
'line(snowX - 40, snowY - 30, snowX - 70, snowY - 70);',correct
'stroke(455)',correct
'// introducing a variable for the background imagePImage mountain;',correct
'ellipse(snowX - 15, snowY - 80, 5, 15)',correct
'float snowH_',correct
'background(0xff030202)',correct
'snowflakeRad',correct
'i * 20',correct
'snowX + 15',correct
'PImage',correct
'float snowflakeRad_',correct
'i < snowY + snowH / 2',correct
'i * 0',correct
'float snowX_',correct
'snowflakeY = snowflakeY + random(-10, 10);',correct
'"carrot.png"',correct
'snowflakes.length',correct
'PImage nose;',correct
'ellipse(snowX - 15, snowY - 80, 10, 20);',correct
'strokeWeight(2);',correct
'{    snowflakeX = snowflakeX_;    snowflakeY = snowflakeY_;    snowflakeRad = snowflakeRad_;}',correct
'new Snowflake[100]',correct
'snowflakeY = snowflakeY + random(-10, 10)',correct
'float snowY_',correct
'Snowman',correct
'ellipse(snowX + 15, snowY - 80, 10, 20);',correct
'fill(0xff070808);',correct
'[100]',correct
'snowW / 1.5f',correct
'snowY - 150',correct
'constrain(snowflakeY, 0, height)',correct
'{    snowflakes[i] = new Snowflake(i * 20, i * 0, 5);}',correct
'constrain(snowflakeX, 0, width)',correct
'// Draw Snowmans armsstroke(0xffAD7A1C);',correct
'snowman.display()',correct
'snowflakeY = constrain(snowflakeY, 0, height);',correct
'Snowflake[]',correct
'float i = snowY - snowH / 4',correct
'ellipse(snowX, snowY, snowW, snowH);',correct
'snowX + 40',correct
'void mouseDragged() {    snowman.move(mouseX, mouseY);}',correct
'snowflakeY = snowflakeY_',correct
'Snowflake',correct
'ellipse(snowX - 15, snowY - 80, 5, 15);',correct
'for (int i = 0; i < snowflakes.length; i++) {    snowflakes[i].display();    snowflakes[i].jiggle();}',correct
'hat',correct
'// Move Snowman using the mousevoid move(float mouseX_, float mouseY_) {    snowX = mouseX_;    snowY = mouseY_;}',correct
'{    snowX = snowX_;    snowY = snowY_;    snowW = snowW_;    snowH = snowH_;    nose = loadImage("carrot.png");    hat = loadImage("hat.png");}',correct
'strokeWeight(3);',correct
'background(0xff030202);',correct
'// Draw Snowflakestroke(455);',correct
'snowflakes[i].display()',correct
'snowH / 1.5f',correct
'hat = loadImage("hat.png")',correct
'// Snowflake constructorSnowflake(float snowflakeX_, float snowflakeY_, float snowflakeRad_) {    snowflakeX = snowflakeX_;    snowflakeY = snowflakeY_;    snowflakeRad = snowflakeRad_;}',correct
'i += 27',correct
'jiggle',correct
'snowman.move(mouseX, mouseY)',correct
'snowflakes[i] = new Snowflake(i * 20, i * 0, 5)',correct
'fill(255)',correct
'hat = loadImage("hat.png");',correct
'// Snowmans variablesfloat snowX, snowY, snowW, snowH;',correct
'Processing',correct
'snowflakeY = constrain(snowflakeY, 0, height)',correct
'"hat.png"',correct
'snowX - 7',correct
'snowflakeRad = snowflakeRad_',correct
'snowflakes[i].jiggle()',correct
'snowX = mouseX_;',correct
'snowW = snowW_',correct
'strokeWeight(4);',correct
'ellipse(snowX, snowY, snowW, snowH)',correct
'ellipse(snowX + 15, snowY - 80, 5, 15)',correct
'"backgrounddd2.png"',correct
'ellipseMode(CENTER);',correct
'int i = 0',correct
'snowX + 70',correct
'line(snowX + 40, snowY - 30, snowX + 70, snowY - 70)',correct
'setup',correct
'stroke(255)',correct
'ellipse(snowX + 15, snowY - 80, 5, 15);',correct
'// Draw Snowmans bodystroke(0xff869598);',correct
'// The SnowCreature world by Bente de Jongh - s1998811// introducing the class of the snowmanSnowman snowman;',correct
'i = 0',correct
'ellipse(snowflakeX, snowflakeY, snowflakeRad, snowflakeRad);',correct
'ellipse(snowX, i, 5, 5)',correct
'stroke(0xff070808);',correct
'new Snowman(250, 250, 100, 100)',correct
'class Snowman {    // Snowmans variables    float snowX, snowY, snowW, snowH;    PImage nose;    PImage hat;    // Snowman constructor    Snowman(float snowX_, float snowY_, float snowW_, float snowH_) {        snowX = snowX_;        snowY = snowY_;        snowW = snowW_;        snowH = snowH_;        nose = loadImage("carrot.png");        hat = loadImage("hat.png");    }    // Display Snowman    void display() {        ellipseMode(CENTER);        // Draw Snowmans body        stroke(0xff869598);        strokeWeight(4);        fill(255);        ellipse(snowX, snowY, snowW, snowH);        ellipse(snowX, snowY - 70, snowW / 1.5f, snowH / 1.5f);        // Draw Snowmans buttons        stroke(0xff070808);        fill(0xff070808);        for (float i = snowY - snowH / 4; i < snowY + snowH / 2; i += 27) {            stroke(0xff070808);            fill(0xff070808);            ellipse(snowX, i, 5, 5);        }        // Draw Snowmans arms        stroke(0xffAD7A1C);        strokeWeight(3);        line(snowX + 40, snowY - 30, snowX + 70, snowY - 70);        line(snowX - 40, snowY - 30, snowX - 70, snowY - 70);        // Draw Snowmans nose        image(nose, snowX - 7, snowY - 80, width / 15, height / 15);        // Draw Snowmans eyes        stroke(0xff0F0F0F);        strokeWeight(1);        fill(255);        ellipse(snowX - 15, snowY - 80, 10, 20);        ellipse(snowX + 15, snowY - 80, 10, 20);        fill(0xff0F0F0F);        ellipse(snowX - 15, snowY - 80, 5, 15);        ellipse(snowX + 15, snowY - 80, 5, 15);        stroke(255);        fill(255);        ellipse(snowX - 15, snowY - 85, 2.5f, 2.5f);        ellipse(snowX + 15, snowY - 85, 2.5f, 2.5f);        // Draw Snowmans hat        image(hat, snowX - 30, snowY - 150, width / 10, height / 10);    }    // Move Snowman using the mouse    void move(float mouseX_, float mouseY_) {        snowX = mouseX_;        snowY = mouseY_;    }}',correct
'-10',correct
'snowX - 15',correct
'loadImage("backgrounddd2.png")',correct
'snowflakeX = snowflakeX_',correct
'fill(0xff0F0F0F)',correct
'float snowflakeY_',correct
'image(mountain, 0, 0)',correct
'snowH = snowH_;',correct
'ellipse(snowX, snowY - 70, snowW / 1.5f, snowH / 1.5f)',correct
'snowflakes[i].jiggle();',correct
'snowW = snowW_;',correct
'{    snowflakes[i].display();    snowflakes[i].jiggle();}',correct
'snowflakeX = snowflakeX + random(-10, 10);',correct
'snowX - 30',correct
'// displaying the background imageimage(mountain, 0, 0);',correct
'snowflakeX = constrain(snowflakeX, 0, width)',correct
'float snowflakeX_',correct
'loadImage("hat.png")',correct
'for (int i = 0; i < snowflakes.length; i++) {    snowflakes[i] = new Snowflake(i * 20, i * 0, 5);}',correct
'snowY = mouseY_',correct
'ellipse(snowX + 15, snowY - 80, 10, 20)',correct
'line(snowX + 40, snowY - 30, snowX + 70, snowY - 70);',correct
'{    background(0xff030202);    // displaying the background image    image(mountain, 0, 0);    text("Welcome to the SnowCreature world!", 30, 50);    snowman.display();    for (int i = 0; i < snowflakes.length; i++) {        snowflakes[i].display();        snowflakes[i].jiggle();    }}',correct
'strokeWeight(1)',correct
'mountain = loadImage("backgrounddd2.png")',correct
'snowX = snowX_;',correct
'snowX - 40',correct
'line(snowX - 40, snowY - 30, snowX - 70, snowY - 70)',correct
'// introducing the class of the snowflakes in an arraySnowflake[] snowflakes = new Snowflake[100];',correct
'snowflakeX = snowflakeX_;',correct
'// Snowflakes variablesfloat snowflakeX, snowflakeY, snowflakeRad;',correct
'snowH / 4',correct
'snowX = snowX_',correct
'void draw() {    background(0xff030202);    // displaying the background image    image(mountain, 0, 0);    text("Welcome to the SnowCreature world!", 30, 50);    snowman.display();    for (int i = 0; i < snowflakes.length; i++) {        snowflakes[i].display();        snowflakes[i].jiggle();    }}',correct
'display',LongMethodRule
'snowflakeY = snowflakeY_;',correct
'draw',correct
'// Draw Snowmans noseimage(nose, snowX - 7, snowY - 80, width / 15, height / 15);',correct
'snowman.display();',correct
'snowH / 2',correct
'snowflakeX + random(-10, 10)',correct
'{    snowX = mouseX_;    snowY = mouseY_;}',correct
'stroke(0xffAD7A1C)',correct
'snowflakeY',correct
'snowflakeX',correct
'fill(0xff070808)',correct
'snowman',correct
'void setup() {    // loading the image    mountain = loadImage("backgrounddd2.png");    snowman = new Snowman(250, 250, 100, 100);    for (int i = 0; i < snowflakes.length; i++) {        snowflakes[i] = new Snowflake(i * 20, i * 0, 5);    }}',correct
'i++',correct
'// Snowman constructorSnowman(float snowX_, float snowY_, float snowW_, float snowH_) {    snowX = snowX_;    snowY = snowY_;    snowW = snowW_;    snowH = snowH_;    nose = loadImage("carrot.png");    hat = loadImage("hat.png");}',correct
'ellipse(snowX + 15, snowY - 85, 2.5f, 2.5f)',correct
'fill(255);',correct
'ellipse(snowX + 15, snowY - 85, 2.5f, 2.5f);',correct
'ellipseMode(CENTER)',correct
'snowY - 70',correct
'strokeWeight(3)',correct
'i < snowflakes.length',correct
'ellipse(snowX - 15, snowY - 85, 2.5f, 2.5f);',correct
'snowY = mouseY_;',correct
'loadImage("carrot.png")',correct
'snowY + snowH / 2',correct
'snowman = new Snowman(250, 250, 100, 100);',correct
'snowY = snowY_',correct
'for (float i = snowY - snowH / 4; i < snowY + snowH / 2; i += 27) {    stroke(0xff070808);    fill(0xff070808);    ellipse(snowX, i, 5, 5);}',correct
'void',correct
'float mouseY_',correct
'// loading the imagemountain = loadImage("backgrounddd2.png");',correct
'snowflakes = new Snowflake[100]',correct
'snowH',correct
'image(hat, snowX - 30, snowY - 150, width / 10, height / 10)',correct
'snowY - 80',correct
'ellipse(snowX, snowY - 70, snowW / 1.5f, snowH / 1.5f);',correct
'{    // loading the image    mountain = loadImage("backgrounddd2.png");    snowman = new Snowman(250, 250, 100, 100);    for (int i = 0; i < snowflakes.length; i++) {        snowflakes[i] = new Snowflake(i * 20, i * 0, 5);    }}',correct
'stroke(0xff070808)',correct
'// The SnowCreature world by Bente de Jongh - s1998811',correct
'ellipse(snowX, i, 5, 5);',correct
'random(-10, 10)',correct
'float snowW_',correct
'strokeWeight(2)',correct
'1.5f',correct
'snowX - 70',correct
'// Draw Snowmans hatimage(hat, snowX - 30, snowY - 150, width / 10, height / 10);',correct
'snowW',correct
'snowX',correct
'snowY',correct
'snowY - 85',correct
'ellipse(snowflakeX, snowflakeY, snowflakeRad, snowflakeRad)',correct
'stroke(0xff0F0F0F)',correct
'snowX = mouseX_',correct
'snowman.move(mouseX, mouseY);',correct
'stroke(255);',correct
'float mouseX_',correct
'// Constrain Snowflakes to windowsnowflakeX = constrain(snowflakeX, 0, width);',correct
'snowH = snowH_',correct
'stroke(0xff869598)',correct
'height / 15',correct
'text("Welcome to the SnowCreature world!", 30, 50)',correct
'height / 10',correct
'PImage hat;',correct
'text("Welcome to the SnowCreature world!", 30, 50);',PixelHardcodeIgnoranceRule
'// Display Snowflakevoid display() {    // Draw Snowflake    stroke(455);    strokeWeight(2);    ellipse(snowflakeX, snowflakeY, snowflakeRad, snowflakeRad);}',correct
'snowman = new Snowman(250, 250, 100, 100)',correct
'nose',correct
'snowflakeY + random(-10, 10)',correct
'move',correct
'ellipse(snowX - 15, snowY - 80, 10, 20)',correct
'snowflakeX = snowflakeX + random(-10, 10)',correct
'"Welcome to the SnowCreature world!"',correct
'ellipse(snowX - 15, snowY - 85, 2.5f, 2.5f)',correct
'strokeWeight(4)',correct
'image(nose, snowX - 7, snowY - 80, width / 15, height / 15)',correct
'snowflakes[i]',correct
'// Let the Snowflakes jiggle aroundvoid jiggle() {    snowflakeX = snowflakeX + random(-10, 10);    snowflakeY = snowflakeY + random(-10, 10);    // Constrain Snowflakes to window    snowflakeX = constrain(snowflakeX, 0, width);    snowflakeY = constrain(snowflakeY, 0, height);}',correct
'snowY = snowY_;',correct
'speedY = random(1, 2);',correct
'Creature',correct
'+50',correct
'ellipse(+17, -5, 10, 10)',correct
'random(1, 2)',correct
'isCrazy = true;',correct
'translate(toothX, toothY)',correct
'r = 0',correct
'arc(+50, -33, 35, 73, radians(-180), radians(20));',correct
'theeth[3] = c4',correct
'{    isCrazy = false;    if (speedX == 0 && speedY == 0) {        speedX = random(1, 2);        speedY = random(1, 2);    }}',correct
'c2 = new Creature(width / 3, height / 2);',correct
'c4.goCrazy()',correct
'void draw() {    // black    background(0);    c1.display();    c3.display();    c4.display();    c5.display();    c6.display();    c2.display();    c1.update();    c2.update();    c3.update();    c4.update();    c5.update();    c6.update();}',correct
'c2.display()',correct
'theeth[i]',correct
'theeth[3] = c4;',correct
'speedX = speedX * -1;',correct
'// Veronique KochetovCreature c1;',correct
'c6.test()',correct
'speedY = speedY * -1',correct
'+60',correct
'pushMatrix();',correct
'{    theeth[i].goThere();}',correct
'speedX == 0 && speedY == 0',correct
'c1',correct
'c2',correct
'c3',correct
'c4',correct
'c5',correct
'c6',correct
'c3.display()',correct
'c2.test()',correct
'radians(18)',correct
'c1 = new Creature(width / 2, height / 2);',correct
'void goThere() {    toothX = mouseX;    toothY = mouseY;}',correct
'// funnyFace',correct
'c4.test()',correct
'// Veronique Kochetov',correct
'if (toothY <= 0) {    speedY = speedY * -1;}',correct
'stroke(100);',correct
'void mousePressed() {    c1.goCrazy();    c2.goCrazy();    c3.goCrazy();    c4.goCrazy();    c5.goCrazy();    c6.goCrazy();}',correct
'color(random(255), random(255), random(255))',correct
'c5 = new Creature(width / 3, height / 6);',correct
'stroke(bodyColor)',correct
'{    pushMatrix();    translate(toothX, toothY);    stroke(bodyColor);    fill(bodyColor);    if (isCrazy) {        speedX = 0;        speedY = 0;        // now the coordinate system rotates and the tooth rotates around itself        rotate(radians(r));        r += 1;        // random color change        bodyColor = color(random(255), random(255), random(255));    } else {        // white        bodyColor = color(255);    }    // tooth    smooth();    rect(0, 0, 70, 80);    quad(+20, +50, +50, +30, +60, -30, +10, -20);    stroke(100);    ellipse(+50, 0, 35, 135);    ellipse(0, 0, 35, 140);    ellipse(-24, +5, 35, 150);    ellipse(+24, +10, 49, 150);    noStroke();    rect(0, 0, 70, 70);    stroke(100);    arc(0, -35, 35, 70, radians(-180), radians(0));    arc(+50, -33, 35, 73, radians(-180), radians(20));    arc(+27, -30, 44, 75, radians(-180), radians(18));    arc(-17, -35, 45, 70, radians(-190), radians(0));    // funnyFace    // glasses    strokeWeight(5);    ellipse(-17, -8, 27, 27);    ellipse(+17, -5, 27, 27);    line(-5, -8, +4, -8);    line(+29, -8, +60, -15);    line(-30, -15, -40, -20);    // eyes    strokeWeight(1);    fill(0);    ellipse(-17, -8, 10, 10);    ellipse(+17, -5, 10, 10);    fill(255, 0, 10);    // mouth    arc(0, +10, 35, 40, radians(0), radians(180));    popMatrix();}',LongMethodRule
'toothY += speedY;',correct
'fill(0);',correct
'c1.update();',correct
'c5.goCrazy()',correct
'c6.test();',correct
'c6.goNormal()',correct
'theeth[1] = c2;',correct
'ellipse(-17, -8, 27, 27);',correct
'isCrazy = false;',correct
'{    speedX = speedX * -1;}',correct
'float speedY = random(1, 2);',correct
'speedY = 0;',correct
'new Creature(width / 9, height / 2)',correct
'toothX <= 0',correct
'c2.goCrazy()',correct
'rectMode(CENTER)',correct
'void update() {    toothX += speedX;    toothY += speedY;    if (toothX >= width) {        speedX = speedX * -1;    }    if (toothX <= 0) {        speedX = speedX * -1;    }    if (toothY <= 0) {        speedY = speedY * -1;    }    if (toothY >= height) {        speedY = speedY * -1;    }}',correct
'c4.display();',correct
'{    // white    bodyColor = color(255);}',correct
'c2.goNormal();',correct
'// tooth',correct
'c1.goNormal();',correct
'c6.goNormal();',correct
'popMatrix();',correct
'theeth[i].goThere()',correct
'c3.display();',correct
'void mouseClicked() {    for (int i = 0; i < theeth.length; i++) {        theeth[i].goThere();    }}',correct
'arc(0, -35, 35, 70, radians(-180), radians(0))',correct
'c5.goNormal();',correct
'speedX = 0',correct
'rectMode(CENTER);',correct
'random(255)',correct
'c4.goNormal();',correct
'if (toothX >= width) {    speedX = speedX * -1;}',correct
'// now the coordinate system rotates and the tooth rotates around itselfrotate(radians(r));',correct
'toothY = yp',correct
'if (dist(mouseX, mouseY, toothX, toothY) <= 50) {    isCrazy = true;    toothX = mouseX;    toothY = mouseY;}',correct
'boolean isCrazy = false;',correct
'c3.test();',correct
'noStroke()',correct
'c3.goNormal();',correct
'Creature c6;',ShortVariable
'[6]',correct
'arc(+27, -30, 44, 75, radians(-180), radians(18))',correct
'speedX * -1',correct
'ellipse(0, 0, 35, 140);',correct
'speedY * -1',correct
'translate(toothX, toothY);',correct
'{    c1.goNormal();    c2.goNormal();    c3.goNormal();    c4.goNormal();    c5.goNormal();    c6.goNormal();}',correct
'toothX = mouseX;',correct
'radians(-190)',correct
'toothY = mouseY;',correct
'c2.goNormal()',correct
'fill(bodyColor)',correct
'radians(0)',correct
'radians(r)',correct
'theeth[4] = c5',correct
'void goNormal() {    isCrazy = false;    if (speedX == 0 && speedY == 0) {        speedX = random(1, 2);        speedY = random(1, 2);    }}',correct
'isCrazy = true',correct
'theeth.length',correct
'c6.display()',correct
'Creature c5;',ShortVariable
'height / 6',correct
'fill(0)',correct
'height / 2',correct
'height / 3',correct
'stroke(100)',correct
'height / 4',correct
'dist(mouseX, mouseY, toothX, toothY) <= 50',correct
'fill(bodyColor);',correct
'ellipse(+50, 0, 35, 135);',correct
'c1.goCrazy()',correct
'float toothX;',correct
'c5.goCrazy();',correct
'{    speedY = speedY * -1;}',correct
'i < theeth.length',correct
'smooth()',correct
'if (toothY >= height) {    speedY = speedY * -1;}',correct
'Processing',correct
'speedX == 0',correct
'toothX',correct
'toothY',correct
'fill(255, 0, 10);',correct
'speedX = speedX * -1',correct
'pushMatrix()',correct
'{    for (int i = 0; i < theeth.length; i++) {        theeth[i].goThere();    }}',correct
'c4.update()',correct
'arc(+27, -30, 44, 75, radians(-180), radians(18));',correct
'radians(-180)',correct
'theeth[1] = c2',correct
'toothY = mouseY',correct
'theeth[5] = c6;',correct
'// blackbackground(0);',correct
'c1.test();',correct
'c3.goCrazy();',correct
'theeth[2] = c3',correct
'c6.goCrazy()',correct
'rotate(radians(r))',correct
'quad(+20, +50, +50, +30, +60, -30, +10, -20);',correct
'false',correct
'println(toothX, toothY)',correct
'c1.update()',correct
'void setup() {    rectMode(CENTER);    ellipseMode(CENTER);    c1 = new Creature(width / 2, height / 2);    c2 = new Creature(width / 3, height / 2);    c3 = new Creature(width / 2, height / 3);    c4 = new Creature(width / 9, height / 2);    c5 = new Creature(width / 3, height / 6);    c6 = new Creature(width / 5, height / 4);    theeth[0] = c1;    theeth[1] = c2;    theeth[2] = c3;    theeth[3] = c4;    theeth[4] = c5;    theeth[5] = c6;}',correct
'toothX >= width',correct
'radians(20)',correct
'c1.display()',correct
'line(-30, -15, -40, -20);',correct
'// moutharc(0, +10, 35, 40, radians(0), radians(180));',correct
'ellipseMode(CENTER);',correct
'c3 = new Creature(width / 2, height / 3);',correct
'int i = 0',correct
'speedX = random(1, 2)',correct
'c3 = new Creature(width / 2, height / 3)',correct
'arc(-17, -35, 45, 70, radians(-190), radians(0))',correct
'println(toothX, toothY);',correct
'stroke(bodyColor);',correct
'c6 = new Creature(width / 5, height / 4);',correct
'float speedX = random(1, 2);',correct
'c5.update()',correct
'i = 0',correct
'toothY >= height',correct
'// 0 degree;// for the rotationint r = 0;',correct
'color(255)',correct
'{    toothX = xp;    toothY = yp;    println(toothX, toothY);}',correct
'if (isCrazy) {    speedX = 0;    speedY = 0;    // now the coordinate system rotates and the tooth rotates around itself    rotate(radians(r));    r += 1;    // random color change    bodyColor = color(random(255), random(255), random(255));} else {    // white    bodyColor = color(255);}',correct
'c6.update();',correct
'Creature c2;',ShortVariable
'void mouseReleased() {    c1.goNormal();    c2.goNormal();    c3.goNormal();    c4.goNormal();    c5.goNormal();    c6.goNormal();}',correct
'-15',correct
'background(0)',correct
'-17',correct
'new Creature(width / 5, height / 4)',correct
'isCrazy',correct
'c1.goCrazy();',correct
'// 0 degree;',correct
'// whiteint bodyColor = color(255);',correct
'radians(180)',correct
'ellipse(-17, -8, 10, 10)',correct
'ellipse(-24, +5, 35, 150);',correct
'void goCrazy() {    if (dist(mouseX, mouseY, toothX, toothY) <= 50) {        isCrazy = true;        toothX = mouseX;        toothY = mouseY;    }}',correct
'for (int i = 0; i < theeth.length; i++) {    theeth[i].goThere();}',correct
'if (toothX <= 0) {    speedX = speedX * -1;}',correct
'c3.goNormal()',correct
'-20',correct
'new Creature(width / 3, height / 2)',correct
'-24',correct
'speedX = 0;',correct
'c4.test();',correct
'// eyesstrokeWeight(1);',correct
'{    isCrazy = true;    toothX = mouseX;    toothY = mouseY;}',correct
'// random color changebodyColor = color(random(255), random(255), random(255));',correct
'noStroke();',correct
'ellipse(-24, +5, 35, 150)',correct
'theeth[0] = c1',correct
'c4.goNormal()',correct
'c5.update();',correct
'{    toothX += speedX;    toothY += speedY;    if (toothX >= width) {        speedX = speedX * -1;    }    if (toothX <= 0) {        speedX = speedX * -1;    }    if (toothY <= 0) {        speedY = speedY * -1;    }    if (toothY >= height) {        speedY = speedY * -1;    }}',correct
'theeth[2] = c3;',correct
'theeth[2]',correct
'// toothsmooth();',correct
'arc(-17, -35, 45, 70, radians(-190), radians(0));',correct
'{    c1.goCrazy();    c2.goCrazy();    c3.goCrazy();    c4.goCrazy();    c5.goCrazy();    c6.goCrazy();}',correct
'strokeWeight(1)',correct
'-30',correct
'c6.display();',correct
'-33',correct
'Creature c4;',ShortVariable
'-35',correct
'ellipse(+17, -5, 10, 10);',correct
'{    if (dist(mouseX, mouseY, toothX, toothY) <= 50) {        isCrazy = true;        toothX = mouseX;        toothY = mouseY;    }}',correct
'c1.display();',correct
'c5 = new Creature(width / 3, height / 6)',correct
'float toothY;',correct
'toothY = yp;',correct
'Creature[]',correct
'c4.update();',correct
'theeth[1]',correct
'c4 = new Creature(width / 9, height / 2)',correct
'theeth = new Creature[6]',correct
'{    toothX = mouseX;    toothY = mouseY;}',correct
'c5.test()',correct
'{    rectMode(CENTER);    ellipseMode(CENTER);    c1 = new Creature(width / 2, height / 2);    c2 = new Creature(width / 3, height / 2);    c3 = new Creature(width / 2, height / 3);    c4 = new Creature(width / 9, height / 2);    c5 = new Creature(width / 3, height / 6);    c6 = new Creature(width / 5, height / 4);    theeth[0] = c1;    theeth[1] = c2;    theeth[2] = c3;    theeth[3] = c4;    theeth[4] = c5;    theeth[5] = c6;}',correct
'display',LongMethodRule
'line(+29, -8, +60, -15)',correct
'if (isCrazy) {    toothX = mouseX;    toothY = mouseY;}',correct
'-40',correct
'+4',correct
'speedY = random(1, 2)',correct
'+5',correct
'draw',correct
'ellipse(+17, -5, 27, 27)',correct
'Creature c3;',ShortVariable
'class Creature {    float toothX;    float toothY;    // white    int bodyColor = color(255);    // 0 degree;    // for the rotation    int r = 0;    float speedX = random(1, 2);    float speedY = random(1, 2);    boolean isCrazy = false;    Creature(int xp, int yp) {        toothX = xp;        toothY = yp;        println(toothX, toothY);    }    void display() {        pushMatrix();        translate(toothX, toothY);        stroke(bodyColor);        fill(bodyColor);        if (isCrazy) {            speedX = 0;            speedY = 0;            // now the coordinate system rotates and the tooth rotates around itself            rotate(radians(r));            r += 1;            // random color change            bodyColor = color(random(255), random(255), random(255));        } else {            // white            bodyColor = color(255);        }        // tooth        smooth();        rect(0, 0, 70, 80);        quad(+20, +50, +50, +30, +60, -30, +10, -20);        stroke(100);        ellipse(+50, 0, 35, 135);        ellipse(0, 0, 35, 140);        ellipse(-24, +5, 35, 150);        ellipse(+24, +10, 49, 150);        noStroke();        rect(0, 0, 70, 70);        stroke(100);        arc(0, -35, 35, 70, radians(-180), radians(0));        arc(+50, -33, 35, 73, radians(-180), radians(20));        arc(+27, -30, 44, 75, radians(-180), radians(18));        arc(-17, -35, 45, 70, radians(-190), radians(0));        // funnyFace        // glasses        strokeWeight(5);        ellipse(-17, -8, 27, 27);        ellipse(+17, -5, 27, 27);        line(-5, -8, +4, -8);        line(+29, -8, +60, -15);        line(-30, -15, -40, -20);        // eyes        strokeWeight(1);        fill(0);        ellipse(-17, -8, 10, 10);        ellipse(+17, -5, 10, 10);        fill(255, 0, 10);        // mouth        arc(0, +10, 35, 40, radians(0), radians(180));        popMatrix();    }    void goCrazy() {        if (dist(mouseX, mouseY, toothX, toothY) <= 50) {            isCrazy = true;            toothX = mouseX;            toothY = mouseY;        }    }    void goNormal() {        isCrazy = false;        if (speedX == 0 && speedY == 0) {            speedX = random(1, 2);            speedY = random(1, 2);        }    }    void test() {        if (isCrazy) {            toothX = mouseX;            toothY = mouseY;        }    }    void update() {        toothX += speedX;        toothY += speedY;        if (toothX >= width) {            speedX = speedX * -1;        }        if (toothX <= 0) {            speedX = speedX * -1;        }        if (toothY <= 0) {            speedY = speedY * -1;        }        if (toothY >= height) {            speedY = speedY * -1;        }    }    void goThere() {        toothX = mouseX;        toothY = mouseY;    }}',correct
'theeth[0] = c1;',correct
'void mouseDragged() {    c1.test();    c2.test();    c3.test();    c4.test();    c5.test();    c6.test();}',correct
'c1.test()',correct
'{    // black    background(0);    c1.display();    c3.display();    c4.display();    c5.display();    c6.display();    c2.display();    c1.update();    c2.update();    c3.update();    c4.update();    c5.update();    c6.update();}',correct
'Creature(int xp, int yp) {    toothX = xp;    toothY = yp;    println(toothX, toothY);}',correct
'new Creature[6]',correct
'toothX = xp;',correct
'speedX = random(1, 2);',correct
'toothX = mouseX',correct
'{    if (isCrazy) {        toothX = mouseX;        toothY = mouseY;    }}',correct
'speedY == 0',correct
'theeth[5] = c6',correct
'theeth[0]',correct
'ellipse(0, 0, 35, 140)',correct
'arc(0, +10, 35, 40, radians(0), radians(180))',correct
'theeth[4]',correct
'Creature[] theeth = new Creature[6];',correct
'c2.update()',correct
'if (speedX == 0 && speedY == 0) {    speedX = random(1, 2);    speedY = random(1, 2);}',correct
'{    speedX = random(1, 2);    speedY = random(1, 2);}',correct
'c5.goNormal()',correct
'c2.display();',correct
'c5.display()',correct
'i++',correct
'isCrazy = false',correct
'-180',correct
'+10',correct
'new Creature(width / 2, height / 3)',correct
'void test() {    if (isCrazy) {        toothX = mouseX;        toothY = mouseY;    }}',correct
'toothX += speedX',correct
'ellipse(-17, -8, 27, 27)',correct
'+17',correct
'ellipseMode(CENTER)',correct
'c2.update();',correct
'ellipse(+24, +10, 49, 150)',correct
'c5.display();',correct
'c6.goCrazy();',correct
'void display() {    pushMatrix();    translate(toothX, toothY);    stroke(bodyColor);    fill(bodyColor);    if (isCrazy) {        speedX = 0;        speedY = 0;        // now the coordinate system rotates and the tooth rotates around itself        rotate(radians(r));        r += 1;        // random color change        bodyColor = color(random(255), random(255), random(255));    } else {        // white        bodyColor = color(255);    }    // tooth    smooth();    rect(0, 0, 70, 80);    quad(+20, +50, +50, +30, +60, -30, +10, -20);    stroke(100);    ellipse(+50, 0, 35, 135);    ellipse(0, 0, 35, 140);    ellipse(-24, +5, 35, 150);    ellipse(+24, +10, 49, 150);    noStroke();    rect(0, 0, 70, 70);    stroke(100);    arc(0, -35, 35, 70, radians(-180), radians(0));    arc(+50, -33, 35, 73, radians(-180), radians(20));    arc(+27, -30, 44, 75, radians(-180), radians(18));    arc(-17, -35, 45, 70, radians(-190), radians(0));    // funnyFace    // glasses    strokeWeight(5);    ellipse(-17, -8, 27, 27);    ellipse(+17, -5, 27, 27);    line(-5, -8, +4, -8);    line(+29, -8, +60, -15);    line(-30, -15, -40, -20);    // eyes    strokeWeight(1);    fill(0);    ellipse(-17, -8, 10, 10);    ellipse(+17, -5, 10, 10);    fill(255, 0, 10);    // mouth    arc(0, +10, 35, 40, radians(0), radians(180));    popMatrix();}',correct
'int yp',correct
'c1 = new Creature(width / 2, height / 2)',correct
'toothX += speedX;',correct
'ellipse(+17, -5, 27, 27);',correct
'void',correct
'theeth[3]',correct
'-1',correct
'c6 = new Creature(width / 5, height / 4)',correct
'rect(0, 0, 70, 80);',correct
'theeth[i].goThere();',correct
'-5',correct
'new Creature(width / 3, height / 6)',correct
'+20',correct
'new Creature(width / 2, height / 2)',correct
'-8',correct
'// funnyFace// glassesstrokeWeight(5);',correct
'+24',correct
'r += 1',correct
'-190',correct
'{    c1.test();    c2.test();    c3.test();    c4.test();    c5.test();    c6.test();}',correct
'+27',correct
'+29',correct
'toothY += speedY',correct
'speedY = speedY * -1;',correct
'{    speedX = 0;    speedY = 0;    // now the coordinate system rotates and the tooth rotates around itself    rotate(radians(r));    r += 1;    // random color change    bodyColor = color(random(255), random(255), random(255));}',correct
'true',correct
'int xp',correct
'c2.test();',correct
'c3.update()',correct
'quad(+20, +50, +50, +30, +60, -30, +10, -20)',correct
'arc(+50, -33, 35, 73, radians(-180), radians(20))',correct
'popMatrix()',correct
'line(-30, -15, -40, -20)',correct
'rect(0, 0, 70, 70);',correct
'fill(255, 0, 10)',correct
'+30',correct
'c2.goCrazy();',correct
'rect(0, 0, 70, 70)',correct
'bodyColor = color(255)',correct
'c1.goNormal()',correct
'line(-5, -8, +4, -8);',correct
'line(+29, -8, +60, -15);',correct
'strokeWeight(5)',correct
'dist(mouseX, mouseY, toothX, toothY)',correct
'arc(0, -35, 35, 70, radians(-180), radians(0));',correct
'c4.display()',correct
'ellipse(+50, 0, 35, 135)',correct
'c2 = new Creature(width / 3, height / 2)',correct
'theeth[5]',correct
'ellipse(+24, +10, 49, 150);',correct
'speedY = 0',correct
'ellipse(-17, -8, 10, 10);',correct
'rect(0, 0, 70, 80)',correct
'c5.test();',correct
'r += 1;',correct
'width / 2',correct
'toothY <= 0',correct
'toothX = xp',correct
'bodyColor = color(random(255), random(255), random(255))',correct
'c6.update()',correct
'c4 = new Creature(width / 9, height / 2);',correct
'c4.goCrazy();',correct
'c3.update();',correct
'c3.goCrazy()',correct
'c3.test()',correct
'width / 9',correct
'width / 3',correct
'theeth[4] = c5;',correct
'width / 5',correct
'line(-5, -8, +4, -8)',correct
'{    yvector = abs(yvector);}',correct
'eyeRight.trackMouse(xpos + 60, ypos + 15)',correct
'Creature',correct
'Eye',correct
'for (int i = 0; i < flock.length; i++) {    flock[i].display();    flock[i].move();    flock[i].checkBorder();}',correct
'yposOriginal - 5',correct
'eyeLeft.revertColor();',correct
'random(innerBorderX, outerBorderX)',correct
'{    flock[i] = new Creature(random(innerBorderX, outerBorderX), random(innerBorderY, outerBorderY), random(-1, 1), random(-1, 1));}',correct
'{    flock[i].click();}',correct
'void revertColor() {    eyeColor = color(60);}',correct
'Time >= TWO_PI',correct
'float posX',correct
'float posY',correct
'void release() {    glasses = color(60);    eyeLeft.revertColor();    eyeRight.revertColor();}',correct
'float xposEye;',correct
'xpos = xpos + 5 * xvector',correct
'{    flock[i].display();    flock[i].move();    flock[i].checkBorder();}',correct
'strokeWeight(1);',correct
'eyeRight = new Eye();',correct
'flock[i].display();',correct
'Time = 0;',DrawingStateChangeRule
'ypos - 30',correct
'strokeWeight(6)',correct
'-abs(xvector)',correct
'eyeLeft.changeColor()',correct
'constrain(xMouse, xposOriginal - 10, xposOriginal + 10)',correct
'xMouse',correct
'yposEye = constrain(yMouse, yposOriginal - 5, yposOriginal + 5)',correct
'bg = color(255)',correct
'{    flock[i].release();}',correct
'innerBorderX',correct
'xposEye = constrain(xMouse, xposOriginal - 10, xposOriginal + 10);',correct
'innerBorderY',correct
'Creature[] flock;',correct
'float outerBorderX;',correct
'Creature(float posX, float posY, float vectorX, float vectorY) {    xpos = posX;    ypos = posY;    xvector = vectorX;    yvector = vectorY;    glasses = color(60);    bg = color(255);    eyeLeft = new Eye();    eyeRight = new Eye();}',correct
'constrain(yMouse, yposOriginal - 5, yposOriginal + 5)',correct
'{    eyeColor = color(255);}',correct
'void display() {    stroke(90);    strokeWeight(6);    ypos = ypos + (2 * timeOffset);    fill(glasses);    line(xpos - 20, ypos, xpos + 20, ypos);    rect(xpos - 60, ypos + 15, 80, 60, 5);    rect(xpos + 60, ypos + 15, 80, 60, 5);    fill(255);    triangle(xpos, ypos - 30, (xpos + 20) + (5 * timeOffset), (ypos - 80) + (8 * timeOffset), (xpos + 100) + (8 * timeOffset), (ypos - 100) + (10 * timeOffset));    stroke(255);    strokeWeight(1);    arc(xpos - 60, ypos + 5, 40, 40, ((1 / 6) * PI), (PI + ((5 / 6) * PI)));    arc(xpos + 60, ypos + 5, 40, 40, ((1 / 6) * PI), (PI + ((5 / 6) * PI)));    eyeLeft.trackMouse(xpos - 60, ypos + 15);    eyeRight.trackMouse(xpos + 60, ypos + 15);    eyeLeft.display();    eyeRight.display();}',correct
'flock[i].checkBorder();',correct
'(Creature[]) expand(flock, flock.length + 1)',correct
'eyeRight.changeColor();',correct
'{    background(bg);    for (int i = 0; i < flock.length; i++) {        flock[i].display();        flock[i].move();        flock[i].checkBorder();    }    if (Time >= TWO_PI) {        Time = 0;    }    Time += 0.1f;    xMouse = mouseX;    yMouse = mouseY;    timeOffset = sin(Time);}',correct
'arc(xpos + 60, ypos + 5, 40, 40, ((1 / 6) * PI), (PI + ((5 / 6) * PI)))',correct
'xvector = vectorX',correct
'rectMode(CENTER)',correct
'eyeLeft.revertColor()',correct
'i < flock.length',correct
'void draw() {    background(bg);    for (int i = 0; i < flock.length; i++) {        flock[i].display();        flock[i].move();        flock[i].checkBorder();    }    if (Time >= TWO_PI) {        Time = 0;    }    Time += 0.1f;    xMouse = mouseX;    yMouse = mouseY;    timeOffset = sin(Time);}',correct
'line(xpos - 20, ypos, xpos + 20, ypos);',correct
'timeOffset',correct
'{    stroke(90);    strokeWeight(6);    ypos = ypos + (2 * timeOffset);    fill(glasses);    line(xpos - 20, ypos, xpos + 20, ypos);    rect(xpos - 60, ypos + 15, 80, 60, 5);    rect(xpos + 60, ypos + 15, 80, 60, 5);    fill(255);    triangle(xpos, ypos - 30, (xpos + 20) + (5 * timeOffset), (ypos - 80) + (8 * timeOffset), (xpos + 100) + (8 * timeOffset), (ypos - 100) + (10 * timeOffset));    stroke(255);    strokeWeight(1);    arc(xpos - 60, ypos + 5, 40, 40, ((1 / 6) * PI), (PI + ((5 / 6) * PI)));    arc(xpos + 60, ypos + 5, 40, 40, ((1 / 6) * PI), (PI + ((5 / 6) * PI)));    eyeLeft.trackMouse(xpos - 60, ypos + 15);    eyeRight.trackMouse(xpos + 60, ypos + 15);    eyeLeft.display();    eyeRight.display();}',correct
'rect(xpos + 60, ypos + 15, 80, 60, 5)',correct
'yposOriginal = posY;',correct
'{    glasses = color(255);    eyeLeft.changeColor();    eyeRight.changeColor();}',correct
'eyeLeft = new Eye()',correct
'eyeColor = color(255)',correct
'float ypos;',correct
'rectMode(CENTER);',correct
'flock[i].release()',correct
'ypos <= innerBorderY',correct
'eyeLeft.display();',correct
'innerBorderY = 100;',correct
'flock[flock.length - 1]',correct
'stroke(eyeColor);',correct
'yvector = abs(yvector);',correct
'background(bg)',correct
'ypos + (2 * timeOffset)',correct
'int bg = color(255);',ShortVariable
'(xpos + 20) + (5 * timeOffset)',correct
'yposOriginal + 5',correct
'sin(Time)',correct
'ypos + 5 * yvector',correct
'color(60)',correct
'ypos = ypos + (2 * timeOffset)',correct
'eyeRight.display()',correct
'new Creature[1]',correct
'yvector = -abs(yvector);',correct
'eyeLeft.trackMouse(xpos - 60, ypos + 15);',correct
'void trackMouse(float posX, float posY) {    xposOriginal = posX;    yposOriginal = posY;    xposEye = constrain(xMouse, xposOriginal - 10, xposOriginal + 10);    yposEye = constrain(yMouse, yposOriginal - 5, yposOriginal + 5);}',correct
'random(innerBorderY, outerBorderY)',correct
'yposOriginal = posY',correct
'yMouse = mouseY;',DecentralizedEventHandlingRule
'void mouseReleased() {    for (int i = 0; i < flock.length; i++) {        flock[i].release();    }    bg = color(255);}',correct
'bg = color(255);',correct
'new Eye()',correct
'yvector = vectorY',correct
'xpos = posX;',correct
'yposEye',correct
'Time = 0',correct
'(ypos - 100) + (10 * timeOffset)',correct
'line(xpos - 20, ypos, xpos + 20, ypos)',correct
'xvector',correct
'eyeLeft.display()',correct
'glasses = color(255);',correct
'background(bg);',correct
'0.1f',correct
'class Creature {    float xpos;    float ypos;    float xvector;    float yvector;    int glasses;    Eye eyeLeft;    Eye eyeRight;    Creature(float posX, float posY, float vectorX, float vectorY) {        xpos = posX;        ypos = posY;        xvector = vectorX;        yvector = vectorY;        glasses = color(60);        bg = color(255);        eyeLeft = new Eye();        eyeRight = new Eye();    }    void display() {        stroke(90);        strokeWeight(6);        ypos = ypos + (2 * timeOffset);        fill(glasses);        line(xpos - 20, ypos, xpos + 20, ypos);        rect(xpos - 60, ypos + 15, 80, 60, 5);        rect(xpos + 60, ypos + 15, 80, 60, 5);        fill(255);        triangle(xpos, ypos - 30, (xpos + 20) + (5 * timeOffset), (ypos - 80) + (8 * timeOffset), (xpos + 100) + (8 * timeOffset), (ypos - 100) + (10 * timeOffset));        stroke(255);        strokeWeight(1);        arc(xpos - 60, ypos + 5, 40, 40, ((1 / 6) * PI), (PI + ((5 / 6) * PI)));        arc(xpos + 60, ypos + 5, 40, 40, ((1 / 6) * PI), (PI + ((5 / 6) * PI)));        eyeLeft.trackMouse(xpos - 60, ypos + 15);        eyeRight.trackMouse(xpos + 60, ypos + 15);        eyeLeft.display();        eyeRight.display();    }    void move() {        xpos = xpos + 5 * xvector;        ypos = ypos + 5 * yvector;    }    void checkBorder() {        if (xpos <= innerBorderX) {            xvector = abs(xvector);        }        if (xpos >= outerBorderX) {            xvector = -abs(xvector);        }        if (ypos <= innerBorderY) {            yvector = abs(yvector);        }        if (ypos >= outerBorderY) {            yvector = -abs(yvector);        }    }    void click() {        glasses = color(255);        eyeLeft.changeColor();        eyeRight.changeColor();    }    void release() {        glasses = color(60);        eyeLeft.revertColor();        eyeRight.revertColor();    }}',correct
'eyeRight.display();',correct
'fill(255)',correct
'Processing',correct
'xpos - 60',correct
'flock[i].click()',correct
'bg = color(0)',correct
'flock[i].move();',correct
'{    glasses = color(60);    eyeLeft.revertColor();    eyeRight.revertColor();}',correct
'eyeLeft',correct
'flock[i].display()',correct
'float vectorX',correct
'xvector = -abs(xvector);',correct
'float vectorY',correct
'xMouse = mouseX',correct
'eyeRight.changeColor()',correct
'xpos',correct
'outerBorderX',correct
'outerBorderY',correct
'class Eye {    float xposEye;    float yposEye;    float xposOriginal;    float yposOriginal;    int eyeColor;    Eye() {        eyeColor = color(60);    }    void display() {        yposEye = yposEye + (2 * timeOffset);        fill(eyeColor);        stroke(eyeColor);        ellipse(xposEye, yposEye, 10, 10);    }    void trackMouse(float posX, float posY) {        xposOriginal = posX;        yposOriginal = posY;        xposEye = constrain(xMouse, xposOriginal - 10, xposOriginal + 10);        yposEye = constrain(yMouse, yposOriginal - 5, yposOriginal + 5);    }    void changeColor() {        eyeColor = color(255);    }    void revertColor() {        eyeColor = color(60);    }}',correct
'xposEye',correct
'xposOriginal + 10',correct
'outerBorderY = height - 100;',correct
'flock[flock.length - 1] = new Creature(xMouse, yMouse, random(-1, 1), random(-1, 1));',correct
'ypos + 5',correct
'ellipse(xposEye, yposEye, 10, 10);',correct
'int i = 0',correct
'if (ypos <= innerBorderY) {    yvector = abs(yvector);}',correct
'float xvector;',correct
'flock[i] = new Creature(random(innerBorderX, outerBorderX), random(innerBorderY, outerBorderY), random(-1, 1), random(-1, 1));',correct
'stroke(255)',correct
'yMouse = mouseY',correct
'abs(xvector)',correct
'flock.length',correct
'i = 0',correct
'ypos',correct
'eyeLeft.changeColor();',correct
'color(255)',correct
'xvector = -abs(xvector)',correct
'flock[flock.length - 1] = new Creature(xMouse, yMouse, random(-1, 1), random(-1, 1))',correct
'expand(flock, flock.length + 1)',correct
'ypos >= outerBorderY',correct
'5 * yvector',correct
'void checkBorder() {    if (xpos <= innerBorderX) {        xvector = abs(xvector);    }    if (xpos >= outerBorderX) {        xvector = -abs(xvector);    }    if (ypos <= innerBorderY) {        yvector = abs(yvector);    }    if (ypos >= outerBorderY) {        yvector = -abs(yvector);    }}',correct
'int eyeColor;',correct
'float xposOriginal;',correct
'outerBorderX = width - 100',correct
'flock = new Creature[1];',correct
'float yposOriginal;',correct
'float timeOffset;',correct
'yvector',correct
'if (Time >= TWO_PI) {    Time = 0;}',correct
'outerBorderX = width - 100;',correct
'{    for (int i = 0; i < flock.length; i++) {        flock[i].click();    }    flock = (Creature[]) expand(flock, flock.length + 1);    flock[flock.length - 1] = new Creature(xMouse, yMouse, random(-1, 1), random(-1, 1));    bg = color(0);}',correct
'void changeColor() {    eyeColor = color(255);}',correct
'ypos = ypos + 5 * yvector',correct
'arc(xpos - 60, ypos + 5, 40, 40, ((1 / 6) * PI), (PI + ((5 / 6) * PI)))',correct
'flock[i] = new Creature(random(innerBorderX, outerBorderX), random(innerBorderY, outerBorderY), random(-1, 1), random(-1, 1))',correct
'xvector = vectorX;',correct
'innerBorderY = 100',correct
'Eye() {    eyeColor = color(60);}',correct
'xposOriginal - 10',correct
'flock[i].checkBorder()',correct
'Eye eyeRight;',correct
'ypos + 15',correct
'xposOriginal',correct
'xpos = xpos + 5 * xvector;',correct
'xMouse = mouseX;',DecentralizedEventHandlingRule
'fill(glasses)',correct
'void setup() {    innerBorderX = 100;    outerBorderX = width - 100;    innerBorderY = 100;    outerBorderY = height - 100;    rectMode(CENTER);    flock = new Creature[1];    for (int i = 0; i < flock.length; i++) {        flock[i] = new Creature(random(innerBorderX, outerBorderX), random(innerBorderY, outerBorderY), random(-1, 1), random(-1, 1));    }}',correct
'flock',correct
'eyeRight.revertColor();',correct
'rect(xpos + 60, ypos + 15, 80, 60, 5);',correct
'yMouse',correct
'strokeWeight(1)',correct
'eyeRight = new Eye()',correct
'void display() {    yposEye = yposEye + (2 * timeOffset);    fill(eyeColor);    stroke(eyeColor);    ellipse(xposEye, yposEye, 10, 10);}',correct
'flock.length + 1',correct
'xvector = abs(xvector)',correct
'(ypos - 80) + (8 * timeOffset)',correct
'rect(xpos - 60, ypos + 15, 80, 60, 5)',correct
'eyeColor = color(60)',correct
'{    yposEye = yposEye + (2 * timeOffset);    fill(eyeColor);    stroke(eyeColor);    ellipse(xposEye, yposEye, 10, 10);}',correct
'glasses',correct
'stroke(90)',correct
'eyeColor',correct
'xpos - 20',correct
'triangle(xpos, ypos - 30, (xpos + 20) + (5 * timeOffset), (ypos - 80) + (8 * timeOffset), (xpos + 100) + (8 * timeOffset), (ypos - 100) + (10 * timeOffset))',correct
'ypos = posY;',correct
'triangle(xpos, ypos - 30, (xpos + 20) + (5 * timeOffset), (ypos - 80) + (8 * timeOffset), (xpos + 100) + (8 * timeOffset), (ypos - 100) + (10 * timeOffset));',correct
'glasses = color(60);',correct
'color(0)',correct
'flock = (Creature[]) expand(flock, flock.length + 1);',correct
'eyeLeft.trackMouse(xpos - 60, ypos + 15)',correct
'Creature[]',correct
'yposEye + (2 * timeOffset)',correct
'eyeColor = color(255);',correct
'for (int i = 0; i < flock.length; i++) {    flock[i].release();}',correct
'xpos + 20',correct
'{    yvector = -abs(yvector);}',correct
'xposOriginal = posX;',correct
'if (ypos >= outerBorderY) {    yvector = -abs(yvector);}',correct
'Eye eyeLeft;',correct
'yvector = vectorY;',correct
'strokeWeight(6);',correct
'-abs(yvector)',correct
'yposEye = yposEye + (2 * timeOffset)',correct
'{    Time = 0;}',correct
'yposEye = yposEye + (2 * timeOffset);',correct
'5 * xvector',correct
'stroke(90);',correct
'for (int i = 0; i < flock.length; i++) {    flock[i] = new Creature(random(innerBorderX, outerBorderX), random(innerBorderY, outerBorderY), random(-1, 1), random(-1, 1));}',correct
'float yposEye;',correct
'width - 100',correct
'xpos <= innerBorderX',correct
'fill(eyeColor);',correct
'void click() {    glasses = color(255);    eyeLeft.changeColor();    eyeRight.changeColor();}',correct
'outerBorderY = height - 100',correct
'random(-1, 1)',correct
'flock = new Creature[1]',correct
'arc(xpos + 60, ypos + 5, 40, 40, ((1 / 6) * PI), (PI + ((5 / 6) * PI)));',correct
'innerBorderX = 100;',correct
'yposOriginal',correct
'float innerBorderY;',correct
'eyeRight.revertColor()',correct
'i++',correct
'yposEye = constrain(yMouse, yposOriginal - 5, yposOriginal + 5);',correct
'{    xvector = -abs(xvector);}',correct
'eyeLeft = new Eye();',correct
'for (int i = 0; i < flock.length; i++) {    flock[i].click();}',correct
'fill(255);',correct
'Time += 0.1f',correct
'xposOriginal = posX',correct
'ellipse(xposEye, yposEye, 10, 10)',correct
'flock[i].click();',correct
'flock[i]',correct
'glasses = color(60)',correct
'flock[i].release();',correct
'flock = (Creature[]) expand(flock, flock.length + 1)',correct
'float yMouse;',correct
'void',correct
'int glasses;',correct
'-1',correct
'float innerBorderX;',correct
'float Time = 0;',VariableNamingConventions
'stroke(eyeColor)',correct
'{    if (xpos <= innerBorderX) {        xvector = abs(xvector);    }    if (xpos >= outerBorderX) {        xvector = -abs(xvector);    }    if (ypos <= innerBorderY) {        yvector = abs(yvector);    }    if (ypos >= outerBorderY) {        yvector = -abs(yvector);    }}',correct
'yvector = abs(yvector)',correct
'{    for (int i = 0; i < flock.length; i++) {        flock[i].release();    }    bg = color(255);}',correct
'rect(xpos - 60, ypos + 15, 80, 60, 5);',correct
'{    innerBorderX = 100;    outerBorderX = width - 100;    innerBorderY = 100;    outerBorderY = height - 100;    rectMode(CENTER);    flock = new Creature[1];    for (int i = 0; i < flock.length; i++) {        flock[i] = new Creature(random(innerBorderX, outerBorderX), random(innerBorderY, outerBorderY), random(-1, 1), random(-1, 1));    }}',correct
'float outerBorderY;',correct
'Time += 0.1f;',DrawingStateChangeRule
'xvector = abs(xvector);',correct
'new Creature(xMouse, yMouse, random(-1, 1), random(-1, 1))',correct
'ypos = ypos + (2 * timeOffset);',correct
'(xpos + 100) + (8 * timeOffset)',correct
'xpos = posX',correct
'if (xpos <= innerBorderX) {    xvector = abs(xvector);}',correct
'flock.length - 1',correct
'abs(yvector)',correct
'float yvector;',correct
'timeOffset = sin(Time)',correct
'height - 100',correct
'fill(eyeColor)',correct
'void move() {    xpos = xpos + 5 * xvector;    ypos = ypos + 5 * yvector;}',correct
'xpos + 5 * xvector',correct
'ypos = ypos + 5 * yvector;',correct
'flock[i].move()',correct
'stroke(255);',correct
'xpos >= outerBorderX',correct
'float xpos;',correct
'if (xpos >= outerBorderX) {    xvector = -abs(xvector);}',correct
'eyeRight.trackMouse(xpos + 60, ypos + 15);',correct
'{    eyeColor = color(60);}',correct
'{    xposOriginal = posX;    yposOriginal = posY;    xposEye = constrain(xMouse, xposOriginal - 10, xposOriginal + 10);    yposEye = constrain(yMouse, yposOriginal - 5, yposOriginal + 5);}',correct
'{    xpos = posX;    ypos = posY;    xvector = vectorX;    yvector = vectorY;    glasses = color(60);    bg = color(255);    eyeLeft = new Eye();    eyeRight = new Eye();}',correct
'eyeRight',correct
'eyeColor = color(60);',correct
'void mousePressed() {    for (int i = 0; i < flock.length; i++) {        flock[i].click();    }    flock = (Creature[]) expand(flock, flock.length + 1);    flock[flock.length - 1] = new Creature(xMouse, yMouse, random(-1, 1), random(-1, 1));    bg = color(0);}',correct
'bg = color(0);',correct
'glasses = color(255)',correct
'float xMouse;',correct
'[1]',correct
'{    xpos = xpos + 5 * xvector;    ypos = ypos + 5 * yvector;}',correct
'arc(xpos - 60, ypos + 5, 40, 40, ((1 / 6) * PI), (PI + ((5 / 6) * PI)));',correct
'xpos + 60',correct
'ypos = posY',correct
'xposEye = constrain(xMouse, xposOriginal - 10, xposOriginal + 10)',correct
'new Creature(random(innerBorderX, outerBorderX), random(innerBorderY, outerBorderY), random(-1, 1), random(-1, 1))',correct
'{    xvector = abs(xvector);}',correct
'yvector = -abs(yvector)',correct
'timeOffset = sin(Time);',DrawingStateChangeRule
'innerBorderX = 100',correct
'fill(glasses);',correct
'ghostCreature2 = new Ghost(screenWidth * .75f, screenHeight * .5f, color(15, 20, 40), color(235, 240, 250), 100)',correct
'// Destroy itself upon inpact, add to the appropriate score and change the size of the ghost it collided with to make collisions more visually appealingbullets.remove(bullets.indexOf(this));',correct
'new Ghost(screenWidth * .75f, screenHeight * .5f, color(15, 20, 40), color(235, 240, 250), 100)',correct
'// spikestriangle(creatureX - creatureSize * .5f, creatureY + creatureSize * .5f, creatureX + creatureSize * .5f, creatureY + creatureSize * .5f, creatureX - horizontalDirection * offset * .5f, creatureY + creatureSize * .75f);',correct
'screenWidth - 32',correct
'fill(starColor)',correct
'// Determine color based on teamint bulletColor;',correct
'// scores for the two ghost teamsint scoreBlack = 0, scoreWhite = 0;',correct
'// METHODS// Updatingvoid update() {    // Move    move();    // Warp around the screen Pacman style    warpScreen(screenWidth, screenHeight);    // Update the shoot timer    updateShoot();    // Update the size if needed    updateSize();}',correct
'destroy()',correct
'{    // Check team to determine which ghost it should look for collisions with    if (team == 1) {        if (isOver(ghostCreature2.creatureX, ghostCreature2.creatureY)) {            // Destroy itself upon inpact, add to the appropriate score and change the size of the ghost it collided with to make collisions more visually appealing            bullets.remove(bullets.indexOf(this));            scoreWhite++;            ghostCreature2.changeSize(-20);        }    } else {        if (isOver(ghostCreature1.creatureX, ghostCreature1.creatureY)) {            // Destroy itself upon inpact, add to the appropriate score and change the size of the ghost it collided with to make collisions more visually appealing            bullets.remove(bullets.indexOf(this));            scoreBlack++;            ghostCreature1.changeSize(-20);        }    }}',correct
'scoreBlack = 0',correct
'{    // Warp to the opposite side of the screen if offscreen    if (creatureX > screenWidth + creatureSize)        creatureX = -creatureSize;    if (creatureX < -creatureSize)        creatureX = screenWidth + creatureSize;    if (creatureY > screenHeight + creatureSize)        creatureY = -creatureSize;    if (creatureY < -creatureSize)        creatureY = screenHeight + creatureSize;}',correct
'{    Bullet bullet = bullets.get(i);    bullet.display();}',correct
'displayFace',correct
'ghostCreature2.input(3, 1);',correct
'ghostCreature1.creatureY >= ghostCreature2.creatureY',correct
'if ((key == D) || (key == d))    ghostCreature1.input(3, 1);',correct
'',correct
'text("ARROW KEYS | L - move | shoot black ghost", 8, 64);',correct
'shootTimer = 0;',correct
'// VARIABLES// position and sizefloat starX, starY, starSize;',correct
'ghostCreature1.horizontalDirection',correct
'ghostCreature1.changeSize(-20)',correct
'ArrayList<Bullet>',correct
'// direction of movementint horizontalDirection, verticalDirection;',correct
'bulletX = initX',correct
'bullets.add(new Bullet(initX, initY, initSize, initHorSpeed, initVertSpeed, initTeam))',correct
'changeSize(20);',correct
'bullets.remove(bullets.indexOf(this))',correct
'" points for the white team"',correct
'random(32, screenHeight - 32)',correct
'creatureBodyColor = initBodyColor',correct
'{    // Move the bullet    bulletX += horizontalSpeed;    bulletY += verticalSpeed;    // Destroy the bullet if its off screen    destroy();    // Check for collision with the ghosts    ghostCollide();    // Flicker the size    sizeChange *= -1;}',correct
'random(2, 8)',correct
'// variable to offset the eyes/mouth/spikes according to the direction of movementint offset;',correct
'new Star(random(32, screenWidth - 32), random(32, screenHeight - 32), random(2, 8))',correct
'screenHeight - 32',correct
'[4]',correct
'creatureX',correct
'fill(creatureBodyColor)',correct
'creatureY',correct
'// Update the sizevoid updateSize() {    // Smoothly go back to the original size of 100 if weve changed it    if (creatureSize < 100)        creatureSize++;    else if (creatureSize > 100)        creatureSize--;}',correct
'ellipse(creatureX - creatureSize * .25f + horizontalDirection * offset, creatureY + verticalDirection * offset, creatureSize * .2f, creatureSize * .25f)',correct
'{    if (isOver(ghostCreature1.creatureX, ghostCreature1.creatureY)) {        // Destroy itself upon inpact, add to the appropriate score and change the size of the ghost it collided with to make collisions more visually appealing        bullets.remove(bullets.indexOf(this));        scoreBlack++;        ghostCreature1.changeSize(-20);    }}',correct
'// shooting ghost 1if (key ==  )    ghostCreature1.shoot(ghostCreature1.creatureX, ghostCreature1.creatureY + 25, 75, ghostCreature1.horizontalDirection * 15, ghostCreature1.verticalDirection * 15, 1);',correct
'ghostCreature1.input(1, 1)',correct
'ghostCreature2 = new Ghost(screenWidth * .75f, screenHeight * .5f, color(15, 20, 40), color(235, 240, 250), 100);',correct
'ghostCreature2.input(1, 1)',correct
'(key == S) || (key == s)',correct
'if ((key == D) || (key == d))    ghostCreature1.input(3, 0);',correct
'offset = creatureSize / 10',correct
'// Check for collision with the ghostsghostCollide();',correct
'ghostCreature2.input(3, 0);',correct
'bullet.display();',correct
'text("WASD | SPACE - move | shoot white ghost", 8, 24)',correct
'shootTimer',correct
'creatureX = initX;',correct
'// METHODS// Displayvoid display() {    // Determine color based on team    int bulletColor;    if (team == 1)        bulletColor = color(235, 240, 250);    else        bulletColor = color(15, 20, 40);    // Draw the bullet    fill(bulletColor);    ellipse(bulletX, bulletY, bulletSize, bulletSize + sizeChange);}',correct
'{    keys[keyIn] = keyValue;}',correct
'// Update the size if neededupdateSize();',correct
'// CREATURE PROJECT BY FILIP IVANOV s2096935',correct
'{    creatureSize += sizeChange;}',correct
'verticalSpeed = initVertSpeed',correct
'creatureSize * .25f',correct
'bullets.size()',correct
'// Display bulletsfor (int i = 0; i < bullets.size(); i++) {    Bullet bullet = bullets.get(i);    bullet.display();}',correct
'ghostCreature2.verticalDirection * 15',correct
'{    stars[i].display();}',correct
'// CONSTRUCTORSBullet(float initX, float initY, float initSize, float initHorSpeed, float initVertSpeed, int initTeam) {    bulletX = initX;    bulletY = initY;    bulletSize = initSize;    horizontalSpeed = initHorSpeed;    verticalSpeed = initVertSpeed;    team = initTeam;}',correct
'(key == A) || (key == a)',correct
'ghostCreature1.input(1, 0)',correct
'ghostCreature2.input(1, 0)',correct
'new Bullet(initX, initY, initSize, initHorSpeed, initVertSpeed, initTeam)',correct
'fill(color(255, 255, 255))',correct
'// Destroyvoid destroy() {    // Destroy if the bullet is off screen    if ((bulletX > screenWidth + 100) || (bulletX < -100) || (bulletY > screenHeight + 100) || (bulletY < -100))        bullets.remove(bullets.indexOf(this));}',correct
'i < bullets.size()',correct
'ellipse(creatureX + horizontalDirection * offset, creatureY + creatureSize * .25f + verticalDirection * offset, creatureSize * .1f, creatureSize * .1f)',correct
'ghostCreature1.display()',correct
'// Timer so you cant spam shootingint shootTimer;',correct
'shootTimer = 0',correct
'if ((key == A) || (key == a))    ghostCreature1.input(2, 1);',IfStmtsMustUseBraces
'creatureX < -creatureSize',correct
'creatureY += verticalDirection * movementSpeed',correct
'ghostCreature1.input(0, 1);',correct
'horizontalDirection',correct
'bullet = bullets.get(i)',correct
'creatureX > screenWidth + creatureSize',IfStmtsMustUseBraces
'screenHeight - 48',correct
'{    ghostCreature1.display();    ghostCreature2.display();}',correct
'{    fill(creatureFaceColor);    // eyes    ellipse(creatureX - creatureSize * .25f + horizontalDirection * offset, creatureY + verticalDirection * offset, creatureSize * .2f, creatureSize * .25f);    ellipse(creatureX + creatureSize * .25f + horizontalDirection * offset, creatureY + verticalDirection * offset, creatureSize * .2f, creatureSize * .25f);    // mouth    ellipse(creatureX + horizontalDirection * offset, creatureY + creatureSize * .25f + verticalDirection * offset, creatureSize * .1f, creatureSize * .1f);}',correct
'{    // Destroy itself upon inpact, add to the appropriate score and change the size of the ghost it collided with to make collisions more visually appealing    bullets.remove(bullets.indexOf(this));    scoreBlack++;    ghostCreature1.changeSize(-20);}',correct
'{    // Determine color based on team    int bulletColor;    if (team == 1)        bulletColor = color(235, 240, 250);    else        bulletColor = color(15, 20, 40);    // Draw the bullet    fill(bulletColor);    ellipse(bulletX, bulletY, bulletSize, bulletSize + sizeChange);}',correct
'rect(creatureX - creatureSize * .5f, creatureY, creatureSize, creatureSize * .5f)',correct
'{    if (keyCode == UP)        ghostCreature2.input(0, 0);    if (keyCode == DOWN)        ghostCreature2.input(1, 0);    if (keyCode == LEFT)        ghostCreature2.input(2, 0);    if (keyCode == RIGHT)        ghostCreature2.input(3, 0);}',correct
'ghostCreature2.input(0, 0);',correct
'ghostCollide()',correct
'ghostCreature2',correct
'stars[i].display();',correct
'ghostCreature1',correct
'{    Bullet bullet = bullets.get(i);    bullet.update();}',correct
'// CREATURE PROJECT BY FILIP IVANOV s2096935// resolutionint screenWidth = 1280, screenHeight = 720;',correct
'shootTimer--',correct
'ghostCreature2.shoot(ghostCreature2.creatureX, ghostCreature2.creatureY + 25, 75, ghostCreature2.horizontalDirection * 15, ghostCreature2.verticalDirection * 15, 2)',correct
'color(235, 240, 250)',correct
'// Display the facedisplayFace();',correct
'starColor = color(70, 115, 155)',correct
'ellipse(starX, starY, starSize, starSize);',correct
'ghostCreature1.horizontalDirection * 15',correct
'" points for the black team"',correct
'fill(creatureBodyColor);',correct
'isOver',correct
'bulletX += horizontalSpeed',correct
'{    if (!((horizontalDirection == 0) && (verticalDirection == 0))) {        bullets.add(new Bullet(initX, initY, initSize, initHorSpeed, initVertSpeed, initTeam));        shootTimer = PApplet.parseInt(frameRate) / 3;        changeSize(20);    }}',correct
'screenWidth * .25f',correct
'// Adjust the order of drawing of the ghosts to give the illusion of 3D space (the lower ghost appears "on top" of the higher one)if (ghostCreature1.creatureY >= ghostCreature2.creatureY) {    ghostCreature2.display();    ghostCreature1.display();} else {    ghostCreature1.display();    ghostCreature2.display();}',correct
'horizontalSpeed = initHorSpeed',correct
'ghostCreature2.input(0, 0)',correct
'creatureX = initX',correct
'move()',correct
'int backgroundColor = color(45, 55, 85)',correct
'bulletSize = initSize;',correct
'// STAR CLASSclass Star {    // VARIABLES    // position and size    float starX, starY, starSize;    // CONSTRUCTORS    Star(float initX, float initY, float initSize) {        starX = initX;        starY = initY;        starSize = initSize;    }    // METHODS    // Display    void display() {        int starColor = color(70, 115, 155);        fill(starColor);        ellipse(starX, starY, starSize, starSize);    }}',correct
'shootTimer > 0',correct
'Processing',correct
'if ((key == A) || (key == a))    ghostCreature1.input(2, 0);',correct
'bullets.indexOf(this)',correct
'stars[i]',correct
'starY = initY',correct
'verticalDirection = keys[1] - keys[0]',correct
'// an array of 100 star objectsStar[] stars = new Star[100];',correct
'ghostCreature1.input(0, 0);',IfStmtsMustUseBraces
'ghostCreature1.input(2, 1)',correct
'int screenWidth',correct
'ghostCreature2.horizontalDirection',correct
'new ArrayList<Bullet>()',correct
'ghostCreature2.input(0, 1)',correct
'creatureY + creatureSize * .25f',correct
'if (dist(bulletX, bulletY, collisionX, collisionY) < bulletSize)    return true;else    return false;',IfElseStmtsMustUseBraces
'false',correct
'warpScreen(screenWidth, screenHeight)',correct
'creatureBodyColor = initBodyColor;',correct
'ghostCreature1.input(2, 0)',correct
'scoreWhite + " points for the white team"',correct
'setup',correct
'scoreWhite++;',DrawingStateChangeRule
'starX = initX;',correct
'i = 0',correct
'ghostCreature2.update()',correct
'if (creatureSize > 100)    creatureSize--;',IfStmtsMustUseBraces
'ghostCreature2.input(2, 1);',correct
'// VARIABLES',correct
'ellipse(creatureX + creatureSize * .25f + horizontalDirection * offset, creatureY + verticalDirection * offset, creatureSize * .2f, creatureSize * .25f);',correct
'ellipse(creatureX, creatureY, creatureSize, creatureSize)',correct
'creatureSize',correct
'horizontalSpeed = initHorSpeed;',correct
'bulletY += verticalSpeed;',correct
'{    creatureX = initX;    creatureY = initY;    creatureBodyColor = initBodyColor;    creatureFaceColor = initFaceColor;    creatureSize = initCreatureSize;    offset = creatureSize / 10;}',correct
'creatureY = screenHeight + creatureSize;',correct
'creatureSize++;',IfElseStmtsMustUseBraces
'color(70, 115, 155)',correct
'keys[keyIn] = keyValue',correct
'background(backgroundColor)',correct
'int sizeChange',correct
'stars[i] = new Star(random(32, screenWidth - 32), random(32, screenHeight - 32), random(2, 8))',correct
'// GHOST CLASSclass Ghost {    // VARIABLES    // postion    float creatureX, creatureY;    // body color    int creatureBodyColor;    // face/eye color    int creatureFaceColor;    // size    int creatureSize;    // variable to offset the eyes/mouth/spikes according to the direction of movement    int offset;    // direction of movement    int horizontalDirection, verticalDirection;    // Timer so you cant spam shooting    int shootTimer;    // Movement keys variables (0: UP, 1: DOWN, 2: LEFT, 3: RIGHT)    int[] keys = new int[4];    // CONSTRUCTORS    Ghost(float initX, float initY, int initBodyColor, int initFaceColor, int initCreatureSize) {        creatureX = initX;        creatureY = initY;        creatureBodyColor = initBodyColor;        creatureFaceColor = initFaceColor;        creatureSize = initCreatureSize;        offset = creatureSize / 10;    }    // METHODS    // Updating    void update() {        // Move        move();        // Warp around the screen Pacman style        warpScreen(screenWidth, screenHeight);        // Update the shoot timer        updateShoot();        // Update the size if needed        updateSize();    }    // Moving    void move() {        float movementSpeed = 6;        // Calculate direction        // horizontal direction is equal to the right key value minus the left key value (0: dont move, 1: move right, -1: move left)        horizontalDirection = keys[3] - keys[2];        // vertical direction is equal to the down key value minus the up key value (0: dont move, 1: move down, -1: move up)        verticalDirection = keys[1] - keys[0];        // Move        creatureX += horizontalDirection * movementSpeed;        creatureY += verticalDirection * movementSpeed;    }    // Display    void display() {        // Display the body        displayBody();        // Display the face        displayFace();    }    // Display the face    void displayFace() {        fill(creatureFaceColor);        // eyes        ellipse(creatureX - creatureSize * .25f + horizontalDirection * offset, creatureY + verticalDirection * offset, creatureSize * .2f, creatureSize * .25f);        ellipse(creatureX + creatureSize * .25f + horizontalDirection * offset, creatureY + verticalDirection * offset, creatureSize * .2f, creatureSize * .25f);        // mouth        ellipse(creatureX + horizontalDirection * offset, creatureY + creatureSize * .25f + verticalDirection * offset, creatureSize * .1f, creatureSize * .1f);    }    // Display the body    void displayBody() {        fill(creatureBodyColor);        // torso        ellipse(creatureX, creatureY, creatureSize, creatureSize);        rect(creatureX - creatureSize * .5f, creatureY, creatureSize, creatureSize * .5f);        // spikes        triangle(creatureX - creatureSize * .5f, creatureY + creatureSize * .5f, creatureX + creatureSize * .5f, creatureY + creatureSize * .5f, creatureX - horizontalDirection * offset * .5f, creatureY + creatureSize * .75f);        triangle(creatureX - creatureSize * .5f, creatureY + creatureSize * .5f, creatureX - creatureSize * .5f - horizontalDirection * offset * .5f, creatureY + creatureSize * .75f, creatureX + creatureSize * .5f, creatureY + creatureSize * .5f);        triangle(creatureX + creatureSize * .5f, creatureY + creatureSize * .5f, creatureX + creatureSize * .5f - horizontalDirection * offset * .5f, creatureY + creatureSize * .75f, creatureX - creatureSize * .5f, creatureY + creatureSize * .5f);    }    // Warp when offscreen    void warpScreen(int screenWidth, int screenHeight) {        // Warp to the opposite side of the screen if offscreen        if (creatureX > screenWidth + creatureSize)            creatureX = -creatureSize;        if (creatureX < -creatureSize)            creatureX = screenWidth + creatureSize;        if (creatureY > screenHeight + creatureSize)            creatureY = -creatureSize;        if (creatureY < -creatureSize)            creatureY = screenHeight + creatureSize;    }    // Get keyboard input into the array    void input(int keyIn, int keyValue) {        keys[keyIn] = keyValue;    }    // Shoot    void shoot(float initX, float initY, float initSize, float initHorSpeed, float initVertSpeed, int initTeam) {        // Shoot by creating a bullet at the position of the ghost and giving it an appropriate speed based on direction (the shoot timer is used for adding a buffer to each shot so that you cant spam them)        if (shootTimer == 0) {            if (!((horizontalDirection == 0) && (verticalDirection == 0))) {                bullets.add(new Bullet(initX, initY, initSize, initHorSpeed, initVertSpeed, initTeam));                shootTimer = PApplet.parseInt(frameRate) / 3;                changeSize(20);            }        }    }    // Update the shoot timer    void updateShoot() {        // Take away one from the shot delay if its above zero        if (shootTimer > 0) {            shootTimer--;        } else            shootTimer = 0;    }    // Change the size    void changeSize(int sizeChange) {        creatureSize += sizeChange;    }    // Update the size    void updateSize() {        // Smoothly go back to the original size of 100 if weve changed it        if (creatureSize < 100)            creatureSize++;        else if (creatureSize > 100)            creatureSize--;    }}',correct
'creatureX + horizontalDirection * offset',correct
'noStroke();',correct
'if ((key == S) || (key == s))    ghostCreature1.input(1, 1);',correct
'horizontalDirection * offset * .5f',correct
'ghostCreature1.input(2, 1);',correct
'// MovecreatureX += horizontalDirection * movementSpeed;',correct
'ghostCreature1.creatureX',correct
'stars = new Star[100]',correct
'ghostCreature1.creatureY',correct
'ghostCreature2.input(2, 0);',correct
'ghostCreature1.verticalDirection * 15',correct
'ghostCreature1.input(3, 1)',correct
'Bullet bullet = bullets.get(i);',correct
'text("ARROW KEYS | L - move | shoot black ghost", 8, 64)',correct
'keys[3] - keys[2]',correct
'scoreWhite++',correct
'creatureY + creatureSize * .25f + verticalDirection * offset',correct
'Bullet bullet = bullets.get(i)',correct
'keyCode == UP',correct
'dist(bulletX, bulletY, collisionX, collisionY) < bulletSize',correct
'// vertical direction is equal to the down key value minus the up key value (0: dont move, 1: move down, -1: move up)verticalDirection = keys[1] - keys[0];',correct
'// set up two ghostsGhost ghostCreature1, ghostCreature2;',correct
'// CONSTRUCTORSGhost(float initX, float initY, int initBodyColor, int initFaceColor, int initCreatureSize) {    creatureX = initX;    creatureY = initY;    creatureBodyColor = initBodyColor;    creatureFaceColor = initFaceColor;    creatureSize = initCreatureSize;    offset = creatureSize / 10;}',correct
'fill(creatureFaceColor)',correct
'creatureBodyColor',correct
'if (team == 1)    bulletColor = color(235, 240, 250);else    bulletColor = color(15, 20, 40);',correct
'horizontalDirection * movementSpeed',correct
'stars.length',correct
'{    fill(creatureBodyColor);    // torso    ellipse(creatureX, creatureY, creatureSize, creatureSize);    rect(creatureX - creatureSize * .5f, creatureY, creatureSize, creatureSize * .5f);    // spikes    triangle(creatureX - creatureSize * .5f, creatureY + creatureSize * .5f, creatureX + creatureSize * .5f, creatureY + creatureSize * .5f, creatureX - horizontalDirection * offset * .5f, creatureY + creatureSize * .75f);    triangle(creatureX - creatureSize * .5f, creatureY + creatureSize * .5f, creatureX - creatureSize * .5f - horizontalDirection * offset * .5f, creatureY + creatureSize * .75f, creatureX + creatureSize * .5f, creatureY + creatureSize * .5f);    triangle(creatureX + creatureSize * .5f, creatureY + creatureSize * .5f, creatureX + creatureSize * .5f - horizontalDirection * offset * .5f, creatureY + creatureSize * .75f, creatureX - creatureSize * .5f, creatureY + creatureSize * .5f);}',correct
'// Move the bulletbulletX += horizontalSpeed;',correct
'// METHODS// Displayvoid display() {    int starColor = color(70, 115, 155);    fill(starColor);    ellipse(starX, starY, starSize, starSize);}',correct
'float movementSpeed = 6',correct
'creatureSize > 100',correct
'// Update the shoot timervoid updateShoot() {    // Take away one from the shot delay if its above zero    if (shootTimer > 0) {        shootTimer--;    } else        shootTimer = 0;}',correct
'creatureSize--;',correct
'bulletY = initY',correct
'Star[]',correct
'shootTimer--;',correct
'team = initTeam',correct
'ghostCreature1.input(3, 0)',correct
'sizeChange = 4',correct
'draw',LongMethodRule
'{    // Take away one from the shot delay if its above zero    if (shootTimer > 0) {        shootTimer--;    } else        shootTimer = 0;}',correct
'// Draw instructionsfill(color(255, 255, 255));',correct
'ghostCreature1.input(2, 0);',correct
'text(scoreBlack + " points for the black team", 8, screenHeight - 8)',correct
'new Ghost(screenWidth * .25f, screenHeight * .5f, color(235, 240, 250), color(15, 20, 40), 100)',correct
'screenWidth * .75f',correct
'{    int starColor = color(70, 115, 155);    fill(starColor);    ellipse(starX, starY, starSize, starSize);}',correct
'// Destroy the bullet if its off screendestroy();',correct
'PApplet.parseInt(frameRate) / 3',correct
'horizontalSpeed',correct
'creatureX - creatureSize * .25f + horizontalDirection * offset',correct
'// Movemove();',correct
'ghostCreature1 = new Ghost(screenWidth * .25f, screenHeight * .5f, color(235, 240, 250), color(15, 20, 40), 100)',correct
'creatureFaceColor = initFaceColor;',correct
'// METHODS',correct
'void',correct
'verticalSpeed = initVertSpeed;',correct
'ghostCreature2.display()',correct
'-1',correct
'creatureY + creatureSize * .75f',correct
'screenHeight - 8',correct
'ghostCreature2.creatureY + 25',correct
'// body colorint creatureBodyColor;',correct
'bullet.update();',correct
'updateSize()',correct
'true',correct
'// Warp to the opposite side of the screen if offscreenif (creatureX > screenWidth + creatureSize)    creatureX = -creatureSize;',correct
'// Displayvoid display() {    // Display the body    displayBody();    // Display the face    displayFace();}',correct
'creatureY = screenHeight + creatureSize',correct
'text("WASD | SPACE - move | shoot white ghost", 8, 24);',correct
'if ((key == S) || (key == s))    ghostCreature1.input(1, 0);',correct
'// Display the bodyvoid displayBody() {    fill(creatureBodyColor);    // torso    ellipse(creatureX, creatureY, creatureSize, creatureSize);    rect(creatureX - creatureSize * .5f, creatureY, creatureSize, creatureSize * .5f);    // spikes    triangle(creatureX - creatureSize * .5f, creatureY + creatureSize * .5f, creatureX + creatureSize * .5f, creatureY + creatureSize * .5f, creatureX - horizontalDirection * offset * .5f, creatureY + creatureSize * .75f);    triangle(creatureX - creatureSize * .5f, creatureY + creatureSize * .5f, creatureX - creatureSize * .5f - horizontalDirection * offset * .5f, creatureY + creatureSize * .75f, creatureX + creatureSize * .5f, creatureY + creatureSize * .5f);    triangle(creatureX + creatureSize * .5f, creatureY + creatureSize * .5f, creatureX + creatureSize * .5f - horizontalDirection * offset * .5f, creatureY + creatureSize * .75f, creatureX - creatureSize * .5f, creatureY + creatureSize * .5f);}',correct
'triangle(creatureX + creatureSize * .5f, creatureY + creatureSize * .5f, creatureX + creatureSize * .5f - horizontalDirection * offset * .5f, creatureY + creatureSize * .75f, creatureX - creatureSize * .5f, creatureY + creatureSize * .5f)',correct
'{    // Smoothly go back to the original size of 100 if weve changed it    if (creatureSize < 100)        creatureSize++;    else if (creatureSize > 100)        creatureSize--;}',correct
'color(15, 20, 40)',correct
'fill(creatureFaceColor);',correct
'// Update ghostsghostCreature1.update();',correct
'ghostCreature2.creatureX',correct
'keys[keyIn]',correct
'isOver(ghostCreature1.creatureX, ghostCreature1.creatureY)',correct
'offset = creatureSize / 10;',correct
'screenHeight + creatureSize',correct
'bullets.get(i)',correct
'screenHeight * .5f',correct
'updateShoot',correct
'float initHorSpeed',LongParameterListRule
'ghostCreature2.creatureY',correct
'(bulletX > screenWidth + 100) || (bulletX < -100) || (bulletY > screenHeight + 100)',correct
'{    stars[i] = new Star(random(32, screenWidth - 32), random(32, screenHeight - 32), random(2, 8));}',correct
'fill(bulletColor)',correct
'keys[1]',correct
'horizontalDirection * offset',correct
'new int[4]',correct
'// CONSTRUCTORSStar(float initX, float initY, float initSize) {    starX = initX;    starY = initY;    starSize = initSize;}',correct
'// Get keyboard input into the arrayvoid input(int keyIn, int keyValue) {    keys[keyIn] = keyValue;}',correct
'starY = initY;',correct
'// Collisions with the playersvoid ghostCollide() {    // Check team to determine which ghost it should look for collisions with    if (team == 1) {        if (isOver(ghostCreature2.creatureX, ghostCreature2.creatureY)) {            // Destroy itself upon inpact, add to the appropriate score and change the size of the ghost it collided with to make collisions more visually appealing            bullets.remove(bullets.indexOf(this));            scoreWhite++;            ghostCreature2.changeSize(-20);        }    } else {        if (isOver(ghostCreature1.creatureX, ghostCreature1.creatureY)) {            // Destroy itself upon inpact, add to the appropriate score and change the size of the ghost it collided with to make collisions more visually appealing            bullets.remove(bullets.indexOf(this));            scoreBlack++;            ghostCreature1.changeSize(-20);        }    }}',correct
'float initVertSpeed',LongParameterListRule
'shootTimer = PApplet.parseInt(frameRate) / 3;',correct
'starX = initX',correct
'shootTimer = PApplet.parseInt(frameRate) / 3',correct
'{    starX = initX;    starY = initY;    starSize = initSize;}',correct
'// VARIABLES// postionfloat creatureX, creatureY;',correct
'bulletY = initY;',correct
'creatureY + creatureSize * .5f',correct
'{    // Draw background    // dark blue    int backgroundColor = color(45, 55, 85);    background(backgroundColor);    // Draw stars    for (int i = 0; i < stars.length; i++) {        stars[i].display();    }    // Draw instructions    fill(color(255, 255, 255));    textSize(24);    text("WASD | SPACE - move | shoot white ghost", 8, 24);    text("ARROW KEYS | L - move | shoot black ghost", 8, 64);    // Draw score    text(scoreBlack + " points for the black team", 8, screenHeight - 8);    text(scoreWhite + " points for the white team", 8, screenHeight - 48);    // Update bullets    for (int i = 0; i < bullets.size(); i++) {        Bullet bullet = bullets.get(i);        bullet.update();    }    // Display bullets    for (int i = 0; i < bullets.size(); i++) {        Bullet bullet = bullets.get(i);        bullet.display();    }    // Adjust the order of drawing of the ghosts to give the illusion of 3D space (the lower ghost appears "on top" of the higher one)    if (ghostCreature1.creatureY >= ghostCreature2.creatureY) {        ghostCreature2.display();        ghostCreature1.display();    } else {        ghostCreature1.display();        ghostCreature2.display();    }    // Update ghosts    ghostCreature1.update();    ghostCreature2.update();}',LongMethodRule
'if (creatureY > screenHeight + creatureSize)    creatureY = -creatureSize;',IfStmtsMustUseBraces
'keys[0]',correct
'bulletColor',correct
'ghostCreature2.input(1, 1);',correct
'ghostCreature1.shoot(ghostCreature1.creatureX, ghostCreature1.creatureY + 25, 75, ghostCreature1.horizontalDirection * 15, ghostCreature1.verticalDirection * 15, 1)',correct
'int keyValue',correct
'ghostCreature2.changeSize(-20);',correct
'void draw() {    // Draw background    // dark blue    int backgroundColor = color(45, 55, 85);    background(backgroundColor);    // Draw stars    for (int i = 0; i < stars.length; i++) {        stars[i].display();    }    // Draw instructions    fill(color(255, 255, 255));    textSize(24);    text("WASD | SPACE - move | shoot white ghost", 8, 24);    text("ARROW KEYS | L - move | shoot black ghost", 8, 64);    // Draw score    text(scoreBlack + " points for the black team", 8, screenHeight - 8);    text(scoreWhite + " points for the white team", 8, screenHeight - 48);    // Update bullets    for (int i = 0; i < bullets.size(); i++) {        Bullet bullet = bullets.get(i);        bullet.update();    }    // Display bullets    for (int i = 0; i < bullets.size(); i++) {        Bullet bullet = bullets.get(i);        bullet.display();    }    // Adjust the order of drawing of the ghosts to give the illusion of 3D space (the lower ghost appears "on top" of the higher one)    if (ghostCreature1.creatureY >= ghostCreature2.creatureY) {        ghostCreature2.display();        ghostCreature1.display();    } else {        ghostCreature1.display();        ghostCreature2.display();    }    // Update ghosts    ghostCreature1.update();    ghostCreature2.update();}',correct
'{    // movement input ghost 1    if ((key == W) || (key == w))        ghostCreature1.input(0, 0);    if ((key == S) || (key == s))        ghostCreature1.input(1, 0);    if ((key == A) || (key == a))        ghostCreature1.input(2, 0);    if ((key == D) || (key == d))        ghostCreature1.input(3, 0);    // movement input ghost 2    if (key == CODED) {        if (keyCode == UP)            ghostCreature2.input(0, 0);        if (keyCode == DOWN)            ghostCreature2.input(1, 0);        if (keyCode == LEFT)            ghostCreature2.input(2, 0);        if (keyCode == RIGHT)            ghostCreature2.input(3, 0);    }}',correct
'input',correct
'triangle(creatureX - creatureSize * .5f, creatureY + creatureSize * .5f, creatureX - creatureSize * .5f - horizontalDirection * offset * .5f, creatureY + creatureSize * .75f, creatureX + creatureSize * .5f, creatureY + creatureSize * .5f);',correct
'bullets.add(new Bullet(initX, initY, initSize, initHorSpeed, initVertSpeed, initTeam));',correct
'updateSize',correct
'creatureY < -creatureSize',correct
'if (keyCode == RIGHT)    ghostCreature2.input(3, 0);',IfStmtsMustUseBraces
'ghostCreature2.horizontalDirection * 15',correct
'int initCreatureSize',correct
'// Updatevoid update() {    // Move the bullet    bulletX += horizontalSpeed;    bulletY += verticalSpeed;    // Destroy the bullet if its off screen    destroy();    // Check for collision with the ghosts    ghostCollide();    // Flicker the size    sizeChange *= -1;}',correct
'// BULLET CLASSclass Bullet {    // VARIABLES    float bulletX, bulletY, bulletSize, horizontalSpeed, verticalSpeed;    int team, sizeChange = 4;    // CONSTRUCTORS    Bullet(float initX, float initY, float initSize, float initHorSpeed, float initVertSpeed, int initTeam) {        bulletX = initX;        bulletY = initY;        bulletSize = initSize;        horizontalSpeed = initHorSpeed;        verticalSpeed = initVertSpeed;        team = initTeam;    }    // METHODS    // Display    void display() {        // Determine color based on team        int bulletColor;        if (team == 1)            bulletColor = color(235, 240, 250);        else            bulletColor = color(15, 20, 40);        // Draw the bullet        fill(bulletColor);        ellipse(bulletX, bulletY, bulletSize, bulletSize + sizeChange);    }    // Update    void update() {        // Move the bullet        bulletX += horizontalSpeed;        bulletY += verticalSpeed;        // Destroy the bullet if its off screen        destroy();        // Check for collision with the ghosts        ghostCollide();        // Flicker the size        sizeChange *= -1;    }    // Destroy    void destroy() {        // Destroy if the bullet is off screen        if ((bulletX > screenWidth + 100) || (bulletX < -100) || (bulletY > screenHeight + 100) || (bulletY < -100))            bullets.remove(bullets.indexOf(this));    }    // Collisions with the players    void ghostCollide() {        // Check team to determine which ghost it should look for collisions with        if (team == 1) {            if (isOver(ghostCreature2.creatureX, ghostCreature2.creatureY)) {                // Destroy itself upon inpact, add to the appropriate score and change the size of the ghost it collided with to make collisions more visually appealing                bullets.remove(bullets.indexOf(this));                scoreWhite++;                ghostCreature2.changeSize(-20);            }        } else {            if (isOver(ghostCreature1.creatureX, ghostCreature1.creatureY)) {                // Destroy itself upon inpact, add to the appropriate score and change the size of the ghost it collided with to make collisions more visually appealing                bullets.remove(bullets.indexOf(this));                scoreBlack++;                ghostCreature1.changeSize(-20);            }        }    }    // Collision checking    boolean isOver(float collisionX, float collisionY) {        if (dist(bulletX, bulletY, collisionX, collisionY) < bulletSize)            return true;        else            return false;    }}',correct
'creatureSize * .5f',correct
'scoreBlack++',correct
'{    // Setup 2 ghosts    ghostCreature1 = new Ghost(screenWidth * .25f, screenHeight * .5f, color(235, 240, 250), color(15, 20, 40), 100);    ghostCreature2 = new Ghost(screenWidth * .75f, screenHeight * .5f, color(15, 20, 40), color(235, 240, 250), 100);    // Setup 100 stars placed in random positions    for (int i = 0; i < stars.length; i++) {        stars[i] = new Star(random(32, screenWidth - 32), random(32, screenHeight - 32), random(2, 8));    }    noStroke();}',correct
'new Star[100]',correct
'bulletSize',correct
'background(backgroundColor);',correct
'creatureX + creatureSize * .5f',correct
'creatureSize += sizeChange;',correct
'creatureX + creatureSize * .25f',correct
'.75f',correct
'bulletColor = color(15, 20, 40)',correct
'creatureY = -creatureSize',correct
'void keyReleased() {    // movement input ghost 1    if ((key == W) || (key == w))        ghostCreature1.input(0, 0);    if ((key == S) || (key == s))        ghostCreature1.input(1, 0);    if ((key == A) || (key == a))        ghostCreature1.input(2, 0);    if ((key == D) || (key == d))        ghostCreature1.input(3, 0);    // movement input ghost 2    if (key == CODED) {        if (keyCode == UP)            ghostCreature2.input(0, 0);        if (keyCode == DOWN)            ghostCreature2.input(1, 0);        if (keyCode == LEFT)            ghostCreature2.input(2, 0);        if (keyCode == RIGHT)            ghostCreature2.input(3, 0);    }}',correct
'return false;',IfElseStmtsMustUseBraces
'{    bulletX = initX;    bulletY = initY;    bulletSize = initSize;    horizontalSpeed = initHorSpeed;    verticalSpeed = initVertSpeed;    team = initTeam;}',correct
'triangle(creatureX + creatureSize * .5f, creatureY + creatureSize * .5f, creatureX + creatureSize * .5f - horizontalDirection * offset * .5f, creatureY + creatureSize * .75f, creatureX - creatureSize * .5f, creatureY + creatureSize * .5f);',correct
'Star',correct
'!((horizontalDirection == 0) && (verticalDirection == 0))',correct
'// Update bulletsfor (int i = 0; i < bullets.size(); i++) {    Bullet bullet = bullets.get(i);    bullet.update();}',correct
'float initSize',LongParameterListRule
'updateShoot()',correct
'Bullet',correct
'team == 1',correct
'keys[keyIn] = keyValue;',correct
'{    bullets.add(new Bullet(initX, initY, initSize, initHorSpeed, initVertSpeed, initTeam));    shootTimer = PApplet.parseInt(frameRate) / 3;    changeSize(20);}',correct
'// face/eye colorint creatureFaceColor;',correct
'ghostCreature2.verticalDirection',correct
'ellipse(creatureX + creatureSize * .25f + horizontalDirection * offset, creatureY + verticalDirection * offset, creatureSize * .2f, creatureSize * .25f)',correct
'int starColor = color(70, 115, 155)',correct
'creatureSize++',correct
'creatureFaceColor',correct
'creatureX = -creatureSize;',IfStmtsMustUseBraces
'int[]',correct
'bulletY += verticalSpeed',correct
'ghostCreature1.shoot(ghostCreature1.creatureX, ghostCreature1.creatureY + 25, 75, ghostCreature1.horizontalDirection * 15, ghostCreature1.verticalDirection * 15, 1);',correct
'team',correct
'// Calculate direction',correct
'bulletSize + sizeChange',correct
'// Setup 2 ghostsghostCreature1 = new Ghost(screenWidth * .25f, screenHeight * .5f, color(235, 240, 250), color(15, 20, 40), 100);',correct
'scoreBlack + " points for the black team"',correct
'Ghost',correct
'bullets.remove(bullets.indexOf(this));',correct
'{    // Destroy if the bullet is off screen    if ((bulletX > screenWidth + 100) || (bulletX < -100) || (bulletY > screenHeight + 100) || (bulletY < -100))        bullets.remove(bullets.indexOf(this));}',correct
'bulletX',correct
'bulletY',correct
'int initBodyColor',correct
'if (keyCode == RIGHT)    ghostCreature2.input(3, 1);',IfStmtsMustUseBraces
'{    if (isOver(ghostCreature2.creatureX, ghostCreature2.creatureY)) {        // Destroy itself upon inpact, add to the appropriate score and change the size of the ghost it collided with to make collisions more visually appealing        bullets.remove(bullets.indexOf(this));        scoreWhite++;        ghostCreature2.changeSize(-20);    }}',correct
'[100]',correct
'noStroke()',correct
'{    // Move    move();    // Warp around the screen Pacman style    warpScreen(screenWidth, screenHeight);    // Update the shoot timer    updateShoot();    // Update the size if needed    updateSize();}',correct
'creatureY = initY',correct
'creatureX + creatureSize * .25f + horizontalDirection * offset',correct
'{    shootTimer--;}',correct
'team = initTeam;',correct
'rect(creatureX - creatureSize * .5f, creatureY, creatureSize, creatureSize * .5f);',correct
'key ==',IfStmtsMustUseBraces
'stars[i].display()',correct
'verticalDirection',correct
'shoot',LongParameterListRule
'triangle(creatureX - creatureSize * .5f, creatureY + creatureSize * .5f, creatureX - creatureSize * .5f - horizontalDirection * offset * .5f, creatureY + creatureSize * .75f, creatureX + creatureSize * .5f, creatureY + creatureSize * .5f)',correct
'ghostCreature2.changeSize(-20)',correct
'screenWidth = 1280',correct
'screenHeight = 720',correct
'void setup() {    // Setup 2 ghosts    ghostCreature1 = new Ghost(screenWidth * .25f, screenHeight * .5f, color(235, 240, 250), color(15, 20, 40), 100);    ghostCreature2 = new Ghost(screenWidth * .75f, screenHeight * .5f, color(15, 20, 40), color(235, 240, 250), 100);    // Setup 100 stars placed in random positions    for (int i = 0; i < stars.length; i++) {        stars[i] = new Star(random(32, screenWidth - 32), random(32, screenHeight - 32), random(2, 8));    }    noStroke();}',correct
'float movementSpeed = 6;',correct
'// movement input ghost 1if ((key == W) || (key == w))    ghostCreature1.input(0, 0);',correct
'textSize(24)',correct
'creatureSize--',correct
'this',correct
'key == CODED',correct
'creatureSize * .75f',correct
'ghostCreature2.display();',correct
'changeSize(20)',correct
'creatureFaceColor = initFaceColor',correct
'ghostCreature1.input(1, 1);',correct
'if (creatureY < -creatureSize)    creatureY = screenHeight + creatureSize;',IfStmtsMustUseBraces
'creatureSize < 100',IfElseStmtsMustUseBraces
'if (creatureX < -creatureSize)    creatureX = screenWidth + creatureSize;',IfStmtsMustUseBraces
'dist(bulletX, bulletY, collisionX, collisionY)',correct
'// Shootvoid shoot(float initX, float initY, float initSize, float initHorSpeed, float initVertSpeed, int initTeam) {    // Shoot by creating a bullet at the position of the ghost and giving it an appropriate speed based on direction (the shoot timer is used for adding a buffer to each shot so that you cant spam them)    if (shootTimer == 0) {        if (!((horizontalDirection == 0) && (verticalDirection == 0))) {            bullets.add(new Bullet(initX, initY, initSize, initHorSpeed, initVertSpeed, initTeam));            shootTimer = PApplet.parseInt(frameRate) / 3;            changeSize(20);        }    }}',correct
'ghostCreature1.creatureY + 25',correct
'// mouthellipse(creatureX + horizontalDirection * offset, creatureY + creatureSize * .25f + verticalDirection * offset, creatureSize * .1f, creatureSize * .1f);',correct
'"ARROW KEYS | L - move | shoot black ghost"',correct
'keys[3]',correct
'scoreWhite = 0',correct
'// Draw scoretext(scoreBlack + " points for the black team", 8, screenHeight - 8);',correct
'// Update the shoot timerupdateShoot();',correct
'// KEYBOARD INPUTvoid keyPressed() {    // movement input ghost 1    if ((key == W) || (key == w))        ghostCreature1.input(0, 1);    if ((key == S) || (key == s))        ghostCreature1.input(1, 1);    if ((key == A) || (key == a))        ghostCreature1.input(2, 1);    if ((key == D) || (key == d))        ghostCreature1.input(3, 1);    // shooting ghost 1    if (key ==  )        ghostCreature1.shoot(ghostCreature1.creatureX, ghostCreature1.creatureY + 25, 75, ghostCreature1.horizontalDirection * 15, ghostCreature1.verticalDirection * 15, 1);    // movement input ghost 2    if (key == CODED) {        if (keyCode == UP)            ghostCreature2.input(0, 1);        if (keyCode == DOWN)            ghostCreature2.input(1, 1);        if (keyCode == LEFT)            ghostCreature2.input(2, 1);        if (keyCode == RIGHT)            ghostCreature2.input(3, 1);    }    // shooting ghost 2    if ((key == L) || (key == l))        ghostCreature2.shoot(ghostCreature2.creatureX, ghostCreature2.creatureY + 25, 75, ghostCreature2.horizontalDirection * 15, ghostCreature2.verticalDirection * 15, 2);}',correct
'// eyesellipse(creatureX - creatureSize * .25f + horizontalDirection * offset, creatureY + verticalDirection * offset, creatureSize * .2f, creatureSize * .25f);',correct
'update',correct
'// Change the sizevoid changeSize(int sizeChange) {    creatureSize += sizeChange;}',correct
'starX',correct
'starY',correct
'ghostCreature1.verticalDirection',correct
'{    if (dist(bulletX, bulletY, collisionX, collisionY) < bulletSize)        return true;    else        return false;}',correct
'creatureSize += sizeChange',correct
'keys[2]',correct
'creatureSize = initCreatureSize;',correct
'// Warp when offscreenvoid warpScreen(int screenWidth, int screenHeight) {    // Warp to the opposite side of the screen if offscreen    if (creatureX > screenWidth + creatureSize)        creatureX = -creatureSize;    if (creatureX < -creatureSize)        creatureX = screenWidth + creatureSize;    if (creatureY > screenHeight + creatureSize)        creatureY = -creatureSize;    if (creatureY < -creatureSize)        creatureY = screenHeight + creatureSize;}',correct
'isOver(ghostCreature2.creatureX, ghostCreature2.creatureY)',correct
'{    // Shoot by creating a bullet at the position of the ghost and giving it an appropriate speed based on direction (the shoot timer is used for adding a buffer to each shot so that you cant spam them)    if (shootTimer == 0) {        if (!((horizontalDirection == 0) && (verticalDirection == 0))) {            bullets.add(new Bullet(initX, initY, initSize, initHorSpeed, initVertSpeed, initTeam));            shootTimer = PApplet.parseInt(frameRate) / 3;            changeSize(20);        }    }}',LongParameterListRule
'// movement input ghost 1if ((key == W) || (key == w))    ghostCreature1.input(0, 1);',correct
'creatureX = screenWidth + creatureSize',correct
'// torsoellipse(creatureX, creatureY, creatureSize, creatureSize);',correct
'scoreBlack++;',DrawingStateChangeRule
'ghostCreature2.input(1, 0);',correct
'{    // Display the body    displayBody();    // Display the face    displayFace();}',correct
'if (!((horizontalDirection == 0) && (verticalDirection == 0))) {    bullets.add(new Bullet(initX, initY, initSize, initHorSpeed, initVertSpeed, initTeam));    shootTimer = PApplet.parseInt(frameRate) / 3;    changeSize(20);}',correct
'int i = 0',correct
'screenWidth + creatureSize',correct
'// Movingvoid move() {    float movementSpeed = 6;    // Calculate direction    // horizontal direction is equal to the right key value minus the left key value (0: dont move, 1: move right, -1: move left)    horizontalDirection = keys[3] - keys[2];    // vertical direction is equal to the down key value minus the up key value (0: dont move, 1: move down, -1: move up)    verticalDirection = keys[1] - keys[0];    // Move    creatureX += horizontalDirection * movementSpeed;    creatureY += verticalDirection * movementSpeed;}',correct
'ghostCreature2.shoot(ghostCreature2.creatureX, ghostCreature2.creatureY + 25, 75, ghostCreature2.horizontalDirection * 15, ghostCreature2.verticalDirection * 15, 2);',correct
'creatureX + creatureSize * .5f - horizontalDirection * offset * .5f',correct
'verticalDirection * movementSpeed',correct
'if (keyCode == UP)    ghostCreature2.input(0, 0);',IfStmtsMustUseBraces
'int starColor = color(70, 115, 155);',correct
'.1f',correct
'ghostCreature2.update();',correct
'bulletColor = color(235, 240, 250);',correct
'// Display the facevoid displayFace() {    fill(creatureFaceColor);    // eyes    ellipse(creatureX - creatureSize * .25f + horizontalDirection * offset, creatureY + verticalDirection * offset, creatureSize * .2f, creatureSize * .25f);    ellipse(creatureX + creatureSize * .25f + horizontalDirection * offset, creatureY + verticalDirection * offset, creatureSize * .2f, creatureSize * .25f);    // mouth    ellipse(creatureX + horizontalDirection * offset, creatureY + creatureSize * .25f + verticalDirection * offset, creatureSize * .1f, creatureSize * .1f);}',correct
'color(255, 255, 255)',correct
'creatureY += verticalDirection * movementSpeed;',correct
'ellipse(bulletX, bulletY, bulletSize, bulletSize + sizeChange)',correct
'// shooting ghost 2if ((key == L) || (key == l))    ghostCreature2.shoot(ghostCreature2.creatureX, ghostCreature2.creatureY + 25, 75, ghostCreature2.horizontalDirection * 15, ghostCreature2.verticalDirection * 15, 2);',correct
'int screenHeight',correct
'ellipse(bulletX, bulletY, bulletSize, bulletSize + sizeChange);',correct
'starSize',correct
'// sizeint creatureSize;',correct
'verticalDirection * offset',correct
'.2f',correct
'(key == L) || (key == l)',correct
'keyCode == LEFT',correct
'destroy',correct
'bullets = new ArrayList<Bullet>()',correct
'creatureSize = initCreatureSize',correct
'-20',correct
'creatureX = -creatureSize',correct
'bulletColor = color(235, 240, 250)',correct
'return true;',correct
'triangle(creatureX - creatureSize * .5f, creatureY + creatureSize * .5f, creatureX + creatureSize * .5f, creatureY + creatureSize * .5f, creatureX - horizontalDirection * offset * .5f, creatureY + creatureSize * .75f)',correct
'// Calculate direction// horizontal direction is equal to the right key value minus the left key value (0: dont move, 1: move right, -1: move left)horizontalDirection = keys[3] - keys[2];',correct
'changeSize',correct
'shootTimer == 0',correct
'fill(starColor);',correct
'if (keyCode == UP)    ghostCreature2.input(0, 1);',IfStmtsMustUseBraces
'keys = new int[4]',correct
'creatureX - creatureSize * .5f',correct
'// Draw background// dark blueint backgroundColor = color(45, 55, 85);',correct
'ghostCreature2.input(3, 1)',correct
'warpScreen',correct
'text(scoreWhite + " points for the white team", 8, screenHeight - 48);',PixelHardcodeIgnoranceRule
'creatureY + verticalDirection * offset',correct
'stars[i] = new Star(random(32, screenWidth - 32), random(32, screenHeight - 32), random(2, 8));',correct
'// Collision checkingboolean isOver(float collisionX, float collisionY) {    if (dist(bulletX, bulletY, collisionX, collisionY) < bulletSize)        return true;    else        return false;}',correct
'{    float movementSpeed = 6;    // Calculate direction    // horizontal direction is equal to the right key value minus the left key value (0: dont move, 1: move right, -1: move left)    horizontalDirection = keys[3] - keys[2];    // vertical direction is equal to the down key value minus the up key value (0: dont move, 1: move down, -1: move up)    verticalDirection = keys[1] - keys[0];    // Move    creatureX += horizontalDirection * movementSpeed;    creatureY += verticalDirection * movementSpeed;}',correct
'displayBody()',correct
'(bulletX > screenWidth + 100) || (bulletX < -100) || (bulletY > screenHeight + 100) || (bulletY < -100)',correct
'int bulletColor',correct
'{    // Destroy itself upon inpact, add to the appropriate score and change the size of the ghost it collided with to make collisions more visually appealing    bullets.remove(bullets.indexOf(this));    scoreWhite++;    ghostCreature2.changeSize(-20);}',correct
'keyReleased',correct
'ghostCreature2.input(0, 1);',correct
'{    ghostCreature2.display();    ghostCreature1.display();}',correct
'text(scoreWhite + " points for the white team", 8, screenHeight - 48)',correct
'keyCode == RIGHT',correct
'creatureX - horizontalDirection * offset * .5f',correct
'// an arraylist of bulletsArrayList<Bullet> bullets = new ArrayList<Bullet>();',correct
'displayFace()',correct
'ghostCreature2.input(3, 0)',correct
'display',correct
'int initTeam',LongParameterListRule
'random(32, screenWidth - 32)',correct
'creatureY > screenHeight + creatureSize',correct
'color(45, 55, 85)',correct
'if (keyCode == DOWN)    ghostCreature2.input(1, 0);',IfStmtsMustUseBraces
'// movement input ghost 2if (key == CODED) {    if (keyCode == UP)        ghostCreature2.input(0, 1);    if (keyCode == DOWN)        ghostCreature2.input(1, 1);    if (keyCode == LEFT)        ghostCreature2.input(2, 1);    if (keyCode == RIGHT)        ghostCreature2.input(3, 1);}',correct
'ghostCreature1.input(1, 0);',correct
'-creatureSize',correct
'// Draw starsfor (int i = 0; i < stars.length; i++) {    stars[i].display();}',correct
'{    // movement input ghost 1    if ((key == W) || (key == w))        ghostCreature1.input(0, 1);    if ((key == S) || (key == s))        ghostCreature1.input(1, 1);    if ((key == A) || (key == a))        ghostCreature1.input(2, 1);    if ((key == D) || (key == d))        ghostCreature1.input(3, 1);    // shooting ghost 1    if (key ==  )        ghostCreature1.shoot(ghostCreature1.creatureX, ghostCreature1.creatureY + 25, 75, ghostCreature1.horizontalDirection * 15, ghostCreature1.verticalDirection * 15, 1);    // movement input ghost 2    if (key == CODED) {        if (keyCode == UP)            ghostCreature2.input(0, 1);        if (keyCode == DOWN)            ghostCreature2.input(1, 1);        if (keyCode == LEFT)            ghostCreature2.input(2, 1);        if (keyCode == RIGHT)            ghostCreature2.input(3, 1);    }    // shooting ghost 2    if ((key == L) || (key == l))        ghostCreature2.shoot(ghostCreature2.creatureX, ghostCreature2.creatureY + 25, 75, ghostCreature2.horizontalDirection * 15, ghostCreature2.verticalDirection * 15, 2);}',StdCyclomaticComplexity
'verticalSpeed',correct
'"WASD | SPACE - move | shoot white ghost"',correct
'.5f',correct
'ghostCollide',correct
'horizontalDirection = keys[3] - keys[2]',correct
'.25f',correct
'(key == W) || (key == w)',correct
'starSize = initSize;',correct
'ellipse(starX, starY, starSize, starSize)',correct
'bulletSize = initSize',correct
'// Draw background',correct
'float initX',correct
'float initY',correct
'i++',correct
'// Warp around the screen Pacman stylewarpScreen(screenWidth, screenHeight);',correct
'// Flicker the sizesizeChange *= -1;',correct
'int initFaceColor',correct
'if (keyCode == LEFT)    ghostCreature2.input(2, 1);',IfStmtsMustUseBraces
'// movement input ghost 2if (key == CODED) {    if (keyCode == UP)        ghostCreature2.input(0, 0);    if (keyCode == DOWN)        ghostCreature2.input(1, 0);    if (keyCode == LEFT)        ghostCreature2.input(2, 0);    if (keyCode == RIGHT)        ghostCreature2.input(3, 0);}',correct
'keyCode == DOWN',correct
'creatureSize * .2f',correct
'(bulletX > screenWidth + 100) || (bulletX < -100)',correct
'ghostCreature1.changeSize(-20);',correct
'ghostCreature1.input(3, 0);',correct
'displayBody',correct
'creatureX += horizontalDirection * movementSpeed',correct
'creatureX - creatureSize * .5f - horizontalDirection * offset * .5f',correct
'keyPressed',StdCyclomaticComplexity
'offset',correct
'creatureX - creatureSize * .25f',correct
'ghostCreature1.display();',correct
'int keyIn',correct
'bulletColor = color(15, 20, 40);',IfElseStmtsMustUseBraces
'// VARIABLESfloat bulletX, bulletY, bulletSize, horizontalSpeed, verticalSpeed;',correct
'keys[1] - keys[0]',correct
'creatureX = screenWidth + creatureSize;',correct
'creatureY = -creatureSize;',correct
'if (keyCode == DOWN)    ghostCreature2.input(1, 1);',IfStmtsMustUseBraces
'(key == D) || (key == d)',correct
'creatureSize * .1f',correct
'starSize = initSize',correct
'bullet.update()',correct
'sizeChange *= -1',correct
'ghostCreature1.input(0, 0)',correct
'ghostCreature2.input(2, 1)',correct
'// Setup 100 stars placed in random positionsfor (int i = 0; i < stars.length; i++) {    stars[i] = new Star(random(32, screenWidth - 32), random(32, screenHeight - 32), random(2, 8));}',correct
'float collisionX',correct
'float collisionY',correct
'// Display the bodydisplayBody();',correct
'creatureY = initY;',correct
'backgroundColor = color(45, 55, 85)',correct
'if (keyCode == LEFT)    ghostCreature2.input(2, 0);',IfStmtsMustUseBraces
'bulletX = initX;',correct
'textSize(24);',correct
'// Draw the bulletfill(bulletColor);',correct
'movementSpeed = 6',correct
'ghostCreature1.input(3, 1);',correct
'ghostCreature1.input(0, 1)',correct
'i < stars.length',correct
'move',correct
'ghostCreature2.input(2, 0)',correct
'creatureSize / 10',correct
'int team, sizeChange = 4;',correct
'// Movement keys variables (0: UP, 1: DOWN, 2: LEFT, 3: RIGHT)int[] keys = new int[4];',correct
'boolean',correct
'{    if (keyCode == UP)        ghostCreature2.input(0, 1);    if (keyCode == DOWN)        ghostCreature2.input(1, 1);    if (keyCode == LEFT)        ghostCreature2.input(2, 1);    if (keyCode == RIGHT)        ghostCreature2.input(3, 1);}',correct
'bullet.display()',correct
'ghostCreature1.update()',correct
'PApplet.parseInt(frameRate)',correct
'fft.analyze(spectrum);',correct
'song.loop();',correct
'scale(2)',correct
'int posY = 0;',correct
'// nose holesfill(44, 0, 0);',correct
'// mouthfill(160, 160, 160);',correct
'{    scale(2);}',correct
'rect(0, -23, 16, 16, 6, 6, 6, 6)',correct
'{    // ears    pushMatrix();    translate(200, 30);    rotate(PI / 4.0000f);    fill(160, 160, 160);    rect(-23, 0, 16, 16, 6, 6, 6, 6);    rect(0, -23, 16, 16, 6, 6, 6, 6);    // inner ear    fill(255, 142, 142);    rect(-20, 2.5f, 10, 10, 4, 4, 4, 4);    rect(2.5f, -20, 10, 10, 4, 4, 4, 4);    popMatrix();}',correct
'posX = 0',correct
'animal = new Animal();',correct
'rect(2.5f, -20, 10, 10, 4, 4, 4, 4);',correct
'mouth()',correct
'song.loop()',correct
'{    eyeOpen = false;    arc(210, 50, 10, 10, PI, 2 * PI);}',correct
'posX = mouseX',correct
'2.5f',correct
'head();',correct
'{}',correct
'new SoundFile(this, "ILTMI.mp3")',correct
'scale(1.2f);',correct
'snout()',correct
'{    posX = mouseX;    posY = mouseY;}',correct
'fill(0, 0, 0)',correct
'pushMatrix();',correct
'animal.display();',correct
'"wall.jpg"',correct
'// FFT ModuleFFT fft;',correct
'int bands = 512;',correct
'// teethfill(255, 255, 255);',correct
'posX = mouseX;',correct
'animal',correct
'song = new SoundFile(this, "ILTMI.mp3")',correct
'{    bg = loadImage("wall.jpg");    song = new SoundFile(this, "ILTMI.mp3");    song.loop();    // New Input stream which is routed into the Amplitude analyzer    fft = new FFT(this, bands);    fft.input(song);    animal = new Animal();}',correct
'snout();',correct
'bg',correct
'eyeOpen = true;',correct
'fill(44, 0, 0)',correct
'posY = mouseY;',correct
'fill(160, 160, 160)',correct
'sum',correct
'rect(189, 107, 5, 10, 3, 6, 12, 18);',correct
'{    scale(1.2f);}',correct
'{    // nose area    fill(160, 160, 160);    ellipse(200, 85, 85, 55);    // nose holes    fill(44, 0, 0);    ellipse(178, 76, 9, 9);    ellipse(222, 76, 9, 9);}',correct
'PImage',correct
'if (sum <= 1.2f) {    scale(1.2f);} else if (sum >= 2) {    scale(2);} else {    scale(sum);}',correct
'for (int s = 15; s < 150; s++) {    sum += spectrum[s];}',correct
'fft.analyze(spectrum)',correct
'arc(210, 50, 10, 10, PI, 2 * PI)',correct
'eyeOpen = false;',DrawingStateChangeRule
's = 15',correct
'SoundFile',correct
'popMatrix();',correct
'ellipse(190, 55, 10, 35);',correct
'-200',correct
't',correct
'scale(1.2f)',correct
'void mouth() {    // mouth    fill(160, 160, 160);    ellipse(200, 110, 35, 25);    // teeth    fill(255, 255, 255);    rect(189, 107, 5, 10, 3, 6, 12, 18);    rect(206, 107, 5, 10, 3, 6, 12, 18);}',StatelessClassRule
'w',correct
'rect(-23, 0, 16, 16, 6, 6, 6, 6);',correct
'ears()',correct
'ellipse(200, 110, 35, 25)',correct
'fill(225, 225, 225);',correct
'// Key press actionsvoid update() {    if (keyPressed) {        if (key == w) {            eyeOpen = false;            arc(210, 50, 10, 10, PI, 2 * PI);        }        if (key == t) {            fill(245, 175, 177);            ellipse(200, 108, 26, 47);        }    }    if (eyeOpen) {        fill(225, 225, 225);        ellipse(210, 55, 10, 35);        fill(0, 0, 0);        ellipse(210, 55, 3, 17);    }}',StatelessClassRule
'void ears() {    // ears    pushMatrix();    translate(200, 30);    rotate(PI / 4.0000f);    fill(160, 160, 160);    rect(-23, 0, 16, 16, 6, 6, 6, 6);    rect(0, -23, 16, 16, 6, 6, 6, 6);    // inner ear    fill(255, 142, 142);    rect(-20, 2.5f, 10, 10, 4, 4, 4, 4);    rect(2.5f, -20, 10, 10, 4, 4, 4, 4);    popMatrix();}',StatelessClassRule
'ears();',correct
'background(bg)',correct
'{    if (keyPressed) {        if (key == w) {            eyeOpen = false;            arc(210, 50, 10, 10, PI, 2 * PI);        }        if (key == t) {            fill(245, 175, 177);            ellipse(200, 108, 26, 47);        }    }    if (eyeOpen) {        fill(225, 225, 225);        ellipse(210, 55, 10, 35);        fill(0, 0, 0);        ellipse(210, 55, 3, 17);    }}',correct
'sum = 0',correct
'fill(160, 160, 160);',correct
'ellipse(210, 55, 3, 17);',correct
'this',correct
'{    eyeOpen = true;}',correct
'if (key == w) {    eyeOpen = false;    arc(210, 50, 10, 10, PI, 2 * PI);}',DecentralizedEventHandlingRule
'rotate(PI / 4.0000f);',correct
'eyeOpen = false',correct
'void mouseDragged() {    posX = mouseX;    posY = mouseY;}',correct
'sum = 0;',DrawingStateChangeRule
'if (eyeOpen) {    fill(225, 225, 225);    ellipse(210, 55, 10, 35);    fill(0, 0, 0);    ellipse(210, 55, 3, 17);}',correct
'void keyReleased() {    eyeOpen = true;}',correct
'bands = 512',correct
'println(sum);',correct
'background(bg);',correct
'{    background(bg);    sum = 0;    for (int s = 15; s < 150; s++) {        sum += spectrum[s];    }    println(sum);    fft.analyze(spectrum);    animal.display();}',correct
'sum <= 1.2f',correct
'update',correct
'Processing',correct
'pushMatrix()',correct
'animal.display()',correct
'// Eye booleanboolean eyeOpen = true;',correct
'false',correct
'// earspushMatrix();',correct
'fill(225, 225, 225)',correct
'scale(sum);',correct
'float[]',correct
'mouth',correct
'fft.input(song)',correct
'{    fill(225, 225, 225);    ellipse(210, 55, 10, 35);    fill(0, 0, 0);    ellipse(210, 55, 3, 17);}',correct
'void snout() {    // nose area    fill(160, 160, 160);    ellipse(200, 85, 85, 55);    // nose holes    fill(44, 0, 0);    ellipse(178, 76, 9, 9);    ellipse(222, 76, 9, 9);}',StatelessClassRule
'rect(189, 107, 5, 10, 3, 6, 12, 18)',correct
'setup',correct
'translate(200, 30)',correct
'ellipse(191, 55, 3, 17);',correct
'{    pushMatrix();    // Scalling limitation    translate(posX, posY);    if (sum <= 1.2f) {        scale(1.2f);    } else if (sum >= 2) {        scale(2);    } else {        scale(sum);    }    translate(-200, -80);    // Elements of hipo    mouth();    ears();    head();    snout();    popMatrix();}',correct
'{    if (key == w) {        eyeOpen = false;        arc(210, 50, 10, 10, PI, 2 * PI);    }    if (key == t) {        fill(245, 175, 177);        ellipse(200, 108, 26, 47);    }}',correct
'ellipse(200, 66, 55, 90)',correct
'spectrum[s]',correct
'// Right eye wink moduleupdate();',correct
'int posX = 0;',correct
's++',correct
'ellipse(222, 76, 9, 9);',correct
'ellipse(200, 85, 85, 55);',correct
'void display() {    pushMatrix();    // Scalling limitation    translate(posX, posY);    if (sum <= 1.2f) {        scale(1.2f);    } else if (sum >= 2) {        scale(2);    } else {        scale(sum);    }    translate(-200, -80);    // Elements of hipo    mouth();    ears();    head();    snout();    popMatrix();}',StatelessClassRule
'song = new SoundFile(this, "ILTMI.mp3");',correct
'song',correct
'void head() {    // top head    fill(160, 160, 160);    ellipse(200, 66, 55, 90);    // Right eye wink module    update();    // Left eye    fill(225, 225, 225);    ellipse(190, 55, 10, 35);    fill(0, 0, 0);    ellipse(191, 55, 3, 17);}',StatelessClassRule
'"ILTMI.mp3"',correct
'Animal animal;',correct
'new Animal()',correct
'ellipse(210, 55, 3, 17)',correct
'-20',correct
'-23',correct
'Animal',StatelessClassRule
'posY = mouseY',correct
'// Scalling limitationtranslate(posX, posY);',correct
'bg = loadImage("wall.jpg")',correct
'1.2f',correct
'PI / 4.0000f',correct
'// nose areafill(160, 160, 160);',correct
'{    fill(245, 175, 177);    ellipse(200, 108, 26, 47);}',correct
'ellipse(178, 76, 9, 9);',correct
'key == w',correct
'translate(posX, posY)',correct
'key == t',correct
'fill(255, 142, 142)',correct
'update()',correct
'loadImage("wall.jpg")',correct
'if (keyPressed) {    if (key == w) {        eyeOpen = false;        arc(210, 50, 10, 10, PI, 2 * PI);    }    if (key == t) {        fill(245, 175, 177);        ellipse(200, 108, 26, 47);    }}',DecentralizedEventHandlingRule
'display',correct
'ellipse(210, 55, 10, 35);',correct
'rect(0, -23, 16, 16, 6, 6, 6, 6);',correct
'// BackGroundPImage bg;',correct
'{    // top head    fill(160, 160, 160);    ellipse(200, 66, 55, 90);    // Right eye wink module    update();    // Left eye    fill(225, 225, 225);    ellipse(190, 55, 10, 35);    fill(0, 0, 0);    ellipse(191, 55, 3, 17);}',correct
'// FFT module',correct
'translate(-200, -80)',correct
'posY = 0',correct
'translate(200, 30);',correct
'rotate(PI / 4.0000f)',correct
'ellipse(210, 55, 10, 35)',correct
'fill(245, 175, 177);',correct
'ellipse(200, 108, 26, 47);',correct
'// Left eyefill(225, 225, 225);',correct
'rect(2.5f, -20, 10, 10, 4, 4, 4, 4)',correct
'float sum;',correct
'animal = new Animal()',correct
'sum >= 2',correct
'println(sum)',correct
'{    sum += spectrum[s];}',correct
'if (key == t) {    fill(245, 175, 177);    ellipse(200, 108, 26, 47);}',DecentralizedEventHandlingRule
'{    // mouth    fill(160, 160, 160);    ellipse(200, 110, 35, 25);    // teeth    fill(255, 255, 255);    rect(189, 107, 5, 10, 3, 6, 12, 18);    rect(206, 107, 5, 10, 3, 6, 12, 18);}',correct
'ellipse(200, 85, 85, 55)',correct
'fft = new FFT(this, bands)',correct
'arc(210, 50, 10, 10, PI, 2 * PI);',correct
'rect(206, 107, 5, 10, 3, 6, 12, 18);',correct
'FFT',correct
'float[] spectrum = new float[bands];',correct
'snout',correct
'new float[bands]',correct
'fill(255, 255, 255)',correct
'spectrum = new float[bands]',correct
'// top headfill(160, 160, 160);',correct
'void',correct
'rect(-23, 0, 16, 16, 6, 6, 6, 6)',correct
'if (sum >= 2) {    scale(2);} else {    scale(sum);}',correct
'fft.input(song);',correct
'rect(-20, 2.5f, 10, 10, 4, 4, 4, 4);',correct
'fft',correct
'int s = 15',correct
'void setup() {    bg = loadImage("wall.jpg");    song = new SoundFile(this, "ILTMI.mp3");    song.loop();    // New Input stream which is routed into the Amplitude analyzer    fft = new FFT(this, bands);    fft.input(song);    animal = new Animal();}',correct
'true',correct
'ellipse(200, 110, 35, 25);',correct
'fill(245, 175, 177)',correct
'ellipse(200, 66, 55, 90);',correct
'popMatrix()',correct
'new FFT(this, bands)',correct
'// Elements of hipomouth();',correct
'[bands]',correct
'rect(206, 107, 5, 10, 3, 6, 12, 18)',correct
'fill(0, 0, 0);',correct
'Animal() {}',StatelessClassRule
'// New Input stream which is routed into the Amplitude analyzerfft = new FFT(this, bands);',correct
'head',correct
'4.0000f',correct
'// FFT moduleSoundFile song;',correct
'head()',correct
'// inner earfill(255, 142, 142);',correct
'bg = loadImage("wall.jpg");',correct
's < 150',correct
'void draw() {    background(bg);    sum = 0;    for (int s = 15; s < 150; s++) {        sum += spectrum[s];    }    println(sum);    fft.analyze(spectrum);    animal.display();}',correct
'translate(-200, -80);',correct
'ellipse(200, 108, 26, 47)',correct
'eyeOpen = true',correct
'-80',correct
'{    scale(sum);}',correct
'sum += spectrum[s];',DrawingStateChangeRule
'sum += spectrum[s]',correct
'class Animal {    Animal() {    }    void display() {        pushMatrix();        // Scalling limitation        translate(posX, posY);        if (sum <= 1.2f) {            scale(1.2f);        } else if (sum >= 2) {            scale(2);        } else {            scale(sum);        }        translate(-200, -80);        // Elements of hipo        mouth();        ears();        head();        snout();        popMatrix();    }    // Key press actions    void update() {        if (keyPressed) {            if (key == w) {                eyeOpen = false;                arc(210, 50, 10, 10, PI, 2 * PI);            }            if (key == t) {                fill(245, 175, 177);                ellipse(200, 108, 26, 47);            }        }        if (eyeOpen) {            fill(225, 225, 225);            ellipse(210, 55, 10, 35);            fill(0, 0, 0);            ellipse(210, 55, 3, 17);        }    }    void ears() {        // ears        pushMatrix();        translate(200, 30);        rotate(PI / 4.0000f);        fill(160, 160, 160);        rect(-23, 0, 16, 16, 6, 6, 6, 6);        rect(0, -23, 16, 16, 6, 6, 6, 6);        // inner ear        fill(255, 142, 142);        rect(-20, 2.5f, 10, 10, 4, 4, 4, 4);        rect(2.5f, -20, 10, 10, 4, 4, 4, 4);        popMatrix();    }    void snout() {        // nose area        fill(160, 160, 160);        ellipse(200, 85, 85, 55);        // nose holes        fill(44, 0, 0);        ellipse(178, 76, 9, 9);        ellipse(222, 76, 9, 9);    }    void mouth() {        // mouth        fill(160, 160, 160);        ellipse(200, 110, 35, 25);        // teeth        fill(255, 255, 255);        rect(189, 107, 5, 10, 3, 6, 12, 18);        rect(206, 107, 5, 10, 3, 6, 12, 18);    }    void head() {        // top head        fill(160, 160, 160);        ellipse(200, 66, 55, 90);        // Right eye wink module        update();        // Left eye        fill(225, 225, 225);        ellipse(190, 55, 10, 35);        fill(0, 0, 0);        ellipse(191, 55, 3, 17);    }}',correct
'rect(-20, 2.5f, 10, 10, 4, 4, 4, 4)',correct
'ellipse(190, 55, 10, 35)',correct
'ears',correct
'2 * PI',correct
'scale(sum)',correct
'ellipse(222, 76, 9, 9)',correct
'ellipse(178, 76, 9, 9)',correct
'scale(2);',correct
'ellipse(191, 55, 3, 17)',correct
'easterTimer = 0',correct
'println("Phone is upset: " + isUpset)',correct
'-90',correct
'rect(29, 32, 3, 15)',correct
'yPos + 50',correct
'fill(110, 110, 110)',correct
'phone1.update();',correct
'fill(255, 255, 0, 255 - lifeTime);',correct
'ySpeed',correct
'radius * objectX + 15',correct
'rect(-9, -11, 5, 2);',correct
'stroke(0);',correct
'{    pushMatrix();    translate(x, y);    rectMode(CENTER);    strokeWeight(2);    stroke(0);    fill(60);    rect(radius * objectX, radius * objectY, 35, 60);    fill(30);    rect(radius * objectX, radius * objectY, 32, 45);    fill(50);    ellipse(radius * objectX, radius * objectY + 25, 8, 8);    line(radius * objectX - 15, radius * objectY - 25, radius * objectX + 15, radius * objectY - 25);    popMatrix();}',correct
'"Nice! You found an Easter-Egg!"',correct
'radians(angle) + interval',correct
'rect(0, 0, 100, 100);',correct
'yPos + 60',correct
'if (isUpset) {    // if upset display blue screen    stroke(0);    fill(0, 0, 255);    rect(radius * objectX, radius * objectY, 110, 62);    fill(255);    stroke(255);    textSize(25);    textAlign(CENTER);    text(":(", radius * objectX - 35, radius * objectY - 5);    textSize(9);    text("Something went wrong", radius * objectX, radius * objectY + 10);}',correct
'{    // Run when upset    println("Screen is upset: " + isUpset);    isUpsetTimer++;    if (speed < 15) {        speed++;    }}',correct
'{    // if EasterIimer reaches 400 then reset timer and set easterEgg to false    easterEgg = false;    easterTimer = 0;}',correct
'int isUpsetTimer;',correct
'for (int i = 0; i < smokeParticles.length; i++) {    if (smokeParticles[i].isDead()) {        for (int n = 0; n < smokeParticles.length; n++) {            smokeParticles[n] = new SmokeParticle(xPos, yPos, random(1, 60));        }    }}',correct
'x = xInit',correct
'size',correct
'screen1.update();',correct
'easterTimer = 0;',correct
'void display() {    pushMatrix();    translate(x, y);    rectMode(CENTER);    fill(110, 110, 110);    stroke(0);    strokeWeight(2);    // Computer    rect(radius * objectX, radius * objectY, 50, 100);    fill(180);    // CD Drive    rect(radius * objectX, radius * objectY - 30, 40, 10);    // Panel    rect(radius * objectX, radius * objectY + 5, 40, 50);    for (int counter = 0; counter < 5; counter++) {        // buttons        ellipse(radius * objectX + 15, radius * objectY - 10 + counter * 7, 5, 5);    }    // Powerbutton    ellipse(radius * objectX, radius * objectY + 40, 10, 10);    popMatrix();}',correct
'{    screen1.isUpset = true;    computer1.isUpset = true;    keyboard1.isUpset = true;    phone1.isUpset = true;}',correct
'rect(20, 25, 50, 20);',correct
'for (int i = 0; i < smokeParticles.length; i++) {    smokeParticles[i].display();    smokeParticles[i].update();}',correct
'xPos = xPos + xSpeed;',correct
'n = 0',correct
'radius * objectY - 25',correct
'rotate(radians(-135));',correct
'easterEgg',correct
'-1.0f',correct
'smokeParticles[i].display()',correct
'screen1 = new Screen(200, PI, raccoon1.xPos, raccoon1.yPos)',correct
'radius * objectY - 30',correct
'// <------------------------------ Part of isUpset// Red overlay over earsfill(bodyUpset);',correct
'computer1.upset();',correct
'raccoon1.upset()',correct
'rectMode(CENTER)',correct
'println("Phone is upset: " + isUpset);',correct
'isUpsetTimer = 0',correct
'{    // isUpset    if (isUpsetTimer >= isUpsetDuration) {        // Reset isUpsetTimer when it reaches the UpsetDuration        isUpset = false;        isUpsetTimer = 0;        println("Screen is upset: " + isUpset);    }    if (isUpset) {        // Run when upset        println("Screen is upset: " + isUpset);        isUpsetTimer++;        if (speed < 15) {            speed++;        }    } else {        // Run when not upset        if (speed > 1) {            speed--;        }    }}',correct
'speed--',correct
'void setup() {    raccoon1 = new Raccoon(width / 2, height / 2);    orbitlines = new OrbitRings(raccoon1.xPos, raccoon1.yPos);    screen1 = new Screen(200, PI, raccoon1.xPos, raccoon1.yPos);    computer1 = new Computer(200, 0, raccoon1.xPos, raccoon1.yPos);    keyboard1 = new Keyboard(300, PI / 2, raccoon1.xPos, raccoon1.yPos);    phone1 = new Phone(300, PI + PI / 2, raccoon1.xPos, raccoon1.yPos);}',correct
'screen1.display()',correct
'x',correct
'y',correct
'dist(referenceX, referenceY, xPos, yPos)',correct
'counter < 5',correct
'smokeParticles[i].isDead()',correct
'SparkParticle',correct
'ySpeed = random(-4, 4);',correct
'lifeTime > maxTime',correct
'Computer computer1;',correct
'{    isUpset = false;    isUpsetTimer = 0;    println("Computer is upset: " + isUpset);}',correct
'radius * objectY - 5',correct
'computer1',correct
'100 - lifeTime',correct
'new Phone(300, PI + PI / 2, raccoon1.xPos, raccoon1.yPos)',correct
'easterEgg == true && isUpset == false',SimplifyBooleanExpressions
'{    sparkParticles[n] = new SparkParticle(xPos, yPos, random(1, 3));}',correct
'void display() {    // draws the particle    fill(255, 200, 0, 100 - lifeTime);    noStroke();    ellipse(xPos, yPos, size + 5, size + 5);    fill(255, 255, 0, 255 - lifeTime);    ellipse(xPos, yPos, size, size);}',correct
'PI + PI / 2',correct
'int bodyUpset = color(255, 0, 0, 120);',TooManyFields
'PApplet.parseInt(random(1600))',correct
'phone1.display()',correct
'// White stripespushMatrix();',correct
'easterTimer++',correct
'{    rect(radius * objectX + timerX * 7, radius * objectY + timerY * 7, 7, 7);}',correct
'sparkParticles[i] = new SparkParticle(xPos, yPos, random(1, 3));',correct
'250 - lifeTime / 2',correct
'rect(radius * objectX + timerX * 7, radius * objectY + timerY * 7, 7, 7);',correct
'// Middle Leftrect(-11, 1, 10, 12);',correct
'computer1.isUpset',correct
'computer1 = new Computer(200, 0, raccoon1.xPos, raccoon1.yPos);',correct
'rect(radius * objectX, radius * objectY + 55, 60, 5)',correct
'isUpsetTimer',correct
'{    // Display text when easterEgg is true    stroke(bodyBlack);    fill(bodyBlack);    textAlign(CENTER);    textSize(20);    text("General Kenobi!", xPos, yPos - 90);}',SimplifyBooleanExpressions
'{    if (isUpsetTimer >= isUpsetDuration) {        isUpset = false;        isUpsetTimer = 0;        println("Computer is upset: " + isUpset);    }    if (isUpset) {        // Run when upset        println("Computer is upset: " + isUpset);        isUpsetTimer++;        if (speed < 15) {            speed++;        }    } else {        // Run when not upset        if (speed > 1) {            speed--;        }    }}',correct
'float x;',correct
'Phone(float radiusInit, float initInterval, float xInit, float yInit) {    x = xInit;    y = yInit;    radius = radiusInit;    interval = initInterval;    speed = 1;}',correct
'easterEgg = false',correct
'if (dist(referenceX, referenceY, xPos, yPos) <= 60) {    return true;}',correct
'pushMatrix()',correct
'phone1.isUpset',correct
'smokeParticles[i].update();',correct
'// Run when upsetprintln("Keyboard is upset: " + isUpset);',correct
'// if EasterIimer reaches 400 then reset timer and set easterEgg to falseeasterEgg = false;',correct
'fill(80, 250 - lifeTime / 2)',correct
'{    if (isUpsetTimer >= isUpsetDuration) {        isUpset = false;        isUpsetTimer = 0;        println("Keyboard is upset: " + isUpset);    }    if (isUpset) {        // Run when upset        println("Keyboard is upset: " + isUpset);        isUpsetTimer++;        if (speed < 15) {            speed++;        }    } else {        // Run when not upset        if (speed > 1) {            speed--;        }    }}',correct
'float y;',correct
'rect(15, -15, 8, 8);',correct
'color(255, 0, 0, 120)',correct
'rect(-15, 15, 8, 8);',correct
'println("Keyboard is upset: " + isUpset);',correct
'class OrbitRings {    float xPos;    float yPos;    OrbitRings(float initX, float initY) {        xPos = initX;        yPos = initY;    }    void display() {        noFill();        stroke(255, 255, 255, 30);        ellipse(xPos, yPos, 400, 400);        ellipse(xPos, yPos, 600, 600);    }}',correct
'OrbitRings(float initX, float initY) {    xPos = initX;    yPos = initY;}',correct
'radius = radiusInit',correct
'radius * objectY + 5',correct
'// side of eyesrect(20, -25, 50, 20);',correct
'rotate(radians(-45))',correct
'if (easterEgg == true && isUpset == false) {    // Display text when easterEgg is true    stroke(bodyBlack);    fill(bodyBlack);    textAlign(CENTER);    textSize(20);    text("General Kenobi!", xPos, yPos - 90);}',correct
'1.0f',correct
'computer1.update()',correct
'"Hello there!"',correct
'int counter = 0',correct
'// middle eyesrotate(radians(-135));',correct
'isDead',correct
'radius * objectX - 35',correct
'rect(30, 41, 40, 10);',correct
'println("Nice! You found an Easter-Egg!");',correct
'rect(20, 25, 50, 20)',correct
'rect(29, 32, 3, 15);',correct
'{    xPos = initX;    yPos = initY;    size = initSize;    xSpeed = random(-1.0f, 1.0f);    ySpeed = random(-1.0f, 1.0f);    lifeTime = 0;}',correct
'void easterEgg() {    if (easterTimer > 400) {        // if EasterIimer reaches 400 then reset timer and set easterEgg to false        easterEgg = false;        easterTimer = 0;    }    if (easterEgg) {        // Add time to timer for easterEgg        easterTimer++;    }}',TooManyFields
'{    // updates the particle    lifeTime++;    ySpeed = ySpeed + 0.04f;    xPos = xPos + xSpeed;    yPos = yPos + ySpeed;}',correct
'ySpeed = ySpeed + 0.04f;',correct
'screen1.easterEgg = true',correct
'rect(50, 8, 20, 3);',correct
'noStroke();',correct
'rect(18, 23, 10, 40)',correct
'Keyboard(float radiusInit, float initInterval, float xInit, float yInit) {    x = xInit;    y = yInit;    radius = radiusInit;    interval = initInterval;    speed = 1;}',correct
'{    if (easterTimer > 400) {        // if EasterIimer reaches 400 then reset timer and set easterEgg to false        easterEgg = false;        easterTimer = 0;    }    if (easterEgg) {        // Add time to timer for easterEgg        easterTimer++;    }}',correct
'int maxTime = 510;',correct
'computer1 = new Computer(200, 0, raccoon1.xPos, raccoon1.yPos)',correct
'{    pushMatrix();    translate(xPos, yPos);    rotate(radians(45));    rect(15, -15, 8, 8);    rect(-15, 15, 8, 8);    // Stroke to Black    stroke(bodyBlack);    rect(18, -18, 4, 4);    rect(-18, 18, 4, 4);    popMatrix();}',correct
'SmokeParticle[]',correct
'void update() {    // updates the particle    lifeTime++;    ySpeed = ySpeed + 0.04f;    xPos = xPos + xSpeed;    yPos = yPos + ySpeed;}',correct
'PApplet.parseInt(random(1600)) == 66 && easterEgg == false && isUpset == false',correct
'ellipse(xPos, yPos, size + 5, size + 5)',correct
'for (int counter = 0; counter < 5; counter++) {    // buttons    ellipse(radius * objectX + 15, radius * objectY - 10 + counter * 7, 5, 5);}',correct
'strokeWeight(1)',correct
'if (easterTimer > 400) {    // if EasterIimer reaches 400 then reset timer and set easterEgg to false    easterEgg = false;    easterTimer = 0;}',correct
'{    for (int n = 0; n < sparkParticles.length; n++) {        sparkParticles[n] = new SparkParticle(xPos, yPos, random(1, 3));    }}',correct
'PI / 2',correct
'yPos - 90',correct
'text("Hello there!", radius * objectX, radius * objectY)',correct
'computer1.display()',correct
'rect(radius * objectX, radius * objectY, 50, 100)',correct
'OrbitRings orbitlines;',correct
'int easterTimer;',correct
'keyboard1.upset()',correct
'keyboard1.isUpset = true',correct
'rect(xPos + 20, yPos, 3, 3);',correct
'/* This code was written by: Darryl Reekers No touchy! */',correct
'new SmokeParticle(xPos, yPos, random(1, 60))',correct
'screen1.update()',correct
'PApplet.parseInt(random(1600)) == 66',correct
'ySpeed = random(-4, 4)',correct
'{    return true;}',correct
'{    xPos = initX;    yPos = initY;    isUpset = false;    for (int i = 0; i < smokeParticles.length; i++) {        smokeParticles[i] = new SmokeParticle(xPos, yPos, random(1, 60));    }    for (int i = 0; i < sparkParticles.length; i++) {        sparkParticles[i] = new SparkParticle(xPos, yPos, random(1, 3));    }}',correct
'yPos - 35',correct
'phone1 = new Phone(300, PI + PI / 2, raccoon1.xPos, raccoon1.yPos);',correct
'{    // <------------------------------ Part of isUpset    // Red overlay over head when triggered    fill(255, 0, 0, 120);    noStroke();    pushMatrix();    translate(xPos, yPos);    rotate(radians(45));    rect(0, 0, 100, 100);    popMatrix();    // Restore opacity    fill(255, 0, 0, 255);    // Display text when triggered    stroke(bodyBlack);    fill(bodyBlack);    textAlign(CENTER);    textSize(20);    text("Stop it!", xPos, yPos - 90);}',correct
'orbitlines = new OrbitRings(raccoon1.xPos, raccoon1.yPos)',correct
'sparkParticles[i].display()',correct
'// Noserect(18, 23, 10, 40);',correct
'mousePressed',correct
'boolean isDead() {    // checks if the particle has expired    if (lifeTime > maxTime) {        return true;    } else {        return false;    }}',correct
'{    // Reset isUpsetTimer when it reaches the UpsetDuration    isUpset = false;    isUpsetTimer = 0;    println("Screen is upset: " + isUpset);}',correct
'ellipse(xPos, yPos, size + 5, size + 5);',correct
'// If mouse is over raccoon make him upset. When upset the rotation speed increases and he becomes red.void mousePressed() {    if (raccoon1.isOver(mouseX, mouseY)) {        raccoon1.isUpset = true;    }}',correct
'{    speed--;}',correct
'raccoon1 = new Raccoon(width / 2, height / 2)',correct
'void display() {    if (isUpset) {        for (int i = 0; i < smokeParticles.length; i++) {            smokeParticles[i].display();            smokeParticles[i].update();        }        for (int i = 0; i < sparkParticles.length; i++) {            sparkParticles[i].display();            sparkParticles[i].update();        }        for (int i = 0; i < smokeParticles.length; i++) {            if (smokeParticles[i].isDead()) {                for (int n = 0; n < smokeParticles.length; n++) {                    smokeParticles[n] = new SmokeParticle(xPos, yPos, random(1, 60));                }            }        }        for (int i = 0; i < sparkParticles.length; i++) {            if (sparkParticles[i].isDead()) {                for (int n = 0; n < sparkParticles.length; n++) {                    sparkParticles[n] = new SparkParticle(xPos, yPos, random(1, 3));                }            }        }    }    rectMode(CENTER);    // Stroke to Black    stroke(bodyBlack);    // Fill to Gray    fill(bodyGray);    // Stroke width to 5    strokeWeight(5);    // Ears    rect(xPos - 35, yPos - 35, 40, 40);    rect(xPos + 35, yPos - 35, 40, 40);    // Fill to White    fill(bodyWhite);    // No stroke    noStroke();    rect(xPos - 35, yPos - 35, 20, 20);    rect(xPos + 35, yPos - 35, 20, 20);    if (isUpset) {        // <------------------------------ Part of isUpset        // Red overlay over ears        fill(bodyUpset);        noStroke();        rect(xPos - 35, yPos - 35, 40, 40);        rect(xPos + 35, yPos - 35, 40, 40);        // Restore opacity        fill(255, 0, 0, 255);        stroke(bodyBlack);    }    // Fill to Gray    fill(bodyGray);    // Stroke to Black    stroke(bodyBlack);    // Head    pushMatrix();    translate(xPos, yPos);    rotate(radians(45));    rect(0, 0, 100, 100);    popMatrix();    // White stripes    pushMatrix();    translate(xPos, yPos);    // Fill to White    fill(bodyWhite);    // Stroke to White    stroke(bodyWhite);    rotate(radians(45));    // side of eyes    rect(20, -25, 50, 20);    rotate(radians(90));    rect(20, 25, 50, 20);    // middle eyes    rotate(radians(-135));    rect(-9, -11, 5, 2);    rect(9, -11, 5, 2);    // sides    rect(-50, 8, 20, 3);    rect(50, 8, 20, 3);    rotate(radians(45));    rect(-41, 48, 5, 5);    rotate(radians(90));    rect(-41, -48, 5, 5);    rotate(radians(-135));    // Nose    rect(18, 23, 10, 40);    rect(-18, 23, 10, 40);    rotate(radians(45));    rect(30, 41, 40, 10);    rotate(radians(-90));    rect(-30, 41, 40, 10);    popMatrix();    // Black stripes    pushMatrix();    translate(xPos, yPos);    rotate(radians(45));    // Fill to Black    fill(bodyBlack);    // Stroke to Black    stroke(bodyBlack);    // Top Right Eye    rect(25, -20, 50, 20);    // Bottom Right    rect(30, -3, 35, 10);    rotate(radians(-45));    // Middle Right    rect(11, 1, 10, 12);    rect(29, 32, 3, 15);    // Middle Left    rect(-11, 1, 10, 12);    rect(-29, 32, 3, 15);    rotate(radians(45));    rotate(radians(90));    // Top Left Eye    rect(25, 20, 50, 20);    // Bottom Left    rect(30, 3, 35, 10);    popMatrix();    // Nose    rect(xPos, yPos + 60, 1, 15);    rect(xPos, yPos + 50, 9, 9);    // Eyes    // Fill to White    fill(bodyWhite);    // Stroke to White    stroke(bodyWhite);    if (isUpset) {        pushMatrix();        translate(xPos, yPos);        rotate(radians(45));        rect(15, -15, 8, 8);        rect(-15, 15, 8, 8);        // Stroke to Black        stroke(bodyBlack);        rect(18, -18, 4, 4);        rect(-18, 18, 4, 4);        popMatrix();    } else {        rect(xPos - 20, yPos, 3, 3);        rect(xPos + 20, yPos, 3, 3);    }    // Head Lines    // No fill    noFill();    // Stroke to Black    stroke(bodyBlack);    pushMatrix();    translate(xPos, yPos);    rotate(radians(45));    rect(0, 0, 100, 100);    popMatrix();    if (isUpset) {        // <------------------------------ Part of isUpset        // Red overlay over head when triggered        fill(255, 0, 0, 120);        noStroke();        pushMatrix();        translate(xPos, yPos);        rotate(radians(45));        rect(0, 0, 100, 100);        popMatrix();        // Restore opacity        fill(255, 0, 0, 255);        // Display text when triggered        stroke(bodyBlack);        fill(bodyBlack);        textAlign(CENTER);        textSize(20);        text("Stop it!", xPos, yPos - 90);    }    if (easterEgg == true && isUpset == false) {        // Display text when easterEgg is true        stroke(bodyBlack);        fill(bodyBlack);        textAlign(CENTER);        textSize(20);        text("General Kenobi!", xPos, yPos - 90);    }}',TooManyFields
'void',correct
'if (easterEgg) {    // if Easteregg is true then display secret    fill(255);    stroke(255);    textSize(18);    textAlign(CENTER);    text("Hello there!", radius * objectX, radius * objectY);}',correct
'raccoon1.display()',correct
'timerY = -2',correct
'raccoon1.easterEgg',correct
'screen1.upset();',correct
'i < sparkParticles.length',correct
'strokeWeight(2)',correct
'noFill();',correct
'fill(bodyBlack)',correct
'phone1 = new Phone(300, PI + PI / 2, raccoon1.xPos, raccoon1.yPos)',correct
'// Stroke to Blackstroke(bodyBlack);',correct
'popMatrix()',correct
'{    if (isUpsetTimer >= isUpsetDuration) {        isUpset = false;        isUpsetTimer = 0;        println("Phone is upset: " + isUpset);    }    if (isUpset) {        // Run when upset        println("Phone is upset: " + isUpset);        isUpsetTimer++;        if (speed < 15) {            speed++;        }    } else {        // Run when not upset        if (speed > 1) {            speed--;        }    }}',correct
'rect(-15, 15, 8, 8)',correct
'rect(xPos + 35, yPos - 35, 20, 20)',correct
'radius * objectX - 15',correct
'strokeWeight(5)',correct
'Phone',correct
'Raccoon',TooManyFields
'{    return false;}',correct
'line(radius * objectX - 15, radius * objectY - 25, radius * objectX + 15, radius * objectY - 25)',correct
'text(":(", radius * objectX - 35, radius * objectY - 5)',correct
'lifeTime++',correct
'Keyboard',correct
'objectY',correct
'objectX',correct
'new Keyboard(300, PI / 2, raccoon1.xPos, raccoon1.yPos)',correct
'ellipse(xPos, yPos, size, size)',correct
'void display() {    // draws the particle    fill(80, 250 - lifeTime / 2);    noStroke();    ellipse(xPos, yPos, size, size);}',correct
'keyboard1.display()',correct
'sin(radians(angle) + interval)',correct
'"Computer is upset: " + isUpset',correct
'orbitlines',correct
'rect(-41, 48, 5, 5)',correct
'// Fill to Whitefill(bodyWhite);',correct
'fill(120)',correct
'phone1.isUpset = true;',correct
'rotate(radians(45))',correct
'textSize(25);',correct
'cos(radians(angle) + interval)',correct
'rect(-50, 8, 20, 3)',correct
'// Run when upsetprintln("Screen is upset: " + isUpset);',correct
'y = yInit',correct
'Raccoon(float initX, float initY) {    xPos = initX;    yPos = initY;    isUpset = false;    for (int i = 0; i < smokeParticles.length; i++) {        smokeParticles[i] = new SmokeParticle(xPos, yPos, random(1, 60));    }    for (int i = 0; i < sparkParticles.length; i++) {        sparkParticles[i] = new SparkParticle(xPos, yPos, random(1, 3));    }}',TooManyFields
'rect(-41, 48, 5, 5);',correct
'if (isUpset) {    // <------------------------------ Part of isUpset    // Red overlay over ears    fill(bodyUpset);    noStroke();    rect(xPos - 35, yPos - 35, 40, 40);    rect(xPos + 35, yPos - 35, 40, 40);    // Restore opacity    fill(255, 0, 0, 255);    stroke(bodyBlack);}',correct
'rect(radius * objectX, radius * objectY, 32, 45)',correct
'float objectX;',correct
'if (isUpset) {    // <------------------------------ Part of isUpset    // Red overlay over head when triggered    fill(255, 0, 0, 120);    noStroke();    pushMatrix();    translate(xPos, yPos);    rotate(radians(45));    rect(0, 0, 100, 100);    popMatrix();    // Restore opacity    fill(255, 0, 0, 255);    // Display text when triggered    stroke(bodyBlack);    fill(bodyBlack);    textAlign(CENTER);    textSize(20);    text("Stop it!", xPos, yPos - 90);}',correct
'{    // draws the particle    fill(255, 200, 0, 100 - lifeTime);    noStroke();    ellipse(xPos, yPos, size + 5, size + 5);    fill(255, 255, 0, 255 - lifeTime);    ellipse(xPos, yPos, size, size);}',correct
'phone1.update()',correct
'boolean isOver(float referenceX, float referenceY) {    if (dist(referenceX, referenceY, xPos, yPos) <= 60) {        return true;    }    return false;}',TooManyFields
'// Fill to Grayfill(bodyGray);',correct
'rect(xPos + 20, yPos, 3, 3)',correct
'for (int i = 0; i < sparkParticles.length; i++) {    sparkParticles[i] = new SparkParticle(xPos, yPos, random(1, 3));}',correct
'SmokeParticle',correct
'float objectY;',correct
'{    // If easterEgg is true increase timer    easterTimer++;}',correct
'n++',correct
'radius * objectY - 10 + counter * 7',correct
'maxTime = 255',correct
'xSpeed = random(-1.0f, 1.0f)',correct
'xPos = initX;',correct
'ellipse(radius * objectX, radius * objectY + 40, 10, 10)',correct
'timerX++',correct
'fill(255, 200, 0, 100 - lifeTime)',correct
'"Screen is upset: " + isUpset',correct
'popMatrix();',correct
'strokeWeight(2);',correct
'angle + speed % 360',correct
'timerY < 3',correct
'text("Something went wrong", radius * objectX, radius * objectY + 10)',correct
'new Raccoon(width / 2, height / 2)',correct
'rect(30, -3, 35, 10)',correct
'size + 5',correct
'int lifeTime;',correct
'fill(30);',correct
'{    // Add time to timer for easterEgg    easterTimer++;}',correct
'screen1.upset()',correct
'for (int timerX = -8; timerX < 9; timerX++) {    rect(radius * objectX + timerX * 7, radius * objectY + timerY * 7, 7, 7);}',correct
'rect(radius * objectX, radius * objectY, 130, 50)',correct
'rect(30, 3, 35, 10)',correct
'dist(referenceX, referenceY, xPos, yPos) <= 60',correct
'if (raccoon1.isOver(mouseX, mouseY)) {    raccoon1.isUpset = true;}',correct
'bodyGray = color(100)',correct
'smokeParticles[i].display();',correct
'rect(-18, 23, 10, 40)',correct
'xPos = initX',correct
'raccoon1',correct
'{    raccoon1.isUpset = true;}',correct
'rect(-9, -11, 5, 2)',correct
'// Inner-Screen',correct
'{    raccoon1 = new Raccoon(width / 2, height / 2);    orbitlines = new OrbitRings(raccoon1.xPos, raccoon1.yPos);    screen1 = new Screen(200, PI, raccoon1.xPos, raccoon1.yPos);    computer1 = new Computer(200, 0, raccoon1.xPos, raccoon1.yPos);    keyboard1 = new Keyboard(300, PI / 2, raccoon1.xPos, raccoon1.yPos);    phone1 = new Phone(300, PI + PI / 2, raccoon1.xPos, raccoon1.yPos);}',correct
'{    // Activates the easteregg on the raccoon side    screen1.easterEgg = true;}',correct
'i < smokeParticles.length',correct
'// No strokenoStroke();',correct
'int maxTime = 255;',correct
'float radiusInit',correct
'class SmokeParticle {    float xPos;    float yPos;    float size;    float xSpeed;    float ySpeed;    int maxTime = 510;    int lifeTime;    SmokeParticle(float initX, float initY, float initSize) {        xPos = initX;        yPos = initY;        size = initSize;        xSpeed = random(-1.0f, 1.0f);        ySpeed = random(-1.0f, 1.0f);        lifeTime = 0;    }    void display() {        // draws the particle        fill(80, 250 - lifeTime / 2);        noStroke();        ellipse(xPos, yPos, size, size);    }    void update() {        // updates the particle        lifeTime++;        xPos = xPos + xSpeed;        yPos = yPos + ySpeed;    }    boolean isDead() {        // checks if the particle has expired        if (lifeTime > maxTime) {            return true;        } else {            return false;        }    }}',correct
'n < smokeParticles.length',correct
'angle = angle + speed % 360;',correct
'if (isUpset) {    // Run when upset    println("Screen is upset: " + isUpset);    isUpsetTimer++;    if (speed < 15) {        speed++;    }} else {    // Run when not upset    if (speed > 1) {        speed--;    }}',correct
'if (raccoon1.isUpset) {    screen1.isUpset = true;    computer1.isUpset = true;    keyboard1.isUpset = true;    phone1.isUpset = true;}',correct
'fill(110, 110, 110);',correct
'fill(255)',correct
'random(-4, 4)',correct
'rect(9, -11, 5, 2);',correct
'speed % 360',correct
'rect(xPos - 20, yPos, 3, 3);',correct
'{    isUpset = false;    isUpsetTimer = 0;    println("Keyboard is upset: " + isUpset);}',correct
'rect(-29, 32, 3, 15)',correct
'smokeParticles[i] = new SmokeParticle(xPos, yPos, random(1, 60));',correct
'Computer(float radiusInit, float initInterval, float xInit, float yInit) {    x = xInit;    y = yInit;    radius = radiusInit;    interval = initInterval;    speed = 1;}',correct
'speed < 15',correct
'if (isUpset) {    pushMatrix();    translate(xPos, yPos);    rotate(radians(45));    rect(15, -15, 8, 8);    rect(-15, 15, 8, 8);    // Stroke to Black    stroke(bodyBlack);    rect(18, -18, 4, 4);    rect(-18, 18, 4, 4);    popMatrix();} else {    rect(xPos - 20, yPos, 3, 3);    rect(xPos + 20, yPos, 3, 3);}',correct
'raccoon1.isUpset = true;',correct
'smokeParticles[i].update()',correct
'[200]',correct
'text("General Kenobi!", xPos, yPos - 90)',correct
'rect(50, 8, 20, 3)',correct
'"Something went wrong"',correct
'rect(18, -18, 4, 4);',correct
'noFill()',correct
'radius * objectY + timerY * 7',correct
'objectY = cos(radians(angle) + interval);',correct
'println("Screen is upset: " + isUpset)',correct
'// Eyes// Fill to Whitefill(bodyWhite);',correct
'radius * objectY',correct
'radius * objectX',correct
'int i = 0',correct
'easterTimer',correct
'ySpeed + 0.04f',correct
'color(255)',correct
'for (int n = 0; n < sparkParticles.length; n++) {    sparkParticles[n] = new SparkParticle(xPos, yPos, random(1, 3));}',correct
'radians(45)',correct
'void upset() {    if (isUpsetTimer >= isUpsetDuration) {        isUpset = false;        isUpsetTimer = 0;        println("Keyboard is upset: " + isUpset);    }    if (isUpset) {        // Run when upset        println("Keyboard is upset: " + isUpset);        isUpsetTimer++;        if (speed < 15) {            speed++;        }    } else {        // Run when not upset        if (speed > 1) {            speed--;        }    }}',correct
'-135',correct
'class Raccoon {    SmokeParticle[] smokeParticles = new SmokeParticle[200];    SparkParticle[] sparkParticles = new SparkParticle[200];    float xPos;    float yPos;    int bodyBlack = color(0);    int bodyWhite = color(255);    int bodyGray = color(100);    int bodyUpset = color(255, 0, 0, 120);    // Upset    boolean isUpset;    int isUpsetTimer;    int isUpsetDuration = 500;    // Easter-Egg    boolean easterEgg;    int easterTimer;    Raccoon(float initX, float initY) {        xPos = initX;        yPos = initY;        isUpset = false;        for (int i = 0; i < smokeParticles.length; i++) {            smokeParticles[i] = new SmokeParticle(xPos, yPos, random(1, 60));        }        for (int i = 0; i < sparkParticles.length; i++) {            sparkParticles[i] = new SparkParticle(xPos, yPos, random(1, 3));        }    }    void display() {        if (isUpset) {            for (int i = 0; i < smokeParticles.length; i++) {                smokeParticles[i].display();                smokeParticles[i].update();            }            for (int i = 0; i < sparkParticles.length; i++) {                sparkParticles[i].display();                sparkParticles[i].update();            }            for (int i = 0; i < smokeParticles.length; i++) {                if (smokeParticles[i].isDead()) {                    for (int n = 0; n < smokeParticles.length; n++) {                        smokeParticles[n] = new SmokeParticle(xPos, yPos, random(1, 60));                    }                }            }            for (int i = 0; i < sparkParticles.length; i++) {                if (sparkParticles[i].isDead()) {                    for (int n = 0; n < sparkParticles.length; n++) {                        sparkParticles[n] = new SparkParticle(xPos, yPos, random(1, 3));                    }                }            }        }        rectMode(CENTER);        // Stroke to Black        stroke(bodyBlack);        // Fill to Gray        fill(bodyGray);        // Stroke width to 5        strokeWeight(5);        // Ears        rect(xPos - 35, yPos - 35, 40, 40);        rect(xPos + 35, yPos - 35, 40, 40);        // Fill to White        fill(bodyWhite);        // No stroke        noStroke();        rect(xPos - 35, yPos - 35, 20, 20);        rect(xPos + 35, yPos - 35, 20, 20);        if (isUpset) {            // <------------------------------ Part of isUpset            // Red overlay over ears            fill(bodyUpset);            noStroke();            rect(xPos - 35, yPos - 35, 40, 40);            rect(xPos + 35, yPos - 35, 40, 40);            // Restore opacity            fill(255, 0, 0, 255);            stroke(bodyBlack);        }        // Fill to Gray        fill(bodyGray);        // Stroke to Black        stroke(bodyBlack);        // Head        pushMatrix();        translate(xPos, yPos);        rotate(radians(45));        rect(0, 0, 100, 100);        popMatrix();        // White stripes        pushMatrix();        translate(xPos, yPos);        // Fill to White        fill(bodyWhite);        // Stroke to White        stroke(bodyWhite);        rotate(radians(45));        // side of eyes        rect(20, -25, 50, 20);        rotate(radians(90));        rect(20, 25, 50, 20);        // middle eyes        rotate(radians(-135));        rect(-9, -11, 5, 2);        rect(9, -11, 5, 2);        // sides        rect(-50, 8, 20, 3);        rect(50, 8, 20, 3);        rotate(radians(45));        rect(-41, 48, 5, 5);        rotate(radians(90));        rect(-41, -48, 5, 5);        rotate(radians(-135));        // Nose        rect(18, 23, 10, 40);        rect(-18, 23, 10, 40);        rotate(radians(45));        rect(30, 41, 40, 10);        rotate(radians(-90));        rect(-30, 41, 40, 10);        popMatrix();        // Black stripes        pushMatrix();        translate(xPos, yPos);        rotate(radians(45));        // Fill to Black        fill(bodyBlack);        // Stroke to Black        stroke(bodyBlack);        // Top Right Eye        rect(25, -20, 50, 20);        // Bottom Right        rect(30, -3, 35, 10);        rotate(radians(-45));        // Middle Right        rect(11, 1, 10, 12);        rect(29, 32, 3, 15);        // Middle Left        rect(-11, 1, 10, 12);        rect(-29, 32, 3, 15);        rotate(radians(45));        rotate(radians(90));        // Top Left Eye        rect(25, 20, 50, 20);        // Bottom Left        rect(30, 3, 35, 10);        popMatrix();        // Nose        rect(xPos, yPos + 60, 1, 15);        rect(xPos, yPos + 50, 9, 9);        // Eyes        // Fill to White        fill(bodyWhite);        // Stroke to White        stroke(bodyWhite);        if (isUpset) {            pushMatrix();            translate(xPos, yPos);            rotate(radians(45));            rect(15, -15, 8, 8);            rect(-15, 15, 8, 8);            // Stroke to Black            stroke(bodyBlack);            rect(18, -18, 4, 4);            rect(-18, 18, 4, 4);            popMatrix();        } else {            rect(xPos - 20, yPos, 3, 3);            rect(xPos + 20, yPos, 3, 3);        }        // Head Lines        // No fill        noFill();        // Stroke to Black        stroke(bodyBlack);        pushMatrix();        translate(xPos, yPos);        rotate(radians(45));        rect(0, 0, 100, 100);        popMatrix();        if (isUpset) {            // <------------------------------ Part of isUpset            // Red overlay over head when triggered            fill(255, 0, 0, 120);            noStroke();            pushMatrix();            translate(xPos, yPos);            rotate(radians(45));            rect(0, 0, 100, 100);            popMatrix();            // Restore opacity            fill(255, 0, 0, 255);            // Display text when triggered            stroke(bodyBlack);            fill(bodyBlack);            textAlign(CENTER);            textSize(20);            text("Stop it!", xPos, yPos - 90);        }        if (easterEgg == true && isUpset == false) {            // Display text when easterEgg is true            stroke(bodyBlack);            fill(bodyBlack);            textAlign(CENTER);            textSize(20);            text("General Kenobi!", xPos, yPos - 90);        }    }    void upset() {        // isUpset        if (isUpsetTimer >= isUpsetDuration) {            isUpset = false;            isUpsetTimer = 0;            println("Raccoon is upset: " + isUpset);        }        if (isUpset) {            isUpsetTimer++;            println(isUpsetTimer);            println("Raccoon is upset: " + isUpset);        }    }    void easterEgg() {        if (PApplet.parseInt(random(1600)) == 66 && easterEgg == false && isUpset == false) {            // Random chance to trigger easter-egg only when its not triggered already            easterEgg = true;            println("Nice! You found an Easter-Egg!");        }        if (easterTimer > 400) {            // If eastertimer > 400 then disable the easter egg and reset the timer            easterEgg = false;            easterTimer = 0;        }        if (easterEgg) {            // If easterEgg is true increase timer            easterTimer++;        }    }    boolean isOver(float referenceX, float referenceY) {        if (dist(referenceX, referenceY, xPos, yPos) <= 60) {            return true;        }        return false;    }}',correct
'// sidesrect(-50, 8, 20, 3);',correct
'// HeadpushMatrix();',correct
'timerX < 9',correct
'Computer',correct
'float xInit',correct
'// Black stripespushMatrix();',correct
'yPos',correct
'int timerX = -8',correct
'xSpeed',correct
'ySpeed = random(-1.0f, 1.0f)',correct
'background(0, 104, 255)',correct
'float radius;',correct
'rect(-11, 1, 10, 12)',correct
'void upset() {    // isUpset    if (isUpsetTimer >= isUpsetDuration) {        isUpset = false;        isUpsetTimer = 0;        println("Raccoon is upset: " + isUpset);    }    if (isUpset) {        isUpsetTimer++;        println(isUpsetTimer);        println("Raccoon is upset: " + isUpset);    }}',TooManyFields
'return true;',correct
'new Computer(200, 0, raccoon1.xPos, raccoon1.yPos)',correct
'{    // updates the particle    lifeTime++;    xPos = xPos + xSpeed;    yPos = yPos + ySpeed;}',correct
'fill(120);',correct
'":("',correct
'color(100)',correct
'yPos = yPos + ySpeed;',correct
'rect(xPos - 35, yPos - 35, 40, 40)',correct
'yPos + ySpeed',correct
'println("Nice! You found an Easter-Egg!")',correct
'screen1.easterEgg();',correct
'isUpset',correct
'rect(11, 1, 10, 12)',correct
'raccoon1.xPos',correct
'display',correct
'rect(0, 0, 100, 100)',correct
'raccoon1.upset();',correct
'fill(255, 255, 0, 255 - lifeTime)',correct
'rect(xPos - 35, yPos - 35, 40, 40);',correct
'speed > 1',correct
'{    // checks if the particle has expired    if (lifeTime > maxTime) {        return true;    } else {        return false;    }}',correct
'raccoon1.display();',correct
'fill(bodyUpset)',correct
'// if Easteregg is true then display secretfill(255);',correct
'screen1.isUpset = true;',correct
'float initX',correct
'float initY',correct
'rect(xPos - 35, yPos - 35, 20, 20)',correct
'xPos = xPos + xSpeed',correct
'fill(255);',correct
'radians(angle)',correct
'// Eyes',correct
'class Phone {    float x;    float y;    float objectX;    float objectY;    float radius;    float angle;    float interval;    int speed;    // Upset    boolean isUpset;    int isUpsetTimer;    int isUpsetDuration = 500;    Phone(float radiusInit, float initInterval, float xInit, float yInit) {        x = xInit;        y = yInit;        radius = radiusInit;        interval = initInterval;        speed = 1;    }    void display() {        pushMatrix();        translate(x, y);        rectMode(CENTER);        strokeWeight(2);        stroke(0);        fill(60);        rect(radius * objectX, radius * objectY, 35, 60);        fill(30);        rect(radius * objectX, radius * objectY, 32, 45);        fill(50);        ellipse(radius * objectX, radius * objectY + 25, 8, 8);        line(radius * objectX - 15, radius * objectY - 25, radius * objectX + 15, radius * objectY - 25);        popMatrix();    }    void update() {        angle = angle + speed % 360;        objectX = sin(radians(angle) + interval);        objectY = cos(radians(angle) + interval);    }    void upset() {        if (isUpsetTimer >= isUpsetDuration) {            isUpset = false;            isUpsetTimer = 0;            println("Phone is upset: " + isUpset);        }        if (isUpset) {            // Run when upset            println("Phone is upset: " + isUpset);            isUpsetTimer++;            if (speed < 15) {                speed++;            }        } else {            // Run when not upset            if (speed > 1) {                speed--;            }        }    }}',correct
'{    sparkParticles[i].display();    sparkParticles[i].update();}',correct
'{    isUpsetTimer++;    println(isUpsetTimer);    println("Raccoon is upset: " + isUpset);}',correct
'"Screen is upset: "',correct
'rect(xPos, yPos + 60, 1, 15)',correct
'screen1.isUpset',correct
'n < sparkParticles.length',correct
'rect(9, -11, 5, 2)',correct
'isUpset == false',correct
'rect(30, 41, 40, 10)',correct
'sparkParticles = new SparkParticle[200]',correct
'ellipse(radius * objectX, radius * objectY + 25, 8, 8);',correct
'keyboard1.update();',correct
'float yInit',correct
'angle = angle + speed % 360',correct
'// Earsrect(xPos - 35, yPos - 35, 40, 40);',correct
'fill(50)',correct
'{    // <------------------------------ Part of isUpset    // Red overlay over ears    fill(bodyUpset);    noStroke();    rect(xPos - 35, yPos - 35, 40, 40);    rect(xPos + 35, yPos - 35, 40, 40);    // Restore opacity    fill(255, 0, 0, 255);    stroke(bodyBlack);}',correct
'smokeParticles[n]',correct
'computer1.isUpset = true',correct
'if (speed < 15) {    speed++;}',correct
'rect(-41, -48, 5, 5);',correct
'fill(50);',correct
'{    // Run when not upset    if (speed > 1) {        speed--;    }}',correct
'{    xPos = initX;    yPos = initY;}',correct
'radians(-90)',correct
'int isUpsetDuration = 500;',correct
'raccoon1.easterEgg()',correct
'random(-1.0f, 1.0f)',correct
'{    for (int timerX = -8; timerX < 9; timerX++) {        rect(radius * objectX + timerX * 7, radius * objectY + timerY * 7, 7, 7);    }}',correct
'computer1.update();',correct
'xPos + xSpeed',correct
'keyboard1',correct
'textSize(18)',correct
'// isUpsetif (isUpsetTimer >= isUpsetDuration) {    // Reset isUpsetTimer when it reaches the UpsetDuration    isUpset = false;    isUpsetTimer = 0;    println("Screen is upset: " + isUpset);}',correct
'lifeTime = 0;',correct
'for (int i = 0; i < sparkParticles.length; i++) {    sparkParticles[i].display();    sparkParticles[i].update();}',correct
'keyboard1 = new Keyboard(300, PI / 2, raccoon1.xPos, raccoon1.yPos);',correct
'timerX = -8',correct
'keyboard1.isUpset',correct
'new SmokeParticle[200]',correct
'speed--;',correct
'rotate(radians(90));',correct
'ellipse(radius * objectX + 15, radius * objectY - 10 + counter * 7, 5, 5)',correct
'// Reset isUpsetTimer when it reaches the UpsetDurationisUpset = false;',correct
'void draw() {    background(0, 104, 255);    raccoon1.display();    raccoon1.upset();    raccoon1.easterEgg();    orbitlines.display();    screen1.display();    screen1.update();    screen1.upset();    screen1.easterEgg();    computer1.display();    computer1.update();    computer1.upset();    keyboard1.display();    keyboard1.update();    keyboard1.upset();    phone1.display();    phone1.update();    phone1.upset();    if (raccoon1.isUpset) {        screen1.isUpset = true;        computer1.isUpset = true;        keyboard1.isUpset = true;        phone1.isUpset = true;    }    if (raccoon1.easterEgg) {        // Activates the easteregg on the raccoon side        screen1.easterEgg = true;    }}',correct
'float size;',correct
'{    if (smokeParticles[i].isDead()) {        for (int n = 0; n < smokeParticles.length; n++) {            smokeParticles[n] = new SmokeParticle(xPos, yPos, random(1, 60));        }    }}',correct
'PApplet.parseInt(random(1600)) == 66 && easterEgg == false',correct
'stroke(0)',correct
'yPos = yPos + ySpeed',correct
'rotate(radians(-90))',correct
'rect(radius * objectX, radius * objectY + 15, 42, 7);',correct
'ellipse(xPos, yPos, 400, 400);',correct
'fill(30)',correct
'// Standrect(radius * objectX, radius * objectY + 40, 20, 30);',correct
'rect(xPos - 35, yPos - 35, 20, 20);',correct
'sparkParticles[i].isDead()',correct
'Phone phone1;',correct
'raccoon1 = new Raccoon(width / 2, height / 2);',correct
'{    // if upset display blue screen    stroke(0);    fill(0, 0, 255);    rect(radius * objectX, radius * objectY, 110, 62);    fill(255);    stroke(255);    textSize(25);    textAlign(CENTER);    text(":(", radius * objectX - 35, radius * objectY - 5);    textSize(9);    text("Something went wrong", radius * objectX, radius * objectY + 10);}',correct
'"Keyboard is upset: "',correct
'for (int i = 0; i < sparkParticles.length; i++) {    if (sparkParticles[i].isDead()) {        for (int n = 0; n < sparkParticles.length; n++) {            sparkParticles[n] = new SparkParticle(xPos, yPos, random(1, 3));        }    }}',correct
'stroke(255, 255, 255, 30);',correct
'{    // if Easteregg is true then display secret    fill(255);    stroke(255);    textSize(18);    textAlign(CENTER);    text("Hello there!", radius * objectX, radius * objectY);}',correct
'println("Computer is upset: " + isUpset);',correct
'if (isUpsetTimer >= isUpsetDuration) {    isUpset = false;    isUpsetTimer = 0;    println("Computer is upset: " + isUpset);}',correct
'fill(255, 0, 0, 120)',correct
'OrbitRings',correct
'textAlign(CENTER)',correct
'{    // Run when upset    println("Computer is upset: " + isUpset);    isUpsetTimer++;    if (speed < 15) {        speed++;    }}',correct
'{    pushMatrix();    translate(x, y);    rectMode(CENTER);    fill(180);    stroke(0);    strokeWeight(2);    // Stand    rect(radius * objectX, radius * objectY + 40, 20, 30);    // BottomStand    rect(radius * objectX, radius * objectY + 55, 60, 5);    // Outer-Screen    rect(radius * objectX, radius * objectY, 120, 68);    // Inner-Screen    // if not upset display black screen    fill(0);    stroke(0);    rect(radius * objectX, radius * objectY, 110, 62);    if (easterEgg) {        // if Easteregg is true then display secret        fill(255);        stroke(255);        textSize(18);        textAlign(CENTER);        text("Hello there!", radius * objectX, radius * objectY);    }    if (isUpset) {        // if upset display blue screen        stroke(0);        fill(0, 0, 255);        rect(radius * objectX, radius * objectY, 110, 62);        fill(255);        stroke(255);        textSize(25);        textAlign(CENTER);        text(":(", radius * objectX - 35, radius * objectY - 5);        textSize(9);        text("Something went wrong", radius * objectX, radius * objectY + 10);    }    popMatrix();}',LongMethodRule
'Keyboard keyboard1;',correct
'random(1, 3)',correct
'float yPos;',correct
'rect(radius * objectX, radius * objectY - 30, 40, 10)',correct
'255 - lifeTime',correct
'interval = initInterval',correct
'easterEgg = true',correct
'rectMode(CENTER);',correct
'text(":(", radius * objectX - 35, radius * objectY - 5);',correct
'int timerY = -2',correct
'// draws the particlefill(255, 200, 0, 100 - lifeTime);',correct
'rect(20, -25, 50, 20)',correct
'size = initSize',correct
'bodyUpset = color(255, 0, 0, 120)',correct
'sparkParticles.length',correct
'// Head Lines// No fillnoFill();',correct
'void display() {    pushMatrix();    translate(x, y);    rectMode(CENTER);    strokeWeight(2);    fill(120);    stroke(0);    // Keyboard    rect(radius * objectX, radius * objectY, 130, 50);    strokeWeight(1);    fill(60);    for (int timerY = -2; timerY < 3; timerY++) {        for (int timerX = -8; timerX < 9; timerX++) {            rect(radius * objectX + timerX * 7, radius * objectY + timerY * 7, 7, 7);        }    }    rect(radius * objectX, radius * objectY + 15, 42, 7);    popMatrix();}',correct
'Screen screen1;',correct
'rect(xPos, yPos + 50, 9, 9)',correct
'fill(255, 0, 0, 255)',correct
'{    if (sparkParticles[i].isDead()) {        for (int n = 0; n < sparkParticles.length; n++) {            sparkParticles[n] = new SparkParticle(xPos, yPos, random(1, 3));        }    }}',correct
'float xSpeed;',correct
'rotate(radians(45));',correct
'radius',correct
'println(isUpsetTimer)',correct
'// Panelrect(radius * objectX, radius * objectY + 5, 40, 50);',correct
'// Restore opacityfill(255, 0, 0, 255);',correct
'ellipse(xPos, yPos, 600, 600);',correct
'void update() {    angle = angle + speed % 360;    objectX = sin(radians(angle) + interval);    objectY = cos(radians(angle) + interval);}',correct
'radians(-135)',correct
'isUpset = false;',correct
'lifeTime = 0',correct
'fill(180)',correct
'text("Stop it!", xPos, yPos - 90)',correct
'smokeParticles[i]',correct
'SmokeParticle(float initX, float initY, float initSize) {    xPos = initX;    yPos = initY;    size = initSize;    xSpeed = random(-1.0f, 1.0f);    ySpeed = random(-1.0f, 1.0f);    lifeTime = 0;}',correct
'{    x = xInit;    y = yInit;    radius = radiusInit;    interval = initInterval;    speed = 1;}',correct
'"Phone is upset: " + isUpset',correct
'println("Screen is upset: " + isUpset);',correct
'if (PApplet.parseInt(random(1600)) == 66 && easterEgg == false && isUpset == false) {    // Random chance to trigger easter-egg only when its not triggered already    easterEgg = true;    println("Nice! You found an Easter-Egg!");}',correct
'textSize(9)',correct
'counter++',correct
'rect(-30, 41, 40, 10);',correct
'counter * 7',correct
'Processing',correct
'textSize(20);',correct
'SparkParticle[]',correct
'// Head Lines',correct
'new SparkParticle(xPos, yPos, random(1, 3))',correct
'{    for (int i = 0; i < smokeParticles.length; i++) {        smokeParticles[i].display();        smokeParticles[i].update();    }    for (int i = 0; i < sparkParticles.length; i++) {        sparkParticles[i].display();        sparkParticles[i].update();    }    for (int i = 0; i < smokeParticles.length; i++) {        if (smokeParticles[i].isDead()) {            for (int n = 0; n < smokeParticles.length; n++) {                smokeParticles[n] = new SmokeParticle(xPos, yPos, random(1, 60));            }        }    }    for (int i = 0; i < sparkParticles.length; i++) {        if (sparkParticles[i].isDead()) {            for (int n = 0; n < sparkParticles.length; n++) {                sparkParticles[n] = new SparkParticle(xPos, yPos, random(1, 3));            }        }    }}',correct
'rect(radius * objectX, radius * objectY, 120, 68)',correct
'rect(-18, 23, 10, 40);',correct
'{    smokeParticles[n] = new SmokeParticle(xPos, yPos, random(1, 60));}',correct
'rect(radius * objectX, radius * objectY + 5, 40, 50)',correct
'for (int n = 0; n < smokeParticles.length; n++) {    smokeParticles[n] = new SmokeParticle(xPos, yPos, random(1, 60));}',correct
'false',correct
'computer1.isUpset = true;',correct
'// Display text when easterEgg is truestroke(bodyBlack);',correct
'rect(radius * objectX, radius * objectY, 35, 60);',correct
'{    if (dist(referenceX, referenceY, xPos, yPos) <= 60) {        return true;    }    return false;}',correct
'random(1600)',correct
'rect(15, -15, 8, 8)',correct
'i = 0',correct
'xPos + 35',correct
'rect(xPos + 35, yPos - 35, 40, 40)',correct
'new OrbitRings(raccoon1.xPos, raccoon1.yPos)',correct
'"Raccoon is upset: " + isUpset',correct
'sparkParticles[i].update()',correct
'if (isUpset) {    isUpsetTimer++;    println(isUpsetTimer);    println("Raccoon is upset: " + isUpset);}',correct
'// Stroke width to 5strokeWeight(5);',correct
'stroke(bodyBlack)',correct
'rect(xPos + 35, yPos - 35, 40, 40);',correct
'{    // Random chance to trigger easter-egg only when its not triggered already    easterEgg = true;    println("Nice! You found an Easter-Egg!");}',SimplifyBooleanExpressions
'{    isUpset = false;    isUpsetTimer = 0;    println("Phone is upset: " + isUpset);}',correct
'radians(90)',correct
'println("Keyboard is upset: " + isUpset)',correct
'if (easterEgg) {    // Add time to timer for easterEgg    easterTimer++;}',correct
'int n = 0',correct
'fill(bodyBlack);',correct
'interval',correct
'// <------------------------------ Part of isUpset',correct
'radians(-45)',correct
'// if upset display blue screenstroke(0);',correct
'{    // draws the particle    fill(80, 250 - lifeTime / 2);    noStroke();    ellipse(xPos, yPos, size, size);}',correct
'upset',correct
'{    noFill();    stroke(255, 255, 255, 30);    ellipse(xPos, yPos, 400, 400);    ellipse(xPos, yPos, 600, 600);}',correct
'// updates the particlelifeTime++;',correct
'println(isUpsetTimer);',correct
'ellipse(xPos, yPos, size, size);',correct
'easterEgg == false',correct
'phone1.upset()',correct
'rect(radius * objectX, radius * objectY + 40, 20, 30)',correct
'rect(-30, 41, 40, 10)',correct
'radius = radiusInit;',correct
'xSpeed = random(-4, 4)',correct
'text("Hello there!", radius * objectX, radius * objectY);',correct
'angle',correct
'new Screen(200, PI, raccoon1.xPos, raccoon1.yPos)',correct
'ySpeed = random(-1.0f, 1.0f);',correct
'{    // Run when upset    println("Phone is upset: " + isUpset);    isUpsetTimer++;    if (speed < 15) {        speed++;    }}',correct
'{    // isUpset    if (isUpsetTimer >= isUpsetDuration) {        isUpset = false;        isUpsetTimer = 0;        println("Raccoon is upset: " + isUpset);    }    if (isUpset) {        isUpsetTimer++;        println(isUpsetTimer);        println("Raccoon is upset: " + isUpset);    }}',correct
'screen1.easterEgg()',correct
'// Upsetboolean isUpset;',TooManyFields
'textSize(18);',correct
'draw',LongMethodRule
'if (isUpset) {    // Run when upset    println("Keyboard is upset: " + isUpset);    isUpsetTimer++;    if (speed < 15) {        speed++;    }} else {    // Run when not upset    if (speed > 1) {        speed--;    }}',correct
'xPos + 20',correct
'"Computer is upset: "',correct
'fill(180);',correct
'isUpsetTimer = 0;',correct
'sparkParticles[n] = new SparkParticle(xPos, yPos, random(1, 3));',correct
'// Computerrect(radius * objectX, radius * objectY, 50, 100);',correct
'screen1.display();',correct
'{    background(0, 104, 255);    raccoon1.display();    raccoon1.upset();    raccoon1.easterEgg();    orbitlines.display();    screen1.display();    screen1.update();    screen1.upset();    screen1.easterEgg();    computer1.display();    computer1.update();    computer1.upset();    keyboard1.display();    keyboard1.update();    keyboard1.upset();    phone1.display();    phone1.update();    phone1.upset();    if (raccoon1.isUpset) {        screen1.isUpset = true;        computer1.isUpset = true;        keyboard1.isUpset = true;        phone1.isUpset = true;    }    if (raccoon1.easterEgg) {        // Activates the easteregg on the raccoon side        screen1.easterEgg = true;    }}',LongMethodRule
'if (isUpset) {    for (int i = 0; i < smokeParticles.length; i++) {        smokeParticles[i].display();        smokeParticles[i].update();    }    for (int i = 0; i < sparkParticles.length; i++) {        sparkParticles[i].display();        sparkParticles[i].update();    }    for (int i = 0; i < smokeParticles.length; i++) {        if (smokeParticles[i].isDead()) {            for (int n = 0; n < smokeParticles.length; n++) {                smokeParticles[n] = new SmokeParticle(xPos, yPos, random(1, 60));            }        }    }    for (int i = 0; i < sparkParticles.length; i++) {        if (sparkParticles[i].isDead()) {            for (int n = 0; n < sparkParticles.length; n++) {                sparkParticles[n] = new SparkParticle(xPos, yPos, random(1, 3));            }        }    }}',correct
'phone1',correct
'float referenceX',correct
'rect(xPos - 20, yPos, 3, 3)',correct
'float angle;',correct
'keyboard1.update()',correct
'float referenceY',correct
'rotate(radians(-135))',correct
'stroke(bodyWhite)',correct
'void update() {    // updates the particle    lifeTime++;    xPos = xPos + xSpeed;    yPos = yPos + ySpeed;}',correct
'rect(radius * objectX + timerX * 7, radius * objectY + timerY * 7, 7, 7)',correct
'isUpsetTimer >= isUpsetDuration',correct
'-2',correct
'-3',correct
'-4',correct
'translate(xPos, yPos);',correct
'size = initSize;',correct
'-8',correct
'-9',correct
'phone1.isUpset = true',correct
'xPos - 20',correct
'int bodyWhite = color(255);',TooManyFields
'true',correct
'// Fill to Blackfill(bodyBlack);',correct
'float interval;',correct
'computer1.display();',correct
'counter = 0',correct
'rect(xPos, yPos + 50, 9, 9);',correct
'ySpeed = ySpeed + 0.04f',correct
'text("Something went wrong", radius * objectX, radius * objectY + 10);',correct
'speed++;',correct
'isUpset = false',correct
'raccoon1.isUpset',correct
'rect(radius * objectX, radius * objectY + 15, 42, 7)',correct
'// Run when upsetprintln("Phone is upset: " + isUpset);',correct
'class Computer {    float x;    float y;    float objectX;    float objectY;    float radius;    float angle;    float interval;    int speed;    // Upset    boolean isUpset;    int isUpsetTimer;    int isUpsetDuration = 500;    Computer(float radiusInit, float initInterval, float xInit, float yInit) {        x = xInit;        y = yInit;        radius = radiusInit;        interval = initInterval;        speed = 1;    }    void display() {        pushMatrix();        translate(x, y);        rectMode(CENTER);        fill(110, 110, 110);        stroke(0);        strokeWeight(2);        // Computer        rect(radius * objectX, radius * objectY, 50, 100);        fill(180);        // CD Drive        rect(radius * objectX, radius * objectY - 30, 40, 10);        // Panel        rect(radius * objectX, radius * objectY + 5, 40, 50);        for (int counter = 0; counter < 5; counter++) {            // buttons            ellipse(radius * objectX + 15, radius * objectY - 10 + counter * 7, 5, 5);        }        // Powerbutton        ellipse(radius * objectX, radius * objectY + 40, 10, 10);        popMatrix();    }    void update() {        angle = angle + speed % 360;        objectX = sin(radians(angle) + interval);        objectY = cos(radians(angle) + interval);    }    void upset() {        if (isUpsetTimer >= isUpsetDuration) {            isUpset = false;            isUpsetTimer = 0;            println("Computer is upset: " + isUpset);        }        if (isUpset) {            // Run when upset            println("Computer is upset: " + isUpset);            isUpsetTimer++;            if (speed < 15) {                speed++;            }        } else {            // Run when not upset            if (speed > 1) {                speed--;            }        }    }}',correct
'raccoon1.isOver(mouseX, mouseY)',correct
'{    speed++;}',correct
'"Raccoon is upset: "',correct
'smokeParticles[n] = new SmokeParticle(xPos, yPos, random(1, 60));',correct
'// Top Right Eyerect(25, -20, 50, 20);',correct
'{    pushMatrix();    translate(x, y);    rectMode(CENTER);    fill(110, 110, 110);    stroke(0);    strokeWeight(2);    // Computer    rect(radius * objectX, radius * objectY, 50, 100);    fill(180);    // CD Drive    rect(radius * objectX, radius * objectY - 30, 40, 10);    // Panel    rect(radius * objectX, radius * objectY + 5, 40, 50);    for (int counter = 0; counter < 5; counter++) {        // buttons        ellipse(radius * objectX + 15, radius * objectY - 10 + counter * 7, 5, 5);    }    // Powerbutton    ellipse(radius * objectX, radius * objectY + 40, 10, 10);    popMatrix();}',correct
'{    smokeParticles[i].display();    smokeParticles[i].update();}',correct
'"General Kenobi!"',correct
'sparkParticles[i] = new SparkParticle(xPos, yPos, random(1, 3))',correct
'if (isUpsetTimer >= isUpsetDuration) {    isUpset = false;    isUpsetTimer = 0;    println("Phone is upset: " + isUpset);}',correct
'radius * objectX + timerX * 7',correct
'"Phone is upset: "',correct
'void upset() {    if (isUpsetTimer >= isUpsetDuration) {        isUpset = false;        isUpsetTimer = 0;        println("Computer is upset: " + isUpset);    }    if (isUpset) {        // Run when upset        println("Computer is upset: " + isUpset);        isUpsetTimer++;        if (speed < 15) {            speed++;        }    } else {        // Run when not upset        if (speed > 1) {            speed--;        }    }}',correct
'smokeParticles = new SmokeParticle[200]',correct
'isUpsetTimer++',correct
'// Stroke to Whitestroke(bodyWhite);',correct
'text("General Kenobi!", xPos, yPos - 90);',correct
'line(radius * objectX - 15, radius * objectY - 25, radius * objectX + 15, radius * objectY - 25);',correct
'x = xInit;',correct
'{    // If eastertimer > 400 then disable the easter egg and reset the timer    easterEgg = false;    easterTimer = 0;}',correct
'ellipse(radius * objectX, radius * objectY + 25, 8, 8)',correct
'smokeParticles[i] = new SmokeParticle(xPos, yPos, random(1, 60))',correct
'pushMatrix();',correct
'sparkParticles[i].update();',correct
'strokeWeight(1);',correct
'{    if (raccoon1.isOver(mouseX, mouseY)) {        raccoon1.isUpset = true;    }}',correct
'// isUpsetif (isUpsetTimer >= isUpsetDuration) {    isUpset = false;    isUpsetTimer = 0;    println("Raccoon is upset: " + isUpset);}',correct
'{    // buttons    ellipse(radius * objectX + 15, radius * objectY - 10 + counter * 7, 5, 5);}',correct
'timerY++',correct
'println("Raccoon is upset: " + isUpset)',correct
'if (raccoon1.easterEgg) {    // Activates the easteregg on the raccoon side    screen1.easterEgg = true;}',correct
'textSize(20)',correct
'rect(-18, 18, 4, 4)',correct
'{    rect(xPos - 20, yPos, 3, 3);    rect(xPos + 20, yPos, 3, 3);}',correct
'// Bottom Rightrect(30, -3, 35, 10);',correct
'raccoon1.isUpset = true',correct
'xPos - 35',correct
'if (easterTimer > 400) {    // If eastertimer > 400 then disable the easter egg and reset the timer    easterEgg = false;    easterTimer = 0;}',correct
'{    if (isUpset) {        for (int i = 0; i < smokeParticles.length; i++) {            smokeParticles[i].display();            smokeParticles[i].update();        }        for (int i = 0; i < sparkParticles.length; i++) {            sparkParticles[i].display();            sparkParticles[i].update();        }        for (int i = 0; i < smokeParticles.length; i++) {            if (smokeParticles[i].isDead()) {                for (int n = 0; n < smokeParticles.length; n++) {                    smokeParticles[n] = new SmokeParticle(xPos, yPos, random(1, 60));                }            }        }        for (int i = 0; i < sparkParticles.length; i++) {            if (sparkParticles[i].isDead()) {                for (int n = 0; n < sparkParticles.length; n++) {                    sparkParticles[n] = new SparkParticle(xPos, yPos, random(1, 3));                }            }        }    }    rectMode(CENTER);    // Stroke to Black    stroke(bodyBlack);    // Fill to Gray    fill(bodyGray);    // Stroke width to 5    strokeWeight(5);    // Ears    rect(xPos - 35, yPos - 35, 40, 40);    rect(xPos + 35, yPos - 35, 40, 40);    // Fill to White    fill(bodyWhite);    // No stroke    noStroke();    rect(xPos - 35, yPos - 35, 20, 20);    rect(xPos + 35, yPos - 35, 20, 20);    if (isUpset) {        // <------------------------------ Part of isUpset        // Red overlay over ears        fill(bodyUpset);        noStroke();        rect(xPos - 35, yPos - 35, 40, 40);        rect(xPos + 35, yPos - 35, 40, 40);        // Restore opacity        fill(255, 0, 0, 255);        stroke(bodyBlack);    }    // Fill to Gray    fill(bodyGray);    // Stroke to Black    stroke(bodyBlack);    // Head    pushMatrix();    translate(xPos, yPos);    rotate(radians(45));    rect(0, 0, 100, 100);    popMatrix();    // White stripes    pushMatrix();    translate(xPos, yPos);    // Fill to White    fill(bodyWhite);    // Stroke to White    stroke(bodyWhite);    rotate(radians(45));    // side of eyes    rect(20, -25, 50, 20);    rotate(radians(90));    rect(20, 25, 50, 20);    // middle eyes    rotate(radians(-135));    rect(-9, -11, 5, 2);    rect(9, -11, 5, 2);    // sides    rect(-50, 8, 20, 3);    rect(50, 8, 20, 3);    rotate(radians(45));    rect(-41, 48, 5, 5);    rotate(radians(90));    rect(-41, -48, 5, 5);    rotate(radians(-135));    // Nose    rect(18, 23, 10, 40);    rect(-18, 23, 10, 40);    rotate(radians(45));    rect(30, 41, 40, 10);    rotate(radians(-90));    rect(-30, 41, 40, 10);    popMatrix();    // Black stripes    pushMatrix();    translate(xPos, yPos);    rotate(radians(45));    // Fill to Black    fill(bodyBlack);    // Stroke to Black    stroke(bodyBlack);    // Top Right Eye    rect(25, -20, 50, 20);    // Bottom Right    rect(30, -3, 35, 10);    rotate(radians(-45));    // Middle Right    rect(11, 1, 10, 12);    rect(29, 32, 3, 15);    // Middle Left    rect(-11, 1, 10, 12);    rect(-29, 32, 3, 15);    rotate(radians(45));    rotate(radians(90));    // Top Left Eye    rect(25, 20, 50, 20);    // Bottom Left    rect(30, 3, 35, 10);    popMatrix();    // Nose    rect(xPos, yPos + 60, 1, 15);    rect(xPos, yPos + 50, 9, 9);    // Eyes    // Fill to White    fill(bodyWhite);    // Stroke to White    stroke(bodyWhite);    if (isUpset) {        pushMatrix();        translate(xPos, yPos);        rotate(radians(45));        rect(15, -15, 8, 8);        rect(-15, 15, 8, 8);        // Stroke to Black        stroke(bodyBlack);        rect(18, -18, 4, 4);        rect(-18, 18, 4, 4);        popMatrix();    } else {        rect(xPos - 20, yPos, 3, 3);        rect(xPos + 20, yPos, 3, 3);    }    // Head Lines    // No fill    noFill();    // Stroke to Black    stroke(bodyBlack);    pushMatrix();    translate(xPos, yPos);    rotate(radians(45));    rect(0, 0, 100, 100);    popMatrix();    if (isUpset) {        // <------------------------------ Part of isUpset        // Red overlay over head when triggered        fill(255, 0, 0, 120);        noStroke();        pushMatrix();        translate(xPos, yPos);        rotate(radians(45));        rect(0, 0, 100, 100);        popMatrix();        // Restore opacity        fill(255, 0, 0, 255);        // Display text when triggered        stroke(bodyBlack);        fill(bodyBlack);        textAlign(CENTER);        textSize(20);        text("Stop it!", xPos, yPos - 90);    }    if (easterEgg == true && isUpset == false) {        // Display text when easterEgg is true        stroke(bodyBlack);        fill(bodyBlack);        textAlign(CENTER);        textSize(20);        text("General Kenobi!", xPos, yPos - 90);    }}',LongMethodRule
'SmokeParticle[] smokeParticles = new SmokeParticle[200];',TooManyFields
'return false;',correct
'rect(-41, -48, 5, 5)',correct
'y = yInit;',correct
'fill(0, 0, 255);',correct
'float initSize',correct
'keyboard1.display();',correct
'fill(bodyGray)',correct
'rect(-18, 18, 4, 4);',correct
'raccoon1.easterEgg();',correct
'// draws the particlefill(80, 250 - lifeTime / 2);',correct
'/* This code was written by: Darryl Reekers No touchy! */Raccoon raccoon1;',correct
'fill(bodyWhite)',correct
'{    if (PApplet.parseInt(random(1600)) == 66 && easterEgg == false && isUpset == false) {        // Random chance to trigger easter-egg only when its not triggered already        easterEgg = true;        println("Nice! You found an Easter-Egg!");    }    if (easterTimer > 400) {        // If eastertimer > 400 then disable the easter egg and reset the timer        easterEgg = false;        easterTimer = 0;    }    if (easterEgg) {        // If easterEgg is true increase timer        easterTimer++;    }}',correct
'keyboard1.upset();',correct
'new SparkParticle[200]',correct
'{    for (int n = 0; n < smokeParticles.length; n++) {        smokeParticles[n] = new SmokeParticle(xPos, yPos, random(1, 60));    }}',correct
'sparkParticles[i]',correct
'noStroke()',correct
'if (isUpset) {    // Run when upset    println("Phone is upset: " + isUpset);    isUpsetTimer++;    if (speed < 15) {        speed++;    }} else {    // Run when not upset    if (speed > 1) {        speed--;    }}',correct
'Screen(float radiusInit, float initInterval, float xInit, float yInit) {    x = xInit;    y = yInit;    radius = radiusInit;    interval = initInterval;    speed = 1;}',correct
'SparkParticle[] sparkParticles = new SparkParticle[200];',TooManyFields
'textSize(25)',correct
'bodyBlack = color(0)',correct
'{    pushMatrix();    translate(x, y);    rectMode(CENTER);    strokeWeight(2);    fill(120);    stroke(0);    // Keyboard    rect(radius * objectX, radius * objectY, 130, 50);    strokeWeight(1);    fill(60);    for (int timerY = -2; timerY < 3; timerY++) {        for (int timerX = -8; timerX < 9; timerX++) {            rect(radius * objectX + timerX * 7, radius * objectY + timerY * 7, 7, 7);        }    }    rect(radius * objectX, radius * objectY + 15, 42, 7);    popMatrix();}',correct
'// Run when upsetprintln("Computer is upset: " + isUpset);',correct
'xPos',correct
'// Bottom Leftrect(30, 3, 35, 10);',correct
'text("Stop it!", xPos, yPos - 90);',correct
'0.04f',correct
'if (isUpsetTimer >= isUpsetDuration) {    isUpset = false;    isUpsetTimer = 0;    println("Keyboard is upset: " + isUpset);}',correct
'for (int i = 0; i < smokeParticles.length; i++) {    smokeParticles[i] = new SmokeParticle(xPos, yPos, random(1, 60));}',correct
'orbitlines.display();',correct
'for (int timerY = -2; timerY < 3; timerY++) {    for (int timerX = -8; timerX < 9; timerX++) {        rect(radius * objectX + timerX * 7, radius * objectY + timerY * 7, 7, 7);    }}',correct
'// Noserect(xPos, yPos + 60, 1, 15);',correct
'interval = initInterval;',correct
'computer1.upset()',correct
'keyboard1.isUpset = true;',correct
'fill(0)',correct
'height / 2',correct
'xSpeed = random(-4, 4);',correct
'// Easter-Eggboolean easterEgg;',TooManyFields
'int bodyGray = color(100);',correct
'rect(radius * objectX, radius * objectY, 35, 60)',correct
'void display() {    pushMatrix();    translate(x, y);    rectMode(CENTER);    strokeWeight(2);    stroke(0);    fill(60);    rect(radius * objectX, radius * objectY, 35, 60);    fill(30);    rect(radius * objectX, radius * objectY, 32, 45);    fill(50);    ellipse(radius * objectX, radius * objectY + 25, 8, 8);    line(radius * objectX - 15, radius * objectY - 25, radius * objectX + 15, radius * objectY - 25);    popMatrix();}',correct
'// Random chance to trigger easter-egg only when its not triggered alreadyeasterEgg = true;',correct
'{    smokeParticles[i] = new SmokeParticle(xPos, yPos, random(1, 60));}',correct
'int speed;',correct
'update',correct
'speed',correct
'orbitlines.display()',correct
'// Inner-Screen// if not upset display black screenfill(0);',correct
'void upset() {    // isUpset    if (isUpsetTimer >= isUpsetDuration) {        // Reset isUpsetTimer when it reaches the UpsetDuration        isUpset = false;        isUpsetTimer = 0;        println("Screen is upset: " + isUpset);    }    if (isUpset) {        // Run when upset        println("Screen is upset: " + isUpset);        isUpsetTimer++;        if (speed < 15) {            speed++;        }    } else {        // Run when not upset        if (speed > 1) {            speed--;        }    }}',TooManyFields
'class Screen {    float x;    float y;    float objectX;    float objectY;    float radius;    float angle;    float interval;    int speed;    // Upset    boolean isUpset;    int isUpsetTimer;    int isUpsetDuration = 500;    // Easter-Egg    boolean easterEgg;    int easterTimer;    Screen(float radiusInit, float initInterval, float xInit, float yInit) {        x = xInit;        y = yInit;        radius = radiusInit;        interval = initInterval;        speed = 1;    }    void display() {        pushMatrix();        translate(x, y);        rectMode(CENTER);        fill(180);        stroke(0);        strokeWeight(2);        // Stand        rect(radius * objectX, radius * objectY + 40, 20, 30);        // BottomStand        rect(radius * objectX, radius * objectY + 55, 60, 5);        // Outer-Screen        rect(radius * objectX, radius * objectY, 120, 68);        // Inner-Screen        // if not upset display black screen        fill(0);        stroke(0);        rect(radius * objectX, radius * objectY, 110, 62);        if (easterEgg) {            // if Easteregg is true then display secret            fill(255);            stroke(255);            textSize(18);            textAlign(CENTER);            text("Hello there!", radius * objectX, radius * objectY);        }        if (isUpset) {            // if upset display blue screen            stroke(0);            fill(0, 0, 255);            rect(radius * objectX, radius * objectY, 110, 62);            fill(255);            stroke(255);            textSize(25);            textAlign(CENTER);            text(":(", radius * objectX - 35, radius * objectY - 5);            textSize(9);            text("Something went wrong", radius * objectX, radius * objectY + 10);        }        popMatrix();    }    void update() {        angle = angle + speed % 360;        objectX = sin(radians(angle) + interval);        objectY = cos(radians(angle) + interval);    }    void upset() {        // isUpset        if (isUpsetTimer >= isUpsetDuration) {            // Reset isUpsetTimer when it reaches the UpsetDuration            isUpset = false;            isUpsetTimer = 0;            println("Screen is upset: " + isUpset);        }        if (isUpset) {            // Run when upset            println("Screen is upset: " + isUpset);            isUpsetTimer++;            if (speed < 15) {                speed++;            }        } else {            // Run when not upset            if (speed > 1) {                speed--;            }        }    }    void easterEgg() {        if (easterTimer > 400) {            // if EasterIimer reaches 400 then reset timer and set easterEgg to false            easterEgg = false;            easterTimer = 0;        }        if (easterEgg) {            // Add time to timer for easterEgg            easterTimer++;        }    }}',correct
'isUpsetTimer++;',correct
'println("Computer is upset: " + isUpset)',correct
'rect(xPos + 35, yPos - 35, 20, 20);',correct
'keyboard1 = new Keyboard(300, PI / 2, raccoon1.xPos, raccoon1.yPos)',correct
'// BottomStandrect(radius * objectX, radius * objectY + 55, 60, 5);',correct
'isUpsetDuration = 500',correct
'easterEgg == true',correct
'sparkParticles[n]',correct
'lifeTime',correct
'void display() {    pushMatrix();    translate(x, y);    rectMode(CENTER);    fill(180);    stroke(0);    strokeWeight(2);    // Stand    rect(radius * objectX, radius * objectY + 40, 20, 30);    // BottomStand    rect(radius * objectX, radius * objectY + 55, 60, 5);    // Outer-Screen    rect(radius * objectX, radius * objectY, 120, 68);    // Inner-Screen    // if not upset display black screen    fill(0);    stroke(0);    rect(radius * objectX, radius * objectY, 110, 62);    if (easterEgg) {        // if Easteregg is true then display secret        fill(255);        stroke(255);        textSize(18);        textAlign(CENTER);        text("Hello there!", radius * objectX, radius * objectY);    }    if (isUpset) {        // if upset display blue screen        stroke(0);        fill(0, 0, 255);        rect(radius * objectX, radius * objectY, 110, 62);        fill(255);        stroke(255);        textSize(25);        textAlign(CENTER);        text(":(", radius * objectX - 35, radius * objectY - 5);        textSize(9);        text("Something went wrong", radius * objectX, radius * objectY + 10);    }    popMatrix();}',TooManyFields
'// Powerbuttonellipse(radius * objectX, radius * objectY + 40, 10, 10);',correct
'translate(xPos, yPos)',correct
'// Middle Rightrect(11, 1, 10, 12);',correct
'{    xPos = initX;    yPos = initY;    size = initSize;    xSpeed = random(-4, 4);    ySpeed = random(-4, 4);    lifeTime = 0;}',correct
'if (easterEgg) {    // If easterEgg is true increase timer    easterTimer++;}',correct
'textAlign(CENTER);',correct
'background(0, 104, 255);',correct
'float ySpeed;',correct
'rect(25, -20, 50, 20)',correct
'stroke(255)',correct
'translate(x, y)',correct
'ellipse(xPos, yPos, 400, 400)',correct
'class Keyboard {    float x;    float y;    float objectX;    float objectY;    float radius;    float angle;    float interval;    int speed;    // Upset    boolean isUpset;    int isUpsetTimer;    int isUpsetDuration = 500;    Keyboard(float radiusInit, float initInterval, float xInit, float yInit) {        x = xInit;        y = yInit;        radius = radiusInit;        interval = initInterval;        speed = 1;    }    void display() {        pushMatrix();        translate(x, y);        rectMode(CENTER);        strokeWeight(2);        fill(120);        stroke(0);        // Keyboard        rect(radius * objectX, radius * objectY, 130, 50);        strokeWeight(1);        fill(60);        for (int timerY = -2; timerY < 3; timerY++) {            for (int timerX = -8; timerX < 9; timerX++) {                rect(radius * objectX + timerX * 7, radius * objectY + timerY * 7, 7, 7);            }        }        rect(radius * objectX, radius * objectY + 15, 42, 7);        popMatrix();    }    void update() {        angle = angle + speed % 360;        objectX = sin(radians(angle) + interval);        objectY = cos(radians(angle) + interval);    }    void upset() {        if (isUpsetTimer >= isUpsetDuration) {            isUpset = false;            isUpsetTimer = 0;            println("Keyboard is upset: " + isUpset);        }        if (isUpset) {            // Run when upset            println("Keyboard is upset: " + isUpset);            isUpsetTimer++;            if (speed < 15) {                speed++;            }        } else {            // Run when not upset            if (speed > 1) {                speed--;            }        }    }}',correct
'radius * objectY + 25',correct
'sparkParticles[i].display();',correct
'stroke(bodyBlack);',correct
'easterTimer > 400',correct
'"Stop it!"',correct
'-11',correct
'rotate(radians(90))',correct
'-15',correct
'maxTime = 510',correct
'float initInterval',correct
'-18',correct
'random(1, 60)',correct
'screen1 = new Screen(200, PI, raccoon1.xPos, raccoon1.yPos);',correct
'-20',correct
'{    sparkParticles[i] = new SparkParticle(xPos, yPos, random(1, 3));}',correct
'-25',correct
'objectX = sin(radians(angle) + interval);',correct
'-29',correct
'speed = 1;',correct
'lifeTime / 2',correct
'{    // Run when upset    println("Keyboard is upset: " + isUpset);    isUpsetTimer++;    if (speed < 15) {        speed++;    }}',correct
'radius * objectY + 40',correct
'yPos = initY',correct
'rect(radius * objectX, radius * objectY, 110, 62)',correct
'orbitlines = new OrbitRings(raccoon1.xPos, raccoon1.yPos);',correct
'void easterEgg() {    if (PApplet.parseInt(random(1600)) == 66 && easterEgg == false && isUpset == false) {        // Random chance to trigger easter-egg only when its not triggered already        easterEgg = true;        println("Nice! You found an Easter-Egg!");    }    if (easterTimer > 400) {        // If eastertimer > 400 then disable the easter egg and reset the timer        easterEgg = false;        easterTimer = 0;    }    if (easterEgg) {        // If easterEgg is true increase timer        easterTimer++;    }}',TooManyFields
'-30',correct
'translate(x, y);',correct
'class SparkParticle {    float xPos;    float yPos;    float size;    float xSpeed;    float ySpeed;    int maxTime = 255;    int lifeTime;    SparkParticle(float initX, float initY, float initSize) {        xPos = initX;        yPos = initY;        size = initSize;        xSpeed = random(-4, 4);        ySpeed = random(-4, 4);        lifeTime = 0;    }    void display() {        // draws the particle        fill(255, 200, 0, 100 - lifeTime);        noStroke();        ellipse(xPos, yPos, size + 5, size + 5);        fill(255, 255, 0, 255 - lifeTime);        ellipse(xPos, yPos, size, size);    }    void update() {        // updates the particle        lifeTime++;        ySpeed = ySpeed + 0.04f;        xPos = xPos + xSpeed;        yPos = yPos + ySpeed;    }    boolean isDead() {        // checks if the particle has expired        if (lifeTime > maxTime) {            return true;        } else {            return false;        }    }}',correct
'// CD Driverect(radius * objectX, radius * objectY - 30, 40, 10);',correct
'if (smokeParticles[i].isDead()) {    for (int n = 0; n < smokeParticles.length; n++) {        smokeParticles[n] = new SmokeParticle(xPos, yPos, random(1, 60));    }}',correct
'radius * objectY + 10',correct
'color(0)',correct
'radius * objectY + 15',correct
'phone1.upset();',correct
'rect(18, -18, 4, 4)',correct
'-41',correct
'rect(radius * objectX, radius * objectY, 32, 45);',correct
'-45',correct
'-48',correct
'objectX = sin(radians(angle) + interval)',correct
'// If eastertimer > 400 then disable the easter egg and reset the timereasterEgg = false;',correct
'void upset() {    if (isUpsetTimer >= isUpsetDuration) {        isUpset = false;        isUpsetTimer = 0;        println("Phone is upset: " + isUpset);    }    if (isUpset) {        // Run when upset        println("Phone is upset: " + isUpset);        isUpsetTimer++;        if (speed < 15) {            speed++;        }    } else {        // Run when not upset        if (speed > 1) {            speed--;        }    }}',correct
'fill(0, 0, 255)',correct
'if (isUpset) {    // Run when upset    println("Computer is upset: " + isUpset);    isUpsetTimer++;    if (speed < 15) {        speed++;    }} else {    // Run when not upset    if (speed > 1) {        speed--;    }}',correct
'i++',correct
'-50',correct
'sparkParticles[n] = new SparkParticle(xPos, yPos, random(1, 3))',correct
'// <------------------------------ Part of isUpset// Red overlay over head when triggeredfill(255, 0, 0, 120);',correct
'xSpeed = random(-1.0f, 1.0f);',correct
'smokeParticles[n] = new SmokeParticle(xPos, yPos, random(1, 60))',correct
'{    angle = angle + speed % 360;    objectX = sin(radians(angle) + interval);    objectY = cos(radians(angle) + interval);}',correct
'screen1',correct
'rotate(radians(-45));',correct
'radius * objectY - 10',correct
'// Outer-Screenrect(radius * objectX, radius * objectY, 120, 68);',correct
'ellipse(xPos, yPos, 600, 600)',correct
'int bodyBlack = color(0);',TooManyFields
'fill(60);',correct
'timerX * 7',correct
'speed++',correct
'// Top Left Eyerect(25, 20, 50, 20);',correct
'rect(25, 20, 50, 20)',correct
'screen1.easterEgg',correct
'stroke(255, 255, 255, 30)',correct
'speed = 1',correct
'yPos = initY;',correct
'textSize(9);',correct
'{    isUpset = false;    isUpsetTimer = 0;    println("Raccoon is upset: " + isUpset);}',correct
'Screen',TooManyFields
'bodyWhite = color(255)',correct
'stroke(255);',correct
'void display() {    noFill();    stroke(255, 255, 255, 30);    ellipse(xPos, yPos, 400, 400);    ellipse(xPos, yPos, 600, 600);}',correct
'raccoon1.yPos',correct
'rect(-29, 32, 3, 15);',correct
'objectY = cos(radians(angle) + interval)',correct
'radius * objectY + 55',correct
'timerY * 7',correct
'screen1.isUpset = true',correct
'rect(radius * objectX, radius * objectY, 110, 62);',correct
'// Display text when triggeredstroke(bodyBlack);',correct
'"Keyboard is upset: " + isUpset',correct
'smokeParticles.length',correct
'phone1.display();',correct
'// Keyboardrect(radius * objectX, radius * objectY, 130, 50);',correct
'if (sparkParticles[i].isDead()) {    for (int n = 0; n < sparkParticles.length; n++) {        sparkParticles[n] = new SparkParticle(xPos, yPos, random(1, 3));    }}',correct
'width / 2',correct
'float xPos;',TooManyFields
'boolean',correct
'println("Raccoon is upset: " + isUpset);',correct
'rotate(radians(-90));',correct
'SparkParticle(float initX, float initY, float initSize) {    xPos = initX;    yPos = initY;    size = initSize;    xSpeed = random(-4, 4);    ySpeed = random(-4, 4);    lifeTime = 0;}',correct
'fill(60)',correct
'i = 0',correct
'boatX - 50',correct
'titanic[i] = new Boat();',correct
'new Boat()',correct
'void display() {    fill(Color);    noStroke();    // top    triangle(boatX - 50, boatY, boatX, boatY - 50, boatX + 50, boatY);    fill(255, 80);    noStroke();    // top    triangle(boatX - 50, boatY, boatX, boatY - 50, boatX + 50, boatY);    fill(Color);    noStroke();    // middle    triangle(boatX - 50, boatY + 50, boatX, boatY, boatX + 50, boatY + 50);    fill(Color);    noStroke();    // left    triangle(boatX - 100, boatY - 10, boatX - 50, boatY + 50, boatX, boatY);    // right    triangle(boatX + 50, boatY + 50, boatX, boatY, boatX + 100, boatY - 10);    fill(255, 40);    noStroke();    // left    triangle(boatX - 100, boatY - 10, boatX - 50, boatY + 50, boatX, boatY);    // right    triangle(boatX + 50, boatY + 50, boatX, boatY, boatX + 100, boatY - 10);}',correct
'Color = color(red, green, blue);',correct
'titanic[i].display();',correct
'fill(255, 40);',correct
'rect(0, height / 2, width, height);',PixelHardcodeIgnoranceRule
'void setup() {    for (int i = 0; i < titanic.length; i++) {        titanic[i] = new Boat();    }}',correct
'rect(0, height / 2, width, height)',correct
'map(sin(theta), -1, 1, (height / 2) - 20, (height / 2) + 20)',correct
'{    boatX = 0;    boatY = height / 2;    red = random(200);    green = random(200);    blue = random(200);    Color = color(red, green, blue);}',correct
'{    // make the boat move forward    boatX = boatX + speed;    // make the boat float    boatY = map(sin(theta), -1, 1, (height / 2) - 20, (height / 2) + 20);    theta += 0.05f;}',correct
'Color = color(red, green, blue)',correct
'theta = 0',correct
'blue = random(200);',correct
'fill(33, 150, 243, 150)',correct
'boatY = height / 2',correct
'titanic.length',correct
'Boat[]',correct
'// Draw and move boatfor (int i = 0; i < total; i++) {    titanic[i].move();    titanic[i].display();}',correct
'// righttriangle(boatX + 50, boatY + 50, boatX, boatY, boatX + 100, boatY - 10);',correct
'{    total = total + 1;}',correct
'{    // Draw white background    background(255);    // Water    fill(33, 150, 243, 150);    stroke(33, 150, 243, 150);    rect(0, height / 2, width, height);    // Draw and move boat    for (int i = 0; i < total; i++) {        titanic[i].move();        titanic[i].display();    }}',correct
'boatY - 50',correct
'fill(Color)',correct
'// Program draws boat figure',correct
'// Lars Wintermans & Annefie Tuinstra',correct
'noStroke();',correct
'boatY = height / 2;',correct
'float boatX;',correct
'sin(theta)',correct
'{    titanic[i] = new Boat();}',correct
'// make the boat floatboatY = map(sin(theta), -1, 1, (height / 2) - 20, (height / 2) + 20);',correct
'int total = 0;',correct
'stroke(33, 150, 243, 150)',correct
'total = 0',correct
'random(1, 10)',correct
'int Color;',correct
'blue = random(200)',correct
'(height / 2) - 20',correct
'red = random(200);',correct
'float Ypos;',VariableNamingConventions
'// middletriangle(boatX - 50, boatY + 50, boatX, boatY, boatX + 50, boatY + 50);',correct
'titanic[i].move();',correct
'fill(Color);',correct
'float theta = 0;',correct
'display',correct
'triangle(boatX - 100, boatY - 10, boatX - 50, boatY + 50, boatX, boatY)',correct
'draw',correct
'stroke(33, 150, 243, 150);',correct
'Ypos',correct
'{    titanic[i].move();    titanic[i].display();}',correct
'boatY + 50',correct
'blue',correct
'// Program draws boat figure// Lars Wintermans & Annefie TuinstraBoat[] titanic = new Boat[100];',correct
'// Draw white backgroundbackground(255);',correct
'[100]',correct
'red = random(200)',correct
'noStroke()',correct
'Boat',correct
'boatX',correct
'theta += 0.05f',correct
'titanic[i]',correct
'boatY',correct
'i++',correct
'total = total + 1;',correct
'fill(255, 80);',correct
'red',correct
'boatX + speed',correct
'// Waterfill(33, 150, 243, 150);',correct
'green = random(200)',correct
'(height / 2) + 20',correct
'boatX = 0;',correct
'void',correct
'-1',correct
'class Boat {    float boatX;    float boatY;    float Ypos;    float theta = 0;    int Color;    float red;    float green;    float blue;    float speed = random(1, 10);    Boat() {        boatX = 0;        boatY = height / 2;        red = random(200);        green = random(200);        blue = random(200);        Color = color(red, green, blue);    }    void move() {        // make the boat move forward        boatX = boatX + speed;        // make the boat float        boatY = map(sin(theta), -1, 1, (height / 2) - 20, (height / 2) + 20);        theta += 0.05f;    }    void display() {        fill(Color);        noStroke();        // top        triangle(boatX - 50, boatY, boatX, boatY - 50, boatX + 50, boatY);        fill(255, 80);        noStroke();        // top        triangle(boatX - 50, boatY, boatX, boatY - 50, boatX + 50, boatY);        fill(Color);        noStroke();        // middle        triangle(boatX - 50, boatY + 50, boatX, boatY, boatX + 50, boatY + 50);        fill(Color);        noStroke();        // left        triangle(boatX - 100, boatY - 10, boatX - 50, boatY + 50, boatX, boatY);        // right        triangle(boatX + 50, boatY + 50, boatX, boatY, boatX + 100, boatY - 10);        fill(255, 40);        noStroke();        // left        triangle(boatX - 100, boatY - 10, boatX - 50, boatY + 50, boatX, boatY);        // right        triangle(boatX + 50, boatY + 50, boatX, boatY, boatX + 100, boatY - 10);    }}',correct
'void mousePressed() {    total = total + 1;}',correct
'Color',correct
'// toptriangle(boatX - 50, boatY, boatX, boatY - 50, boatX + 50, boatY);',correct
'// make the boat move forwardboatX = boatX + speed;',correct
'height / 2',correct
'{    fill(Color);    noStroke();    // top    triangle(boatX - 50, boatY, boatX, boatY - 50, boatX + 50, boatY);    fill(255, 80);    noStroke();    // top    triangle(boatX - 50, boatY, boatX, boatY - 50, boatX + 50, boatY);    fill(Color);    noStroke();    // middle    triangle(boatX - 50, boatY + 50, boatX, boatY, boatX + 50, boatY + 50);    fill(Color);    noStroke();    // left    triangle(boatX - 100, boatY - 10, boatX - 50, boatY + 50, boatX, boatY);    // right    triangle(boatX + 50, boatY + 50, boatX, boatY, boatX + 100, boatY - 10);    fill(255, 40);    noStroke();    // left    triangle(boatX - 100, boatY - 10, boatX - 50, boatY + 50, boatX, boatY);    // right    triangle(boatX + 50, boatY + 50, boatX, boatY, boatX + 100, boatY - 10);}',correct
'titanic = new Boat[100]',correct
'// lefttriangle(boatX - 100, boatY - 10, boatX - 50, boatY + 50, boatX, boatY);',correct
'Boat() {    boatX = 0;    boatY = height / 2;    red = random(200);    green = random(200);    blue = random(200);    Color = color(red, green, blue);}',correct
'void draw() {    // Draw white background    background(255);    // Water    fill(33, 150, 243, 150);    stroke(33, 150, 243, 150);    rect(0, height / 2, width, height);    // Draw and move boat    for (int i = 0; i < total; i++) {        titanic[i].move();        titanic[i].display();    }}',correct
'boatY - 10',correct
'triangle(boatX + 50, boatY + 50, boatX, boatY, boatX + 100, boatY - 10)',correct
'boatX = boatX + speed',correct
'float blue;',correct
'theta += 0.05f;',correct
'titanic[i].display()',correct
'color(red, green, blue)',correct
'titanic[i] = new Boat()',correct
'green = random(200);',correct
'float green;',correct
'background(255)',correct
'Processing',correct
'boatX - 100',correct
'boatX + 50',correct
'float boatY;',correct
'triangle(boatX - 50, boatY, boatX, boatY - 50, boatX + 50, boatY)',correct
'i < titanic.length',correct
'random(200)',correct
'titanic[i].move()',correct
'total + 1',correct
'move',correct
'green',correct
'boatY = map(sin(theta), -1, 1, (height / 2) - 20, (height / 2) + 20)',correct
'float red;',correct
'fill(255, 40)',correct
'void move() {    // make the boat move forward    boatX = boatX + speed;    // make the boat float    boatY = map(sin(theta), -1, 1, (height / 2) - 20, (height / 2) + 20);    theta += 0.05f;}',correct
'new Boat[100]',correct
'{    for (int i = 0; i < titanic.length; i++) {        titanic[i] = new Boat();    }}',correct
'boatX = 0',correct
'speed = random(1, 10)',correct
'int i = 0',correct
'boatX + 100',correct
'float speed = random(1, 10);',correct
'for (int i = 0; i < titanic.length; i++) {    titanic[i] = new Boat();}',correct
'total = total + 1',correct
'i < total',correct
'triangle(boatX - 50, boatY + 50, boatX, boatY, boatX + 50, boatY + 50)',correct
'0.05f',correct
'fill(255, 80)',correct
'text("mr. rabbit is fed-up, thanks!", 160, 380);',PixelHardcodeIgnoranceRule
'if (konijnY < 450) {    konijnY = 450;} else if (konijnY > 822) {    konijnY = 822;}',correct
'cloudX - 45 > 846',correct
'sun2 = new sun()',correct
'line(cx - 12, cy, cx - 15, cy - 10);',correct
'speed2 = random(0.3f, 1);',correct
'arc(400, 600, 500, 330, PI, 2 * PI)',correct
'textSize(40);',correct
'// eyesnoStroke();',correct
'"(to reset, eat another carrot)"',correct
'font1',correct
'cx - 12',correct
'cx - 10',correct
'{}',EmptyIfStmt
'stroke(0);',correct
'ellipse(sunX, sunY, 100, 100)',correct
'stroke(0)',correct
'score + 1',correct
'konijnY += 2',correct
'{    sunX = 100;    sunY = 100;}',correct
'boolean fedup;',correct
'line(cx - 3, cy, cx, cy - 10)',correct
'{    arc(sunX + 20, sunY - 5, 40, 40, 2 * PI, 3 * PI);    arc(sunX - 20, sunY - 5, 40, 40, 2 * PI, 3 * PI);}',correct
'konijnY < 450',correct
'if (konijnX + 22 < -11) {    konijnX = 821;} else if (konijnX - 15 > 822) {    konijnX = -10;} else if (konijnY < 450) {    konijnY = 450;} else if (konijnY > 822) {    konijnY = 822;}',correct
'sunY = 100',correct
'void eating() {    if (((konijn2.konijnX - 40) < carrot2.cx && carrot2.cx < (konijn2.konijnX + 40)) && ((konijn2.konijnY - 60) < carrot2.cy && carrot2.cy < (konijn2.konijnY + 10))) {        eating = true;    } else {        eating = false;    }}',correct
'void reset() {    cx = random(width);    cy = random(430, 780);}',correct
'-0.3f',correct
'ellipse(konijnX - 20, konijnY - 30, 3, 4);',correct
'konijnY = height - 200',correct
'text("(to reset, eat another carrot)", 160, 420);',PixelHardcodeIgnoranceRule
'cloud2[i].display();',correct
'PFont',correct
'konijnX = 821',correct
'cloudX = random(width);',correct
'"carrots eaten: "',correct
'ellipse(konijnX - 10, konijnY - 30, 3, 4)',correct
'line(cx - 12, cy, cx - 15, cy - 10)',correct
'{    cx = random(width);    cy = random(430, 780);}',correct
'if (((konijn2.konijnX - 20) < carrot2.cx && carrot2.cx < (konijn2.konijnX + 10)) && ((konijn2.konijnY - 40) < carrot2.cy && carrot2.cy < (konijn2.konijnY - 10))) {    carrot2.reset();    score = score + 1;}',correct
'fill(0);',correct
'ellipse(sunX - 20, sunY - 7, 15, 20);',correct
'ellipse(sunX, sunY, 100, 100);',correct
'arc(cloudX, cloudY, 50, 60, PI, 2 * PI);',correct
'arc(konijnX - 5, konijnY + 5, 15, 15, 2 * PI, 3 * PI)',correct
'konijn2.move()',correct
'sunX = 100;',correct
'arc(sunX + 20, sunY - 5, 40, 40, 2 * PI, 3 * PI)',correct
'background(135, 206, 250);',correct
'rectMode(CENTER)',correct
'cloudX - 45',correct
'fill(255, 131, 0);',correct
'{    konijnX = -10;}',correct
'cx - 15',correct
'ellipse(konijnX - 10, konijnY - 30, 10, 15)',correct
'eating',correct
'konijnX + 22 < -11',correct
'{    konijnX -= 2;}',correct
'ellipse(konijnX - 15, konijnY - 18, 18, 15)',correct
'cx',correct
'cy',correct
'rectMode(CENTER);',correct
'konijnX - 15 > 822',correct
'konijn konijn2;',correct
'arc(cloudX, cloudY, 50, 60, PI, 2 * PI)',correct
'if (eating) {    ellipse(konijnX - 20, konijnY - 30, 10, 15);    ellipse(konijnX - 10, konijnY - 30, 10, 15);} else {    ellipse(konijnX - 20, konijnY - 30, 5, 7);    ellipse(konijnX - 10, konijnY - 30, 5, 7);}',correct
'rect(0, 800, 1600, 400);',PixelHardcodeIgnoranceRule
'arc(sunX - 20, sunY - 40, 40, 40, 2 * PI, 3 * PI);',correct
'konijnX = -10;',correct
'konijnX = 821;',correct
'line(cx - 3, cy, cx, cy - 10);',correct
'class sun {    float sunX;    float sunY;    boolean eating;    sun() {        sunX = 100;        sunY = 100;    }    void display() {        noStroke();        fill(255, 222, 0);        ellipse(sunX, sunY, 100, 100);        // eyes        stroke(0);        if (eating) {            fill(255);            ellipse(sunX + 20, sunY - 7, 15, 20);            ellipse(sunX - 20, sunY - 7, 15, 20);            fill(0);            ellipse(sunX + 20, sunY - 7, 3, 4);            ellipse(sunX - 20, sunY - 7, 3, 4);        } else {            fill(255);            ellipse(sunX + 20, sunY - 7, 15, 20);            ellipse(sunX - 20, sunY - 7, 15, 20);            fill(0);            ellipse(sunX + 20, sunY - 7, 3, 4);            ellipse(sunX - 20, sunY - 7, 3, 4);            noStroke();            fill(255, 222, 0);            arc(sunX + 20, sunY - 7, 15, 15, PI, 2 * PI);            arc(sunX - 20, sunY - 7, 15, 15, PI, 2 * PI);        }        // sunglasses        fill(0);        if (eating) {            arc(sunX + 20, sunY - 40, 40, 40, 2 * PI, 3 * PI);            arc(sunX - 20, sunY - 40, 40, 40, 2 * PI, 3 * PI);            line(sunX + 40, sunY - 40, sunX + 53, sunY - 33);        } else {            arc(sunX + 20, sunY - 5, 40, 40, 2 * PI, 3 * PI);            arc(sunX - 20, sunY - 5, 40, 40, 2 * PI, 3 * PI);        }        // mouth        if (eating) {            ellipse(sunX, sunY + 20, 20, 17);        } else {            stroke(0);            noFill();            arc(sunX, sunY + 20, 30, 20, 2 * PI, 3 * PI);        }    }    void eating() {        if (((konijn2.konijnX - 40) < carrot2.cx && carrot2.cx < (konijn2.konijnX + 40)) && ((konijn2.konijnY - 60) < carrot2.cy && carrot2.cy < (konijn2.konijnY + 10))) {            eating = true;        } else {            eating = false;        }    }}',correct
'arc(sunX, sunY + 20, 30, 20, 2 * PI, 3 * PI)',correct
'cloudY = random(100, 300);',correct
'cloud2[i].move();',correct
'ellipse(konijnX - 10, konijnY - 30, 10, 15);',correct
'cloudX + speed2',correct
'carrot carrot2;',correct
'cloudX + speed1',correct
'cloudX - 22',correct
'line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 22)',correct
'arc(konijnX - 15, konijnY + 5, 15, 15, 2 * PI, 3 * PI)',correct
'new sun()',correct
'arc(700, 600, 500, 300, PI, 2 * PI);',PixelHardcodeIgnoranceRule
'// bodystroke(0);',correct
'float cx;',ShortVariable
'konijnY -= 2;',correct
'quad(cx, cy, cx - 15, cy, cx - 10, cy + 30, cx - 5, cy + 30)',correct
'carrot2.reset()',correct
'sunX - 20',correct
'score = 0',correct
'carrot2 = new carrot();',correct
'konijn2.eating()',correct
'konijn2 = new konijn()',correct
'ellipse(konijnX - 10, konijnY - 30, 5, 7)',correct
'if (score == 6) {    score = 0;}',correct
'line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 14);',correct
'background(135, 206, 250)',correct
'arc(700, 600, 500, 300, PI, 2 * PI)',correct
'sun2.eating();',correct
'float cy;',ShortVariable
'Processing',correct
'arc(sunX - 20, sunY - 5, 40, 40, 2 * PI, 3 * PI)',correct
'text("carrots eaten: " + score, 470, 100)',correct
'void move() {    cloudX = cloudX + speed1;    cloudX = cloudX + speed2;    if (cloudX - 45 > 846) {        cloudX = -40;    }    if (cloudX < -41) {        cloudX = 845;    }}',correct
'cloud2[i] = new cloud();',correct
'class cloud {    float cloudX;    float cloudY;    float speed1;    float speed2;    cloud() {        cloudX = random(width);        cloudY = random(100, 300);        speed1 = random(-1, -0.3f);        speed2 = random(0.3f, 1);    }    void display() {        noStroke();        fill(255, 255, 255, 200);        arc(cloudX, cloudY, 50, 60, PI, 2 * PI);        arc(cloudX - 45, cloudY, 50, 60, PI, 2 * PI);        arc(cloudX - 22, cloudY - 15, 50, 60, PI, 2 * PI);    }    void move() {        cloudX = cloudX + speed1;        cloudX = cloudX + speed2;        if (cloudX - 45 > 846) {            cloudX = -40;        }        if (cloudX < -41) {            cloudX = 845;        }    }}',correct
'{    konijnX = 821;}',correct
'false',correct
'random(430, 780)',correct
'i = 0',correct
'fill(0, 190, 0)',correct
'if (((konijnX - 40) < carrot2.cx && carrot2.cx < (konijnX + 40)) && ((konijnY - 60) < carrot2.cy && carrot2.cy < (konijnY + 10))) {    eating = true;} else {    eating = false;}',correct
'cloudX = -40',correct
'cloud2[i].display()',correct
'cy - 10',correct
'0.3f',correct
'text("mr. rabbit is fed-up, thanks!", 160, 380)',correct
'if (konijnY > 822) {    konijnY = 822;}',correct
'ellipse(sunX - 20, sunY - 7, 3, 4)',correct
'for (int i = 0; i < cloud2.length; i++) {    cloud2[i] = new cloud();}',correct
'konijnX += 2',correct
'arc(konijnX - 15, konijnY + 5, 15, 15, 0.5f * PI, 2 * PI)',correct
'// tailellipse(konijnX + 22, konijnY + 20, 10, 10);',correct
'fedup',correct
'cloud2.length',correct
'ellipse(sunX + 20, sunY - 7, 3, 4)',correct
'{    carrot2.reset();    score = score + 1;}',correct
'if (cloudX < -41) {    cloudX = 845;}',correct
'sunX + 40',correct
'i < cloud2.length',correct
'text("carrots eaten: " + score, 470, 100);',PixelHardcodeIgnoranceRule
'noStroke();',correct
'arc(sunX + 20, sunY - 7, 15, 15, PI, 2 * PI)',correct
'{    konijnY += 2;}',correct
'{    fill(255);    ellipse(sunX + 20, sunY - 7, 15, 20);    ellipse(sunX - 20, sunY - 7, 15, 20);    fill(0);    ellipse(sunX + 20, sunY - 7, 3, 4);    ellipse(sunX - 20, sunY - 7, 3, 4);}',correct
'// eyesstroke(0);',correct
'{    konijnColor = color(179, 60, 0);    konijnX = width / 2;    konijnY = height - 200;}',correct
'cx - 7',correct
'strokeWeight(1)',correct
'ellipse(konijnX - 20, konijnY - 30, 3, 4)',correct
'arc(sunX + 20, sunY - 40, 40, 40, 2 * PI, 3 * PI);',correct
'konijnX = width / 2',correct
'konijn() {    konijnColor = color(179, 60, 0);    konijnX = width / 2;    konijnY = height - 200;}',correct
'cx - 5',correct
'sunY - 40',correct
'cx - 3',correct
'sunX + 53',correct
'keyCode == UP',correct
'0.5f',correct
'sun2.display();',correct
'// mouthif (eating) {    ellipse(sunX, sunY + 20, 20, 17);} else {    stroke(0);    noFill();    arc(sunX, sunY + 20, 30, 20, 2 * PI, 3 * PI);}',correct
'ellipse(sunX - 20, sunY - 7, 3, 4);',correct
'sun2.eating()',correct
'fill(konijnColor);',correct
'konijnY = 822;',correct
'ellipse(sunX, sunY + 20, 20, 17)',correct
'konijnX -= 2;',correct
'cx = random(width);',correct
'arc(cloudX - 45, cloudY, 50, 60, PI, 2 * PI);',correct
'{    ellipse(konijnX - 15, konijnY - 18, 18, 15);}',correct
'{    ellipse(konijnX - 20, konijnY - 30, 10, 15);    ellipse(konijnX - 10, konijnY - 30, 10, 15);}',correct
'arc(sunX + 20, sunY - 7, 15, 15, PI, 2 * PI);',correct
'new konijn()',correct
'ellipse(konijnX - 20, konijnY - 30, 5, 7)',correct
'sun2 = new sun();',correct
'void display() {    strokeWeight(1);    // ears    stroke(0);    fill(konijnColor);    ellipse(konijnX - 25, konijnY - 45, 12, 30);    ellipse(konijnX - 5, konijnY - 45, 12, 30);    noStroke();    fill(255, 114, 161);    ellipse(konijnX - 25, konijnY - 45, 5, 20);    ellipse(konijnX - 5, konijnY - 45, 5, 20);    // body    stroke(0);    fill(konijnColor);    ellipse(konijnX, konijnY, 45, 60);    // tail    ellipse(konijnX + 22, konijnY + 20, 10, 10);    // head    ellipse(konijnX - 15, konijnY - 25, 40, 40);    // eyes    noStroke();    fill(255);    if (eating) {        ellipse(konijnX - 20, konijnY - 30, 10, 15);        ellipse(konijnX - 10, konijnY - 30, 10, 15);    } else {        ellipse(konijnX - 20, konijnY - 30, 5, 7);        ellipse(konijnX - 10, konijnY - 30, 5, 7);    }    noStroke();    fill(0);    ellipse(konijnX - 20, konijnY - 30, 3, 4);    ellipse(konijnX - 10, konijnY - 30, 3, 4);    // nose    if (eating) {        ellipse(konijnX - 15, konijnY - 18, 18, 15);    } else {        ellipse(konijnX - 15, konijnY - 18, 6, 4);        stroke(0);        line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 14);        line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 18);        line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 22);        line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 14);        line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 18);        line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 22);    }    // paws    stroke(0);    fill(konijnColor);    arc(konijnX - 13, konijnY + 33, 15, 15, PI, 2 * PI);    arc(konijnX - 5, konijnY + 33, 15, 15, PI, 2 * PI);    if (eating) {        arc(konijnX - 15, konijnY + 5, 15, 15, 0.5f * PI, 2 * PI);        arc(konijnX - 5, konijnY + 5, 15, 15, 0.5f * PI, 2 * PI);    } else {        arc(konijnX - 15, konijnY + 5, 15, 15, 2 * PI, 3 * PI);        arc(konijnX - 5, konijnY + 5, 15, 15, 2 * PI, 3 * PI);    }    if (konijnX + 22 < -11) {        konijnX = 821;    } else if (konijnX - 15 > 822) {        konijnX = -10;    } else if (konijnY < 450) {        konijnY = 450;    } else if (konijnY > 822) {        konijnY = 822;    }}',correct
'ellipse(sunX + 20, sunY - 7, 15, 20);',correct
'{    score = 0;}',correct
'ellipseMode(CENTER)',correct
'cloudX = 845;',correct
'fill(255, 114, 161)',correct
'line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 22);',correct
'{    background(135, 206, 250);    noStroke();    fill(0, 190, 0);    arc(100, 600, 500, 300, PI, 2 * PI);    arc(400, 600, 500, 330, PI, 2 * PI);    arc(700, 600, 500, 300, PI, 2 * PI);    rect(0, 800, 1600, 400);    konijn2.display();    konijn2.move();    konijn2.eating();    sun2.display();    sun2.eating();    for (int i = 0; i < cloud2.length; i++) {        cloud2[i].display();        cloud2[i].move();    }    textFont(font1);    textSize(40);    fill(255, 222, 0);    text("carrots eaten: " + score, 470, 100);    carrot2.display();    if (((konijn2.konijnX - 20) < carrot2.cx && carrot2.cx < (konijn2.konijnX + 10)) && ((konijn2.konijnY - 40) < carrot2.cy && carrot2.cy < (konijn2.konijnY - 10))) {        carrot2.reset();        score = score + 1;    }    if (score == 5) {        text("mr. rabbit is fed-up, thanks!", 160, 380);        text("(to reset, eat another carrot)", 160, 420);    } else if (score == 6) {        score = 0;    }}',correct
'{    cloudX = 845;}',correct
'int konijnColor;',correct
'font1 = createFont("Arial Bold", 18)',correct
'3 * PI',correct
'void',LongMethodRule
'-1',correct
'arc(konijnX - 5, konijnY + 5, 15, 15, 0.5f * PI, 2 * PI);',correct
'ellipse(konijnX - 20, konijnY - 30, 10, 15)',correct
'new cloud()',correct
'void move() {    if (keyPressed == true) {        if (keyCode == LEFT) {            konijnX -= 2;        } else if (keyCode == RIGHT) {            konijnX += 2;        } else if (keyCode == UP) {            konijnY -= 2;        } else if (keyCode == DOWN) {            konijnY += 2;        } else {        }    }}',correct
'cloudX < -41',correct
'konijn2.display()',correct
'noFill();',correct
'true',correct
'textSize(40)',correct
'{    eating = false;}',correct
'carrot2.reset();',correct
'arc(sunX - 20, sunY - 40, 40, 40, 2 * PI, 3 * PI)',correct
'arc(100, 600, 500, 300, PI, 2 * PI)',correct
'sunX = 100',correct
'textFont(font1)',correct
'void draw() {    background(135, 206, 250);    noStroke();    fill(0, 190, 0);    arc(100, 600, 500, 300, PI, 2 * PI);    arc(400, 600, 500, 330, PI, 2 * PI);    arc(700, 600, 500, 300, PI, 2 * PI);    rect(0, 800, 1600, 400);    konijn2.display();    konijn2.move();    konijn2.eating();    sun2.display();    sun2.eating();    for (int i = 0; i < cloud2.length; i++) {        cloud2[i].display();        cloud2[i].move();    }    textFont(font1);    textSize(40);    fill(255, 222, 0);    text("carrots eaten: " + score, 470, 100);    carrot2.display();    if (((konijn2.konijnX - 20) < carrot2.cx && carrot2.cx < (konijn2.konijnX + 10)) && ((konijn2.konijnY - 40) < carrot2.cy && carrot2.cy < (konijn2.konijnY - 10))) {        carrot2.reset();        score = score + 1;    }    if (score == 5) {        text("mr. rabbit is fed-up, thanks!", 160, 380);        text("(to reset, eat another carrot)", 160, 420);    } else if (score == 6) {        score = 0;    }}',LongMethodRule
'ellipse(konijnX - 5, konijnY - 45, 5, 20);',correct
'cloudY = random(100, 300)',correct
'{    cloud2[i].display();    cloud2[i].move();}',correct
'{    cloud2[i] = new cloud();}',correct
'konijn2.move();',correct
'time = millis()',correct
'arc(sunX + 20, sunY - 40, 40, 40, 2 * PI, 3 * PI)',correct
'fill(konijnColor)',correct
'konijnX -= 2',correct
'{    if (((konijn2.konijnX - 40) < carrot2.cx && carrot2.cx < (konijn2.konijnX + 40)) && ((konijn2.konijnY - 60) < carrot2.cy && carrot2.cy < (konijn2.konijnY + 10))) {        eating = true;    } else {        eating = false;    }}',correct
'konijnColor = color(179, 60, 0);',correct
'cloud2 = new cloud[10]',correct
'if (keyPressed == true) {    if (keyCode == LEFT) {        konijnX -= 2;    } else if (keyCode == RIGHT) {        konijnX += 2;    } else if (keyCode == UP) {        konijnY -= 2;    } else if (keyCode == DOWN) {        konijnY += 2;    } else {    }}',DecentralizedEventHandlingRule
'sunY - 5',correct
'// ears',correct
'"mr. rabbit is fed-up, thanks!"',correct
'sunX + 20',correct
'if (keyCode == LEFT) {    konijnX -= 2;} else if (keyCode == RIGHT) {    konijnX += 2;} else if (keyCode == UP) {    konijnY -= 2;} else if (keyCode == DOWN) {    konijnY += 2;} else {}',DecentralizedEventHandlingRule
'strokeWeight(4)',correct
'konijnY - 45',correct
'// noseif (eating) {    ellipse(konijnX - 15, konijnY - 18, 18, 15);} else {    ellipse(konijnX - 15, konijnY - 18, 6, 4);    stroke(0);    line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 14);    line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 18);    line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 22);    line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 14);    line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 18);    line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 22);}',correct
'sunY - 7',correct
'carrot() {    cx = random(width);    cy = random(430, 780);}',correct
'konijn2.display();',correct
'random(width)',correct
'random(0.3f, 1)',correct
'void eating() {    if (((konijnX - 40) < carrot2.cx && carrot2.cx < (konijnX + 40)) && ((konijnY - 60) < carrot2.cy && carrot2.cy < (konijnY + 10))) {        eating = true;    } else {        eating = false;    }}',correct
'carrot2',correct
'konijnX = width / 2;',correct
'arc(sunX + 20, sunY - 5, 40, 40, 2 * PI, 3 * PI);',correct
'konijnY - 25',correct
'if (keyCode == DOWN) {    konijnY += 2;} else {}',DecentralizedEventHandlingRule
'konijnY = height - 200;',correct
'konijnY - 30',correct
'ellipse(konijnX, konijnY, 45, 60);',correct
'float sunY;',correct
'konijnColor = color(179, 60, 0)',correct
'eating = false',correct
'ellipse(konijnX - 15, konijnY - 18, 18, 15);',correct
'arc(cloudX - 45, cloudY, 50, 60, PI, 2 * PI)',correct
'{    eating = true;}',correct
'((konijnX - 40) < carrot2.cx && carrot2.cx < (konijnX + 40)) && ((konijnY - 60) < carrot2.cy && carrot2.cy < (konijnY + 10))',correct
'strokeWeight(1);',correct
'konijnY - 14',correct
'konijnY - 18',correct
'fill(255, 222, 0);',correct
'text("(to reset, eat another carrot)", 160, 420)',correct
'konijnY - 22',correct
'ellipse(konijnX - 10, konijnY - 30, 5, 7);',correct
'if (cloudX - 45 > 846) {    cloudX = -40;}',correct
'{    konijnY = 822;}',correct
'{    rectMode(CENTER);    ellipseMode(CENTER);    color(0, 190, 0);    konijnColor = color(179, 60, 0);    konijn2 = new konijn();    carrot2 = new carrot();    sun2 = new sun();    for (int i = 0; i < cloud2.length; i++) {        cloud2[i] = new cloud();    }    font1 = createFont("Arial Bold", 18);    time = millis();}',correct
'void display() {    noStroke();    fill(255, 222, 0);    ellipse(sunX, sunY, 100, 100);    // eyes    stroke(0);    if (eating) {        fill(255);        ellipse(sunX + 20, sunY - 7, 15, 20);        ellipse(sunX - 20, sunY - 7, 15, 20);        fill(0);        ellipse(sunX + 20, sunY - 7, 3, 4);        ellipse(sunX - 20, sunY - 7, 3, 4);    } else {        fill(255);        ellipse(sunX + 20, sunY - 7, 15, 20);        ellipse(sunX - 20, sunY - 7, 15, 20);        fill(0);        ellipse(sunX + 20, sunY - 7, 3, 4);        ellipse(sunX - 20, sunY - 7, 3, 4);        noStroke();        fill(255, 222, 0);        arc(sunX + 20, sunY - 7, 15, 15, PI, 2 * PI);        arc(sunX - 20, sunY - 7, 15, 15, PI, 2 * PI);    }    // sunglasses    fill(0);    if (eating) {        arc(sunX + 20, sunY - 40, 40, 40, 2 * PI, 3 * PI);        arc(sunX - 20, sunY - 40, 40, 40, 2 * PI, 3 * PI);        line(sunX + 40, sunY - 40, sunX + 53, sunY - 33);    } else {        arc(sunX + 20, sunY - 5, 40, 40, 2 * PI, 3 * PI);        arc(sunX - 20, sunY - 5, 40, 40, 2 * PI, 3 * PI);    }    // mouth    if (eating) {        ellipse(sunX, sunY + 20, 20, 17);    } else {        stroke(0);        noFill();        arc(sunX, sunY + 20, 30, 20, 2 * PI, 3 * PI);    }}',correct
'int score = 0;',correct
'ellipse(konijnX - 25, konijnY - 45, 12, 30)',correct
'line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 14)',correct
'{    if (keyPressed == true) {        if (keyCode == LEFT) {            konijnX -= 2;        } else if (keyCode == RIGHT) {            konijnX += 2;        } else if (keyCode == UP) {            konijnY -= 2;        } else if (keyCode == DOWN) {            konijnY += 2;        } else {        }    }}',correct
'if (((konijn2.konijnX - 40) < carrot2.cx && carrot2.cx < (konijn2.konijnX + 40)) && ((konijn2.konijnY - 60) < carrot2.cy && carrot2.cy < (konijn2.konijnY + 10))) {    eating = true;} else {    eating = false;}',correct
'arc(400, 600, 500, 330, PI, 2 * PI);',PixelHardcodeIgnoranceRule
'{    ellipse(konijnX - 20, konijnY - 30, 5, 7);    ellipse(konijnX - 10, konijnY - 30, 5, 7);}',correct
'fill(255, 114, 161);',correct
'sun',correct
'sunY + 20',correct
'konijn2.eating();',correct
'score == 6',correct
'score == 5',correct
'cloudX = cloudX + speed1;',correct
'createFont("Arial Bold", 18)',correct
'speed2',correct
'ellipse(konijnX - 15, konijnY - 25, 40, 40)',correct
'speed1',correct
'{    arc(konijnX - 15, konijnY + 5, 15, 15, 2 * PI, 3 * PI);    arc(konijnX - 5, konijnY + 5, 15, 15, 2 * PI, 3 * PI);}',correct
'time = millis();',correct
'{    arc(konijnX - 15, konijnY + 5, 15, 15, 0.5f * PI, 2 * PI);    arc(konijnX - 5, konijnY + 5, 15, 15, 0.5f * PI, 2 * PI);}',correct
'{    konijnY = 450;}',correct
'cy = random(430, 780)',correct
'new cloud[10]',correct
'{    noStroke();    fill(255, 255, 255, 200);    arc(cloudX, cloudY, 50, 60, PI, 2 * PI);    arc(cloudX - 45, cloudY, 50, 60, PI, 2 * PI);    arc(cloudX - 22, cloudY - 15, 50, 60, PI, 2 * PI);}',correct
'konijnY > 822',correct
'{    noStroke();    fill(255, 222, 0);    ellipse(sunX, sunY, 100, 100);    // eyes    stroke(0);    if (eating) {        fill(255);        ellipse(sunX + 20, sunY - 7, 15, 20);        ellipse(sunX - 20, sunY - 7, 15, 20);        fill(0);        ellipse(sunX + 20, sunY - 7, 3, 4);        ellipse(sunX - 20, sunY - 7, 3, 4);    } else {        fill(255);        ellipse(sunX + 20, sunY - 7, 15, 20);        ellipse(sunX - 20, sunY - 7, 15, 20);        fill(0);        ellipse(sunX + 20, sunY - 7, 3, 4);        ellipse(sunX - 20, sunY - 7, 3, 4);        noStroke();        fill(255, 222, 0);        arc(sunX + 20, sunY - 7, 15, 15, PI, 2 * PI);        arc(sunX - 20, sunY - 7, 15, 15, PI, 2 * PI);    }    // sunglasses    fill(0);    if (eating) {        arc(sunX + 20, sunY - 40, 40, 40, 2 * PI, 3 * PI);        arc(sunX - 20, sunY - 40, 40, 40, 2 * PI, 3 * PI);        line(sunX + 40, sunY - 40, sunX + 53, sunY - 33);    } else {        arc(sunX + 20, sunY - 5, 40, 40, 2 * PI, 3 * PI);        arc(sunX - 20, sunY - 5, 40, 40, 2 * PI, 3 * PI);    }    // mouth    if (eating) {        ellipse(sunX, sunY + 20, 20, 17);    } else {        stroke(0);        noFill();        arc(sunX, sunY + 20, 30, 20, 2 * PI, 3 * PI);    }}',LongMethodRule
'ellipse(sunX, sunY + 20, 20, 17);',correct
'random(100, 300)',correct
'cloudX = cloudX + speed2;',correct
'millis()',correct
'sun sun2;',correct
'speed1 = random(-1, -0.3f);',correct
'cloud2[i]',correct
'cloudY - 15',correct
'void setup() {    rectMode(CENTER);    ellipseMode(CENTER);    color(0, 190, 0);    konijnColor = color(179, 60, 0);    konijn2 = new konijn();    carrot2 = new carrot();    sun2 = new sun();    for (int i = 0; i < cloud2.length; i++) {        cloud2[i] = new cloud();    }    font1 = createFont("Arial Bold", 18);    time = millis();}',correct
'noStroke()',correct
'ellipse(konijnX - 25, konijnY - 45, 12, 30);',correct
'{    arc(sunX + 20, sunY - 40, 40, 40, 2 * PI, 3 * PI);    arc(sunX - 20, sunY - 40, 40, 40, 2 * PI, 3 * PI);    line(sunX + 40, sunY - 40, sunX + 53, sunY - 33);}',correct
'cy + 30',correct
'rect(0, 800, 1600, 400)',correct
'boolean eating;',correct
'arc(sunX - 20, sunY - 5, 40, 40, 2 * PI, 3 * PI);',correct
'{    strokeWeight(4);    stroke(0, 128, 0);    line(cx - 3, cy, cx, cy - 10);    line(cx - 7, cy, cx - 7, cy - 10);    line(cx - 12, cy, cx - 15, cy - 10);    strokeWeight(1);    noStroke();    fill(255, 131, 0);    quad(cx, cy, cx - 15, cy, cx - 10, cy + 30, cx - 5, cy + 30);}',correct
'{    cloudX = -40;}',correct
'konijnX += 2;',correct
'ellipse(konijnX - 15, konijnY - 18, 6, 4)',correct
'float speed2;',correct
'fill(255, 131, 0)',correct
'konijnColor',correct
'arc(konijnX - 13, konijnY + 33, 15, 15, PI, 2 * PI)',correct
'cx = random(width)',correct
'class konijn {    float konijnX;    float konijnY;    int konijnColor;    boolean eating;    konijn() {        konijnColor = color(179, 60, 0);        konijnX = width / 2;        konijnY = height - 200;    }    void display() {        strokeWeight(1);        // ears        stroke(0);        fill(konijnColor);        ellipse(konijnX - 25, konijnY - 45, 12, 30);        ellipse(konijnX - 5, konijnY - 45, 12, 30);        noStroke();        fill(255, 114, 161);        ellipse(konijnX - 25, konijnY - 45, 5, 20);        ellipse(konijnX - 5, konijnY - 45, 5, 20);        // body        stroke(0);        fill(konijnColor);        ellipse(konijnX, konijnY, 45, 60);        // tail        ellipse(konijnX + 22, konijnY + 20, 10, 10);        // head        ellipse(konijnX - 15, konijnY - 25, 40, 40);        // eyes        noStroke();        fill(255);        if (eating) {            ellipse(konijnX - 20, konijnY - 30, 10, 15);            ellipse(konijnX - 10, konijnY - 30, 10, 15);        } else {            ellipse(konijnX - 20, konijnY - 30, 5, 7);            ellipse(konijnX - 10, konijnY - 30, 5, 7);        }        noStroke();        fill(0);        ellipse(konijnX - 20, konijnY - 30, 3, 4);        ellipse(konijnX - 10, konijnY - 30, 3, 4);        // nose        if (eating) {            ellipse(konijnX - 15, konijnY - 18, 18, 15);        } else {            ellipse(konijnX - 15, konijnY - 18, 6, 4);            stroke(0);            line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 14);            line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 18);            line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 22);            line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 14);            line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 18);            line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 22);        }        // paws        stroke(0);        fill(konijnColor);        arc(konijnX - 13, konijnY + 33, 15, 15, PI, 2 * PI);        arc(konijnX - 5, konijnY + 33, 15, 15, PI, 2 * PI);        if (eating) {            arc(konijnX - 15, konijnY + 5, 15, 15, 0.5f * PI, 2 * PI);            arc(konijnX - 5, konijnY + 5, 15, 15, 0.5f * PI, 2 * PI);        } else {            arc(konijnX - 15, konijnY + 5, 15, 15, 2 * PI, 3 * PI);            arc(konijnX - 5, konijnY + 5, 15, 15, 2 * PI, 3 * PI);        }        if (konijnX + 22 < -11) {            konijnX = 821;        } else if (konijnX - 15 > 822) {            konijnX = -10;        } else if (konijnY < 450) {            konijnY = 450;        } else if (konijnY > 822) {            konijnY = 822;        }    }    void move() {        if (keyPressed == true) {            if (keyCode == LEFT) {                konijnX -= 2;            } else if (keyCode == RIGHT) {                konijnX += 2;            } else if (keyCode == UP) {                konijnY -= 2;            } else if (keyCode == DOWN) {                konijnY += 2;            } else {            }        }    }    void eating() {        if (((konijnX - 40) < carrot2.cx && carrot2.cx < (konijnX + 40)) && ((konijnY - 60) < carrot2.cy && carrot2.cy < (konijnY + 10))) {            eating = true;        } else {            eating = false;        }    }}',correct
'sunY - 33',correct
'{    stroke(0);    noFill();    arc(sunX, sunY + 20, 30, 20, 2 * PI, 3 * PI);}',correct
'konijnX = -10',correct
'fill(0)',correct
'konijnX + 22',correct
'color(0, 190, 0)',correct
'ellipse(konijnX - 5, konijnY - 45, 5, 20)',correct
'fill(255, 255, 255, 200)',correct
'cloud2[i] = new cloud()',correct
'ellipse(konijnX - 5, konijnY - 45, 12, 30)',correct
'((konijn2.konijnX - 40) < carrot2.cx && carrot2.cx < (konijn2.konijnX + 40)) && ((konijn2.konijnY - 60) < carrot2.cy && carrot2.cy < (konijn2.konijnY + 10))',correct
'color(179, 60, 0)',correct
'{    fill(255);    ellipse(sunX + 20, sunY - 7, 15, 20);    ellipse(sunX - 20, sunY - 7, 15, 20);    fill(0);    ellipse(sunX + 20, sunY - 7, 3, 4);    ellipse(sunX - 20, sunY - 7, 3, 4);    noStroke();    fill(255, 222, 0);    arc(sunX + 20, sunY - 7, 15, 15, PI, 2 * PI);    arc(sunX - 20, sunY - 7, 15, 15, PI, 2 * PI);}',correct
'float cloudY;',correct
'// sunglassesfill(0);',correct
'cloudX = -40;',correct
'score = score + 1',correct
'{    if (((konijnX - 40) < carrot2.cx && carrot2.cx < (konijnX + 40)) && ((konijnY - 60) < carrot2.cy && carrot2.cy < (konijnY + 10))) {        eating = true;    } else {        eating = false;    }}',correct
'fill(255)',correct
'cloud2[i].move()',correct
'arc(cloudX - 22, cloudY - 15, 50, 60, PI, 2 * PI);',correct
'sun() {    sunX = 100;    sunY = 100;}',correct
'cloudX = 845',correct
'cloud[] cloud2 = new cloud[10];',correct
'konijnY + 33',correct
'carrot2.display();',correct
'arc(100, 600, 500, 300, PI, 2 * PI);',PixelHardcodeIgnoranceRule
'{    if (keyCode == LEFT) {        konijnX -= 2;    } else if (keyCode == RIGHT) {        konijnX += 2;    } else if (keyCode == UP) {        konijnY -= 2;    } else if (keyCode == DOWN) {        konijnY += 2;    } else {    }}',correct
'ellipse(konijnX - 5, konijnY - 45, 12, 30);',correct
'konijnY = 822',correct
'{    ellipse(sunX, sunY + 20, 20, 17);}',correct
'cy = random(430, 780);',correct
'line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 18);',correct
'konijnY = 450;',correct
'line(cx - 7, cy, cx - 7, cy - 10)',correct
'float cloudX;',correct
'noFill()',correct
'stroke(0, 128, 0)',correct
'ellipse(konijnX - 25, konijnY - 45, 5, 20);',correct
'"Arial Bold"',correct
'fill(255, 255, 255, 200);',correct
'{    konijnX += 2;}',correct
'strokeWeight(4);',correct
'konijnX',correct
'int i = 0',correct
'konijnY',correct
'ellipseMode(CENTER);',correct
'arc(konijnX - 5, konijnY + 5, 15, 15, 0.5f * PI, 2 * PI)',correct
'keyPressed == true',correct
'konijnY + 20',correct
'if (eating) {    arc(konijnX - 15, konijnY + 5, 15, 15, 0.5f * PI, 2 * PI);    arc(konijnX - 5, konijnY + 5, 15, 15, 0.5f * PI, 2 * PI);} else {    arc(konijnX - 15, konijnY + 5, 15, 15, 2 * PI, 3 * PI);    arc(konijnX - 5, konijnY + 5, 15, 15, 2 * PI, 3 * PI);}',correct
'cloudX = cloudX + speed2',correct
'line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 22);',correct
'cloudX = cloudX + speed1',correct
'float sunX;',correct
'arc(konijnX - 5, konijnY + 5, 15, 15, 2 * PI, 3 * PI);',correct
'time',correct
'arc(cloudX - 22, cloudY - 15, 50, 60, PI, 2 * PI)',correct
'ellipse(konijnX + 22, konijnY + 20, 10, 10)',correct
'line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 18)',correct
'// tail',correct
'ellipse(sunX - 20, sunY - 7, 15, 20)',correct
'konijnX - 20',correct
'konijn2',correct
'-10',correct
'-11',correct
'konijnX - 15',correct
'konijnX - 13',correct
'arc(sunX, sunY + 20, 30, 20, 2 * PI, 3 * PI);',correct
'ellipse(konijnX - 10, konijnY - 30, 3, 4);',correct
'line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 14)',correct
'{    ellipse(konijnX - 15, konijnY - 18, 6, 4);    stroke(0);    line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 14);    line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 18);    line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 22);    line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 14);    line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 18);    line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 22);}',correct
'ellipse(konijnX, konijnY, 45, 60)',correct
'keyCode == LEFT',correct
'ellipse(konijnX - 20, konijnY - 30, 5, 7);',correct
'konijnX - 10',correct
'{    cloudX = random(width);    cloudY = random(100, 300);    speed1 = random(-1, -0.3f);    speed2 = random(0.3f, 1);}',correct
'ellipse(sunX + 20, sunY - 7, 15, 20)',correct
'if (keyCode == RIGHT) {    konijnX += 2;} else if (keyCode == UP) {    konijnY -= 2;} else if (keyCode == DOWN) {    konijnY += 2;} else {}',DecentralizedEventHandlingRule
'konijn2 = new konijn();',correct
'speed2 = random(0.3f, 1)',correct
'cloudX = random(width)',correct
'0.5f * PI',correct
'for (int i = 0; i < cloud2.length; i++) {    cloud2[i].display();    cloud2[i].move();}',correct
'PFont font1;',correct
'if (eating) {    fill(255);    ellipse(sunX + 20, sunY - 7, 15, 20);    ellipse(sunX - 20, sunY - 7, 15, 20);    fill(0);    ellipse(sunX + 20, sunY - 7, 3, 4);    ellipse(sunX - 20, sunY - 7, 3, 4);} else {    fill(255);    ellipse(sunX + 20, sunY - 7, 15, 20);    ellipse(sunX - 20, sunY - 7, 15, 20);    fill(0);    ellipse(sunX + 20, sunY - 7, 3, 4);    ellipse(sunX - 20, sunY - 7, 3, 4);    noStroke();    fill(255, 222, 0);    arc(sunX + 20, sunY - 7, 15, 15, PI, 2 * PI);    arc(sunX - 20, sunY - 7, 15, 15, PI, 2 * PI);}',correct
'line(sunX + 40, sunY - 40, sunX + 53, sunY - 33)',correct
'ellipse(konijnX - 25, konijnY - 45, 5, 20)',correct
'konijn',correct
'arc(sunX - 20, sunY - 7, 15, 15, PI, 2 * PI);',correct
'konijnY + 5',correct
'ellipse(konijnX - 15, konijnY - 18, 6, 4);',correct
'konijnY += 2;',correct
'score = 0;',DrawingStateChangeRule
'sun2',correct
'color(0, 190, 0);',correct
'((konijn2.konijnX - 20) < carrot2.cx && carrot2.cx < (konijn2.konijnX + 10)) && ((konijn2.konijnY - 40) < carrot2.cy && carrot2.cy < (konijn2.konijnY - 10))',correct
'void display() {    noStroke();    fill(255, 255, 255, 200);    arc(cloudX, cloudY, 50, 60, PI, 2 * PI);    arc(cloudX - 45, cloudY, 50, 60, PI, 2 * PI);    arc(cloudX - 22, cloudY - 15, 50, 60, PI, 2 * PI);}',correct
'konijnX - 5',correct
'score = score + 1;',DrawingStateChangeRule
'arc(konijnX - 5, konijnY + 33, 15, 15, PI, 2 * PI)',correct
'if (keyCode == UP) {    konijnY -= 2;} else if (keyCode == DOWN) {    konijnY += 2;} else {}',DecentralizedEventHandlingRule
'keyCode == RIGHT',correct
'// pawsstroke(0);',correct
'{    text("mr. rabbit is fed-up, thanks!", 160, 380);    text("(to reset, eat another carrot)", 160, 420);}',correct
'if (eating) {    arc(sunX + 20, sunY - 40, 40, 40, 2 * PI, 3 * PI);    arc(sunX - 20, sunY - 40, 40, 40, 2 * PI, 3 * PI);    line(sunX + 40, sunY - 40, sunX + 53, sunY - 33);} else {    arc(sunX + 20, sunY - 5, 40, 40, 2 * PI, 3 * PI);    arc(sunX - 20, sunY - 5, 40, 40, 2 * PI, 3 * PI);}',correct
'fill(0, 190, 0);',correct
'display',LongMethodRule
'konijnY -= 2',correct
'arc(konijnX - 15, konijnY + 5, 15, 15, 0.5f * PI, 2 * PI);',correct
'{    strokeWeight(1);    // ears    stroke(0);    fill(konijnColor);    ellipse(konijnX - 25, konijnY - 45, 12, 30);    ellipse(konijnX - 5, konijnY - 45, 12, 30);    noStroke();    fill(255, 114, 161);    ellipse(konijnX - 25, konijnY - 45, 5, 20);    ellipse(konijnX - 5, konijnY - 45, 5, 20);    // body    stroke(0);    fill(konijnColor);    ellipse(konijnX, konijnY, 45, 60);    // tail    ellipse(konijnX + 22, konijnY + 20, 10, 10);    // head    ellipse(konijnX - 15, konijnY - 25, 40, 40);    // eyes    noStroke();    fill(255);    if (eating) {        ellipse(konijnX - 20, konijnY - 30, 10, 15);        ellipse(konijnX - 10, konijnY - 30, 10, 15);    } else {        ellipse(konijnX - 20, konijnY - 30, 5, 7);        ellipse(konijnX - 10, konijnY - 30, 5, 7);    }    noStroke();    fill(0);    ellipse(konijnX - 20, konijnY - 30, 3, 4);    ellipse(konijnX - 10, konijnY - 30, 3, 4);    // nose    if (eating) {        ellipse(konijnX - 15, konijnY - 18, 18, 15);    } else {        ellipse(konijnX - 15, konijnY - 18, 6, 4);        stroke(0);        line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 14);        line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 18);        line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 22);        line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 14);        line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 18);        line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 22);    }    // paws    stroke(0);    fill(konijnColor);    arc(konijnX - 13, konijnY + 33, 15, 15, PI, 2 * PI);    arc(konijnX - 5, konijnY + 33, 15, 15, PI, 2 * PI);    if (eating) {        arc(konijnX - 15, konijnY + 5, 15, 15, 0.5f * PI, 2 * PI);        arc(konijnX - 5, konijnY + 5, 15, 15, 0.5f * PI, 2 * PI);    } else {        arc(konijnX - 15, konijnY + 5, 15, 15, 2 * PI, 3 * PI);        arc(konijnX - 5, konijnY + 5, 15, 15, 2 * PI, 3 * PI);    }    if (konijnX + 22 < -11) {        konijnX = 821;    } else if (konijnX - 15 > 822) {        konijnX = -10;    } else if (konijnY < 450) {        konijnY = 450;    } else if (konijnY > 822) {        konijnY = 822;    }}',LongMethodRule
'arc(sunX - 20, sunY - 7, 15, 15, PI, 2 * PI)',correct
'-40',correct
'-41',correct
'font1 = createFont("Arial Bold", 18);',correct
'konijnX - 25',correct
'float speed1;',correct
'carrot2.display()',correct
'eating = true',correct
'i++',correct
'eating = true;',correct
'textFont(font1);',correct
'// earsstroke(0);',correct
'fill(255);',correct
'cloud',correct
'"carrots eaten: " + score',correct
'keyCode == DOWN',correct
'line(cx - 7, cy, cx - 7, cy - 10);',correct
'{    cloudX = cloudX + speed1;    cloudX = cloudX + speed2;    if (cloudX - 45 > 846) {        cloudX = -40;    }    if (cloudX < -41) {        cloudX = 845;    }}',correct
'quad(cx, cy, cx - 15, cy, cx - 10, cy + 30, cx - 5, cy + 30);',correct
'stroke(0, 128, 0);',correct
'cloud() {    cloudX = random(width);    cloudY = random(100, 300);    speed1 = random(-1, -0.3f);    speed2 = random(0.3f, 1);}',correct
'eating = false;',correct
'konijnY = 450',correct
'fill(255, 222, 0)',correct
'sunX',correct
'sunY',correct
'line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 18)',correct
'ellipse(sunX + 20, sunY - 7, 3, 4);',correct
'line(konijnX - 15, konijnY - 18, konijnX - 25, konijnY - 18);',correct
'line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 22)',correct
'float konijnX;',correct
'speed1 = random(-1, -0.3f)',correct
'{    konijnY -= 2;}',correct
'// headellipse(konijnX - 15, konijnY - 25, 40, 40);',correct
'int time;',correct
'class carrot {    float cx;    float cy;    carrot() {        cx = random(width);        cy = random(430, 780);    }    void display() {        strokeWeight(4);        stroke(0, 128, 0);        line(cx - 3, cy, cx, cy - 10);        line(cx - 7, cy, cx - 7, cy - 10);        line(cx - 12, cy, cx - 15, cy - 10);        strokeWeight(1);        noStroke();        fill(255, 131, 0);        quad(cx, cy, cx - 15, cy, cx - 10, cy + 30, cx - 5, cy + 30);    }    void reset() {        cx = random(width);        cy = random(430, 780);    }}',correct
'[10]',correct
'sun2.display()',correct
'random(-1, -0.3f)',correct
'arc(konijnX - 15, konijnY + 5, 15, 15, 2 * PI, 3 * PI);',correct
'new carrot()',correct
'cloudY',correct
'sunY = 100;',correct
'cloudX',correct
'ellipse(konijnX - 20, konijnY - 30, 10, 15);',correct
'if (score == 5) {    text("mr. rabbit is fed-up, thanks!", 160, 380);    text("(to reset, eat another carrot)", 160, 420);} else if (score == 6) {    score = 0;}',correct
'float konijnY;',correct
'void display() {    strokeWeight(4);    stroke(0, 128, 0);    line(cx - 3, cy, cx, cy - 10);    line(cx - 7, cy, cx - 7, cy - 10);    line(cx - 12, cy, cx - 15, cy - 10);    strokeWeight(1);    noStroke();    fill(255, 131, 0);    quad(cx, cy, cx - 15, cy, cx - 10, cy + 30, cx - 5, cy + 30);}',correct
'line(konijnX - 15, konijnY - 18, konijnX - 5, konijnY - 14);',correct
'carrot2 = new carrot()',correct
'arc(konijnX - 13, konijnY + 33, 15, 15, PI, 2 * PI);',correct
'cloud[]',correct
'line(sunX + 40, sunY - 40, sunX + 53, sunY - 33);',correct
'width / 2',correct
'2 * PI',correct
'height - 200',correct
'if (konijnX - 15 > 822) {    konijnX = -10;} else if (konijnY < 450) {    konijnY = 450;} else if (konijnY > 822) {    konijnY = 822;}',correct
'arc(konijnX - 5, konijnY + 33, 15, 15, PI, 2 * PI);',correct
'carrot',correct
'ellipse(snowmanX, snowmanY, 60, 50)',correct
'random(width)',correct
'snowX = random(0, width);',correct
'PApplet.parseInt(snowX - diam + 1)',correct
'int darkColor;',correct
'snowmen[i] = new Snowman(random(60, width), random(60, height));',correct
'dy = -dy;',correct
'if (key == b || key == w) {    snowmen[i].changeColor();}',DecentralizedEventHandlingRule
'backgroundHeight[i] = 50',correct
'float snowmanY;',correct
'PApplet.parseInt(snowX + diam)',correct
'hill.backgroundHeight[i] += 2',correct
'{    if (height - hill.backgroundHeight[i] < snowY) {        update = true;    }}',correct
'new Snowman[10]',correct
'dx > 0',correct
'void draw() {    background(135, 206, 250);    hill.display();    for (int i = 0; i < storm.length; i++) {        storm[i].display();        storm[i].update();    }    for (int i = 0; i < snowmen.length; i++) {        snowmen[i].display();        snowmen[i].update();    }    for (int i = 0; i < snowmen.length / 2; i++) {        if (keyPressed == true) {            if (key == b || key == w) {                snowmen[i].changeColor();            }        } else {            snowmen[i].returnColor();        }    }    for (int i = 5; i < snowmen.length; i++) {        if (keyPressed == true) {            if (key == r || key == g) {                snowmen[i].changeColor2();            }        } else {            snowmen[i].returnColor2();        }    }}',correct
'(width / 6) - 30',correct
'height - hill.backgroundHeight[i]',correct
'{    snowmen[i] = new Snowman(random(60, width), random(60, height));}',correct
'{    backgroundHeight[i] = 50;}',correct
'fill(darkColor)',correct
'void returnColor() {    snowColor = color(230);    darkColor = color(0);}',correct
'Snow[] storm = new Snow[200];',correct
'int i = max(0, PApplet.parseInt(snowX - diam + 1))',correct
'ellipse(snowmanX - 40, snowmanY + 80.5f, 10, 10)',correct
'snowX = random(0, width)',correct
'snowmen[i] = new Snowman(random(60, width), random(60, height))',correct
'for (int i = 0; i < backgroundHeight.length; i++) {    line(i, height, i, height - backgroundHeight[i]);}',correct
'boolean update = false',correct
'height - backgroundHeight[i]',correct
'snowmen[i].returnColor();',correct
'float snowmanX;',correct
'i < storm.length',correct
'ellipse(snowmanX + 10, snowmanY - 10, 10, 10)',correct
'dx = random(0.1f, 10)',correct
'snowmen[i].changeColor()',correct
'i = max(0, PApplet.parseInt(snowX - diam))',correct
'fill(carrotColor)',correct
'int carrotColor;',correct
'if (keyPressed == true) {    if (key == b || key == w) {        snowmen[i].changeColor();    }} else {    snowmen[i].returnColor();}',DecentralizedEventHandlingRule
'{    if (key == b || key == w) {        snowmen[i].changeColor();    }}',correct
'snowY = y',correct
'broomColor = color(139, 69, 19);',correct
'ellipse(snowmanX - 40, snowmanY + 80.5f, 10, 10);',correct
'ellipse((width / 6) - 30, height - 175, 40, 40)',correct
'diam = random(2, 10);',correct
'{    dy = -dy;}',correct
';',EmptyStatementNotInLoop
'void returnColor2() {    snowColor = color(230);    darkColor = color(0);}',correct
'frameRate(30);',correct
'int broomColor;',correct
'{    if (keyPressed == true) {        if (key == b || key == w) {            snowmen[i].changeColor();        }    } else {        snowmen[i].returnColor();    }}',correct
'backgroundHeight.length',correct
'max(0, PApplet.parseInt(snowX - diam))',correct
'update = false',correct
'{    snowColor = color(233, 14, 14);    darkColor = color(46, 223, 14);}',correct
'if (keyPressed == true) {    if (key == r || key == g) {        snowmen[i].changeColor2();    }} else {    snowmen[i].returnColor2();}',DecentralizedEventHandlingRule
'snowColor = color(255);',correct
'update = true;',correct
'new Snow[200]',correct
'snowmanX > width - 40 && dx > 0 || (snowmanX < 45)',correct
'// broombasefill(broomColor);',correct
'color(255, 140, 0)',correct
'rect(snowmanX, snowmanY - 45, 30, 30)',correct
'float snowY;',correct
'snowmanX + 10',correct
'line(i, height, i, height - backgroundHeight[i]);',correct
'{    fill(255);    stroke(255);    for (int i = 0; i < backgroundHeight.length; i++) {        line(i, height, i, height - backgroundHeight[i]);    }    // rect(x,y,width,50);    //     ellipse(width / 6, height - 25, 200, 200);    rect((width / 6) - 30, height - 125, 40, 100);    ellipse((width / 6) - 30, height - 175, 40, 40);}',correct
'[600]',correct
'snowmanY = y;',correct
'if (snowmanY > height - 80 && dy > 0 || (snowmanY < 50)) {    dy = -dy;}',correct
'{    update = true;}',correct
'background(135, 206, 250);',correct
'rectMode(CENTER)',correct
'b',correct
'BackgroundSnow(float backgroundX, float backgroundY) {    x = backgroundX;    y = backgroundY;    for (int i = 0; i < backgroundHeight.length; i++) {        backgroundHeight[i] = 50;    }}',correct
'random(height)',correct
'darkColor = color(0)',correct
'class BackgroundSnow {    int[] backgroundHeight = new int[600];    float x;    float y;    BackgroundSnow(float backgroundX, float backgroundY) {        x = backgroundX;        y = backgroundY;        for (int i = 0; i < backgroundHeight.length; i++) {            backgroundHeight[i] = 50;        }    }    void display() {        fill(255);        stroke(255);        for (int i = 0; i < backgroundHeight.length; i++) {            line(i, height, i, height - backgroundHeight[i]);        }        // rect(x,y,width,50);        //         ellipse(width / 6, height - 25, 200, 200);        rect((width / 6) - 30, height - 125, 40, 100);        ellipse((width / 6) - 30, height - 175, 40, 40);    }}',correct
'height - hill.backgroundHeight[i] < snowY',correct
'g',correct
'for (int i = max(0, PApplet.parseInt(snowX - diam + 1)); i < min(PApplet.parseInt(snowX + diam - 1), width - 1); i++) {    hill.backgroundHeight[i] += 2;}',correct
'ellipse(snowmanX - 40, snowmanY - 42.5f, 10, 10)',correct
'random(0, width)',correct
'{    if (key == r || key == g) {        snowmen[i].changeColor2();    }}',correct
'int[]',correct
'if (height - hill.backgroundHeight[i] < snowY) {    update = true;}',correct
'float dx;',correct
'y = backgroundY',correct
'if (key == r || key == g) {    snowmen[i].changeColor2();}',DecentralizedEventHandlingRule
'hill',correct
'r',correct
'{    snowmen[i].changeColor2();}',correct
'for (int i = max(0, PApplet.parseInt(snowX - diam)); i < min(PApplet.parseInt(snowX + diam), width - 1); i++) {    if (height - hill.backgroundHeight[i] < snowY) {        update = true;    }}',correct
'darkColor = color(0);',correct
'{    hill.backgroundHeight[i] += 2;}',correct
'snowmen.length',correct
'line(i, height, i, height - backgroundHeight[i])',correct
'w',correct
'x',correct
'snowmanY > height - 80 && dy > 0 || (snowmanY < 50)',correct
'Snowman',correct
'y',correct
'snowY = snowY + 2',correct
'rectMode(CENTER);',correct
'Snowman[]',correct
'snowY = 0',correct
'boolean update = false;',correct
'void display() {    // linkerarm    fill(snowColor);    rect(snowmanX - 20, snowmanY + 40, 50, 10);    // lichaam    ellipse(snowmanX, snowmanY + 50, 60, 75);    // hoofd    ellipse(snowmanX, snowmanY, 60, 50);    fill(darkColor);    // linkeroog    ellipse(snowmanX - 15, snowmanY - 10, 10, 10);    // rechteroog    ellipse(snowmanX + 10, snowmanY - 10, 10, 10);    // hat    noStroke();    rect(snowmanX, snowmanY - 45, 30, 30);    // rim    noStroke();    fill(darkColor);    rect(snowmanX, snowmanY - 25, 60, 10);    // broombase    fill(broomColor);    rect(snowmanX - 40, snowmanY + 20, 10, 125);    // broomend    fill(broomColor);    ellipse(snowmanX - 40, snowmanY - 42.5f, 10, 10);    // broomtop    fill(broomColor);    ellipse(snowmanX - 40, snowmanY + 80.5f, 10, 10);    // hand    fill(snowColor);    arc(snowmanX - 45, snowmanY + 40, 10, 10, PI + HALF_PI, TWO_PI + HALF_PI);    // carrot    fill(carrotColor);    triangle(snowmanX, snowmanY, snowmanX + 40, snowmanY, snowmanX, snowmanY + 10);}',correct
'noStroke()',correct
'{    x = backgroundX;    y = backgroundY;    for (int i = 0; i < backgroundHeight.length; i++) {        backgroundHeight[i] = 50;    }}',correct
'random(0.1f, 10)',correct
'snowmanY - 10',correct
'{    snowmen[i].display();    snowmen[i].update();}',correct
'storm.length',correct
'storm[i] = new Snow(random(width), random(height))',correct
'rect(snowmanX, snowmanY - 25, 60, 10)',correct
'int i = max(0, PApplet.parseInt(snowX - diam))',correct
'snowX + diam - 1',correct
'broomColor = color(139, 69, 19)',correct
'float dy;',correct
'for (int i = 0; i < backgroundHeight.length; i++) {    backgroundHeight[i] = 50;}',correct
'dx',correct
'ellipse(snowmanX - 40, snowmanY - 42.5f, 10, 10);',correct
'dy',correct
'{    background(135, 206, 250);    hill.display();    for (int i = 0; i < storm.length; i++) {        storm[i].display();        storm[i].update();    }    for (int i = 0; i < snowmen.length; i++) {        snowmen[i].display();        snowmen[i].update();    }    for (int i = 0; i < snowmen.length / 2; i++) {        if (keyPressed == true) {            if (key == b || key == w) {                snowmen[i].changeColor();            }        } else {            snowmen[i].returnColor();        }    }    for (int i = 5; i < snowmen.length; i++) {        if (keyPressed == true) {            if (key == r || key == g) {                snowmen[i].changeColor2();            }        } else {            snowmen[i].returnColor2();        }    }}',correct
'class Snowman {    int snowColor;    int darkColor;    int broomColor;    int carrotColor;    float snowmanX;    float snowmanY;    float dx;    float dy;    float snowX;    float diam;    Snowman(float x, float y) {        snowmanX = x;        snowmanY = y;        dx = random(0.1f, 10);        dy = random(0.1f, 10);        snowColor = color(230);        darkColor = color(0);        carrotColor = color(255, 140, 0);        broomColor = color(139, 69, 19);    }    void display() {        // linkerarm        fill(snowColor);        rect(snowmanX - 20, snowmanY + 40, 50, 10);        // lichaam        ellipse(snowmanX, snowmanY + 50, 60, 75);        // hoofd        ellipse(snowmanX, snowmanY, 60, 50);        fill(darkColor);        // linkeroog        ellipse(snowmanX - 15, snowmanY - 10, 10, 10);        // rechteroog        ellipse(snowmanX + 10, snowmanY - 10, 10, 10);        // hat        noStroke();        rect(snowmanX, snowmanY - 45, 30, 30);        // rim        noStroke();        fill(darkColor);        rect(snowmanX, snowmanY - 25, 60, 10);        // broombase        fill(broomColor);        rect(snowmanX - 40, snowmanY + 20, 10, 125);        // broomend        fill(broomColor);        ellipse(snowmanX - 40, snowmanY - 42.5f, 10, 10);        // broomtop        fill(broomColor);        ellipse(snowmanX - 40, snowmanY + 80.5f, 10, 10);        // hand        fill(snowColor);        arc(snowmanX - 45, snowmanY + 40, 10, 10, PI + HALF_PI, TWO_PI + HALF_PI);        // carrot        fill(carrotColor);        triangle(snowmanX, snowmanY, snowmanX + 40, snowmanY, snowmanX, snowmanY + 10);    }    void update() {        snowmanX = snowmanX + dx;        if (snowmanX > width - 40 && dx > 0 || (snowmanX < 45)) {            dx = -dx;        }        snowmanY = snowmanY + dy;        if (snowmanY > height - 80 && dy > 0 || (snowmanY < 50)) {            dy = -dy;        }    }    void changeColor() {        snowColor = color(0);        darkColor = color(230);    }    void returnColor() {        snowColor = color(230);        darkColor = color(0);    }    void changeColor2() {        snowColor = color(233, 14, 14);        darkColor = color(46, 223, 14);    }    void returnColor2() {        snowColor = color(230);        darkColor = color(0);    }}',correct
'i < snowmen.length',correct
'// hoofdellipse(snowmanX, snowmanY, 60, 50);',correct
'snowY = snowY + 2;',correct
'dy = random(0.1f, 10);',correct
'arc(snowmanX - 45, snowmanY + 40, 10, 10, PI + HALF_PI, TWO_PI + HALF_PI);',correct
'{    snowmanX = x;    snowmanY = y;    dx = random(0.1f, 10);    dy = random(0.1f, 10);    snowColor = color(230);    darkColor = color(0);    carrotColor = color(255, 140, 0);    broomColor = color(139, 69, 19);}',correct
'frameRate(30)',correct
'float diam;',correct
'void setup() {    rectMode(CENTER);    frameRate(30);    hill = new BackgroundSnow((width / 2), height - 20);    for (int i = 0; i < snowmen.length; i++) {        snowmen[i] = new Snowman(random(60, width), random(60, height));    }    for (int i = 0; i < storm.length; i++) {        storm[i] = new Snow(random(width), random(height));    }}',correct
'snowX = x',correct
'PI + HALF_PI',correct
'snowmanY - 25',correct
'snowmen[i].display()',correct
'width - 40',correct
'{    line(i, height, i, height - backgroundHeight[i]);}',correct
'backgroundHeight[i] = 50;',correct
'triangle(snowmanX, snowmanY, snowmanX + 40, snowmanY, snowmanX, snowmanY + 10);',correct
'80.5f',correct
'BackgroundSnow',correct
'height - 25',correct
'snowY = 0;',correct
'height - 20',correct
'PApplet.parseInt(snowX - diam)',correct
'42.5f',correct
'dx = random(0.1f, 10);',correct
'// linkerarmfill(snowColor);',correct
'update = true',correct
'i < min(PApplet.parseInt(snowX + diam - 1), width - 1)',correct
'background(135, 206, 250)',correct
'0.1f',correct
'snowmanY > height - 80',correct
'snowmen.length / 2',correct
'triangle(snowmanX, snowmanY, snowmanX + 40, snowmanY, snowmanX, snowmanY + 10)',correct
'float x;',correct
'void display() {    fill(255);    stroke(255);    for (int i = 0; i < backgroundHeight.length; i++) {        line(i, height, i, height - backgroundHeight[i]);    }    // rect(x,y,width,50);    //     ellipse(width / 6, height - 25, 200, 200);    rect((width / 6) - 30, height - 125, 40, 100);    ellipse((width / 6) - 30, height - 175, 40, 40);}',correct
'snowColor = color(230);',correct
'fill(255)',correct
'snowY + 2',correct
'ellipse(snowX, snowY, diam, diam);',correct
'hill.display();',correct
'Processing',correct
'// rect(x,y,width,50);',correct
'darkColor = color(230)',correct
'{    for (int i = max(0, PApplet.parseInt(snowX - diam + 1)); i < min(PApplet.parseInt(snowX + diam - 1), width - 1); i++) {        hill.backgroundHeight[i] += 2;    }    snowY = 0;    snowX = random(0, width);}',correct
'darkColor = color(46, 223, 14)',correct
'if (snowmanX > width - 40 && dx > 0 || (snowmanX < 45)) {    dx = -dx;}',correct
'height - 175',correct
'[200]',correct
'{    rectMode(CENTER);    frameRate(30);    hill = new BackgroundSnow((width / 2), height - 20);    for (int i = 0; i < snowmen.length; i++) {        snowmen[i] = new Snowman(random(60, width), random(60, height));    }    for (int i = 0; i < storm.length; i++) {        storm[i] = new Snow(random(width), random(height));    }}',correct
'hill = new BackgroundSnow((width / 2), height - 20);',correct
'float rightX;',correct
'snowColor = color(0);',correct
'Snow(float x, float y) {    snowX = x;    snowY = y;    diam = random(2, 10);    rightX = snowX + 4;    snowColor = color(255);}',correct
'hill.backgroundHeight[i] += 2;',DrawingStateChangeRule
'void display() {    fill(snowColor);    ellipse(snowX, snowY, diam, diam);}',correct
'snowmanY - 45',correct
'rect((width / 6) - 30, height - 125, 40, 100)',correct
'float y;',correct
'false',correct
'dx = -dx;',correct
'storm = new Snow[200]',correct
'snowmanX = x;',correct
'hill.display()',correct
'int i = 0',correct
'void changeColor2() {    snowColor = color(233, 14, 14);    darkColor = color(46, 223, 14);}',correct
'keyPressed == true',correct
'for (int i = 5; i < snowmen.length; i++) {    if (keyPressed == true) {        if (key == r || key == g) {            snowmen[i].changeColor2();        }    } else {        snowmen[i].returnColor2();    }}',correct
'stroke(255)',correct
'random(2, 10)',correct
'snowmanX = snowmanX + dx;',correct
'int i = 5',correct
'i = 0',correct
'color(233, 14, 14)',correct
'snowmanY - 42.5f',correct
'ellipse(snowmanX - 15, snowmanY - 10, 10, 10)',correct
'color(255)',correct
'// linkeroogellipse(snowmanX - 15, snowmanY - 10, 10, 10);',correct
'snowmen[i].returnColor2();',correct
'// hatnoStroke();',correct
'hill.backgroundHeight[i]',correct
'i = 5',correct
'random(60, width)',correct
'carrotColor',correct
'// rimnoStroke();',correct
'new Snowman(random(60, width), random(60, height))',correct
'fill(darkColor);',correct
'snowmen[i].changeColor();',correct
'darkColor = color(230);',correct
'dy = -dy',correct
'snowmen[i].returnColor()',correct
'int[] backgroundHeight = new int[600];',correct
'{    snowmen[i].changeColor();}',correct
'// rect(x,y,width,50);// ellipse(width / 6, height - 25, 200, 200);',correct
'rightX = snowX + 4;',correct
'new Snow(random(width), random(height))',correct
'PApplet.parseInt(snowX + diam - 1)',correct
'BackgroundSnow hill;',correct
'darkColor = color(46, 223, 14);',correct
'max(0, PApplet.parseInt(snowX - diam + 1))',correct
'{    snowmen[i].returnColor();}',correct
'{    // linkerarm    fill(snowColor);    rect(snowmanX - 20, snowmanY + 40, 50, 10);    // lichaam    ellipse(snowmanX, snowmanY + 50, 60, 75);    // hoofd    ellipse(snowmanX, snowmanY, 60, 50);    fill(darkColor);    // linkeroog    ellipse(snowmanX - 15, snowmanY - 10, 10, 10);    // rechteroog    ellipse(snowmanX + 10, snowmanY - 10, 10, 10);    // hat    noStroke();    rect(snowmanX, snowmanY - 45, 30, 30);    // rim    noStroke();    fill(darkColor);    rect(snowmanX, snowmanY - 25, 60, 10);    // broombase    fill(broomColor);    rect(snowmanX - 40, snowmanY + 20, 10, 125);    // broomend    fill(broomColor);    ellipse(snowmanX - 40, snowmanY - 42.5f, 10, 10);    // broomtop    fill(broomColor);    ellipse(snowmanX - 40, snowmanY + 80.5f, 10, 10);    // hand    fill(snowColor);    arc(snowmanX - 45, snowmanY + 40, 10, 10, PI + HALF_PI, TWO_PI + HALF_PI);    // carrot    fill(carrotColor);    triangle(snowmanX, snowmanY, snowmanX + 40, snowmanY, snowmanX, snowmanY + 10);}',correct
'color(230)',correct
'storm[i].display()',correct
'void update() {    snowY = snowY + 2;    boolean update = false;    for (int i = max(0, PApplet.parseInt(snowX - diam)); i < min(PApplet.parseInt(snowX + diam), width - 1); i++) {        if (height - hill.backgroundHeight[i] < snowY) {            update = true;        }    }    ;    if (update) {        for (int i = max(0, PApplet.parseInt(snowX - diam + 1)); i < min(PApplet.parseInt(snowX + diam - 1), width - 1); i++) {            hill.backgroundHeight[i] += 2;        }        snowY = 0;        snowX = random(0, width);    }}',correct
'snowmanX - 40',correct
'dy = random(0.1f, 10)',correct
'void update() {    snowmanX = snowmanX + dx;    if (snowmanX > width - 40 && dx > 0 || (snowmanX < 45)) {        dx = -dx;    }    snowmanY = snowmanY + dy;    if (snowmanY > height - 80 && dy > 0 || (snowmanY < 50)) {        dy = -dy;    }}',correct
'snowmanX - 45',correct
'snowmanY + 40',correct
'rightX',correct
'rect(snowmanX - 40, snowmanY + 20, 10, 125)',correct
'key == g',correct
'storm[i].update();',correct
'fill(snowColor)',correct
'snowmanY > height - 80 && dy > 0',correct
'{    fill(snowColor);    ellipse(snowX, snowY, diam, diam);}',correct
'y = backgroundY;',correct
'float backgroundX',correct
'float backgroundY',correct
'key == b',correct
'{    storm[i].display();    storm[i].update();}',correct
'snowmanX > width - 40 && dx > 0',correct
'for (int i = 0; i < snowmen.length / 2; i++) {    if (keyPressed == true) {        if (key == b || key == w) {            snowmen[i].changeColor();        }    } else {        snowmen[i].returnColor();    }}',correct
'key == w',correct
'carrotColor = color(255, 140, 0);',correct
'diam = random(2, 10)',correct
'snowmanY + 50',correct
'color(0)',correct
'TWO_PI + HALF_PI',correct
'arc(snowmanX - 45, snowmanY + 40, 10, 10, PI + HALF_PI, TWO_PI + HALF_PI)',correct
'snowX - diam + 1',correct
'snowX + 4',correct
'diam',correct
'key == r',correct
'snowmanY + dy',correct
'for (int i = 0; i < snowmen.length; i++) {    snowmen[i] = new Snowman(random(60, width), random(60, height));}',correct
'// broomtopfill(broomColor);',correct
'Snowman[] snowmen = new Snowman[10];',correct
'{    snowY = snowY + 2;    boolean update = false;    for (int i = max(0, PApplet.parseInt(snowX - diam)); i < min(PApplet.parseInt(snowX + diam), width - 1); i++) {        if (height - hill.backgroundHeight[i] < snowY) {            update = true;        }    }    ;    if (update) {        for (int i = max(0, PApplet.parseInt(snowX - diam + 1)); i < min(PApplet.parseInt(snowX + diam - 1), width - 1); i++) {            hill.backgroundHeight[i] += 2;        }        snowY = 0;        snowX = random(0, width);    }}',correct
'snowmanX = snowmanX + dx',correct
'snowmanY = snowmanY + dy',correct
'int snowColor;',correct
'display',correct
'snowmanY + 80.5f',correct
'snowX - diam',correct
'{    snowmen[i].returnColor2();}',correct
'fill(broomColor)',correct
'width - 1',correct
'snowmanX - 20',correct
'dx = -dx',correct
'snowColor = color(233, 14, 14);',correct
'snowmen[i].update()',correct
'height - 125',correct
'color(139, 69, 19)',correct
'key == b || key == w',correct
'storm[i]',correct
'i = max(0, PApplet.parseInt(snowX - diam + 1))',correct
'int value = 0;',correct
'snowmanY',correct
'storm[i].display();',correct
'snowmen[i].update();',correct
'snowmanX',correct
'-dx',correct
'-dy',correct
'snowY = y;',correct
'darkColor',correct
'snowmanX = x',correct
'Snow',correct
'fill(snowColor);',correct
'snowX = x;',correct
'i++',correct
'snowmen = new Snowman[10]',correct
'storm[i].update()',correct
'{    if (keyPressed == true) {        if (key == r || key == g) {            snowmen[i].changeColor2();        }    } else {        snowmen[i].returnColor2();    }}',correct
'key == r || key == g',correct
'snowColor = color(255)',correct
'i < backgroundHeight.length',correct
'rect(snowmanX, snowmanY - 45, 30, 30);',correct
'color(46, 223, 14)',correct
'snowmen[i]',correct
'fill(255);',correct
'ellipse((width / 6) - 30, height - 175, 40, 40);',correct
'snowColor = color(230)',correct
'snowmanX - 15',correct
'new BackgroundSnow((width / 2), height - 20)',correct
'rect(snowmanX - 40, snowmanY + 20, 10, 125);',correct
'i < min(PApplet.parseInt(snowX + diam), width - 1)',correct
'snowColor = color(233, 14, 14)',correct
'value = 0',correct
'dy > 0',correct
'// carrotfill(carrotColor);',correct
'Snow[]',correct
'void',correct
'new int[600]',correct
'rightX = snowX + 4',correct
'// broomendfill(broomColor);',correct
'rect(snowmanX, snowmanY - 25, 60, 10);',correct
'rect(snowmanX - 20, snowmanY + 40, 50, 10)',correct
'snowX + diam',correct
'for (int i = 0; i < snowmen.length; i++) {    snowmen[i].display();    snowmen[i].update();}',correct
'x = backgroundX',correct
'ellipse(width / 6, height - 25, 200, 200)',correct
'{    snowColor = color(230);    darkColor = color(0);}',correct
'float snowX;',correct
'snowmen[i].returnColor2()',correct
'{    storm[i] = new Snow(random(width), random(height));}',correct
'hill.backgroundHeight',correct
'rect(snowmanX - 20, snowmanY + 40, 50, 10);',correct
'true',correct
'snowmen[i].changeColor2()',correct
'snowX',correct
'for (int i = 0; i < storm.length; i++) {    storm[i].display();    storm[i].update();}',correct
'random(60, height)',correct
'snowY',correct
'min(PApplet.parseInt(snowX + diam - 1), width - 1)',correct
'i < snowmen.length / 2',correct
'snowmanY + 10',correct
'hill = new BackgroundSnow((width / 2), height - 20)',correct
'// handfill(snowColor);',correct
'stroke(255);',correct
'ellipse(snowmanX, snowmanY + 50, 60, 75)',correct
'[10]',correct
'snowmanX + dx',correct
'snowmen[i].changeColor2();',correct
'snowmanX > width - 40',correct
'broomColor',correct
'carrotColor = color(255, 140, 0)',correct
'if (update) {    for (int i = max(0, PApplet.parseInt(snowX - diam + 1)); i < min(PApplet.parseInt(snowX + diam - 1), width - 1); i++) {        hill.backgroundHeight[i] += 2;    }    snowY = 0;    snowX = random(0, width);}',correct
'rect((width / 6) - 30, height - 125, 40, 100);',correct
'snowmen[i].display();',correct
'x = backgroundX;',correct
'float x',correct
'{    snowX = x;    snowY = y;    diam = random(2, 10);    rightX = snowX + 4;    snowColor = color(255);}',correct
'float y',correct
'snowmanY + 20',correct
'Snowman(float x, float y) {    snowmanX = x;    snowmanY = y;    dx = random(0.1f, 10);    dy = random(0.1f, 10);    snowColor = color(230);    darkColor = color(0);    carrotColor = color(255, 140, 0);    broomColor = color(139, 69, 19);}',correct
'snowColor',correct
'min(PApplet.parseInt(snowX + diam), width - 1)',correct
'{    snowColor = color(0);    darkColor = color(230);}',correct
'class Snow {    float snowX;    float snowY;    float diam;    float rightX;    int snowColor;    Snow(float x, float y) {        snowX = x;        snowY = y;        diam = random(2, 10);        rightX = snowX + 4;        snowColor = color(255);    }    void display() {        fill(snowColor);        ellipse(snowX, snowY, diam, diam);    }    void update() {        snowY = snowY + 2;        boolean update = false;        for (int i = max(0, PApplet.parseInt(snowX - diam)); i < min(PApplet.parseInt(snowX + diam), width - 1); i++) {            if (height - hill.backgroundHeight[i] < snowY) {                update = true;            }        }        ;        if (update) {            for (int i = max(0, PApplet.parseInt(snowX - diam + 1)); i < min(PApplet.parseInt(snowX + diam - 1), width - 1); i++) {                hill.backgroundHeight[i] += 2;            }            snowY = 0;            snowX = random(0, width);        }    }}',correct
'// lichaamellipse(snowmanX, snowmanY + 50, 60, 75);',correct
'snowmanX + 40',correct
'backgroundHeight = new int[600]',correct
'// rechteroogellipse(snowmanX + 10, snowmanY - 10, 10, 10);',correct
'snowColor = color(0)',correct
'snowmanY = snowmanY + dy;',correct
'for (int i = 0; i < storm.length; i++) {    storm[i] = new Snow(random(width), random(height));}',correct
'ellipse(snowX, snowY, diam, diam)',correct
'{    dx = -dx;}',correct
'storm[i] = new Snow(random(width), random(height));',correct
'snowmanY = y',correct
'backgroundHeight[i]',correct
'height - 80',correct
'void changeColor() {    snowColor = color(0);    darkColor = color(230);}',correct
'width / 6',correct
'{    snowmanX = snowmanX + dx;    if (snowmanX > width - 40 && dx > 0 || (snowmanX < 45)) {        dx = -dx;    }    snowmanY = snowmanY + dy;    if (snowmanY > height - 80 && dy > 0 || (snowmanY < 50)) {        dy = -dy;    }}',correct
'random(50, 200)',correct
'ellipse(creaturex + 10, creaturey - 50, 75, 75)',correct
'line(creaturex + 65, creaturey - 45, creaturex + 75, creaturey - 70);',correct
'ellipse(creaturex + 10, creaturey - 50, 100, 100)',correct
'hans.spawnnew == true',correct
'x - (size - 20) + 30',correct
'x = PApplet.parseInt(random(mouseX - (width / 3), mouseX + width / 3));',correct
'// bodyellipse(creaturex, creaturey, 130, 30);',correct
'mouseX + width / 3',correct
'Meteors',correct
'ellipse(x, y, (size + 40), (size - 50))',correct
'line(creaturex - 65, creaturey - 45, creaturex - 75, creaturey - 70)',correct
'// end grass',correct
'creaturex - 62',correct
'john = new Ball(200)',correct
'creaturex - 66',correct
'float size;',correct
'int startx;',correct
'creaturex - 65',correct
'y - ((size / 2) + 40)',correct
'{}',correct
'ellipse(creaturex + 10, creaturey - 50, 75, 75);',correct
'creaturey = creaturey - 2;',correct
'fill(0xffFF0000)',correct
'ellipse(creaturex - 10, creaturey - 50, 100, 100);',correct
'stroke(0)',correct
'grassUno.display();',correct
'y > height - yStop',correct
'if (ground() == true) {    y = y + dropspeed;    x = x + (dropspeed / 2);} else {    explode = true;}',SimplifyBooleanExpressions
'y = y + dropspeed',correct
'class Ball {    int ballColor;    float size;    int startx;    int starty;    int globalballsize;    Ball(int ballsize) {        startx = width - 200;        starty = 200;        globalballsize = ballsize;        int red = PApplet.parseInt(random(220, 255));        int green = PApplet.parseInt(random(220, 255));        int blue = PApplet.parseInt(random(0, 20));        ballColor = color(red, green, blue);    }    void display() {        fill(ballColor);        noStroke();        ellipse(startx, starty, size, size);    }    void update() {        size = globalballsize + random(0, 40);    }}',correct
'size',correct
'creaturex = creaturex + 2',correct
'dropspeed = random(3, 8)',correct
'// sprietenstroke(0, 150, 150);',correct
'((hans.creaturey - 50) < (pietertjes[i].y + pietertjes[i].size / 2)) && ((pietertjes[i].x - (pietertjes[i].size / 3)) < (hans.creaturex + 100)) && ((pietertjes[i].x + (pietertjes[i].size / 3)) > (hans.creaturex - 100))',correct
'creaturex - 55',correct
'stroke(0, 150, 150)',correct
'new Meteors[4]',correct
'{    // body    ellipse(creaturex, creaturey, 130, 30);    ellipse(creaturex - 35, creaturey - 7, 30, 25);    ellipse(creaturex - 55, creaturey - 13, 40, 30);    ellipse(creaturex - 65, creaturey - 30, 40, 30);    // ronde gedeelte    stroke(200, 100, 60);    strokeWeight(2);    fill(229, 137, 71);    ellipse(creaturex + 10, creaturey - 50, 100, 100);    ellipse(creaturex + 10, creaturey - 50, 75, 75);    ellipse(creaturex + 10, creaturey - 50, 50, 50);    ellipse(creaturex + 10, creaturey - 50, 10, 10);    // sprieten    stroke(0, 150, 150);    strokeWeight(4);    line(creaturex - 65, creaturey - 45, creaturex - 75, creaturey - 70);    line(creaturex - 62, creaturey - 45, creaturex - 66, creaturey - 70);    // ogen    fill(0);    ellipse(creaturex - 73, creaturey - 35, 10, 10);    // mond    stroke(0);    strokeWeight(4);    curve(creaturex - 85, creaturey - 28, creaturex - 80, creaturey - 24, creaturex - 65, creaturey - 25, creaturex - 55, creaturey - 35);}',SimplifyBooleanExpressions
'hans.spawnnew = false;',correct
'x = x + (dropspeed / 2)',correct
'[4]',correct
'{    visability = false;}',correct
'movementLeft = false;',correct
'{    if (ground() == true) {        y = y + dropspeed;        x = x + (dropspeed / 2);    } else {        explode = true;    }    return explode;}',correct
'triangle(x - (size / 2), y, x - (size - 20), y - (size + 30), x + (size / 2) - 10, y - 20);',correct
'if (creaturey <= height - 20) {    creaturey = creaturey + 2;}',correct
'curve(creaturex - 85, creaturey - 28, creaturex - 80, creaturey - 24, creaturex - 65, creaturey - 25, creaturex - 55, creaturey - 35);',correct
'fill(0);',correct
'size = globalballsize + random(0, 40)',correct
'x + ((size / 3) + 20)',correct
'hans',correct
'creaturex - 80',correct
'explode = true;',correct
'if (meteorsdissapear == false) {    pietertjes[i].display();}',SimplifyBooleanExpressions
'meteorsdissapear = false',correct
'creaturex - 85',correct
'if (creaturey > height - 200) {    creaturey = creaturey - 2;}',correct
'if (hans.spawnnew == true) {    hans.creaturex = width / 2;    hans.creaturey = height - 150;    meteorsdissapear = true;    collision = false;}',SimplifyBooleanExpressions
'y = mouseY',correct
'class Grass {    Grass() {    }    void display() {        // grass        strokeWeight(3);        stroke(0, 100, 0);        fill(0, 128, 0);        rect(width / 2, height, width, 400);    // end grass    }}',correct
'background(135, 206, 250);',correct
'rectMode(CENTER)',correct
'triangle(x - (size / 2), y, x - (size - 20), y - (size + 30), x + (size / 2) - 10, y - 20)',correct
'creaturey = creaturey - 2',correct
'ellipse(x, y, (size + 100), (size - 20));',correct
'x + (size / 2) - 10',correct
'{    strokeWeight(0);    fill(0, 150, 150);    noStroke();    moveCreature();    if (movementLeft == false) {        // body        ellipse(creaturex, creaturey, 130, 30);        ellipse(creaturex + 35, creaturey - 7, 30, 25);        ellipse(creaturex + 55, creaturey - 13, 40, 30);        ellipse(creaturex + 65, creaturey - 30, 40, 30);        // ronde gedeelte        stroke(200, 100, 60);        strokeWeight(2);        fill(229, 137, 71);        ellipse(creaturex - 10, creaturey - 50, 100, 100);        ellipse(creaturex - 10, creaturey - 50, 75, 75);        ellipse(creaturex - 10, creaturey - 50, 50, 50);        ellipse(creaturex - 10, creaturey - 50, 10, 10);        // sprieten        stroke(0, 150, 150);        strokeWeight(4);        line(creaturex + 65, creaturey - 45, creaturex + 75, creaturey - 70);        line(creaturex + 62, creaturey - 45, creaturex + 66, creaturey - 70);        // ogen        fill(0);        ellipse(creaturex + 73, creaturey - 35, 10, 10);        // mond        stroke(0);        strokeWeight(4);        curve(creaturex + 85, creaturey - 28, creaturex + 80, creaturey - 24, creaturex + 65, creaturey - 25, creaturex + 55, creaturey - 35);    // legs    } else {        // body        ellipse(creaturex, creaturey, 130, 30);        ellipse(creaturex - 35, creaturey - 7, 30, 25);        ellipse(creaturex - 55, creaturey - 13, 40, 30);        ellipse(creaturex - 65, creaturey - 30, 40, 30);        // ronde gedeelte        stroke(200, 100, 60);        strokeWeight(2);        fill(229, 137, 71);        ellipse(creaturex + 10, creaturey - 50, 100, 100);        ellipse(creaturex + 10, creaturey - 50, 75, 75);        ellipse(creaturex + 10, creaturey - 50, 50, 50);        ellipse(creaturex + 10, creaturey - 50, 10, 10);        // sprieten        stroke(0, 150, 150);        strokeWeight(4);        line(creaturex - 65, creaturey - 45, creaturex - 75, creaturey - 70);        line(creaturex - 62, creaturey - 45, creaturex - 66, creaturey - 70);        // ogen        fill(0);        ellipse(creaturex - 73, creaturey - 35, 10, 10);        // mond        stroke(0);        strokeWeight(4);        curve(creaturex - 85, creaturey - 28, creaturex - 80, creaturey - 24, creaturex - 65, creaturey - 25, creaturex - 55, creaturey - 35);    }}',LongMethodRule
'ellipse(creaturex - 35, creaturey - 7, 30, 25);',correct
'fill(0xffe22822)',correct
'{    hans.creaturex = width / 2;    hans.creaturey = height - 150;    meteorsdissapear = true;    collision = false;}',correct
'n',correct
'{    movementLeft = true;    if (creaturex - 90 >= 0) {        creaturex = creaturex - 2;    }}',correct
'creaturey = height - 150;',correct
'boolean movementLeft;',correct
'creaturex - 73',correct
'triangle(x - ((size / 3) + 20), y, x, y - ((size / 2) + 50), x + ((size / 3) + 20), y)',correct
'// grassstrokeWeight(3);',correct
'line(creaturex - 62, creaturey - 45, creaturex - 66, creaturey - 70);',correct
'x',correct
'y',correct
'rectMode(CENTER);',correct
'creaturex - 75',correct
'ellipse(creaturex + 10, creaturey - 50, 10, 10)',correct
'{    pietertjes[i].display();}',correct
'{    checkSpawnnew();    background(135, 206, 250);    grassUno.display();    john.update();    john.display();    if (mousepressed == true) {        for (int i = 0; i < pietertjes.length; i++) {            if (meteorsdissapear == false) {                pietertjes[i].display();            }            if (hans.spawnnew == true) {                collision = false;            } else if (((hans.creaturey - 50) < (pietertjes[i].y + pietertjes[i].size / 2)) && ((pietertjes[i].x - (pietertjes[i].size / 3)) < (hans.creaturex + 100)) && ((pietertjes[i].x + (pietertjes[i].size / 3)) > (hans.creaturex - 100))) {                collision = true;            }        }    }    if (collision == false) {        hans.display();    }}',correct
'yStop = PApplet.parseInt(random(100, 130))',correct
'x - (size - 20)',correct
'// innerFire',correct
'fill(0xffe22822);',correct
'globalballsize',correct
'ellipse(creaturex - 10, creaturey - 50, 50, 50);',correct
'PApplet.parseInt(random(100, 130))',correct
'PApplet.parseInt(random(mouseX - (width / 3), mouseX + width / 3))',correct
'if (((hans.creaturey - 50) < (pietertjes[i].y + pietertjes[i].size / 2)) && ((pietertjes[i].x - (pietertjes[i].size / 3)) < (hans.creaturex + 100)) && ((pietertjes[i].x + (pietertjes[i].size / 3)) > (hans.creaturex - 100))) {    collision = true;}',correct
'int blue = PApplet.parseInt(random(0, 20))',correct
'float creaturex;',correct
'pietertjes.length',correct
'creaturex = creaturex - 2;',correct
'new Meteors()',correct
'grassUno = new Grass()',correct
'{    startx = width - 200;    starty = 200;    globalballsize = ballsize;    int red = PApplet.parseInt(random(220, 255));    int green = PApplet.parseInt(random(220, 255));    int blue = PApplet.parseInt(random(0, 20));    ballColor = color(red, green, blue);}',correct
'stroke(0, 100, 0);',correct
'x + (size / 2) - 30',correct
'yStop = PApplet.parseInt(random(100, 130));',correct
'boolean visability;',correct
'ellipse(creaturex, creaturey, 130, 30)',correct
'random(3, 8)',correct
'ellipse(creaturex - 73, creaturey - 35, 10, 10)',correct
'creaturex - 90',correct
'height - 20',correct
'PApplet.parseInt(random(0, 20))',correct
'void checkSpawnnew() {    if (hans.spawnnew == true) {        hans.creaturex = width / 2;        hans.creaturey = height - 150;        meteorsdissapear = true;        collision = false;    }}',correct
'float creaturey;',correct
'{    collision = false;    meteorsdissapear = false;    rectMode(CENTER);    ellipseMode(CENTER);    hans = new SlakkieDier();    grassUno = new Grass();    john = new Ball(200);    pietertjes = new Meteors[4];}',correct
'{    size = globalballsize + random(0, 40);}',correct
'collision = false;',DrawingStateChangeRule
'int ballColor;',correct
'background(135, 206, 250)',correct
'dropspeed',correct
'spawnnew = false;',correct
'float x;',correct
'if (keyCode == RIGHT) {    movementLeft = false;    if (creaturex + 90 <= width) {        creaturex = creaturex + 2;    }}',DecentralizedEventHandlingRule
'{    hans.display();}',correct
'Processing',correct
'creaturex = width / 2',correct
'ellipse(creaturex + 55, creaturey - 13, 40, 30);',correct
'john.update();',correct
'checkSpawnnew()',correct
'y - ((size / 2) + 50)',correct
'ellipse(creaturex - 55, creaturey - 13, 40, 30)',correct
'creaturey = creaturey + 2;',correct
'triangle(x - ((size / 2) + 50), y, x - ((size / 3) + 25), y - ((size / 3) + 30), x, y)',correct
'meteorsdissapear',correct
'line(creaturex - 62, creaturey - 45, creaturex - 66, creaturey - 70)',correct
'spawnnew = true',correct
'false',correct
'float y;',correct
'hans.spawnnew = false',correct
'int red = PApplet.parseInt(random(220, 255))',correct
'triangle(x - ((size / 3) + 10), y, x, y - ((size / 2) + 40), x + ((size / 3) + 10), y);',correct
'x = x + (dropspeed / 2);',correct
'int starty;',correct
'boolean falling() {    if (ground() == true) {        y = y + dropspeed;        x = x + (dropspeed / 2);    } else {        explode = true;    }    return explode;}',correct
'creaturey = creaturey + 2',correct
'i = 0',correct
'ellipse(creaturex - 10, creaturey - 50, 50, 50)',correct
'boolean collision;',correct
'random(0, 20)',correct
'pietertjes',correct
'// outermeteoritefill(0xffFF0000);',correct
'hans.display()',correct
'triangle(x + ((size / 2) + 50), y, x + ((size / 3) + 25), y - ((size / 3) + 30), x, y)',correct
'explode',correct
'ellipse(creaturex + 73, creaturey - 35, 10, 10)',correct
'{    if (key == n) {        spawnnew = true;    }    return spawnnew;}',correct
'hans.creaturex',correct
'hans.creaturey',correct
'ellipse(x, y, (size - 10), (size - 10));',correct
'mousepressed',correct
'pietertjes[i]',correct
'ellipse(creaturex - 10, creaturey - 50, 10, 10);',correct
'new Ball(200)',correct
'Meteors pietertje;',correct
'pietertjes = new Meteors[4];',correct
'hans.creaturey = height - 150;',correct
'noStroke();',correct
'john',correct
'creaturex + 35',correct
'{    if (hans.spawnnew == true) {        hans.creaturex = width / 2;        hans.creaturey = height - 150;        meteorsdissapear = true;        collision = false;    }}',correct
'{    hans.moveCreature();    hans.newbutton();}',correct
'int yStop;',correct
'ellipse(creaturex + 73, creaturey - 35, 10, 10);',correct
'explode = false',correct
'Grass() {}',UncommentedEmptyConstructor
'hans.creaturex = width / 2',correct
'y = mouseY;',correct
'grassUno',correct
'keyCode == UP',correct
'starty = 200;',correct
'creaturex + 62',correct
'creaturex + 65',correct
'fill(0xffe25822);',correct
'creaturex + 66',correct
'pietertjes[i].display()',correct
'green = PApplet.parseInt(random(220, 255))',correct
'{    explode = false;    size = random(50, 200);    x = PApplet.parseInt(random(mouseX - (width / 3), mouseX + width / 3));    y = mouseY;    yStop = PApplet.parseInt(random(100, 130));    dropspeed = random(3, 8);}',correct
'curve(creaturex - 85, creaturey - 28, creaturex - 80, creaturey - 24, creaturex - 65, creaturey - 25, creaturex - 55, creaturey - 35)',correct
'if (mousepressed == true) {    for (int i = 0; i < pietertjes.length; i++) {        if (meteorsdissapear == false) {            pietertjes[i].display();        }        if (hans.spawnnew == true) {            collision = false;        } else if (((hans.creaturey - 50) < (pietertjes[i].y + pietertjes[i].size / 2)) && ((pietertjes[i].x - (pietertjes[i].size / 3)) < (hans.creaturex + 100)) && ((pietertjes[i].x + (pietertjes[i].size / 3)) > (hans.creaturex - 100))) {            collision = true;        }    }}',SimplifyBooleanExpressions
'ellipse(creaturex + 10, creaturey - 50, 50, 50);',correct
'ellipse(creaturex - 35, creaturey - 7, 30, 25)',correct
'strokeWeight(0)',correct
'if (creaturex + 90 <= width) {    creaturex = creaturex + 2;}',correct
'creaturex + 90 <= width',correct
'triangle(x - ((size / 2) + 40), y, x - ((size / 3) + 20), y - ((size / 3) + 20), x, y);',correct
'// innermeteoritefill(0);',correct
'stroke(200, 100, 60)',correct
'{    explode = true;}',correct
'float dropspeed;',correct
'pietertjes = new Meteors[4]',correct
'creaturex + 55',correct
'x - (size / 2)',correct
'ellipse(creaturex + 65, creaturey - 30, 40, 30);',correct
'collision = false',correct
'{    collision = false;}',correct
'moveCreature()',correct
'random(0, 40)',correct
'Grass',correct
'visability',correct
'x + ((size / 3) + 10)',correct
'checkSpawnnew();',correct
'fill(229, 137, 71)',correct
'ellipseMode(CENTER)',correct
'ellipse(creaturex + 65, creaturey - 30, 40, 30)',correct
'mouseX - (width / 3)',correct
'ellipse(creaturex - 10, creaturey - 50, 10, 10)',correct
'creaturex + 80',correct
'{    fill(ballColor);    noStroke();    ellipse(startx, starty, size, size);}',correct
'strokeWeight(3)',correct
'creaturex + 85',correct
'ellipse(creaturex + 10, creaturey - 50, 50, 50)',correct
'y - ((size / 3) + 20)',correct
'ellipse(creaturex - 10, creaturey - 50, 75, 75)',correct
'creaturey - 2',correct
'triangle(x - ((size / 3) + 20), y, x, y - ((size / 2) + 50), x + ((size / 3) + 20), y);',correct
'void',LongMethodRule
'ellipse(startx, starty, size, size)',correct
'creaturey - 7',correct
'triangle(x + ((size / 2) + 50), y, x + ((size / 3) + 25), y - ((size / 3) + 30), x, y);',correct
'{    fill(0xff323232);    ellipse(x, y, (size + 100), (size - 20));    fill(0);    ellipse(x, y, (size + 40), (size - 50));    fill(0xffe25822);    triangle(x - ((size / 3) + 20), y, x, y - ((size / 2) + 50), x + ((size / 3) + 20), y);    triangle(x - ((size / 2) + 50), y, x - ((size / 3) + 25), y - ((size / 3) + 30), x, y);    triangle(x + ((size / 2) + 50), y, x + ((size / 3) + 25), y - ((size / 3) + 30), x, y);    // innerFire    fill(0xffe22822);    triangle(x - ((size / 3) + 10), y, x, y - ((size / 2) + 40), x + ((size / 3) + 10), y);    triangle(x - ((size / 2) + 40), y, x - ((size / 3) + 20), y - ((size / 3) + 20), x, y);    triangle(x + ((size / 2) + 40), y, x + ((size / 3) + 20), y - ((size / 3) + 20), x, y);}',SimplifyBooleanExpressions
'mousepressed = true;',correct
'mousepressed = true',correct
'SlakkieDier hans;',correct
'new Grass()',correct
'strokeWeight(2)',correct
'boolean mousepressed;',AvoidFieldNameMatchingMethodName
'true',correct
'creaturex + 73',correct
'creaturex - 10',correct
'creaturex + 75',correct
'PApplet.parseInt(random(220, 255))',correct
'{    spawnnew = true;}',correct
'Meteors() {    explode = false;    size = random(50, 200);    x = PApplet.parseInt(random(mouseX - (width / 3), mouseX + width / 3));    y = mouseY;    yStop = PApplet.parseInt(random(100, 130));    dropspeed = random(3, 8);}',correct
'fill(0, 150, 150)',correct
'color(red, green, blue)',correct
'ellipse(creaturex + 35, creaturey - 7, 30, 25)',correct
'if (keyCode == LEFT) {    movementLeft = true;    if (creaturex - 90 >= 0) {        creaturex = creaturex - 2;    }} else if (keyCode == RIGHT) {    movementLeft = false;    if (creaturex + 90 <= width) {        creaturex = creaturex + 2;    }}',DecentralizedEventHandlingRule
'int globalballsize;',correct
'ellipse(creaturex + 10, creaturey - 50, 10, 10);',correct
'ellipse(creaturex - 73, creaturey - 35, 10, 10);',correct
'y - ((size / 3) + 30)',correct
'void keyPressed() {    hans.moveCreature();    hans.newbutton();}',correct
'starty = 200',correct
'collision == false',correct
'mousepressed == true',correct
'boolean ground() {    if (y > height - yStop) {        visability = false;    } else {        visability = true;    }    return visability;}',correct
'hans = new SlakkieDier();',correct
'SlakkieDier() {    movementLeft = true;    creaturex = width / 2;    creaturey = height - 150;    spawnnew = false;}',correct
'x + ((size / 3) + 25)',correct
'{    y = y + dropspeed;    x = x + (dropspeed / 2);}',correct
'ellipse(creaturex - 65, creaturey - 30, 40, 30)',correct
'creaturex + 90',correct
'hans.spawnnew',correct
'strokeWeight(4)',correct
'{    movementLeft = true;    creaturex = width / 2;    creaturey = height - 150;    spawnnew = false;}',correct
'fill(0, 128, 0);',correct
'grassUno.display()',correct
'creaturex - 35',correct
'y - (size + 30) + 50',correct
'Ball',correct
'collision = true;',DrawingStateChangeRule
'{    hans.spawnnew = false;    mousepressed = true;    for (int i = 0; i < pietertjes.length; i++) {        pietertjes[i] = new Meteors();    }    meteorsdissapear = false;}',correct
'void update() {    size = globalballsize + random(0, 40);}',correct
'y - 20',correct
'Grass grassUno;',correct
'boolean moveCreature() {    if (keyCode == UP) {        if (creaturey > height - 200) {            creaturey = creaturey - 2;        }    } else if (keyCode == DOWN) {        if (creaturey <= height - 20) {            creaturey = creaturey + 2;        }    }    if (keyCode == LEFT) {        movementLeft = true;        if (creaturex - 90 >= 0) {            creaturex = creaturex - 2;        }    } else if (keyCode == RIGHT) {        movementLeft = false;        if (creaturex + 90 <= width) {            creaturex = creaturex + 2;        }    }    return movementLeft;}',correct
'meteorsdissapear = false;',correct
'int green = PApplet.parseInt(random(220, 255));',correct
'// ogenfill(0);',correct
'{    creaturey = creaturey - 2;}',correct
'creaturey <= height - 20',correct
'creaturey + 2',correct
'blue = PApplet.parseInt(random(0, 20))',correct
'john.display();',correct
'creaturex - 2',correct
'{    // grass    strokeWeight(3);    stroke(0, 100, 0);    fill(0, 128, 0);    rect(width / 2, height, width, 400);// end grass}',correct
'triangle(x + ((size / 2) + 40), y, x + ((size / 3) + 20), y - ((size / 3) + 20), x, y)',correct
'ellipse(creaturex + 55, creaturey - 13, 40, 30)',correct
'{    creaturex = creaturex - 2;}',correct
'class SlakkieDier {    boolean movementLeft;    float creaturex;    float creaturey;    boolean spawnnew;    SlakkieDier() {        movementLeft = true;        creaturex = width / 2;        creaturey = height - 150;        spawnnew = false;    }    void display() {        strokeWeight(0);        fill(0, 150, 150);        noStroke();        moveCreature();        if (movementLeft == false) {            // body            ellipse(creaturex, creaturey, 130, 30);            ellipse(creaturex + 35, creaturey - 7, 30, 25);            ellipse(creaturex + 55, creaturey - 13, 40, 30);            ellipse(creaturex + 65, creaturey - 30, 40, 30);            // ronde gedeelte            stroke(200, 100, 60);            strokeWeight(2);            fill(229, 137, 71);            ellipse(creaturex - 10, creaturey - 50, 100, 100);            ellipse(creaturex - 10, creaturey - 50, 75, 75);            ellipse(creaturex - 10, creaturey - 50, 50, 50);            ellipse(creaturex - 10, creaturey - 50, 10, 10);            // sprieten            stroke(0, 150, 150);            strokeWeight(4);            line(creaturex + 65, creaturey - 45, creaturex + 75, creaturey - 70);            line(creaturex + 62, creaturey - 45, creaturex + 66, creaturey - 70);            // ogen            fill(0);            ellipse(creaturex + 73, creaturey - 35, 10, 10);            // mond            stroke(0);            strokeWeight(4);            curve(creaturex + 85, creaturey - 28, creaturex + 80, creaturey - 24, creaturex + 65, creaturey - 25, creaturex + 55, creaturey - 35);        // legs        } else {            // body            ellipse(creaturex, creaturey, 130, 30);            ellipse(creaturex - 35, creaturey - 7, 30, 25);            ellipse(creaturex - 55, creaturey - 13, 40, 30);            ellipse(creaturex - 65, creaturey - 30, 40, 30);            // ronde gedeelte            stroke(200, 100, 60);            strokeWeight(2);            fill(229, 137, 71);            ellipse(creaturex + 10, creaturey - 50, 100, 100);            ellipse(creaturex + 10, creaturey - 50, 75, 75);            ellipse(creaturex + 10, creaturey - 50, 50, 50);            ellipse(creaturex + 10, creaturey - 50, 10, 10);            // sprieten            stroke(0, 150, 150);            strokeWeight(4);            line(creaturex - 65, creaturey - 45, creaturex - 75, creaturey - 70);            line(creaturex - 62, creaturey - 45, creaturex - 66, creaturey - 70);            // ogen            fill(0);            ellipse(creaturex - 73, creaturey - 35, 10, 10);            // mond            stroke(0);            strokeWeight(4);            curve(creaturex - 85, creaturey - 28, creaturex - 80, creaturey - 24, creaturex - 65, creaturey - 25, creaturex - 55, creaturey - 35);        }    }    boolean moveCreature() {        if (keyCode == UP) {            if (creaturey > height - 200) {                creaturey = creaturey - 2;            }        } else if (keyCode == DOWN) {            if (creaturey <= height - 20) {                creaturey = creaturey + 2;            }        }        if (keyCode == LEFT) {            movementLeft = true;            if (creaturex - 90 >= 0) {                creaturex = creaturex - 2;            }        } else if (keyCode == RIGHT) {            movementLeft = false;            if (creaturex + 90 <= width) {                creaturex = creaturex + 2;            }        }        return movementLeft;    }    boolean newbutton() {        if (key == n) {            spawnnew = true;        }        return spawnnew;    }}',correct
'int ballsize',correct
'line(creaturex + 62, creaturey - 45, creaturex + 66, creaturey - 70)',correct
'void draw() {    checkSpawnnew();    background(135, 206, 250);    grassUno.display();    john.update();    john.display();    if (mousepressed == true) {        for (int i = 0; i < pietertjes.length; i++) {            if (meteorsdissapear == false) {                pietertjes[i].display();            }            if (hans.spawnnew == true) {                collision = false;            } else if (((hans.creaturey - 50) < (pietertjes[i].y + pietertjes[i].size / 2)) && ((pietertjes[i].x - (pietertjes[i].size / 3)) < (hans.creaturex + 100)) && ((pietertjes[i].x + (pietertjes[i].size / 3)) > (hans.creaturex - 100))) {                collision = true;            }        }    }    if (collision == false) {        hans.display();    }}',correct
'size = random(50, 200);',correct
'fill(0, 128, 0)',correct
'x + (size / 2)',correct
'collision = true',correct
'pietertjes[i].display();',correct
'creaturey > height - 200',correct
'for (int i = 0; i < pietertjes.length; i++) {    if (meteorsdissapear == false) {        pietertjes[i].display();    }    if (hans.spawnnew == true) {        collision = false;    } else if (((hans.creaturey - 50) < (pietertjes[i].y + pietertjes[i].size / 2)) && ((pietertjes[i].x - (pietertjes[i].size / 3)) < (hans.creaturex + 100)) && ((pietertjes[i].x + (pietertjes[i].size / 3)) > (hans.creaturex - 100))) {        collision = true;    }}',correct
'Ball(int ballsize) {    startx = width - 200;    starty = 200;    globalballsize = ballsize;    int red = PApplet.parseInt(random(220, 255));    int green = PApplet.parseInt(random(220, 255));    int blue = PApplet.parseInt(random(0, 20));    ballColor = color(red, green, blue);}',correct
'triangle(x - (size / 2) + 30, y, x - (size - 20) + 30, y - (size + 30) + 50, x + (size / 2) - 30, y - 20);',correct
'strokeWeight(2);',correct
'globalballsize = ballsize',correct
'line(creaturex + 65, creaturey - 45, creaturex + 75, creaturey - 70)',correct
'fill(ballColor);',correct
'noStroke()',correct
'globalballsize + random(0, 40)',correct
'fill(0xff323232);',correct
'hans.moveCreature()',correct
'curve(creaturex + 85, creaturey - 28, creaturex + 80, creaturey - 24, creaturex + 65, creaturey - 25, creaturex + 55, creaturey - 35);',correct
'((hans.creaturey - 50) < (pietertjes[i].y + pietertjes[i].size / 2)) && ((pietertjes[i].x - (pietertjes[i].size / 3)) < (hans.creaturex + 100))',correct
'ellipse(x, y, size, size);',correct
'curve(creaturex + 85, creaturey - 28, creaturex + 80, creaturey - 24, creaturex + 65, creaturey - 25, creaturex + 55, creaturey - 35)',correct
'red = PApplet.parseInt(random(220, 255))',correct
'{    creaturex = creaturex + 2;}',correct
'starty',correct
'ellipse(creaturex - 65, creaturey - 30, 40, 30);',correct
'startx',correct
'x - (size / 2) + 30',correct
'boolean spawnnew;',correct
'pietertje',correct
'Meteors[]',correct
'return explode;',correct
'void setup() {    collision = false;    meteorsdissapear = false;    rectMode(CENTER);    ellipseMode(CENTER);    hans = new SlakkieDier();    grassUno = new Grass();    john = new Ball(200);    pietertjes = new Meteors[4];}',correct
'random(220, 255)',correct
'fill(0)',correct
'{    if (creaturey <= height - 20) {        creaturey = creaturey + 2;    }}',correct
'meteorsdissapear = true;',DrawingStateChangeRule
'explode = false;',correct
'creaturex + 2',correct
'void display() {    falling();    ground();    noStroke();    if (explode == false) {        // outermeteorite        fill(0xffFF0000);        triangle(x - (size / 2), y, x - (size - 20), y - (size + 30), x + (size / 2) - 10, y - 20);        fill(0xffe22822);        triangle(x - (size / 2) + 30, y, x - (size - 20) + 30, y - (size + 30) + 50, x + (size / 2) - 30, y - 20);        ellipse(x, y, size, size);        // innermeteorite        fill(0);        ellipse(x, y, (size - 10), (size - 10));    } else {        fill(0xff323232);        ellipse(x, y, (size + 100), (size - 20));        fill(0);        ellipse(x, y, (size + 40), (size - 50));        fill(0xffe25822);        triangle(x - ((size / 3) + 20), y, x, y - ((size / 2) + 50), x + ((size / 3) + 20), y);        triangle(x - ((size / 2) + 50), y, x - ((size / 3) + 25), y - ((size / 3) + 30), x, y);        triangle(x + ((size / 2) + 50), y, x + ((size / 3) + 25), y - ((size / 3) + 30), x, y);        // innerFire        fill(0xffe22822);        triangle(x - ((size / 3) + 10), y, x, y - ((size / 2) + 40), x + ((size / 3) + 10), y);        triangle(x - ((size / 2) + 40), y, x - ((size / 3) + 20), y - ((size / 3) + 20), x, y);        triangle(x + ((size / 2) + 40), y, x + ((size / 3) + 20), y - ((size / 3) + 20), x, y);    }}',correct
'x - ((size / 2) + 50)',correct
'int red = PApplet.parseInt(random(220, 255));',correct
'fill(0xffe25822)',correct
'for (int i = 0; i < pietertjes.length; i++) {    pietertjes[i] = new Meteors();}',correct
'visability = true',correct
'ellipse(creaturex + 35, creaturey - 7, 30, 25);',correct
'line(creaturex + 62, creaturey - 45, creaturex + 66, creaturey - 70);',correct
'if (movementLeft == false) {    // body    ellipse(creaturex, creaturey, 130, 30);    ellipse(creaturex + 35, creaturey - 7, 30, 25);    ellipse(creaturex + 55, creaturey - 13, 40, 30);    ellipse(creaturex + 65, creaturey - 30, 40, 30);    // ronde gedeelte    stroke(200, 100, 60);    strokeWeight(2);    fill(229, 137, 71);    ellipse(creaturex - 10, creaturey - 50, 100, 100);    ellipse(creaturex - 10, creaturey - 50, 75, 75);    ellipse(creaturex - 10, creaturey - 50, 50, 50);    ellipse(creaturex - 10, creaturey - 50, 10, 10);    // sprieten    stroke(0, 150, 150);    strokeWeight(4);    line(creaturex + 65, creaturey - 45, creaturex + 75, creaturey - 70);    line(creaturex + 62, creaturey - 45, creaturex + 66, creaturey - 70);    // ogen    fill(0);    ellipse(creaturex + 73, creaturey - 35, 10, 10);    // mond    stroke(0);    strokeWeight(4);    curve(creaturex + 85, creaturey - 28, creaturex + 80, creaturey - 24, creaturex + 65, creaturey - 25, creaturex + 55, creaturey - 35);// legs} else {    // body    ellipse(creaturex, creaturey, 130, 30);    ellipse(creaturex - 35, creaturey - 7, 30, 25);    ellipse(creaturex - 55, creaturey - 13, 40, 30);    ellipse(creaturex - 65, creaturey - 30, 40, 30);    // ronde gedeelte    stroke(200, 100, 60);    strokeWeight(2);    fill(229, 137, 71);    ellipse(creaturex + 10, creaturey - 50, 100, 100);    ellipse(creaturex + 10, creaturey - 50, 75, 75);    ellipse(creaturex + 10, creaturey - 50, 50, 50);    ellipse(creaturex + 10, creaturey - 50, 10, 10);    // sprieten    stroke(0, 150, 150);    strokeWeight(4);    line(creaturex - 65, creaturey - 45, creaturex - 75, creaturey - 70);    line(creaturex - 62, creaturey - 45, creaturex - 66, creaturey - 70);    // ogen    fill(0);    ellipse(creaturex - 73, creaturey - 35, 10, 10);    // mond    stroke(0);    strokeWeight(4);    curve(creaturex - 85, creaturey - 28, creaturex - 80, creaturey - 24, creaturex - 65, creaturey - 25, creaturex - 55, creaturey - 35);}',correct
'movementLeft == false',correct
'creaturex - 90 >= 0',correct
'ellipse(startx, starty, size, size);',correct
'yStop',correct
'creaturex = width / 2;',correct
'explode = true',correct
'john.update()',correct
'SlakkieDier',correct
'void display() {    strokeWeight(0);    fill(0, 150, 150);    noStroke();    moveCreature();    if (movementLeft == false) {        // body        ellipse(creaturex, creaturey, 130, 30);        ellipse(creaturex + 35, creaturey - 7, 30, 25);        ellipse(creaturex + 55, creaturey - 13, 40, 30);        ellipse(creaturex + 65, creaturey - 30, 40, 30);        // ronde gedeelte        stroke(200, 100, 60);        strokeWeight(2);        fill(229, 137, 71);        ellipse(creaturex - 10, creaturey - 50, 100, 100);        ellipse(creaturex - 10, creaturey - 50, 75, 75);        ellipse(creaturex - 10, creaturey - 50, 50, 50);        ellipse(creaturex - 10, creaturey - 50, 10, 10);        // sprieten        stroke(0, 150, 150);        strokeWeight(4);        line(creaturex + 65, creaturey - 45, creaturex + 75, creaturey - 70);        line(creaturex + 62, creaturey - 45, creaturex + 66, creaturey - 70);        // ogen        fill(0);        ellipse(creaturex + 73, creaturey - 35, 10, 10);        // mond        stroke(0);        strokeWeight(4);        curve(creaturex + 85, creaturey - 28, creaturex + 80, creaturey - 24, creaturex + 65, creaturey - 25, creaturex + 55, creaturey - 35);    // legs    } else {        // body        ellipse(creaturex, creaturey, 130, 30);        ellipse(creaturex - 35, creaturey - 7, 30, 25);        ellipse(creaturex - 55, creaturey - 13, 40, 30);        ellipse(creaturex - 65, creaturey - 30, 40, 30);        // ronde gedeelte        stroke(200, 100, 60);        strokeWeight(2);        fill(229, 137, 71);        ellipse(creaturex + 10, creaturey - 50, 100, 100);        ellipse(creaturex + 10, creaturey - 50, 75, 75);        ellipse(creaturex + 10, creaturey - 50, 50, 50);        ellipse(creaturex + 10, creaturey - 50, 10, 10);        // sprieten        stroke(0, 150, 150);        strokeWeight(4);        line(creaturex - 65, creaturey - 45, creaturex - 75, creaturey - 70);        line(creaturex - 62, creaturey - 45, creaturex - 66, creaturey - 70);        // ogen        fill(0);        ellipse(creaturex - 73, creaturey - 35, 10, 10);        // mond        stroke(0);        strokeWeight(4);        curve(creaturex - 85, creaturey - 28, creaturex - 80, creaturey - 24, creaturex - 65, creaturey - 25, creaturex - 55, creaturey - 35);    }}',correct
'{    visability = true;}',correct
'fill(0, 150, 150);',correct
'class Meteors {    float dropspeed;    float x;    float y;    float size;    boolean visability;    boolean explode;    int yStop;    Meteors() {        explode = false;        size = random(50, 200);        x = PApplet.parseInt(random(mouseX - (width / 3), mouseX + width / 3));        y = mouseY;        yStop = PApplet.parseInt(random(100, 130));        dropspeed = random(3, 8);    }    void display() {        falling();        ground();        noStroke();        if (explode == false) {            // outermeteorite            fill(0xffFF0000);            triangle(x - (size / 2), y, x - (size - 20), y - (size + 30), x + (size / 2) - 10, y - 20);            fill(0xffe22822);            triangle(x - (size / 2) + 30, y, x - (size - 20) + 30, y - (size + 30) + 50, x + (size / 2) - 30, y - 20);            ellipse(x, y, size, size);            // innermeteorite            fill(0);            ellipse(x, y, (size - 10), (size - 10));        } else {            fill(0xff323232);            ellipse(x, y, (size + 100), (size - 20));            fill(0);            ellipse(x, y, (size + 40), (size - 50));            fill(0xffe25822);            triangle(x - ((size / 3) + 20), y, x, y - ((size / 2) + 50), x + ((size / 3) + 20), y);            triangle(x - ((size / 2) + 50), y, x - ((size / 3) + 25), y - ((size / 3) + 30), x, y);            triangle(x + ((size / 2) + 50), y, x + ((size / 3) + 25), y - ((size / 3) + 30), x, y);            // innerFire            fill(0xffe22822);            triangle(x - ((size / 3) + 10), y, x, y - ((size / 2) + 40), x + ((size / 3) + 10), y);            triangle(x - ((size / 2) + 40), y, x - ((size / 3) + 20), y - ((size / 3) + 20), x, y);            triangle(x + ((size / 2) + 40), y, x + ((size / 3) + 20), y - ((size / 3) + 20), x, y);        }    }    boolean falling() {        if (ground() == true) {            y = y + dropspeed;            x = x + (dropspeed / 2);        } else {            explode = true;        }        return explode;    }    boolean ground() {        if (y > height - yStop) {            visability = false;        } else {            visability = true;        }        return visability;    }}',correct
'height - yStop',correct
'i < pietertjes.length',correct
'hans.creaturey = height - 150',correct
'return spawnnew;',correct
'ground()',correct
'visability = false;',correct
'if (collision == false) {    hans.display();}',SimplifyBooleanExpressions
'fill(ballColor)',correct
'Ball john;',correct
'strokeWeight(4);',correct
'pietertjes[i] = new Meteors();',correct
'int i = 0',correct
'ellipseMode(CENTER);',correct
'ellipse(x, y, (size + 100), (size - 20))',correct
'x + (dropspeed / 2)',correct
'ellipse(creaturex - 10, creaturey - 50, 100, 100)',correct
'ellipse(creaturex - 10, creaturey - 50, 75, 75);',correct
'y = y + dropspeed;',correct
'creaturex + 10',correct
'hans.creaturex = width / 2;',correct
'line(creaturex - 65, creaturey - 45, creaturex - 75, creaturey - 70);',correct
'x - ((size / 2) + 40)',correct
'{    movementLeft = false;    if (creaturex + 90 <= width) {        creaturex = creaturex + 2;    }}',correct
'dropspeed = random(3, 8);',correct
'int green = PApplet.parseInt(random(220, 255))',correct
'{    if (creaturey > height - 200) {        creaturey = creaturey - 2;    }}',correct
'startx = width - 200;',correct
'void mousePressed() {    hans.spawnnew = false;    mousepressed = true;    for (int i = 0; i < pietertjes.length; i++) {        pietertjes[i] = new Meteors();    }    meteorsdissapear = false;}',correct
'hans.display();',correct
'boolean meteorsdissapear;',correct
'grassUno = new Grass();',correct
'meteorsdissapear == false',correct
'{    falling();    ground();    noStroke();    if (explode == false) {        // outermeteorite        fill(0xffFF0000);        triangle(x - (size / 2), y, x - (size - 20), y - (size + 30), x + (size / 2) - 10, y - 20);        fill(0xffe22822);        triangle(x - (size / 2) + 30, y, x - (size - 20) + 30, y - (size + 30) + 50, x + (size / 2) - 30, y - 20);        ellipse(x, y, size, size);        // innermeteorite        fill(0);        ellipse(x, y, (size - 10), (size - 10));    } else {        fill(0xff323232);        ellipse(x, y, (size + 100), (size - 20));        fill(0);        ellipse(x, y, (size + 40), (size - 50));        fill(0xffe25822);        triangle(x - ((size / 3) + 20), y, x, y - ((size / 2) + 50), x + ((size / 3) + 20), y);        triangle(x - ((size / 2) + 50), y, x - ((size / 3) + 25), y - ((size / 3) + 30), x, y);        triangle(x + ((size / 2) + 50), y, x + ((size / 3) + 25), y - ((size / 3) + 30), x, y);        // innerFire        fill(0xffe22822);        triangle(x - ((size / 3) + 10), y, x, y - ((size / 2) + 40), x + ((size / 3) + 10), y);        triangle(x - ((size / 2) + 40), y, x - ((size / 3) + 20), y - ((size / 3) + 20), x, y);        triangle(x + ((size / 2) + 40), y, x + ((size / 3) + 20), y - ((size / 3) + 20), x, y);    }}',LongMethodRule
'x - ((size / 3) + 25)',correct
'height - 150',correct
'ballColor = color(red, green, blue)',correct
'triangle(x - ((size / 2) + 50), y, x - ((size / 3) + 25), y - ((size / 3) + 30), x, y);',correct
'creaturey - 70',correct
'keyCode == LEFT',correct
'ground() == true',correct
'john.display()',correct
'triangle(x - ((size / 2) + 40), y, x - ((size / 3) + 20), y - ((size / 3) + 20), x, y)',correct
'return visability;',correct
'void display() {    fill(ballColor);    noStroke();    ellipse(startx, starty, size, size);}',correct
'x + ((size / 2) + 40)',correct
'falling()',correct
'{    for (int i = 0; i < pietertjes.length; i++) {        if (meteorsdissapear == false) {            pietertjes[i].display();        }        if (hans.spawnnew == true) {            collision = false;        } else if (((hans.creaturey - 50) < (pietertjes[i].y + pietertjes[i].size / 2)) && ((pietertjes[i].x - (pietertjes[i].size / 3)) < (hans.creaturex + 100)) && ((pietertjes[i].x + (pietertjes[i].size / 3)) > (hans.creaturex - 100))) {            collision = true;        }    }}',correct
'boolean explode;',correct
'key == n',correct
'john = new Ball(200);',correct
'if (keyCode == UP) {    if (creaturey > height - 200) {        creaturey = creaturey - 2;    }} else if (keyCode == DOWN) {    if (creaturey <= height - 20) {        creaturey = creaturey + 2;    }}',DecentralizedEventHandlingRule
'if (y > height - yStop) {    visability = false;} else {    visability = true;}',correct
'new SlakkieDier()',correct
'ellipse(x, y, (size - 10), (size - 10))',correct
'x - ((size / 3) + 10)',correct
'// innerFirefill(0xffe22822);',correct
'ellipse(x, y, size, size)',correct
'moveCreature();',correct
'creaturey - 45',correct
'ballColor = color(red, green, blue);',correct
'hans.moveCreature();',correct
'{    // body    ellipse(creaturex, creaturey, 130, 30);    ellipse(creaturex + 35, creaturey - 7, 30, 25);    ellipse(creaturex + 55, creaturey - 13, 40, 30);    ellipse(creaturex + 65, creaturey - 30, 40, 30);    // ronde gedeelte    stroke(200, 100, 60);    strokeWeight(2);    fill(229, 137, 71);    ellipse(creaturex - 10, creaturey - 50, 100, 100);    ellipse(creaturex - 10, creaturey - 50, 75, 75);    ellipse(creaturex - 10, creaturey - 50, 50, 50);    ellipse(creaturex - 10, creaturey - 50, 10, 10);    // sprieten    stroke(0, 150, 150);    strokeWeight(4);    line(creaturex + 65, creaturey - 45, creaturex + 75, creaturey - 70);    line(creaturex + 62, creaturey - 45, creaturex + 66, creaturey - 70);    // ogen    fill(0);    ellipse(creaturex + 73, creaturey - 35, 10, 10);    // mond    stroke(0);    strokeWeight(4);    curve(creaturex + 85, creaturey - 28, creaturex + 80, creaturey - 24, creaturex + 65, creaturey - 25, creaturex + 55, creaturey - 35);// legs}',SimplifyBooleanExpressions
'keyCode == RIGHT',correct
'spawnnew',correct
'creaturey - 50',correct
'triangle(x - ((size / 3) + 10), y, x, y - ((size / 2) + 40), x + ((size / 3) + 10), y)',correct
'display',LongMethodRule
'size = random(50, 200)',correct
'if (explode == false) {    // outermeteorite    fill(0xffFF0000);    triangle(x - (size / 2), y, x - (size - 20), y - (size + 30), x + (size / 2) - 10, y - 20);    fill(0xffe22822);    triangle(x - (size / 2) + 30, y, x - (size - 20) + 30, y - (size + 30) + 50, x + (size / 2) - 30, y - 20);    ellipse(x, y, size, size);    // innermeteorite    fill(0);    ellipse(x, y, (size - 10), (size - 10));} else {    fill(0xff323232);    ellipse(x, y, (size + 100), (size - 20));    fill(0);    ellipse(x, y, (size + 40), (size - 50));    fill(0xffe25822);    triangle(x - ((size / 3) + 20), y, x, y - ((size / 2) + 50), x + ((size / 3) + 20), y);    triangle(x - ((size / 2) + 50), y, x - ((size / 3) + 25), y - ((size / 3) + 30), x, y);    triangle(x + ((size / 2) + 50), y, x + ((size / 3) + 25), y - ((size / 3) + 30), x, y);    // innerFire    fill(0xffe22822);    triangle(x - ((size / 3) + 10), y, x, y - ((size / 2) + 40), x + ((size / 3) + 10), y);    triangle(x - ((size / 2) + 40), y, x - ((size / 3) + 20), y - ((size / 3) + 20), x, y);    triangle(x + ((size / 2) + 40), y, x + ((size / 3) + 20), y - ((size / 3) + 20), x, y);}',correct
'ballColor',correct
'startx = width - 200',correct
'ellipse(creaturex - 55, creaturey - 13, 40, 30);',correct
'rect(width / 2, height, width, 400);',correct
'{    creaturey = creaturey + 2;}',correct
'visability = true;',correct
'// legs',correct
'meteorsdissapear = true',correct
'x = PApplet.parseInt(random(mouseX - (width / 3), mouseX + width / 3))',correct
'explode == false',correct
'ellipse(creaturex + 10, creaturey - 50, 100, 100);',correct
'creaturey = height - 150',correct
'x - ((size / 3) + 20)',correct
'creaturey - 28',correct
'i++',correct
'creaturey - 25',correct
'creaturey - 24',correct
'if (keyCode == DOWN) {    if (creaturey <= height - 20) {        creaturey = creaturey + 2;    }}',DecentralizedEventHandlingRule
'boolean newbutton() {    if (key == n) {        spawnnew = true;    }    return spawnnew;}',correct
'if (key == n) {    spawnnew = true;}',correct
'visability = false',correct
'pietertjes[i] = new Meteors()',correct
'keyCode == DOWN',correct
'stroke(0, 100, 0)',correct
'hans.newbutton()',correct
'triangle(x - (size / 2) + 30, y, x - (size - 20) + 30, y - (size + 30) + 50, x + (size / 2) - 30, y - 20)',correct
'creaturey - 30',correct
'hans.newbutton();',correct
'creaturex',correct
'fill(0xff323232)',correct
'random(mouseX - (width / 3), mouseX + width / 3)',correct
'// mondstroke(0);',correct
'creaturey',correct
'hans = new SlakkieDier()',correct
'creaturey - 35',correct
'collision',correct
'{    if (y > height - yStop) {        visability = false;    } else {        visability = true;    }    return visability;}',correct
'{    collision = true;}',correct
'creaturex = creaturex - 2',correct
'width - 200',correct
'globalballsize = ballsize;',correct
'{    // outermeteorite    fill(0xffFF0000);    triangle(x - (size / 2), y, x - (size - 20), y - (size + 30), x + (size / 2) - 10, y - 20);    fill(0xffe22822);    triangle(x - (size / 2) + 30, y, x - (size - 20) + 30, y - (size + 30) + 50, x + (size / 2) - 30, y - 20);    ellipse(x, y, size, size);    // innermeteorite    fill(0);    ellipse(x, y, (size - 10), (size - 10));}',SimplifyBooleanExpressions
'movementLeft = false',correct
'{    if (meteorsdissapear == false) {        pietertjes[i].display();    }    if (hans.spawnnew == true) {        collision = false;    } else if (((hans.creaturey - 50) < (pietertjes[i].y + pietertjes[i].size / 2)) && ((pietertjes[i].x - (pietertjes[i].size / 3)) < (hans.creaturex + 100)) && ((pietertjes[i].x + (pietertjes[i].size / 3)) > (hans.creaturex - 100))) {        collision = true;    }}',correct
'creaturex = creaturex + 2;',correct
'int blue = PApplet.parseInt(random(0, 20));',correct
'rect(width / 2, height, width, 400)',correct
'random(100, 130)',correct
'y - (size + 30)',correct
'// ronde gedeelte',correct
'if (hans.spawnnew == true) {    collision = false;} else if (((hans.creaturey - 50) < (pietertjes[i].y + pietertjes[i].size / 2)) && ((pietertjes[i].x - (pietertjes[i].size / 3)) < (hans.creaturex + 100)) && ((pietertjes[i].x + (pietertjes[i].size / 3)) > (hans.creaturex - 100))) {    collision = true;}',SimplifyBooleanExpressions
'falling();',correct
'fill(229, 137, 71);',correct
'size = globalballsize + random(0, 40);',correct
'movementLeft',correct
'movementLeft = true;',correct
'void display() {    // grass    strokeWeight(3);    stroke(0, 100, 0);    fill(0, 128, 0);    rect(width / 2, height, width, 400);// end grass}',StatelessClassRule
'return movementLeft;',correct
'Meteors[] pietertjes;',correct
'spawnnew = true;',correct
'triangle(x + ((size / 2) + 40), y, x + ((size / 3) + 20), y - ((size / 3) + 20), x, y);',correct
'spawnnew = false',correct
'{    if (keyCode == UP) {        if (creaturey > height - 200) {            creaturey = creaturey - 2;        }    } else if (keyCode == DOWN) {        if (creaturey <= height - 20) {            creaturey = creaturey + 2;        }    }    if (keyCode == LEFT) {        movementLeft = true;        if (creaturex - 90 >= 0) {            creaturex = creaturex - 2;        }    } else if (keyCode == RIGHT) {        movementLeft = false;        if (creaturex + 90 <= width) {            creaturex = creaturex + 2;        }    }    return movementLeft;}',correct
'strokeWeight(0);',correct
'y + dropspeed',correct
'// ronde gedeeltestroke(200, 100, 60);',correct
'creaturey - 13',correct
'{    pietertjes[i] = new Meteors();}',correct
'width / 2',correct
'x + ((size / 2) + 50)',correct
'ground();',correct
'ellipse(x, y, (size + 40), (size - 50));',correct
'height - 200',correct
'movementLeft = true',correct
'if (creaturex - 90 >= 0) {    creaturex = creaturex - 2;}',correct
'width / 3',correct
'float alpha = 125;',correct
'{    // left eye    noFill();    arc(lEyeX, lEyeY, M * 25, M * 35, 0, 1.3f * PI, CHORD);    // right eye    noFill();    arc(rEyeX, rEyeY, M * 25, M * 35, -.3f * PI, PI, CHORD);}',correct
'width - 75',correct
'.05f',correct
'new counter()',correct
'coord1x = beginX',correct
'"+1"',correct
'alpha >= -5',correct
'float lEyeX = beginX;',correct
'beginX - M * 40',correct
'height - 50',correct
'rect(width - 100, height - 100, 50, 50)',correct
'stroke(0);',correct
'stroke(0)',correct
'colorb = 125',correct
'alpha + random(0, 3)',correct
'alpha = alpha + 50',correct
'foxesCreated + foxes.length - foxesCreated',correct
'{    foxes[i].display();}',correct
'alpha + 50',correct
'stroke(colorr, colorg, colorb, alpha)',correct
'float lEyeY = beginY + M * 40',correct
'float coord1y = beginY',correct
'foxesCreated < foxes.length && mouseX < width - 50 && mouseX > width - 100 && mouseY < height - 50 && mouseY > height - 100 && foxesCreated > foxes.length - 10',correct
'maxOffsetY = height - 120 * M',correct
'arc(rEyeX, rEyeY, M * 25, M * 35, 0, .75f * PI)',correct
'Counter.display()',correct
'M = random(.05f, .3f)',correct
'{    colorb = colorb - 10;}',correct
'if (alpha < -60) {    alpha = alpha + 50;}',correct
'width - 50',correct
'millis() - timer >= 10',correct
'float coord8x = beginX + M * 120;',correct
'fill(0);',correct
'{    foxesCreated++;}',correct
'if (foxesCreated > 0 && mouseX < width - 50 && mouseX > width - 100 && mouseY < height && mouseY > height - 50) {    foxesCreated = 0;}',correct
'beginX = random(minOffsetX, (maxOffsetX - 40 * M));',correct
'textAlign(CENTER)',correct
'colorb + random(-5, 5)',correct
'float coord6y = beginY + M * 60',correct
'beginX - M * 60',correct
'foxesCreated > 0 && mouseX < width && mouseX > width - 50',correct
'strokeWeight(5 * M)',correct
'Fox[]',correct
'colorg = 125',correct
'text(foxesCreated, width - 25, height - 100)',correct
'vertex(coord1x, coord1y)',correct
'if (colorg < 0) {    colorg = colorg + 10;}',correct
'120 * M',correct
'coord3x = beginX - M * 40',correct
'float coord5x = beginX + M * 40',correct
'vertex(coord7x, coord7y)',correct
'if (foxesCreated < foxes.length && mouseX < width - 50 && mouseX > width - 100 && mouseY < height - 50 && mouseY > height - 100) {    foxesCreated = foxesCreated + 10;}',correct
'beginY = random(minOffsetY, (maxOffsetY - 40 * M))',correct
'beginX = random(minOffsetX, maxOffsetX) - 40 * M',correct
'random(minOffsetY, maxOffsetY)',correct
'{    alpha = alpha + 50;}',correct
'for (int i = 0; i < FOXES; i++) {    foxes[i] = new Fox();}',correct
'height - 15',correct
'float coord9y = beginY;',correct
'minOffsetX = 110 * M',correct
'float coord6y = beginY + M * 60;',correct
'colorg + 10',correct
'float coord6x = beginX + M * 140',correct
'float coord7x = beginX + M * 120;',correct
'float beginY = random(minOffsetY, maxOffsetY) - 40 * M;',StdCyclomaticComplexity
'float coord5y = beginY + M * 160',correct
'Fox',correct
'float coord4x = beginX - M * 60',correct
'float minOffsetY = 110 * M;',correct
'alpha < -60',correct
'if (alpha > 255) {    alpha = -50;}',correct
'colorb = colorb - 10;',correct
'i < FOXES',correct
'float lEyeX = beginX',correct
'beginY - M * 40',correct
'Processing',correct
'i < foxesCreated',correct
'background(255)',correct
'alpha = alpha + random(0, 3);',correct
'arc(lEyeX, lEyeY, M * 25, M * 35, .25f * PI, PI);',correct
'textSize(20);',correct
'float maxOffsetY = height - 120 * M;',correct
'colorb = colorb + 10',correct
'// Rover Vos S2161702 //<>// //<>// //<>//static final int FOXES = 500;',correct
'M * 25',correct
'float coord1x = beginX;',correct
'{    strokeWeight(5 * M);    float coord1x = beginX;    float coord2x = beginX - M * 40;    float coord3x = beginX - M * 40;    float coord4x = beginX - M * 60;    float coord5x = beginX + M * 40;    float coord6x = beginX + M * 140;    float coord7x = beginX + M * 120;    float coord8x = beginX + M * 120;    float coord9x = beginX + M * 80;    float coord1y = beginY;    float coord2y = beginY - M * 40;    float coord3y = beginY + M * 40;    float coord4y = beginY + M * 60;    float coord5y = beginY + M * 160;    float coord6y = beginY + M * 60;    float coord7y = beginY + M * 40;    float coord8y = beginY - M * 40;    float coord9y = beginY;    float lEyeX = beginX;    float rEyeX = beginX + M * 80;    float lEyeY = beginY + M * 40;    float rEyeY = beginY + M * 40;    stroke(colorr, colorg, colorb, alpha);    noFill();    beginShape();    vertex(coord1x, coord1y);    vertex(coord2x, coord2y);    vertex(coord3x, coord3y);    vertex(coord4x, coord4y);    vertex(coord5x, coord5y);    vertex(coord6x, coord6y);    vertex(coord7x, coord7y);    vertex(coord8x, coord8y);    vertex(coord9x, coord9y);    vertex(coord1x, coord1y);    vertex(coord3x, coord3y);    vertex(coord5x, coord5y);    vertex(coord7x, coord7y);    vertex(coord9x, coord9y);    endShape();    // makes the eyes open and close    if (alpha >= 0 && alpha <= 150) {        // left eye        noFill();        arc(lEyeX, lEyeY, M * 25, M * 35, 0, 1.3f * PI, CHORD);        // right eye        noFill();        arc(rEyeX, rEyeY, M * 25, M * 35, -.3f * PI, PI, CHORD);    } else {        // sleep left eye        noFill();        arc(lEyeX, lEyeY, M * 25, M * 35, .25f * PI, PI);        // sleep right eye        noFill();        arc(rEyeX, rEyeY, M * 25, M * 35, 0, .75f * PI);    }    // changes the color of the fox smoothly    if (millis() - timer >= 10) {        colorr = colorr + random(-5, 5);        colorg = colorg + random(-5, 5);        colorb = colorb + random(-5, 5);        alpha = alpha + random(0, 3);        timer = millis();    }    // with this the rgb values cant go under 0    if (colorr < 0) {        colorr = colorr + 10;    }    if (colorg < 0) {        colorg = colorg + 10;    }    if (colorb < 0) {        colorb = colorb + 10;    }    if (alpha < -60) {        alpha = alpha + 50;    }    // with this the rgb values cant go over 255    if (colorr > 255) {        colorr = colorr - 10;    }    if (colorg > 255) {        colorg = colorg - 10;    }    if (colorb > 255) {        colorb = colorb - 10;    }    if (alpha > 255) {        alpha = -50;    }    if (alpha <= 0 && alpha >= -5) {        beginX = random(minOffsetX, (maxOffsetX - 40 * M));        beginY = random(minOffsetY, (maxOffsetY - 40 * M));        M = random(.05f, .3f);    }}',LongMethodRule
'counter Counter = new counter();',correct
'counter',correct
'{    foxesCreated = foxesCreated + 10;}',correct
'float coord9y = beginY',correct
'alpha = alpha + 50;',correct
'alpha <= 0',correct
'float rEyeY = beginY + M * 40;',correct
'// left eyenoFill();',correct
'float coord3x = beginX - M * 40',correct
'colorr + 10',correct
'lEyeX = beginX',correct
'endShape()',correct
'foxesCreated < foxes.length && mouseX < width - 50 && mouseX > width - 100 && mouseY < height - 50 && mouseY > height - 100',correct
'width - 25',correct
'rect(width - 100, height - 100, 50, 50);',correct
'i = 0',correct
'{    foxesCreated--;}',correct
'{    strokeWeight(1);    stroke(0);    textAlign(CENTER);    textSize(20);    text(foxesCreated, width - 25, height - 100);    fill(0, 255, 0);    rect(width - 50, height - 100, 50, 50);    rect(width - 50, height - 50, 50, 50);    rect(width - 100, height - 50, 50, 50);    rect(width - 100, height - 100, 50, 50);    fill(0);    text("+1", width - 25, height - 70);    text("+10", width - 75, height - 70);    text("-1", width - 25, height - 15);    text("clear", width - 75, height - 15);}',correct
'"+10"',correct
'arc(rEyeX, rEyeY, M * 25, M * 35, -.3f * PI, PI, CHORD)',correct
'mouseY < height - 50',correct
'fill(0, 255, 0)',correct
'colorg = colorg - 10;',correct
'{    foxes[i] = new Fox();}',correct
'float coord5y = beginY + M * 160;',correct
'colorr > 255',correct
'foxesCreated > 0 && mouseX < width - 50 && mouseX > width - 100 && mouseY < height && mouseY > height - 50',correct
'float coord2x = beginX - M * 40;',correct
'{    background(255);    for (int i = 0; i < foxesCreated; i++) {        foxes[i].display();    }    Counter.display();}',correct
'foxesCreated > 0 && mouseX < width - 50 && mouseX > width - 100',correct
'void display() {    strokeWeight(5 * M);    float coord1x = beginX;    float coord2x = beginX - M * 40;    float coord3x = beginX - M * 40;    float coord4x = beginX - M * 60;    float coord5x = beginX + M * 40;    float coord6x = beginX + M * 140;    float coord7x = beginX + M * 120;    float coord8x = beginX + M * 120;    float coord9x = beginX + M * 80;    float coord1y = beginY;    float coord2y = beginY - M * 40;    float coord3y = beginY + M * 40;    float coord4y = beginY + M * 60;    float coord5y = beginY + M * 160;    float coord6y = beginY + M * 60;    float coord7y = beginY + M * 40;    float coord8y = beginY - M * 40;    float coord9y = beginY;    float lEyeX = beginX;    float rEyeX = beginX + M * 80;    float lEyeY = beginY + M * 40;    float rEyeY = beginY + M * 40;    stroke(colorr, colorg, colorb, alpha);    noFill();    beginShape();    vertex(coord1x, coord1y);    vertex(coord2x, coord2y);    vertex(coord3x, coord3y);    vertex(coord4x, coord4y);    vertex(coord5x, coord5y);    vertex(coord6x, coord6y);    vertex(coord7x, coord7y);    vertex(coord8x, coord8y);    vertex(coord9x, coord9y);    vertex(coord1x, coord1y);    vertex(coord3x, coord3y);    vertex(coord5x, coord5y);    vertex(coord7x, coord7y);    vertex(coord9x, coord9y);    endShape();    // makes the eyes open and close    if (alpha >= 0 && alpha <= 150) {        // left eye        noFill();        arc(lEyeX, lEyeY, M * 25, M * 35, 0, 1.3f * PI, CHORD);        // right eye        noFill();        arc(rEyeX, rEyeY, M * 25, M * 35, -.3f * PI, PI, CHORD);    } else {        // sleep left eye        noFill();        arc(lEyeX, lEyeY, M * 25, M * 35, .25f * PI, PI);        // sleep right eye        noFill();        arc(rEyeX, rEyeY, M * 25, M * 35, 0, .75f * PI);    }    // changes the color of the fox smoothly    if (millis() - timer >= 10) {        colorr = colorr + random(-5, 5);        colorg = colorg + random(-5, 5);        colorb = colorb + random(-5, 5);        alpha = alpha + random(0, 3);        timer = millis();    }    // with this the rgb values cant go under 0    if (colorr < 0) {        colorr = colorr + 10;    }    if (colorg < 0) {        colorg = colorg + 10;    }    if (colorb < 0) {        colorb = colorb + 10;    }    if (alpha < -60) {        alpha = alpha + 50;    }    // with this the rgb values cant go over 255    if (colorr > 255) {        colorr = colorr - 10;    }    if (colorg > 255) {        colorg = colorg - 10;    }    if (colorb > 255) {        colorb = colorb - 10;    }    if (alpha > 255) {        alpha = -50;    }    if (alpha <= 0 && alpha >= -5) {        beginX = random(minOffsetX, (maxOffsetX - 40 * M));        beginY = random(minOffsetY, (maxOffsetY - 40 * M));        M = random(.05f, .3f);    }}',StdCyclomaticComplexity
'new Fox[FOXES]',correct
'rEyeX = beginX + M * 80',correct
'beginShape()',correct
'float coord7x = beginX + M * 120',correct
'rect(width - 100, height - 50, 50, 50);',correct
'void setup() {    frameRate(120);    for (int i = 0; i < FOXES; i++) {        foxes[i] = new Fox();    }}',correct
'text("clear", width - 75, height - 15);',correct
'strokeWeight(1)',correct
'float colorb = 125;',correct
'arc(lEyeX, lEyeY, M * 25, M * 35, 0, 1.3f * PI, CHORD)',correct
'text("-1", width - 25, height - 15);',correct
'{    beginX = random(minOffsetX, (maxOffsetX - 40 * M));    beginY = random(minOffsetY, (maxOffsetY - 40 * M));    M = random(.05f, .3f);}',correct
'lEyeY = beginY + M * 40',correct
'foxes[i] = new Fox()',correct
'beginY = random(minOffsetY, maxOffsetY) - 40 * M',correct
'40 * M',correct
'colorr = colorr + 10;',correct
'1.3f',correct
'float colorr = 125;',StdCyclomaticComplexity
'beginY = random(minOffsetY, (maxOffsetY - 40 * M));',correct
'coord2x = beginX - M * 40',correct
'vertex(coord1x, coord1y);',correct
'foxesCreated + 10',correct
'alpha = -50;',correct
'height - 120 * M',correct
'{    colorr = colorr + 10;}',correct
'foxesCreated < foxes.length && mouseX < width && mouseX > width - 50 && mouseY < height - 50 && mouseY > height - 100',correct
'coord9x = beginX + M * 80',correct
'float coord4x = beginX - M * 60;',correct
'coord4x = beginX - M * 60',correct
'vertex(coord9x, coord9y);',correct
'5 * M',correct
'M * 120',correct
'beginX + M * 80',correct
'new Fox()',correct
'text(foxesCreated, width - 25, height - 100);',correct
'void',LongMethodRule
'110 * M',correct
'float coord1x = beginX',correct
'-5',correct
'colorb = colorb + random(-5, 5)',correct
'foxesCreated > 0 && mouseX < width - 50 && mouseX > width - 100 && mouseY < height',correct
'float minOffsetX = 110 * M;',StdCyclomaticComplexity
'// right eyenoFill();',correct
'colorr - 10',correct
'mouseX < width - 50',correct
'coord9y = beginY',correct
'width - 110 * M',correct
'alpha >= 0',correct
'colorr = 125',correct
'colorg < 0',correct
'noFill();',correct
'float lEyeY = beginY + M * 40;',correct
'foxes[i]',correct
'if (colorb > 255) {    colorb = colorb - 10;}',correct
'coord7x = beginX + M * 120',correct
'beginShape();',correct
'foxesCreated + foxes.length',correct
'{    colorg = colorg - 10;}',correct
'foxesCreated > 0 && mouseX < width - 50',correct
'colorr = colorr + 10',correct
'text("-1", width - 25, height - 15)',correct
'vertex(coord9x, coord9y)',correct
'height - 70',correct
'M * 140',correct
'// Rover Vos S2161702 //<>// //<>// //<>//',correct
'if (colorg > 255) {    colorg = colorg - 10;}',correct
'void mouseClicked() {    if (foxesCreated > 0 && mouseX < width && mouseX > width - 50 && mouseY < height && mouseY > height - 50) {        foxesCreated--;    }    if (foxesCreated < foxes.length && mouseX < width && mouseX > width - 50 && mouseY < height - 50 && mouseY > height - 100) {        foxesCreated++;    }    if (foxesCreated > 0 && mouseX < width - 50 && mouseX > width - 100 && mouseY < height && mouseY > height - 50) {        foxesCreated = 0;    }    if (foxesCreated < foxes.length && mouseX < width - 50 && mouseX > width - 100 && mouseY < height - 50 && mouseY > height - 100 && foxesCreated > foxes.length - 10) {        foxesCreated = foxesCreated + foxes.length - foxesCreated;    }    if (foxesCreated < foxes.length && mouseX < width - 50 && mouseX > width - 100 && mouseY < height - 50 && mouseY > height - 100) {        foxesCreated = foxesCreated + 10;    }}',correct
'colorg = colorg + 10;',correct
'// sleep right eyenoFill();',correct
'mouseX > width - 100',correct
'vertex(coord4x, coord4y)',correct
'coord5x = beginX + M * 40',correct
'foxesCreated > 0 && mouseX < width && mouseX > width - 50 && mouseY < height && mouseY > height - 50',correct
'endShape();',correct
'float M = random(.05f, .3f);',ShortVariable
'millis() - timer',correct
'{    // sleep left eye    noFill();    arc(lEyeX, lEyeY, M * 25, M * 35, .25f * PI, PI);    // sleep right eye    noFill();    arc(rEyeX, rEyeY, M * 25, M * 35, 0, .75f * PI);}',correct
'vertex(coord5x, coord5y);',correct
'int foxesCreated = 0;',correct
'{    alpha = -50;}',correct
'timer = millis();',correct
'float coord3x = beginX - M * 40;',correct
'beginX + M * 40',correct
'float coord8x = beginX + M * 120',correct
'M * 160',correct
'foxesCreated--;',correct
'-.3f * PI',correct
'arc(rEyeX, rEyeY, M * 25, M * 35, -.3f * PI, PI, CHORD);',correct
'vertex(coord8x, coord8y)',correct
'strokeWeight(1);',correct
'coord8y = beginY - M * 40',correct
'rect(width - 50, height - 50, 50, 50)',correct
'background(255);',correct
'{    colorb = colorb + 10;}',correct
'textSize(20)',correct
'{    if (foxesCreated > 0 && mouseX < width && mouseX > width - 50 && mouseY < height && mouseY > height - 50) {        foxesCreated--;    }    if (foxesCreated < foxes.length && mouseX < width && mouseX > width - 50 && mouseY < height - 50 && mouseY > height - 100) {        foxesCreated++;    }    if (foxesCreated > 0 && mouseX < width - 50 && mouseX > width - 100 && mouseY < height && mouseY > height - 50) {        foxesCreated = 0;    }    if (foxesCreated < foxes.length && mouseX < width - 50 && mouseX > width - 100 && mouseY < height - 50 && mouseY > height - 100 && foxesCreated > foxes.length - 10) {        foxesCreated = foxesCreated + foxes.length - foxesCreated;    }    if (foxesCreated < foxes.length && mouseX < width - 50 && mouseX > width - 100 && mouseY < height - 50 && mouseY > height - 100) {        foxesCreated = foxesCreated + 10;    }}',correct
'{    colorr = colorr + random(-5, 5);    colorg = colorg + random(-5, 5);    colorb = colorb + random(-5, 5);    alpha = alpha + random(0, 3);    timer = millis();}',correct
'float coord2y = beginY - M * 40;',correct
'coord2y = beginY - M * 40',correct
'// makes the eyes open and closeif (alpha >= 0 && alpha <= 150) {    // left eye    noFill();    arc(lEyeX, lEyeY, M * 25, M * 35, 0, 1.3f * PI, CHORD);    // right eye    noFill();    arc(rEyeX, rEyeY, M * 25, M * 35, -.3f * PI, PI, CHORD);} else {    // sleep left eye    noFill();    arc(lEyeX, lEyeY, M * 25, M * 35, .25f * PI, PI);    // sleep right eye    noFill();    arc(rEyeX, rEyeY, M * 25, M * 35, 0, .75f * PI);}',correct
'// changes the color of the fox smoothlyif (millis() - timer >= 10) {    colorr = colorr + random(-5, 5);    colorg = colorg + random(-5, 5);    colorb = colorb + random(-5, 5);    alpha = alpha + random(0, 3);    timer = millis();}',correct
'colorr = colorr - 10;',correct
'foxes[i] = new Fox();',correct
'{    frameRate(120);    for (int i = 0; i < FOXES; i++) {        foxes[i] = new Fox();    }}',correct
'.75f',correct
'arc(lEyeX, lEyeY, M * 25, M * 35, 0, 1.3f * PI, CHORD);',correct
'float colorg = 125;',StdCyclomaticComplexity
'foxes = new Fox[FOXES]',correct
'float coord7y = beginY + M * 40',correct
'arc(lEyeX, lEyeY, M * 25, M * 35, .25f * PI, PI)',correct
'vertex(coord4x, coord4y);',correct
'float rEyeX = beginX + M * 80',correct
'float coord5x = beginX + M * 40;',correct
'float coord4y = beginY + M * 60',correct
'vertex(coord6x, coord6y);',correct
'foxes[i].display();',correct
'float rEyeX = beginX + M * 80;',correct
'// sleep left eyenoFill();',correct
'for (int i = 0; i < foxesCreated; i++) {    foxes[i].display();}',correct
'colorb - 10',correct
'alpha > 255',correct
'int timer = millis();',StdCyclomaticComplexity
'millis()',correct
'void draw() {    background(255);    for (int i = 0; i < foxesCreated; i++) {        foxes[i].display();    }    Counter.display();}',correct
'text("+10", width - 75, height - 70);',correct
'{    foxesCreated = foxesCreated + foxes.length - foxesCreated;}',correct
'colorr = colorr - 10',correct
'coord3y = beginY + M * 40',correct
'mouseY < height',correct
'if (foxesCreated < foxes.length && mouseX < width - 50 && mouseX > width - 100 && mouseY < height - 50 && mouseY > height - 100 && foxesCreated > foxes.length - 10) {    foxesCreated = foxesCreated + foxes.length - foxesCreated;}',correct
'.75f * PI',correct
'.25f * PI',correct
'// with this the rgb values cant go under 0if (colorr < 0) {    colorr = colorr + 10;}',correct
'if (colorb < 0) {    colorb = colorb + 10;}',correct
'Fox[] foxes = new Fox[FOXES];',correct
'rect(width - 50, height - 100, 50, 50)',correct
'float maxOffsetX = width - 110 * M;',StdCyclomaticComplexity
'foxesCreated < foxes.length',correct
'if (foxesCreated < foxes.length && mouseX < width && mouseX > width - 50 && mouseY < height - 50 && mouseY > height - 100) {    foxesCreated++;}',correct
'foxesCreated = foxesCreated + 10',correct
'float beginX = random(minOffsetX, maxOffsetX) - 40 * M;',correct
'frameRate(120)',correct
'foxesCreated = 0;',correct
'vertex(coord5x, coord5y)',correct
'colorg = colorg + 10',correct
'float coord4y = beginY + M * 60;',correct
'foxesCreated > 0 && mouseX < width',correct
'class counter {    void display() {        strokeWeight(1);        stroke(0);        textAlign(CENTER);        textSize(20);        text(foxesCreated, width - 25, height - 100);        fill(0, 255, 0);        rect(width - 50, height - 100, 50, 50);        rect(width - 50, height - 50, 50, 50);        rect(width - 100, height - 50, 50, 50);        rect(width - 100, height - 100, 50, 50);        fill(0);        text("+1", width - 25, height - 70);        text("+10", width - 75, height - 70);        text("-1", width - 25, height - 15);        text("clear", width - 75, height - 15);    }}',correct
'fill(0)',correct
'coord7y = beginY + M * 40',correct
'foxesCreated < foxes.length && mouseX < width && mouseX > width - 50 && mouseY < height - 50',correct
'maxOffsetX = width - 110 * M',correct
'frameRate(120);',correct
'vertex(coord3x, coord3y);',correct
'mouseY > height - 100',correct
'vertex(coord3x, coord3y)',correct
'vertex(coord7x, coord7y);',correct
'foxes.length',correct
'random(minOffsetX, (maxOffsetX - 40 * M))',correct
'random(minOffsetY, (maxOffsetY - 40 * M))',correct
'float rEyeY = beginY + M * 40',correct
'foxesCreated < foxes.length && mouseX < width - 50 && mouseX > width - 100',correct
'colorr < 0',correct
'rEyeY = beginY + M * 40',correct
'foxesCreated++;',correct
'float coord1y = beginY;',correct
'random(minOffsetY, maxOffsetY) - 40 * M',correct
'alpha = alpha + random(0, 3)',correct
'alpha = 125',correct
'foxesCreated < foxes.length && mouseX < width',correct
'noFill()',correct
'strokeWeight(5 * M);',correct
'// with this the rgb values cant go over 255if (colorr > 255) {    colorr = colorr - 10;}',correct
'textAlign(CENTER);',correct
'minOffsetY = 110 * M',correct
'class Fox {    float M = random(.05f, .3f);    float maxOffsetX = width - 110 * M;    float maxOffsetY = height - 120 * M;    float minOffsetX = 110 * M;    float minOffsetY = 110 * M;    float beginX = random(minOffsetX, maxOffsetX) - 40 * M;    float beginY = random(minOffsetY, maxOffsetY) - 40 * M;    float colorr = 125;    float colorg = 125;    float colorb = 125;    float alpha = 125;    int timer = millis();    void display() {        strokeWeight(5 * M);        float coord1x = beginX;        float coord2x = beginX - M * 40;        float coord3x = beginX - M * 40;        float coord4x = beginX - M * 60;        float coord5x = beginX + M * 40;        float coord6x = beginX + M * 140;        float coord7x = beginX + M * 120;        float coord8x = beginX + M * 120;        float coord9x = beginX + M * 80;        float coord1y = beginY;        float coord2y = beginY - M * 40;        float coord3y = beginY + M * 40;        float coord4y = beginY + M * 60;        float coord5y = beginY + M * 160;        float coord6y = beginY + M * 60;        float coord7y = beginY + M * 40;        float coord8y = beginY - M * 40;        float coord9y = beginY;        float lEyeX = beginX;        float rEyeX = beginX + M * 80;        float lEyeY = beginY + M * 40;        float rEyeY = beginY + M * 40;        stroke(colorr, colorg, colorb, alpha);        noFill();        beginShape();        vertex(coord1x, coord1y);        vertex(coord2x, coord2y);        vertex(coord3x, coord3y);        vertex(coord4x, coord4y);        vertex(coord5x, coord5y);        vertex(coord6x, coord6y);        vertex(coord7x, coord7y);        vertex(coord8x, coord8y);        vertex(coord9x, coord9y);        vertex(coord1x, coord1y);        vertex(coord3x, coord3y);        vertex(coord5x, coord5y);        vertex(coord7x, coord7y);        vertex(coord9x, coord9y);        endShape();        // makes the eyes open and close        if (alpha >= 0 && alpha <= 150) {            // left eye            noFill();            arc(lEyeX, lEyeY, M * 25, M * 35, 0, 1.3f * PI, CHORD);            // right eye            noFill();            arc(rEyeX, rEyeY, M * 25, M * 35, -.3f * PI, PI, CHORD);        } else {            // sleep left eye            noFill();            arc(lEyeX, lEyeY, M * 25, M * 35, .25f * PI, PI);            // sleep right eye            noFill();            arc(rEyeX, rEyeY, M * 25, M * 35, 0, .75f * PI);        }        // changes the color of the fox smoothly        if (millis() - timer >= 10) {            colorr = colorr + random(-5, 5);            colorg = colorg + random(-5, 5);            colorb = colorb + random(-5, 5);            alpha = alpha + random(0, 3);            timer = millis();        }        // with this the rgb values cant go under 0        if (colorr < 0) {            colorr = colorr + 10;        }        if (colorg < 0) {            colorg = colorg + 10;        }        if (colorb < 0) {            colorb = colorb + 10;        }        if (alpha < -60) {            alpha = alpha + 50;        }        // with this the rgb values cant go over 255        if (colorr > 255) {            colorr = colorr - 10;        }        if (colorg > 255) {            colorg = colorg - 10;        }        if (colorb > 255) {            colorb = colorb - 10;        }        if (alpha > 255) {            alpha = -50;        }        if (alpha <= 0 && alpha >= -5) {            beginX = random(minOffsetX, (maxOffsetX - 40 * M));            beginY = random(minOffsetY, (maxOffsetY - 40 * M));            M = random(.05f, .3f);        }    }}',correct
'int i = 0',correct
'float coord3y = beginY + M * 40;',correct
'float coord2x = beginX - M * 40',correct
'coord6y = beginY + M * 60',correct
'coord4y = beginY + M * 60',correct
'float coord9x = beginX + M * 80;',correct
'colorg + random(-5, 5)',correct
'{    colorr = colorr - 10;}',correct
'rect(width - 50, height - 100, 50, 50);',correct
'Counter.display();',correct
'text("+10", width - 75, height - 70)',correct
'foxesCreated = 0',correct
'beginY + M * 60',correct
'1.3f * PI',correct
'text("clear", width - 75, height - 15)',correct
'float coord6x = beginX + M * 140;',correct
'float coord8y = beginY - M * 40',correct
'foxesCreated = foxesCreated + 10;',correct
'foxes.length - 10',correct
'foxesCreated < foxes.length && mouseX < width && mouseX > width - 50',correct
'vertex(coord2x, coord2y);',correct
'vertex(coord6x, coord6y)',correct
'M * 40',correct
'Counter = new counter()',correct
'vertex(coord8x, coord8y);',correct
'alpha <= 0 && alpha >= -5',correct
'M * 35',correct
'colorg > 255',correct
'mouseX < width',correct
'colorb + 10',correct
'mouseY > height - 50',correct
'.3f',correct
'text("+1", width - 25, height - 70)',correct
'colorr + random(-5, 5)',correct
'text("+1", width - 25, height - 70);',correct
'foxesCreated > 0',correct
'beginY + M * 40',correct
'M * 60',correct
'random(-5, 5)',correct
'{    colorg = colorg + 10;}',correct
'colorr = colorr + random(-5, 5);',correct
'FOXES = 500',correct
'coord1y = beginY',correct
'vertex(coord2x, coord2y)',correct
'display',LongMethodRule
'colorb > 255',correct
'float coord7y = beginY + M * 40;',correct
'foxesCreated > 0 && mouseX < width && mouseX > width - 50 && mouseY < height',correct
'width - 100',correct
'.25f',correct
'foxesCreated--',correct
'random(.05f, .3f)',correct
'-50',correct
'i++',correct
'colorb = colorb - 10',correct
'colorb = colorb + random(-5, 5);',correct
'"-1"',correct
'fill(0, 255, 0);',correct
'stroke(colorr, colorg, colorb, alpha);',correct
'if (foxesCreated > 0 && mouseX < width && mouseX > width - 50 && mouseY < height && mouseY > height - 50) {    foxesCreated--;}',correct
'foxesCreated < foxes.length && mouseX < width - 50 && mouseX > width - 100 && mouseY < height - 50',correct
'foxesCreated < foxes.length && mouseX < width - 50',correct
'rect(width - 100, height - 50, 50, 50)',correct
'beginY + M * 160',correct
'beginX = random(minOffsetX, (maxOffsetX - 40 * M))',correct
'M * 80',correct
'random(minOffsetX, maxOffsetX)',correct
'colorr = colorr + random(-5, 5)',correct
'void display() {    strokeWeight(1);    stroke(0);    textAlign(CENTER);    textSize(20);    text(foxesCreated, width - 25, height - 100);    fill(0, 255, 0);    rect(width - 50, height - 100, 50, 50);    rect(width - 50, height - 50, 50, 50);    rect(width - 100, height - 50, 50, 50);    rect(width - 100, height - 100, 50, 50);    fill(0);    text("+1", width - 25, height - 70);    text("+10", width - 75, height - 70);    text("-1", width - 25, height - 15);    text("clear", width - 75, height - 15);}',correct
'coord6x = beginX + M * 140',correct
'foxesCreated > foxes.length - 10',correct
'float coord3y = beginY + M * 40',correct
'float coord2y = beginY - M * 40',correct
'-60',correct
'timer = millis()',correct
'M = random(.05f, .3f);',correct
'"clear"',correct
'alpha = -50',correct
'alpha >= 0 && alpha <= 150',correct
'[FOXES]',correct
'colorg = colorg + random(-5, 5);',correct
'height - 100',correct
'if (alpha <= 0 && alpha >= -5) {    beginX = random(minOffsetX, (maxOffsetX - 40 * M));    beginY = random(minOffsetY, (maxOffsetY - 40 * M));    M = random(.05f, .3f);}',correct
'beginX + M * 140',correct
'beginX + M * 120',correct
'foxesCreated++',correct
'colorg - 10',correct
'foxesCreated = foxesCreated + foxes.length - foxesCreated;',correct
'alpha <= 150',correct
'float coord8y = beginY - M * 40;',correct
'{    foxesCreated = 0;}',correct
'coord8x = beginX + M * 120',correct
'colorg = colorg + random(-5, 5)',correct
'mouseX > width - 50',correct
'arc(rEyeX, rEyeY, M * 25, M * 35, 0, .75f * PI);',correct
'-.3f',correct
'random(0, 3)',correct
'float coord9x = beginX + M * 80',correct
'colorb = colorb + 10;',correct
'colorb < 0',correct
'coord5y = beginY + M * 160',correct
'foxes[i].display()',correct
'random(minOffsetX, maxOffsetX) - 40 * M',correct
'colorg = colorg - 10',correct
'rect(width - 50, height - 50, 50, 50);',correct
'foxesCreated = foxesCreated + foxes.length - foxesCreated',correct
'snakeleftX - 37',correct
'snakeY = height / 2;',correct
'ellipse(snakeleftX - 4, snakeleftY + 1, 60, 60)',correct
'strokeWeight(20);',correct
'snakeX + 10',correct
'ellipse(snakeX + 125, snakeY + 130, 60, 60)',correct
'background(0)',correct
'ellipse(snakeX + 165, snakeY + 28, 60, 60)',correct
'// programming creature Daffa Paramitha 2018int snakeX;',correct
'snakeX - 30',correct
'ellipse(snakeX + 50, snakeY + 50, 60, 60)',correct
'snakeleftY + 13',correct
'snakeleftY - 37',correct
'stroke(0);',correct
'stroke(0)',correct
'ellipse(snakeX - 30, snakeY - 30, 30, 30);',correct
'void setup() {    rectMode(CENTER);    ellipseMode(CENTER);    snakeX = width / 2;    snakeY = height / 2;    snakeleftX = width / 3;    snakeleftY = height / 3;}',correct
'// snakeright: ellipses from left to rightif (mousePressed) {    fill(0, 255, 255);} else    fill(255);',correct
'ellipseMode(CORNER)',correct
'snakeY = height / 2',correct
'ellipse(snakeleftX + 30, snakeleftY + 40, 60, 60)',correct
'snakeY + 90',correct
'snakeY - 30',correct
'snakeX + 125',correct
'snakeX + 86',correct
'// snakeright: hanging ellipses from top to bottomellipse(snakeX + 160, snakeY + 85, 60, 60);',correct
'snakeY + 10',correct
'snakeX = width / 2',correct
'int snakeY;',correct
'fill(255, 0, 0);',correct
'snakeleftX + 30',correct
'snakeleftY + 40',correct
'snakeX + 8',correct
'line(230, 272, 230, 400);',correct
'snakeleftX - 4',correct
'fill(0);',correct
'// backgroundbackground(0);',correct
'ellipse(snakeleftX - 70, snakeleftY + 70, 60, 60);',correct
'ellipse(snakeX + 15, snakeY - 30, 30, 30);',correct
'{    fill(0, 255, 255);}',DecentralizedEventHandlingRule
'// snakemiddlefill(255);',correct
'snakeY + 85',correct
'{    fill(255, 0, 0);}',correct
'fill(0, 255, 255);',correct
'rectMode(CENTER)',correct
'snakeY',correct
'snakeX',correct
'{    strokeWeight(8);    // background    background(0);    rectMode(CENTER);    fill(255, 0, 0);    rect(200, 200, 200, 200);    // snakeleft: ellipses from left to right    if (mousePressed) {        fill(255, 255, 0);    } else        fill(255);    ellipse(snakeleftX - 37, snakeleftY - 37, 60, 60);    ellipse(snakeleftX - 4, snakeleftY + 1, 60, 60);    ellipse(snakeleftX + 30, snakeleftY + 40, 60, 60);    // snakeleft: hanging ellipses from top to bottom    ellipse(snakeleftX - 65, snakeleftY + 13, 60, 60);    ellipse(snakeleftX - 70, snakeleftY + 70, 60, 60);    // snakeright: ellipses from left to right    if (mousePressed) {        fill(0, 255, 255);    } else        fill(255);    ellipse(snakeX + 50, snakeY + 50, 60, 60);    ellipse(snakeX + 86, snakeY + 90, 60, 60);    ellipse(snakeX + 125, snakeY + 130, 60, 60);    // snakeright: hanging ellipses from top to bottom    ellipse(snakeX + 160, snakeY + 85, 60, 60);    ellipse(snakeX + 165, snakeY + 28, 60, 60);    // snakemiddle    fill(255);    ellipseMode(CENTER);    ellipse(snakeX + 10, snakeY + 10, 120, 120);    ellipseMode(CORNER);    fill(0);    ellipse(snakeX - 30, snakeY - 30, 30, 30);    ellipse(snakeX + 15, snakeY - 30, 30, 30);    ellipseMode(CENTER);    if (mousePressed) {        fill(255, 0, 0);    } else        fill(255);    ellipse(snakeX + 8, snakeY + 26, 45, 45);    // legs    if (mousePressed) {        strokeWeight(20);        stroke(255);    }    line(180, 262, 180, 400);    line(230, 272, 230, 400);}',LongMethodRule
'snakeleftX - 65',correct
'// legsif (mousePressed) {    strokeWeight(20);    stroke(255);}',correct
'ellipse(snakeleftX - 4, snakeleftY + 1, 60, 60);',correct
'snakeleftY + 1',correct
'ellipse(snakeleftX - 65, snakeleftY + 13, 60, 60)',correct
'ellipse(snakeX + 86, snakeY + 90, 60, 60);',correct
'draw',LongMethodRule
'snakeX + 15',correct
'ellipse(snakeX - 30, snakeY - 30, 30, 30)',correct
'strokeWeight(8)',correct
'ellipse(snakeX + 50, snakeY + 50, 60, 60);',correct
'ellipseMode(CORNER);',correct
'rectMode(CENTER);',correct
'snakeY + 130',correct
'snakeleftX - 70',correct
'// snakeleft: hanging ellipses from top to bottomellipse(snakeleftX - 65, snakeleftY + 13, 60, 60);',correct
'fill(255, 0, 0)',correct
'ellipse(snakeX + 125, snakeY + 130, 60, 60);',correct
'float snakeleftX;',correct
'line(180, 262, 180, 400)',correct
'mousePressed',DecentralizedEventHandlingRule
'fill(255);',DecentralizedEventHandlingRule
'snakeleftX = width / 3',correct
'ellipseMode(CENTER)',correct
'ellipse(snakeX + 160, snakeY + 85, 60, 60)',correct
'ellipse(snakeX + 8, snakeY + 26, 45, 45)',correct
'fill(255, 255, 0)',correct
'snakeX + 50',correct
'{    fill(255, 255, 0);}',DecentralizedEventHandlingRule
'{    rectMode(CENTER);    ellipseMode(CENTER);    snakeX = width / 2;    snakeY = height / 2;    snakeleftX = width / 3;    snakeleftY = height / 3;}',correct
'ellipse(snakeX + 8, snakeY + 26, 45, 45);',correct
'snakeleftX',correct
'snakeleftY',correct
'void',correct
'line(230, 272, 230, 400)',correct
'snakeleftX = width / 3;',correct
'{    strokeWeight(8);    stroke(0);}',correct
'snakeX + 160',correct
'rect(200, 200, 200, 200);',correct
'snakeX + 165',correct
'ellipse(snakeX + 10, snakeY + 10, 120, 120)',correct
'fill(0)',correct
'strokeWeight(20)',correct
'{    strokeWeight(20);    stroke(255);}',correct
'height / 2',correct
'height / 3',correct
'rect(200, 200, 200, 200)',correct
'snakeY + 50',correct
'ellipse(snakeX + 10, snakeY + 10, 120, 120);',correct
'fill(255, 255, 0);',correct
'ellipse(snakeX + 86, snakeY + 90, 60, 60)',correct
'snakeleftY = height / 3;',correct
'fill(0, 255, 255)',correct
'// snakeleft: ellipses from left to rightif (mousePressed) {    fill(255, 255, 0);} else    fill(255);',correct
'if (mousePressed) {    fill(255, 0, 0);} else    fill(255);',correct
'stroke(255);',correct
'snakeX = width / 2;',correct
'fill(255)',correct
'ellipse(snakeleftX + 30, snakeleftY + 40, 60, 60);',correct
'Processing',correct
'ellipse(snakeX + 15, snakeY - 30, 30, 30)',correct
'snakeY + 28',correct
'ellipse(snakeleftX - 37, snakeleftY - 37, 60, 60);',correct
'snakeY + 26',correct
'ellipse(snakeleftX - 70, snakeleftY + 70, 60, 60)',correct
'ellipse(snakeleftX - 37, snakeleftY - 37, 60, 60)',correct
'snakeleftY + 70',correct
'float snakeleftY;',correct
'ellipseMode(CENTER);',correct
'width / 2',correct
'strokeWeight(8);',correct
'snakeleftY = height / 3',correct
'void mouseReleased() {    strokeWeight(8);    stroke(0);}',correct
'// programming creature Daffa Paramitha 2018',correct
'stroke(255)',correct
'ellipse(snakeX + 165, snakeY + 28, 60, 60);',correct
'void draw() {    strokeWeight(8);    // background    background(0);    rectMode(CENTER);    fill(255, 0, 0);    rect(200, 200, 200, 200);    // snakeleft: ellipses from left to right    if (mousePressed) {        fill(255, 255, 0);    } else        fill(255);    ellipse(snakeleftX - 37, snakeleftY - 37, 60, 60);    ellipse(snakeleftX - 4, snakeleftY + 1, 60, 60);    ellipse(snakeleftX + 30, snakeleftY + 40, 60, 60);    // snakeleft: hanging ellipses from top to bottom    ellipse(snakeleftX - 65, snakeleftY + 13, 60, 60);    ellipse(snakeleftX - 70, snakeleftY + 70, 60, 60);    // snakeright: ellipses from left to right    if (mousePressed) {        fill(0, 255, 255);    } else        fill(255);    ellipse(snakeX + 50, snakeY + 50, 60, 60);    ellipse(snakeX + 86, snakeY + 90, 60, 60);    ellipse(snakeX + 125, snakeY + 130, 60, 60);    // snakeright: hanging ellipses from top to bottom    ellipse(snakeX + 160, snakeY + 85, 60, 60);    ellipse(snakeX + 165, snakeY + 28, 60, 60);    // snakemiddle    fill(255);    ellipseMode(CENTER);    ellipse(snakeX + 10, snakeY + 10, 120, 120);    ellipseMode(CORNER);    fill(0);    ellipse(snakeX - 30, snakeY - 30, 30, 30);    ellipse(snakeX + 15, snakeY - 30, 30, 30);    ellipseMode(CENTER);    if (mousePressed) {        fill(255, 0, 0);    } else        fill(255);    ellipse(snakeX + 8, snakeY + 26, 45, 45);    // legs    if (mousePressed) {        strokeWeight(20);        stroke(255);    }    line(180, 262, 180, 400);    line(230, 272, 230, 400);}',correct
'width / 3',correct
'line(180, 262, 180, 400);',correct
'y - 175',correct
'y - 172',correct
'ellipse(x - 310, y - 190, 8, 8);',correct
'float t = millis() / 600.0f;',ShortVariable
'targetY - rocketY',correct
'saturnus.display()',correct
'cy = 300',correct
'saturnusHueOffset += saturnusHueChange;',correct
'colorMode(HSB, 100, 100, 100)',correct
'fill(244, 164, 96)',correct
'ellipse(x - 300, y - 175, 8, 8);',correct
'ellipse(x + 142, y - 249, 6, 6)',correct
'y - 169',correct
'rect(headX - 5, headY + 10, 3, 3);',correct
'ellipse(x + 140, y - 251, 6, 6)',correct
'ellipse(x - 298, y - 175, 8, 8)',correct
'color(255, 0, 0)',correct
'float t = millis() / 800.0f',correct
'text("Earth", x - 320, y - 140);',correct
'saturnusHueOffset += saturnusHueChange',correct
'x - 300',correct
'stroke(bodyColor)',correct
'x - 302',correct
'jupiter',correct
'"Moon"',correct
'fill(0);',correct
'createFont("Arial", 20)',correct
'float easing = 1;',AtLeastOneConstructor
'// windows:noStroke();',correct
'ellipse(x + 165, y + 120, 10, 10);',correct
'fill(150);',correct
'millis() / 600.0f',correct
'rectMode(CENTER)',correct
'y - 140',correct
'x - 310',correct
'void display() {    float t = millis() / 600.0f;    int x = (int) (cx + r * cos(t));    int y = (int) (cy + r * sin(t));    fill(255);    text("Earth", x - 320, y - 140);    fill(0, 119, 190);    ellipse(x - 300, y - 180, 40, 40);    fill(0, 255, 0);    ellipse(x - 300, y - 180, 8, 8);    ellipse(x - 298, y - 175, 8, 8);    ellipse(x - 300, y - 175, 8, 8);    ellipse(x - 302, y - 175, 8, 8);    ellipse(x - 298, y - 172, 8, 8);    ellipse(x - 298, y - 169, 8, 8);    ellipse(x - 310, y - 190, 8, 8);    ellipse(x - 308, y - 193, 8, 8);    ellipse(x - 285, y - 175, 8, 8);}',correct
'rect(headX - 5, headY, 3, 3);',correct
'ellipse(x + 150, y + 135, 10, 10);',correct
'float t = millis() / 400.0f',correct
'bodyColor = color(255, 0, 0);',correct
'ellipse(x - 300, y - 175, 8, 8)',correct
'ellipse(x + 145, y - 250, 30, 30)',correct
'saturnusHueOffset = 100;',correct
'x - 308',correct
'Jupiter',correct
'easing = 1',correct
'rectMode(CENTER);',correct
'saturnusHueOffset = 0;',correct
'y - 251',correct
'y - 250',correct
'x - 320',correct
'dx = targetX - rocketX',correct
'ellipse(x - 298, y - 169, 8, 8);',correct
'600.0f',correct
'ellipse(x - 308, y - 193, 8, 8);',correct
'float saturnusY = 100;',correct
'fill(bodyColor)',correct
'headY - 5',correct
'float headX = rocketX',correct
'x = (int) (cx + r * cos(t))',correct
'fill(139, 69, 19);',correct
'float dy = targetY - rocketY',correct
'y - 249',correct
'y - 247',correct
'y - 245',correct
'{    float t = millis() / 600.0f;    int x = (int) (cx + r * cos(t));    int y = (int) (cy + r * sin(t));    fill(255);    text("Earth", x - 320, y - 140);    fill(0, 119, 190);    ellipse(x - 300, y - 180, 40, 40);    fill(0, 255, 0);    ellipse(x - 300, y - 180, 8, 8);    ellipse(x - 298, y - 175, 8, 8);    ellipse(x - 300, y - 175, 8, 8);    ellipse(x - 302, y - 175, 8, 8);    ellipse(x - 298, y - 172, 8, 8);    ellipse(x - 298, y - 169, 8, 8);    ellipse(x - 310, y - 190, 8, 8);    ellipse(x - 308, y - 193, 8, 8);    ellipse(x - 285, y - 175, 8, 8);}',correct
'rect(headX - 5, headY + 20, 3, 3);',correct
'rect(headX + 5, headY + 15, 3, 3);',correct
'fill(bodyColor);',correct
'rocketX += dx * easing',correct
'float rocketX;',AtLeastOneConstructor
'// bodyrect(rocketX, rocketY, 25, 75);',correct
'new Mars()',correct
'int saturnusY = (int) (cy + (r * 3) * sin(t));',correct
'raket.display();',correct
'Processing',correct
'earth.display()',correct
'float t = millis() / 400.0f;',ShortVariable
'saturnusY = (int) (cy + (r * 3) * sin(t))',correct
'rect(headX + 5, headY + 5, 3, 3)',correct
'y - 220',correct
'x - 350',correct
'rocketX - 18',correct
'500.0f',correct
'rocketX - 16',correct
'void display() {    float t = millis() / 400.0f;    int x = (int) (cx + r * cos(t));    int y = (int) (cy + r * sin(t));    fill(255);    text("Mars", x + 130, y - 220);    fill(139, 69, 19);    ellipse(x + 145, y - 250, 30, 30);    fill(0);    ellipse(x + 138, y - 245, 6, 6);    ellipse(x + 140, y - 247, 6, 6);    ellipse(x + 142, y - 249, 6, 6);    ellipse(x + 140, y - 251, 6, 6);}',correct
'ellipse(x + 160, y + 130, 50, 50)',correct
'ellipse(x + 140, y - 247, 6, 6)',correct
'headY - 10',correct
'rocketX = width / 2;',correct
'ellipse(x + 170, y + 140, 10, 10)',correct
'stroke(bodyColor);',correct
'rocketX - 10',correct
'saturnusX = (int) (cx + (r * 2) * cos(t))',correct
'i = 0',correct
'fill(139, 69, 19)',correct
'rect(headX + 5, headY + 5, 3, 3);',correct
'void draw() {    background(10, 10, 30);    jupiter.display();    mars.display();    saturnus.display();    saturnus.update();    raket.display();    earth.display();    float t = millis() / 500.0f;    int x = (int) (cx + r * cos(t));    int y = (int) (cy + r * sin(t));    fill(255);    ellipse(x + 160, y + 130, 50, 50);    text("Moon", x + 135, y + 170);    fill(150);    ellipse(x + 150, y + 135, 10, 10);    ellipse(x + 165, y + 120, 10, 10);    ellipse(x + 170, y + 140, 10, 10);}',correct
'rect(headX + 5, headY - 5, 3, 3)',correct
'fill(0, 255, 0)',correct
'text("Moon", x + 135, y + 170);',correct
'rocketY - 14',correct
'rect(headX - 5, headY - 5, 3, 3);',correct
'if (saturnusHueOffset >= 0 && saturnusHueOffset <= 100) {    saturnusHueOffset += saturnusHueChange;} else if (saturnusHueOffset > 100) {    saturnusHueOffset = 0;} else {    saturnusHueOffset = 100;}',correct
'Raket',correct
'saturnusHueOffset >= 0 && saturnusHueOffset <= 100',correct
'"Saturnus"',correct
'mars.display();',correct
'headY + 5',correct
'rect(rocketX + 16, rocketY - 3, 8, 15)',correct
'{    rectMode(CENTER);    ellipseMode(CENTER);    rocketX = width / 2;    rocketY = height / 2;    bodyColor = color(255, 0, 0);    stroke(bodyColor);    fill(bodyColor);    float targetX = mouseX;    float dx = targetX - rocketX;    rocketX += dx * easing;    float targetY = mouseY;    float dy = targetY - rocketY;    rocketY += dy * easing;    // body    rect(rocketX, rocketY, 25, 75);    ellipse(rocketX - 10, rocketY + 13, 5, 100);    ellipse(rocketX + 10, rocketY + 13, 5, 100);    rect(rocketX, rocketY + 13, 20, 5);    // sides    ellipse(rocketX - 18, rocketY - 23, 5, 10);    rect(rocketX - 16, rocketY - 3, 8, 15);    rect(rocketX - 18, rocketY - 3, 5, 37);    ellipse(rocketX - 18, rocketY + 22, 5, 10);    ellipse(rocketX + 18, rocketY - 23, 5, 10);    rect(rocketX + 16, rocketY - 3, 8, 15);    rect(rocketX + 18, rocketY - 3, 5, 37);    ellipse(rocketX + 18, rocketY + 22, 5, 10);    // head    float headX = rocketX;    float headY = rocketY - 14;    arc(headX, headY, 25, 175, PI, 2 * PI);    // windows:    noStroke();    fill(255);    rect(headX - 5, headY - 5, 3, 3);    rect(headX + 5, headY - 5, 3, 3);    rect(headX - 5, headY - 10, 3, 3);    rect(headX + 5, headY - 10, 3, 3);    rect(headX - 5, headY, 3, 3);    rect(headX + 5, headY, 3, 3);    rect(headX - 5, headY + 5, 3, 3);    rect(headX + 5, headY + 5, 3, 3);    rect(headX - 5, headY + 10, 3, 3);    rect(headX + 5, headY + 10, 3, 3);    rect(headX - 5, headY + 15, 3, 3);    rect(headX + 5, headY + 15, 3, 3);    rect(headX - 5, headY + 20, 3, 3);    rect(headX + 5, headY + 20, 3, 3);}',LongMethodRule
'millis() / 500.0f',correct
'new Jupiter()',correct
'headX - 5',correct
'noStroke();',correct
'"Arial"',correct
'text("Moon", x + 135, y + 170)',correct
'{    saturnusHueOffset = 100;}',correct
'Jupiter jupiter;',correct
'float t = millis() / 800.0f;',ShortVariable
'void display() {    float t = millis() / 800.0f;    int saturnusX = (int) (cx + (r * 2) * cos(t));    int saturnusY = (int) (cy + (r * 3) * sin(t));    colorMode(HSB, 100, 100, 100);    noStroke();    for (int i = 0; i <= 100; i++) {        fill((i + saturnusHueOffset) % 100, 100, 100);        ellipse(saturnusX, saturnusY, 80 - i, 80 - i);    }    colorMode(RGB, 255, 255, 255);    fill(255);    text("Saturnus", saturnusX - 40, saturnusY + 60);}',correct
'targetX = mouseX',correct
'ellipse(rocketX - 18, rocketY + 22, 5, 10)',correct
'rect(headX - 5, headY - 10, 3, 3)',correct
'0.5f',correct
'rect(rocketX, rocketY + 13, 20, 5);',correct
'float dx = targetX - rocketX;',correct
'float headY = rocketY - 14;',correct
'{    background(10, 10, 30);    jupiter.display();    mars.display();    saturnus.display();    saturnus.update();    raket.display();    earth.display();    float t = millis() / 500.0f;    int x = (int) (cx + r * cos(t));    int y = (int) (cy + r * sin(t));    fill(255);    ellipse(x + 160, y + 130, 50, 50);    text("Moon", x + 135, y + 170);    fill(150);    ellipse(x + 150, y + 135, 10, 10);    ellipse(x + 165, y + 120, 10, 10);    ellipse(x + 170, y + 140, 10, 10);}',correct
'float saturnusHueChange = 0.5f;',correct
'saturnus = new Saturnus();',correct
'rocketY - 23',correct
'for (int i = 0; i <= 100; i++) {    fill((i + saturnusHueOffset) % 100, 100, 100);    ellipse(saturnusX, saturnusY, 80 - i, 80 - i);}',correct
'ellipse(x - 298, y - 169, 8, 8)',correct
'new Earth()',correct
'class Earth {    void display() {        float t = millis() / 600.0f;        int x = (int) (cx + r * cos(t));        int y = (int) (cy + r * sin(t));        text("Jupiter", x - 370, y + 150);        fill(244, 164, 96);        ellipse(x - 350, y + 100, 60, 60);    }}',correct
'ellipse(rocketX + 18, rocketY - 23, 5, 10);',correct
'earth = new Earth();',correct
'jupiter.display()',correct
'rect(headX - 5, headY, 3, 3)',correct
'ellipse(x + 138, y - 245, 6, 6)',correct
'rect(headX + 5, headY, 3, 3);',correct
'ellipse(rocketX + 10, rocketY + 13, 5, 100)',correct
'ellipse(x + 140, y - 251, 6, 6);',correct
'rect(headX - 5, headY + 10, 3, 3)',correct
'rocketY',correct
'ellipseMode(CENTER)',correct
'rocketX',correct
'rect(headX + 5, headY + 20, 3, 3);',correct
'rect(rocketX + 16, rocketY - 3, 8, 15);',correct
'void setup() {    jupiter = new Jupiter();    mars = new Mars();    saturnus = new Saturnus();    raket = new Raket();    earth = new Earth();    textFont(createFont("Arial", 20));}',correct
'colorMode(RGB, 255, 255, 255);',correct
'i <= 100',correct
'Mars mars;',correct
'rocketX + 10',correct
'void',correct
'cx = 300',correct
'raket = new Raket()',correct
'headY = rocketY - 14',correct
'rocketX + 16',correct
'saturnusHueOffset = 0',correct
'rect(rocketX + 18, rocketY - 3, 5, 37)',correct
'rocketX + 18',correct
't = millis() / 600.0f',correct
'ellipse(rocketX - 18, rocketY + 22, 5, 10);',correct
'ellipse(rocketX - 10, rocketY + 13, 5, 100)',correct
'textFont(createFont("Arial", 20));',correct
'int y = (int) (cy + r * sin(t));',correct
'headX + 5',correct
'earth = new Earth()',correct
'colorMode(HSB, 100, 100, 100);',correct
'saturnusX - 40',correct
'Raket raket;',correct
'rect(headX - 5, headY - 10, 3, 3);',correct
'ellipse(rocketX + 18, rocketY + 22, 5, 10);',correct
'int saturnusX = (int) (cx + (r * 2) * cos(t))',correct
'class Raket {    float rocketX;    float rocketY;    float easing = 1;    int bodyColor;    void display() {        rectMode(CENTER);        ellipseMode(CENTER);        rocketX = width / 2;        rocketY = height / 2;        bodyColor = color(255, 0, 0);        stroke(bodyColor);        fill(bodyColor);        float targetX = mouseX;        float dx = targetX - rocketX;        rocketX += dx * easing;        float targetY = mouseY;        float dy = targetY - rocketY;        rocketY += dy * easing;        // body        rect(rocketX, rocketY, 25, 75);        ellipse(rocketX - 10, rocketY + 13, 5, 100);        ellipse(rocketX + 10, rocketY + 13, 5, 100);        rect(rocketX, rocketY + 13, 20, 5);        // sides        ellipse(rocketX - 18, rocketY - 23, 5, 10);        rect(rocketX - 16, rocketY - 3, 8, 15);        rect(rocketX - 18, rocketY - 3, 5, 37);        ellipse(rocketX - 18, rocketY + 22, 5, 10);        ellipse(rocketX + 18, rocketY - 23, 5, 10);        rect(rocketX + 16, rocketY - 3, 8, 15);        rect(rocketX + 18, rocketY - 3, 5, 37);        ellipse(rocketX + 18, rocketY + 22, 5, 10);        // head        float headX = rocketX;        float headY = rocketY - 14;        arc(headX, headY, 25, 175, PI, 2 * PI);        // windows:        noStroke();        fill(255);        rect(headX - 5, headY - 5, 3, 3);        rect(headX + 5, headY - 5, 3, 3);        rect(headX - 5, headY - 10, 3, 3);        rect(headX + 5, headY - 10, 3, 3);        rect(headX - 5, headY, 3, 3);        rect(headX + 5, headY, 3, 3);        rect(headX - 5, headY + 5, 3, 3);        rect(headX + 5, headY + 5, 3, 3);        rect(headX - 5, headY + 10, 3, 3);        rect(headX + 5, headY + 10, 3, 3);        rect(headX - 5, headY + 15, 3, 3);        rect(headX + 5, headY + 15, 3, 3);        rect(headX - 5, headY + 20, 3, 3);        rect(headX + 5, headY + 20, 3, 3);    }}',correct
'float t = millis() / 600.0f',correct
'rect(headX - 5, headY - 5, 3, 3)',correct
'fill(244, 164, 96);',correct
'text("Earth", x - 320, y - 140)',correct
'ellipse(rocketX + 18, rocketY - 23, 5, 10)',correct
'new Raket()',correct
'rect(rocketX, rocketY, 25, 75)',correct
'class Mars {    void display() {        float t = millis() / 400.0f;        int x = (int) (cx + r * cos(t));        int y = (int) (cy + r * sin(t));        fill(255);        text("Mars", x + 130, y - 220);        fill(139, 69, 19);        ellipse(x + 145, y - 250, 30, 30);        fill(0);        ellipse(x + 138, y - 245, 6, 6);        ellipse(x + 140, y - 247, 6, 6);        ellipse(x + 142, y - 249, 6, 6);        ellipse(x + 140, y - 251, 6, 6);    }}',correct
'800.0f',correct
'arc(headX, headY, 25, 175, PI, 2 * PI);',correct
'if (saturnusHueOffset > 100) {    saturnusHueOffset = 0;} else {    saturnusHueOffset = 100;}',correct
'rect(headX - 5, headY + 15, 3, 3)',correct
'ellipse(x - 308, y - 193, 8, 8)',correct
'fill(150)',correct
'earth',correct
'int x = (int) (cx + r * cos(t))',correct
'new Saturnus()',correct
'dx * easing',correct
'rect(headX + 5, headY + 20, 3, 3)',correct
'"Earth"',correct
'text("Saturnus", saturnusX - 40, saturnusY + 60)',correct
'rect(rocketX - 18, rocketY - 3, 5, 37)',correct
'millis() / 400.0f',correct
'raket = new Raket();',correct
'(int) (cx + r * cos(t))',correct
'{    saturnusHueOffset += saturnusHueChange;}',correct
'int r = 100;',correct
'Saturnus',correct
'float targetX = mouseX',correct
'saturnusY = 100',correct
'jupiter = new Jupiter()',correct
'int saturnusY = (int) (cy + (r * 3) * sin(t))',correct
'textFont(createFont("Arial", 20))',correct
'rect(rocketX, rocketY + 13, 20, 5)',correct
'400.0f',correct
'rect(headX - 5, headY + 20, 3, 3)',correct
'80 - i',correct
'saturnus',correct
'rocketY + 13',correct
'ellipse(x - 298, y - 172, 8, 8);',correct
'ellipse(x - 285, y - 175, 8, 8);',correct
'void display() {    rectMode(CENTER);    ellipseMode(CENTER);    rocketX = width / 2;    rocketY = height / 2;    bodyColor = color(255, 0, 0);    stroke(bodyColor);    fill(bodyColor);    float targetX = mouseX;    float dx = targetX - rocketX;    rocketX += dx * easing;    float targetY = mouseY;    float dy = targetY - rocketY;    rocketY += dy * easing;    // body    rect(rocketX, rocketY, 25, 75);    ellipse(rocketX - 10, rocketY + 13, 5, 100);    ellipse(rocketX + 10, rocketY + 13, 5, 100);    rect(rocketX, rocketY + 13, 20, 5);    // sides    ellipse(rocketX - 18, rocketY - 23, 5, 10);    rect(rocketX - 16, rocketY - 3, 8, 15);    rect(rocketX - 18, rocketY - 3, 5, 37);    ellipse(rocketX - 18, rocketY + 22, 5, 10);    ellipse(rocketX + 18, rocketY - 23, 5, 10);    rect(rocketX + 16, rocketY - 3, 8, 15);    rect(rocketX + 18, rocketY - 3, 5, 37);    ellipse(rocketX + 18, rocketY + 22, 5, 10);    // head    float headX = rocketX;    float headY = rocketY - 14;    arc(headX, headY, 25, 175, PI, 2 * PI);    // windows:    noStroke();    fill(255);    rect(headX - 5, headY - 5, 3, 3);    rect(headX + 5, headY - 5, 3, 3);    rect(headX - 5, headY - 10, 3, 3);    rect(headX + 5, headY - 10, 3, 3);    rect(headX - 5, headY, 3, 3);    rect(headX + 5, headY, 3, 3);    rect(headX - 5, headY + 5, 3, 3);    rect(headX + 5, headY + 5, 3, 3);    rect(headX - 5, headY + 10, 3, 3);    rect(headX + 5, headY + 10, 3, 3);    rect(headX - 5, headY + 15, 3, 3);    rect(headX + 5, headY + 15, 3, 3);    rect(headX - 5, headY + 20, 3, 3);    rect(headX + 5, headY + 20, 3, 3);}',AtLeastOneConstructor
'ellipse(saturnusX, saturnusY, 80 - i, 80 - i)',correct
'ellipse(x + 170, y + 140, 10, 10);',correct
'ellipse(x + 150, y + 135, 10, 10)',correct
'fill((i + saturnusHueOffset) % 100, 100, 100);',correct
'"Jupiter"',correct
'rocketX = width / 2',correct
'jupiter.display();',correct
'float dx = targetX - rocketX',correct
'millis()',correct
'background(10, 10, 30)',correct
't = millis() / 400.0f',correct
'noStroke()',correct
'Earth earth;',correct
'"Mars"',correct
'colorMode(RGB, 255, 255, 255)',correct
'int x = (int) (cx + r * cos(t));',correct
'text("Jupiter", x - 370, y + 150)',correct
't = millis() / 800.0f',correct
'ellipse(x - 298, y - 175, 8, 8);',correct
'ellipse(x + 145, y - 250, 30, 30);',correct
'int cy = 300;',correct
'saturnusHueChange = 0.5f',correct
'// sidesellipse(rocketX - 18, rocketY - 23, 5, 10);',correct
'void update() {    if (saturnusHueOffset >= 0 && saturnusHueOffset <= 100) {        saturnusHueOffset += saturnusHueChange;    } else if (saturnusHueOffset > 100) {        saturnusHueOffset = 0;    } else {        saturnusHueOffset = 100;    }}',correct
'(int) (cy + r * sin(t))',correct
'bodyColor = color(255, 0, 0)',correct
'saturnusHueOffset <= 100',correct
'fill(0)',correct
'rect(rocketX - 18, rocketY - 3, 5, 37);',correct
'height / 2',correct
'rocketY + 22',correct
'float headY = rocketY - 14',correct
'float t = millis() / 500.0f;',ShortVariable
'rect(headX + 5, headY + 10, 3, 3);',correct
'int bodyColor;',AtLeastOneConstructor
'rect(rocketX - 16, rocketY - 3, 8, 15)',correct
'int y = (int) (cy + r * sin(t))',correct
'dy = targetY - rocketY',correct
'fill(255)',correct
'mars = new Mars();',correct
'raket.display()',correct
'Mars',correct
'ellipse(rocketX - 10, rocketY + 13, 5, 100);',correct
'ellipse(x - 302, y - 175, 8, 8)',correct
'background(10, 10, 30);',correct
'rect(headX - 5, headY + 5, 3, 3)',correct
'ellipse(x - 285, y - 175, 8, 8)',correct
'ellipse(x - 300, y - 180, 8, 8)',correct
'mars',correct
'rect(headX + 5, headY, 3, 3)',correct
'float saturnusHueOffset = 0;',correct
'rect(headX + 5, headY - 10, 3, 3);',correct
'ellipse(x - 310, y - 190, 8, 8)',correct
'r = 100',correct
'text("Mars", x + 130, y - 220);',correct
'earth.display();',correct
'int i = 0',correct
'ellipseMode(CENTER);',correct
'(int) (cy + (r * 3) * sin(t))',correct
'rocketY += dy * easing;',correct
'ellipse(x - 350, y + 100, 60, 60)',correct
'rect(headX + 5, headY - 10, 3, 3)',correct
'fill(0, 119, 190)',correct
'saturnus.display();',correct
'text("Mars", x + 130, y - 220)',correct
'text("Jupiter", x - 370, y + 150);',correct
'text("Saturnus", saturnusX - 40, saturnusY + 60);',correct
'ellipse(x + 138, y - 245, 6, 6);',correct
'ellipse(x - 300, y - 180, 8, 8);',correct
'x - 370',correct
'rect(rocketX + 18, rocketY - 3, 5, 37);',correct
'saturnusHueOffset = 100',correct
'ellipse(x - 300, y - 180, 40, 40)',correct
'(int) (cx + (r * 2) * cos(t))',correct
'rocketX += dx * easing;',correct
'y + 170',correct
'dy * easing',correct
'ellipse(x - 302, y - 175, 8, 8);',correct
'ellipse(x + 165, y + 120, 10, 10)',correct
'float targetY = mouseY',correct
'ellipse(rocketX + 18, rocketY + 22, 5, 10)',correct
'rect(headX + 5, headY - 5, 3, 3);',correct
'mars = new Mars()',correct
'ellipse(x - 298, y - 172, 8, 8)',correct
'y + 140',correct
'headY + 15',correct
'fill(0, 119, 190);',correct
'rect(headX - 5, headY + 5, 3, 3);',correct
'float targetX = mouseX;',DecentralizedEventHandlingRule
'float targetY = mouseY;',correct
'saturnusX = 300',correct
'headY + 20',correct
'x + 170',correct
'ellipse(saturnusX, saturnusY, 80 - i, 80 - i);',correct
'float saturnusX = 300;',correct
'float rocketY;',correct
'{    float t = millis() / 600.0f;    int x = (int) (cx + r * cos(t));    int y = (int) (cy + r * sin(t));    text("Jupiter", x - 370, y + 150);    fill(244, 164, 96);    ellipse(x - 350, y + 100, 60, 60);}',correct
'rocketY - 3',correct
'rocketY = height / 2;',correct
'x + 165',correct
'display',LongMethodRule
'y + 150',correct
'saturnusY + 60',correct
'jupiter = new Jupiter();',correct
'// headfloat headX = rocketX;',correct
'ellipse(rocketX + 10, rocketY + 13, 5, 100);',correct
'x + 160',correct
'fill((i + saturnusHueOffset) % 100, 100, 100)',correct
'rocketY = height / 2',correct
'saturnus.update()',correct
'{    if (saturnusHueOffset >= 0 && saturnusHueOffset <= 100) {        saturnusHueOffset += saturnusHueChange;    } else if (saturnusHueOffset > 100) {        saturnusHueOffset = 0;    } else {        saturnusHueOffset = 100;    }}',correct
'ellipse(x - 350, y + 100, 60, 60);',correct
'x - 285',correct
'i++',correct
'targetY = mouseY',correct
'y + 120',correct
'mars.display()',correct
'void display() {    float t = millis() / 600.0f;    int x = (int) (cx + r * cos(t));    int y = (int) (cy + r * sin(t));    text("Jupiter", x - 370, y + 150);    fill(244, 164, 96);    ellipse(x - 350, y + 100, 60, 60);}',correct
'rect(headX - 5, headY + 15, 3, 3);',correct
'fill(0, 255, 0);',correct
'fill(255);',correct
'saturnusHueOffset > 100',correct
'y = (int) (cy + r * sin(t))',correct
'x + 150',correct
'x + 145',correct
'Saturnus saturnus;',correct
'x + 140',correct
'x - 298',correct
'x + 142',correct
'y + 130',correct
'saturnus.update();',correct
'class Saturnus {    float saturnusX = 300;    float saturnusY = 100;    float saturnusHueOffset = 0;    float saturnusHueChange = 0.5f;    void display() {        float t = millis() / 800.0f;        int saturnusX = (int) (cx + (r * 2) * cos(t));        int saturnusY = (int) (cy + (r * 3) * sin(t));        colorMode(HSB, 100, 100, 100);        noStroke();        for (int i = 0; i <= 100; i++) {            fill((i + saturnusHueOffset) % 100, 100, 100);            ellipse(saturnusX, saturnusY, 80 - i, 80 - i);        }        colorMode(RGB, 255, 255, 255);        fill(255);        text("Saturnus", saturnusX - 40, saturnusY + 60);    }    void update() {        if (saturnusHueOffset >= 0 && saturnusHueOffset <= 100) {            saturnusHueOffset += saturnusHueChange;        } else if (saturnusHueOffset > 100) {            saturnusHueOffset = 0;        } else {            saturnusHueOffset = 100;        }    }}',correct
'y + 135',correct
'ellipse(x - 300, y - 180, 40, 40);',correct
'saturnus = new Saturnus()',correct
'headY + 10',correct
'millis() / 800.0f',correct
'raket',correct
'{    float t = millis() / 400.0f;    int x = (int) (cx + r * cos(t));    int y = (int) (cy + r * sin(t));    fill(255);    text("Mars", x + 130, y - 220);    fill(139, 69, 19);    ellipse(x + 145, y - 250, 30, 30);    fill(0);    ellipse(x + 138, y - 245, 6, 6);    ellipse(x + 140, y - 247, 6, 6);    ellipse(x + 142, y - 249, 6, 6);    ellipse(x + 140, y - 251, 6, 6);}',correct
'saturnusHueOffset >= 0',correct
't = millis() / 500.0f',correct
'x + 135',correct
'bodyColor',correct
'rect(headX + 5, headY + 15, 3, 3)',correct
'x + 130',correct
'float t = millis() / 500.0f',correct
'y - 193',correct
'x + 138',correct
'y + 100',correct
'Earth',correct
'{    fill((i + saturnusHueOffset) % 100, 100, 100);    ellipse(saturnusX, saturnusY, 80 - i, 80 - i);}',correct
'y - 190',correct
'int cx = 300;',correct
'{    saturnusHueOffset = 0;}',correct
'rect(rocketX - 16, rocketY - 3, 8, 15);',correct
'rocketY += dy * easing',correct
'ellipse(x + 140, y - 247, 6, 6);',correct
'ellipse(rocketX - 18, rocketY - 23, 5, 10)',correct
'float dy = targetY - rocketY;',correct
'arc(headX, headY, 25, 175, PI, 2 * PI)',correct
'ellipse(x + 160, y + 130, 50, 50);',correct
'(i + saturnusHueOffset) % 100',correct
'ellipse(x + 142, y - 249, 6, 6);',correct
'width / 2',correct
'{    jupiter = new Jupiter();    mars = new Mars();    saturnus = new Saturnus();    raket = new Raket();    earth = new Earth();    textFont(createFont("Arial", 20));}',correct
'2 * PI',correct
'targetX - rocketX',correct
'class Jupiter {    void display() {        float t = millis() / 600.0f;        int x = (int) (cx + r * cos(t));        int y = (int) (cy + r * sin(t));        fill(255);        text("Earth", x - 320, y - 140);        fill(0, 119, 190);        ellipse(x - 300, y - 180, 40, 40);        fill(0, 255, 0);        ellipse(x - 300, y - 180, 8, 8);        ellipse(x - 298, y - 175, 8, 8);        ellipse(x - 300, y - 175, 8, 8);        ellipse(x - 302, y - 175, 8, 8);        ellipse(x - 298, y - 172, 8, 8);        ellipse(x - 298, y - 169, 8, 8);        ellipse(x - 310, y - 190, 8, 8);        ellipse(x - 308, y - 193, 8, 8);        ellipse(x - 285, y - 175, 8, 8);    }}',AtLeastOneConstructor
'int saturnusX = (int) (cx + (r * 2) * cos(t));',correct
'rect(headX + 5, headY + 10, 3, 3)',correct
'y - 180',correct
'headX = rocketX',correct
'{    float t = millis() / 800.0f;    int saturnusX = (int) (cx + (r * 2) * cos(t));    int saturnusY = (int) (cy + (r * 3) * sin(t));    colorMode(HSB, 100, 100, 100);    noStroke();    for (int i = 0; i <= 100; i++) {        fill((i + saturnusHueOffset) % 100, 100, 100);        ellipse(saturnusX, saturnusY, 80 - i, 80 - i);    }    colorMode(RGB, 255, 255, 255);    fill(255);    text("Saturnus", saturnusX - 40, saturnusY + 60);}',correct
'ellipse(0, -70, 40, 40)',correct
'line(41, -30, 75, armsY);',correct
'Creature',correct
'// eyesfor (int i = -5; i <= 5; i = i + 10) {    ellipse(i, -75, 5, 5);}',correct
'void update() {    if (discoCount == 10) {        // if all 10 snowmans are in discoMode move arms up by 60 pixels        armsY = -60;    } else {        // if not all 10 snowmans are in discoMode move arms back to 0        armsY = 0;    }}',correct
'// the mouse clicks on the head of the snowmandist(snowmanX, snowmanY - 70, mouseX, mouseY) <= 20',correct
'-90',correct
'{    rectMode(CENTER);    ellipseMode(CENTER);    // for i 0 through 9, make a new snowman, place the snowmans 150 pixels after each other    for (int i = 0; i < 10; i++) {        snowman[i] = new Creature(50 + i * 150, 250);    }}',correct
'50 + i * 150',correct
'float snowmanY;',correct
'snowman[i].display()',correct
'if (discoMode) {    // when the snowman is in discoMode set:    // black->randomcolor    bodyColorBlack = color(random(255), random(255), random(255));} else {    // otherwise bodyColorBlack is black    bodyColorBlack = color(0);}',correct
'// move every snowman 0 through 9snowman[i].move();',correct
'bodyColorWhite = color(255)',correct
'// armsline(-41, -30, -75, armsY);',correct
'snowmanX = initX',correct
'// when the snowman is in discoMode set:// black->randomcolorbodyColorBlack = color(random(255), random(255), random(255));',correct
'{    line(4 + i, -21, 4 + i, -26);}',correct
'stroke(255, 69, 0)',correct
'bodyColorBlack = color(0)',correct
'pushMatrix();',correct
'{    background(205, 235, 255);    for (int i = 0; i < 10; i++) {        // display every snowman 0 through 9        snowman[i].display();        // move every snowman 0 through 9        snowman[i].move();        // update every snowman 0 thorugh 9        snowman[i].update();    }}',correct
'float snowmanX;',correct
'armsY',correct
'dist(snowmanX, snowmanY - 110, mouseX, mouseY)',correct
'// constructorCreature(float initX, float initY) {    // operator    snowmanX = initX;    snowmanY = initY;    bodyColorWhite = color(255);    bodyColorBlack = color(0);    discoCount = 0;    armsY = 0;// speedX = random(0,3);                                            //the code for letting the snowmans bounce off the walls// speedY = random(0,3);                                            //the code for letting the snowmans bounce off the walls}',correct
'{    // otherwise bodyColorBlack is black    bodyColorBlack = color(0);}',correct
'// snowmanY = snowmanY + speedY;',correct
'{    // the mouse clicks on the hat of the snowman    // set discoMode to not discoMode, boolean discomode = false will be true    discoMode = !discoMode;}',correct
'20',correct
'// }',correct
'rect(0, -110, 30, 40)',correct
'// for i 0 through 9, make a new snowman, place the snowmans 150 pixels after each otherfor (int i = 0; i < 10; i++) {    snowman[i] = new Creature(50 + i * 150, 250);}',correct
'i = -10',correct
'color(random(255), random(255), random(255))',correct
'changeColor',correct
'rect(0, -52, 40, 12)',correct
'discoCount++',correct
'snowman[i].discoCount',correct
'// speedX = random(0,3);                                            //the code for letting the snowmans bounce off the walls',correct
'// scarffill(160, 32, 240);',correct
'xspeed = 1',correct
'snowman[i].update()',correct
'// change the color of the snowman when:',correct
'snowmanY - 110',correct
'// move snowmanX with xspeedsnowmanX = snowmanX + xspeed;',correct
'// update every snowman 0 thorugh 9snowman[i].update();',correct
'ellipse(0, i, 7, 7);',correct
'snowmanY - 70',correct
'void draw() {    background(205, 235, 255);    for (int i = 0; i < 10; i++) {        // display every snowman 0 through 9        snowman[i].display();        // move every snowman 0 through 9        snowman[i].move();        // update every snowman 0 thorugh 9        snowman[i].update();    }}',correct
'rectMode(CENTER)',correct
'if (snowman[i].discoMode) {    // discoCount +1    discoCount++;// first counting how many snowmans are in discoMode}',correct
'popMatrix();',correct
'int i = -5',correct
'{    // if all 10 snowmans are in discoMode move arms up by 60 pixels    armsY = -60;}',correct
'snowmanX > width + 75',correct
'i * 150',correct
'rectMode(CENTER);',correct
'rect(0, -110, 30, 40);',correct
'random(255)',correct
'{    pushMatrix();    translate(snowmanX, snowmanY);    if (discoMode) {        // when the snowman is in discoMode set:        // black->randomcolor        bodyColorBlack = color(random(255), random(255), random(255));    } else {        // otherwise bodyColorBlack is black        bodyColorBlack = color(0);    }    stroke(bodyColorWhite);    fill(bodyColorWhite);    // body    ellipse(0, 0, 100, 100);    // head    ellipse(0, -70, 40, 40);    // hat    fill(bodyColorBlack);    stroke(bodyColorBlack);    rect(0, -110, 30, 40);    rect(0, -90, 50, 10);    // eyes    for (int i = -5; i <= 5; i = i + 10) {        ellipse(i, -75, 5, 5);    }    // buttons    for (int i = -10; i <= 10; i = i + 20) {        ellipse(0, i, 7, 7);    }    // arms    line(-41, -30, -75, armsY);    line(41, -30, 75, armsY);    // nose    fill(255, 69, 0);    stroke(255, 69, 0);    triangle(-1, -70, 1, -70, 0, -60);    // scarf    fill(160, 32, 240);    stroke(160, 32, 240);    ellipse(-20, -52, 12, 12);    rect(0, -52, 40, 12);    ellipse(20, -52, 12, 12);    for (int i = 0; i < 14; i = i + 2) {        line(4 + i, -21, 4 + i, -26);    }    rect(10, -42, 12, 30);    popMatrix();}',LongMethodRule
'void move() {    float xspeed = 1;    // move snowmanX with xspeed    snowmanX = snowmanX + xspeed;    if (snowmanX > width + 75) {        // when the snowman is out of the frame, move snowman back to -75, so snowman will move back into the screen        snowmanX = -75;    }}',correct
'i + 10',correct
'discoMode',correct
'float xspeed = 1;',correct
'i + 2',correct
'ellipse(0, 0, 100, 100)',correct
'stroke(160, 32, 240);',correct
'for (int i = 0; i < 10; i++) {    // call function changeColor for every snowman    snowman[i].changeColor();    if (snowman[i].discoMode) {        // discoCount +1        discoCount++;    // first counting how many snowmans are in discoMode    }}',correct
'50',correct
'triangle(-1, -70, 1, -70, 0, -60);',correct
'int bodyColorBlack;',correct
'dist(snowmanX, snowmanY, mouseX, mouseY)',correct
'void changeColor() {    if (// the mouse clicks on the body of the snowman    dist(snowmanX, snowmanY, mouseX, mouseY) <= 50 || // the mouse clicks on the head of the snowman    dist(snowmanX, snowmanY - 70, mouseX, mouseY) <= 20 || dist(snowmanX, snowmanY - 110, mouseX, mouseY) <= 20) {        // the mouse clicks on the hat of the snowman        // set discoMode to not discoMode, boolean discomode = false will be true        discoMode = !discoMode;    }}',correct
'i + 20',correct
'// the mouse clicks on the body of the snowmandist(snowmanX, snowmanY, mouseX, mouseY) <= 50 || // the mouse clicks on the head of the snowmandist(snowmanX, snowmanY - 70, mouseX, mouseY) <= 20 || dist(snowmanX, snowmanY - 110, mouseX, mouseY) <= 20',correct
'snowman[i].move()',correct
'discoCount = 0;',correct
'snowmanX = -75',correct
'line(-41, -30, -75, armsY)',correct
'{    // operator    snowmanX = initX;    snowmanY = initY;    bodyColorWhite = color(255);    bodyColorBlack = color(0);    discoCount = 0;    armsY = 0;// speedX = random(0,3);                                            //the code for letting the snowmans bounce off the walls// speedY = random(0,3);                                            //the code for letting the snowmans bounce off the walls}',correct
'rect(10, -42, 12, 30);',correct
'{    // when the snowman is out of the frame, move snowman back to -75, so snowman will move back into the screen    snowmanX = -75;}',correct
'// bodyellipse(0, 0, 100, 100);',correct
'{    // discoCount +1    discoCount++;// first counting how many snowmans are in discoMode}',correct
'background(205, 235, 255);',correct
'width + 75',correct
'snowman[i] = new Creature(50 + i * 150, 250)',correct
'float armsY;',correct
'// the mouse clicks on the body of the snowmandist(snowmanX, snowmanY, mouseX, mouseY) <= 50',correct
'fill(255, 69, 0)',correct
'update',correct
'// call function changeColor for every snowmansnowman[i].changeColor();',correct
'i = -5',correct
'Processing',correct
'// hatfill(bodyColorBlack);',correct
'i < 10',correct
'ellipse(0, i, 7, 7)',correct
'rect(10, -42, 12, 30)',correct
'armsY = 0;',correct
'i <= 10',correct
'// display every snowman 0 through 9snowman[i].display();',correct
'snowmanY = initY',correct
'i < 14',correct
'-110',correct
'bodyColorBlack',correct
'pushMatrix()',correct
'discoMode = !discoMode',correct
'snowman[i].discoCount = discoCount',correct
'armsY = 0',correct
'boolean discoMode = false;',correct
'false',correct
'// headellipse(0, -70, 40, 40);',correct
'{    discoCount = 0;    for (int i = 0; i < 10; i++) {        // call function changeColor for every snowman        snowman[i].changeColor();        if (snowman[i].discoMode) {            // discoCount +1            discoCount++;        // first counting how many snowmans are in discoMode        }    }    for (int i = 0; i < 10; i++) {        // then telling the snowmans how many snowmans are in discoMode        snowman[i].discoCount = discoCount;    }}',correct
'for (int i = 0; i < 14; i = i + 2) {    line(4 + i, -21, 4 + i, -26);}',correct
'int i = 0',correct
'ellipseMode(CENTER);',correct
'discoCount',correct
'// when the snowman is in discoMode set:',correct
'stroke(bodyColorWhite)',correct
'bodyColorBlack = color(0);',correct
'setup',correct
'i = 0',correct
'color(255)',correct
'// speedX = speedX * -1;',correct
'{    ellipse(0, i, 7, 7);}',correct
'// discoCount +1discoCount++;',correct
'// snowmanX = snowmanX + speedX;',correct
'-10',correct
'// operatorsnowmanX = initX;',correct
'dist(snowmanX, snowmanY - 70, mouseX, mouseY)',correct
'float discoCount = 0;',correct
'void display() {    pushMatrix();    translate(snowmanX, snowmanY);    if (discoMode) {        // when the snowman is in discoMode set:        // black->randomcolor        bodyColorBlack = color(random(255), random(255), random(255));    } else {        // otherwise bodyColorBlack is black        bodyColorBlack = color(0);    }    stroke(bodyColorWhite);    fill(bodyColorWhite);    // body    ellipse(0, 0, 100, 100);    // head    ellipse(0, -70, 40, 40);    // hat    fill(bodyColorBlack);    stroke(bodyColorBlack);    rect(0, -110, 30, 40);    rect(0, -90, 50, 10);    // eyes    for (int i = -5; i <= 5; i = i + 10) {        ellipse(i, -75, 5, 5);    }    // buttons    for (int i = -10; i <= 10; i = i + 20) {        ellipse(0, i, 7, 7);    }    // arms    line(-41, -30, -75, armsY);    line(41, -30, 75, armsY);    // nose    fill(255, 69, 0);    stroke(255, 69, 0);    triangle(-1, -70, 1, -70, 0, -60);    // scarf    fill(160, 32, 240);    stroke(160, 32, 240);    ellipse(-20, -52, 12, 12);    rect(0, -52, 40, 12);    ellipse(20, -52, 12, 12);    for (int i = 0; i < 14; i = i + 2) {        line(4 + i, -21, 4 + i, -26);    }    rect(10, -42, 12, 30);    popMatrix();}',correct
'!discoMode',correct
'ellipse(20, -52, 12, 12);',correct
'discoCount == 10',correct
'if (discoCount == 10) {    // if all 10 snowmans are in discoMode move arms up by 60 pixels    armsY = -60;} else {    // if not all 10 snowmans are in discoMode move arms back to 0    armsY = 0;}',correct
'{    // call function changeColor for every snowman    snowman[i].changeColor();    if (snowman[i].discoMode) {        // discoCount +1        discoCount++;    // first counting how many snowmans are in discoMode    }}',correct
'// the mouse clicks on the body of the snowmandist(snowmanX, snowmanY, mouseX, mouseY) <= 50 || // the mouse clicks on the head of the snowmandist(snowmanX, snowmanY - 70, mouseX, mouseY) <= 20',correct
'4 + i',correct
'fill(160, 32, 240)',correct
'snowmanX + xspeed',correct
'translate(snowmanX, snowmanY)',correct
'-20',correct
'-21',correct
'snowman[i].discoMode',correct
'// if ((snowmanY >= height-50 && speedY >=0) || (snowmanY <= 125 && speedY <= 0)) {',correct
'-26',correct
'dist(snowmanX, snowmanY - 110, mouseX, mouseY) <= 20',correct
'new Creature[10]',correct
'line(41, -30, 75, armsY)',correct
'class Creature {    float snowmanX;    float snowmanY;    int bodyColorWhite;    int bodyColorBlack;    boolean discoMode = false;    float discoCount;    float armsY;    // constructor    Creature(float initX, float initY) {        // operator        snowmanX = initX;        snowmanY = initY;        bodyColorWhite = color(255);        bodyColorBlack = color(0);        discoCount = 0;        armsY = 0;    // speedX = random(0,3);                                            //the code for letting the snowmans bounce off the walls    // speedY = random(0,3);                                            //the code for letting the snowmans bounce off the walls    }    void display() {        pushMatrix();        translate(snowmanX, snowmanY);        if (discoMode) {            // when the snowman is in discoMode set:            // black->randomcolor            bodyColorBlack = color(random(255), random(255), random(255));        } else {            // otherwise bodyColorBlack is black            bodyColorBlack = color(0);        }        stroke(bodyColorWhite);        fill(bodyColorWhite);        // body        ellipse(0, 0, 100, 100);        // head        ellipse(0, -70, 40, 40);        // hat        fill(bodyColorBlack);        stroke(bodyColorBlack);        rect(0, -110, 30, 40);        rect(0, -90, 50, 10);        // eyes        for (int i = -5; i <= 5; i = i + 10) {            ellipse(i, -75, 5, 5);        }        // buttons        for (int i = -10; i <= 10; i = i + 20) {            ellipse(0, i, 7, 7);        }        // arms        line(-41, -30, -75, armsY);        line(41, -30, 75, armsY);        // nose        fill(255, 69, 0);        stroke(255, 69, 0);        triangle(-1, -70, 1, -70, 0, -60);        // scarf        fill(160, 32, 240);        stroke(160, 32, 240);        ellipse(-20, -52, 12, 12);        rect(0, -52, 40, 12);        ellipse(20, -52, 12, 12);        for (int i = 0; i < 14; i = i + 2) {            line(4 + i, -21, 4 + i, -26);        }        rect(10, -42, 12, 30);        popMatrix();    }    void update() {        if (discoCount == 10) {            // if all 10 snowmans are in discoMode move arms up by 60 pixels            armsY = -60;        } else {            // if not all 10 snowmans are in discoMode move arms back to 0            armsY = 0;        }    }    void move() {        float xspeed = 1;        // move snowmanX with xspeed        snowmanX = snowmanX + xspeed;        if (snowmanX > width + 75) {            // when the snowman is out of the frame, move snowman back to -75, so snowman will move back into the screen            snowmanX = -75;        }    }    void changeColor() {        if (// the mouse clicks on the body of the snowman        dist(snowmanX, snowmanY, mouseX, mouseY) <= 50 || // the mouse clicks on the head of the snowman        dist(snowmanX, snowmanY - 70, mouseX, mouseY) <= 20 || dist(snowmanX, snowmanY - 110, mouseX, mouseY) <= 20) {            // the mouse clicks on the hat of the snowman            // set discoMode to not discoMode, boolean discomode = false will be true            discoMode = !discoMode;        }    }}',correct
'discoCount = 0',correct
'bodyColorBlack = color(random(255), random(255), random(255))',correct
'{    // then telling the snowmans how many snowmans are in discoMode    snowman[i].discoCount = discoCount;}',correct
'// float speedX;                                                       //the code for letting the snowmans bounce off the walls',correct
'ellipse(20, -52, 12, 12)',correct
'background(205, 235, 255)',correct
'// if ((snowmanX >= width-50 && speedX >=0)||(snowmanX <= 50 && speedX <= 0)) {',correct
'triangle(-1, -70, 1, -70, 0, -60)',correct
'-30',correct
'if (snowmanX > width + 75) {    // when the snowman is out of the frame, move snowman back to -75, so snowman will move back into the screen    snowmanX = -75;}',correct
'void mouseClicked() {    discoCount = 0;    for (int i = 0; i < 10; i++) {        // call function changeColor for every snowman        snowman[i].changeColor();        if (snowman[i].discoMode) {            // discoCount +1            discoCount++;        // first counting how many snowmans are in discoMode        }    }    for (int i = 0; i < 10; i++) {        // then telling the snowmans how many snowmans are in discoMode        snowman[i].discoCount = discoCount;    }}',correct
'// the mouse clicks on the hat of the snowman// set discoMode to not discoMode, boolean discomode = false will be truediscoMode = !discoMode;',correct
'{    float xspeed = 1;    // move snowmanX with xspeed    snowmanX = snowmanX + xspeed;    if (snowmanX > width + 75) {        // when the snowman is out of the frame, move snowman back to -75, so snowman will move back into the screen        snowmanX = -75;    }}',correct
'{    // if not all 10 snowmans are in discoMode move arms back to 0    armsY = 0;}',correct
'// Feline Waardenburg s2157993// creating an array of 11 snowmansCreature[] snowman = new Creature[10];',correct
'color(0)',correct
'Creature[]',correct
'ellipse(-20, -52, 12, 12);',correct
'display',LongMethodRule
'i = i + 2',correct
'-41',correct
'-42',correct
'draw',correct
'int bodyColorWhite;',correct
'new Creature(50 + i * 150, 250)',correct
'// first counting how many snowmans are in discoMode',correct
'if (// the mouse clicks on the body of the snowmandist(snowmanX, snowmanY, mouseX, mouseY) <= 50 || // the mouse clicks on the head of the snowmandist(snowmanX, snowmanY - 70, mouseX, mouseY) <= 20 || dist(snowmanX, snowmanY - 110, mouseX, mouseY) <= 20) {    // the mouse clicks on the hat of the snowman    // set discoMode to not discoMode, boolean discomode = false will be true    discoMode = !discoMode;}',correct
'void setup() {    rectMode(CENTER);    ellipseMode(CENTER);    // for i 0 through 9, make a new snowman, place the snowmans 150 pixels after each other    for (int i = 0; i < 10; i++) {        snowman[i] = new Creature(50 + i * 150, 250);    }}',correct
'// buttonsfor (int i = -10; i <= 10; i = i + 20) {    ellipse(0, i, 7, 7);}',correct
'fill(bodyColorWhite)',correct
'snowmanY',correct
'snowmanX',correct
'ellipse(i, -75, 5, 5);',correct
'float xspeed = 1',correct
'fill(bodyColorBlack)',correct
'i = i + 10',correct
'stroke(bodyColorBlack);',correct
'float initX',correct
'float initY',correct
'// float speedY;                                                       //the code for letting the snowmans bounce off the walls',correct
'i++',correct
'{    if (// the mouse clicks on the body of the snowman    dist(snowmanX, snowmanY, mouseX, mouseY) <= 50 || // the mouse clicks on the head of the snowman    dist(snowmanX, snowmanY - 70, mouseX, mouseY) <= 20 || dist(snowmanX, snowmanY - 110, mouseX, mouseY) <= 20) {        // the mouse clicks on the hat of the snowman        // set discoMode to not discoMode, boolean discomode = false will be true        discoMode = !discoMode;    }}',correct
'-52',correct
'for (int i = 0; i < 10; i++) {    // then telling the snowmans how many snowmans are in discoMode    snowman[i].discoCount = discoCount;}',correct
'ellipseMode(CENTER)',correct
'discoMode = false',correct
'ellipse(i, -75, 5, 5)',correct
'void',correct
'snowmanX = snowmanX + xspeed',correct
'-1',correct
'{    // display every snowman 0 through 9    snowman[i].display();    // move every snowman 0 through 9    snowman[i].move();    // update every snowman 0 thorugh 9    snowman[i].update();}',correct
'bodyColorWhite',correct
'i <= 5',correct
'// Feline Waardenburg s2157993',correct
'stroke(bodyColorWhite);',correct
'-60',correct
'-5',correct
'stroke(160, 32, 240)',correct
'{    snowman[i] = new Creature(50 + i * 150, 250);}',correct
'mouseClicked',correct
'stroke(bodyColorBlack)',correct
'snowman[i]',correct
'snowman = new Creature[10]',correct
'translate(snowmanX, snowmanY);',correct
'snowman[i] = new Creature(50 + i * 150, 250);',correct
'popMatrix()',correct
'ellipse(-20, -52, 12, 12)',correct
'-70',correct
'// the mouse clicks on the hat of the snowman',correct
'// speedY = random(0,3);                                            //the code for letting the snowmans bounce off the walls',correct
'[10]',correct
'-75',correct
'{    if (discoCount == 10) {        // if all 10 snowmans are in discoMode move arms up by 60 pixels        armsY = -60;    } else {        // if not all 10 snowmans are in discoMode move arms back to 0        armsY = 0;    }}',correct
'float discoCount;',correct
'stroke(255, 69, 0);',correct
'// nosefill(255, 69, 0);',correct
'rect(0, -90, 50, 10);',correct
'rect(0, -90, 50, 10)',correct
'fill(bodyColorWhite);',correct
'move',correct
'// speedY = speedY *-1;',correct
'i = i + 20',correct
'rect(0, -52, 40, 12);',correct
'// the code for letting the snowmans bounce off the walls:',correct
'bodyColorWhite = color(255);',correct
'line(4 + i, -21, 4 + i, -26);',correct
'line(4 + i, -21, 4 + i, -26)',correct
'{    ellipse(i, -75, 5, 5);}',correct
'armsY = -60',correct
'snowmanY = initY;',correct
'{    // when the snowman is in discoMode set:    // black->randomcolor    bodyColorBlack = color(random(255), random(255), random(255));}',correct
'int i = -10',correct
'snowman[i].changeColor()',correct
'for (int i = 0; i < 10; i++) {    // display every snowman 0 through 9    snowman[i].display();    // move every snowman 0 through 9    snowman[i].move();    // update every snowman 0 thorugh 9    snowman[i].update();}',correct
'carModel(car3X, car3Y, green)',correct
'lights = !lights;',correct
'void secondCar() {    car2Y = carY + 200;    car2X = car2X + 6;    carModel(car2X, car2Y, blue);    movement();    if (car2X > 1800) {        car2X = -300;    }}',correct
'carX + 135',correct
'carY + 65',correct
'carY + 100',correct
'action = new car();',correct
'{    car2Y = carY + 200;    car2X = car2X + 6;    carModel(car2X, car2Y, blue);    movement();    if (car2X > 1800) {        car2X = -300;    }}',correct
'stripes',correct
'float car3X;',correct
'float stripeX;',correct
'car2X + 6',correct
'triangle(carX - 60, carY, carX - 20, carY, carX - 20, carY - 80)',correct
'action.mainCar();',correct
'rect(stripeX, 0, 50, 100);',PixelHardcodeIgnoranceRule
'{    action = new car();    for (int i = 0; i < stripes.length; i++) {        stripes[i] = new stripes(i * 75);    }}',correct
'carX + 140',correct
'if (car3X > 1500) {    car3X = -200;}',correct
'rect(carX + 42, carY - 75, 58, 75);',correct
'drawKeys()',correct
'',correct
'PImage img;',correct
'rect(carX - 20, carY - 80, 120, 80)',correct
'car3X = -200;',correct
'{    stripes[i] = new stripes(i * 75);}',correct
'void stripe() {    fill(255, 204, 0);    rect(stripeX, stripeY - 25, 50, 25);    rect(stripeX, stripeY + 175, 50, 25);    fill(80);    rect(stripeX, 0, 50, 100);    stripeX = stripeX - 7;    if (stripeX < -50) {        stripeX = 1000;    }}',correct
'float car3Y;',correct
'carY = 300 + 10 * sin(radians(x / 0.8f))',correct
'carX = carX + 5',correct
'-300',correct
'// bumperfill(65);',correct
'color(255, 0, 0)',correct
'carX = carX + 20',correct
'carX + 150',correct
'carY = 300 + 10 * sin(radians(x / 0.8f));',correct
'A',correct
'stripeX = start;',correct
'{    car2X = -300;}',correct
'D',correct
'if (keyPressed) {    if (key == l || key == L) {        lights = !lights;    }}',DecentralizedEventHandlingRule
'L',correct
'stripes[i].stripe()',correct
'PImage',correct
'carModel(car2X, car2Y, blue);',correct
'fill(65)',correct
'[15]',correct
'{    car3Y = carY - 200;    car3X = car3X + 3;    carModel(car3X, car3Y, green);    movement();    if (car3X > 1500) {        car3X = -200;    }}',correct
'color(0, 255, 0)',correct
'car2X = car2X + 6;',correct
'carX - 50',correct
'stripeX = 1000',correct
'carX - 55',correct
'lights = false',correct
'a',correct
'd',correct
'int green;',correct
'l',correct
'car2X = 0;',correct
'-200',correct
'for (int i = 0; i < stripes.length; i++) {    stripes[i].stripe();}',correct
'float stripeY;',correct
'blue',correct
'radians(x / 0.8f)',correct
'{    carX = carX - 2;}',correct
'carX - 60',correct
'x',correct
'stripeY',correct
'{    background(0);    for (int i = 0; i < stripes.length; i++) {        stripes[i].stripe();    }    action.thirdCar();    action.mainCar();    action.secondCar();}',correct
'triangle(carX - 55, carY, carX - 20, carY, carX - 20, carY - 75);',correct
'stripeX',correct
'stripes[i].stripe();',correct
'sin(radians(x / 0.8f))',correct
'key == l || key == L',correct
'key ==',correct
'key == d || key == D',correct
'boolean lights = false;',correct
'!lights',correct
'red',correct
'car2X = -300;',correct
'lights = !lights',correct
'action.thirdCar();',correct
'car2X',correct
'if (carX > 1100) {    carX = -200;}',correct
'car2Y',correct
'key == L',correct
'void light() {    if (lights) {        fill(255, 204, 0);        rect(carX + 200, carY + 25, 500, 25);    }}',correct
'movement()',correct
'carX + 5',correct
'car() {    img = loadImage("turbo.png");    car2X = 0;    ellipseMode(CENTER);    blue = color(0, 0, 230);    red = color(255, 0, 0);    green = color(0, 255, 0);}',correct
'carX + 100',correct
'{    car3X = -200;}',correct
'key == D',correct
'void draw() {    background(0);    for (int i = 0; i < stripes.length; i++) {        stripes[i].stripe();    }    action.thirdCar();    action.mainCar();    action.secondCar();}',correct
'triangle(carX - 55, carY, carX - 20, carY, carX - 20, carY - 75)',correct
'stripeX = stripeX - 7;',correct
'car2X = 0',correct
'key == A',correct
'fill(r)',correct
'stripes[i]',correct
'carX = carX - 2',correct
'height / 2',correct
'action.mainCar()',correct
'fill(255, 204, 0)',correct
'img = loadImage("turbo.png")',correct
'// bottom partrect(carX - 100, carY, 300, 100);',correct
'int start',correct
'light()',correct
'rect(stripeX, stripeY + 175, 50, 25)',correct
'rect(carX + 200, carY + 25, 500, 25);',correct
'carX + 20',correct
'{    carX = carX + 5;}',correct
'if (key == d || key == D) {    carX = carX + 5;}',DecentralizedEventHandlingRule
'{    if (keyPressed) {        if (key == d || key == D) {            carX = carX + 5;        }    }    if (keyPressed) {        if (key ==  ) {            carX = carX + 20;            image(img, 200, 200, 600, 200);        }    }    if (keyPressed) {        if (key == a || key == A) {            carX = carX - 2;        }    }    if (keyPressed) {        if (key == l || key == L) {            lights = !lights;        }    }}',correct
'float x;',correct
'float carX = width / 2;',correct
'fill(255)',correct
'rect(carX - 20, carY - 75, 58, 75);',correct
'car3X = car3X + 3',correct
'carY + 200',correct
'Processing',correct
'float car2X;',correct
'x = x + 1',correct
'color(0, 0, 230)',correct
'red = color(255, 0, 0);',correct
'{    if (lights) {        fill(255, 204, 0);        rect(carX + 200, carY + 25, 500, 25);    }}',correct
'for (int i = 0; i < stripes.length; i++) {    stripes[i] = new stripes(i * 75);}',correct
'void mainCar() {    carModel(carX, carY, red);    movement();    if (carX > 1100) {        carX = -200;    }    drawKeys();    light();}',correct
'stripeX < -50',correct
'300 + 10 * sin(radians(x / 0.8f))',correct
'stripeX - 7',correct
'if (keyPressed) {    if (key ==  ) {        carX = carX + 20;        image(img, 200, 200, 600, 200);    }}',DecentralizedEventHandlingRule
'car2X = car2X + 6',correct
'green',correct
'carX + 200',correct
'false',correct
'int blue;',correct
'i * 75',correct
'carY - 75',correct
'car3X > 1500',correct
'car2X > 1800',correct
'if (key ==  ) {    carX = carX + 20;    image(img, 200, 200, 600, 200);}',DecentralizedEventHandlingRule
'float car2Y;',correct
'int i = 0',correct
'ellipseMode(CENTER);',correct
'stripeX = stripeX - 7',correct
'triangle(carX + 100, carY, carX + 135, carY, carX + 100, carY - 75)',correct
'fill(80);',correct
'car3X',correct
'image(img, 200, 200, 600, 200);',correct
'car3Y',correct
'{    stripeX = start;    stripeY = height / 2;}',correct
'carY - 80',correct
'i = 0',correct
'{    fill(r);    // bottom part    rect(carX - 100, carY, 300, 100);    // sides of top part    triangle(carX - 60, carY, carX - 20, carY, carX - 20, carY - 80);    triangle(carX + 100, carY, carX + 140, carY, carX + 100, carY - 80);    // middle of top part    rect(carX - 20, carY - 80, 120, 80);    // bumper    fill(65);    rect(carX + 190, carY + 65, 30, 40);    // wheels    fill(255);    ellipse(carX - 50, carY + 100, 75, 75);    ellipse(carX + 150, carY + 100, 75, 75);    // windows    fill(50, 55, 100);    rect(carX - 20, carY - 75, 58, 75);    rect(carX + 42, carY - 75, 58, 75);    triangle(carX - 55, carY, carX - 20, carY, carX - 20, carY - 75);    triangle(carX + 100, carY, carX + 135, carY, carX + 100, carY - 75);}',ShortVariable
'rect(stripeX, stripeY + 175, 50, 25);',correct
'i < stripes.length',correct
'{    fill(255, 204, 0);    rect(carX + 200, carY + 25, 500, 25);}',correct
'loadImage("turbo.png")',correct
'fill(255, 204, 0);',correct
'class car {    float x;    int blue;    int red;    int green;    float carX = width / 2;    float carY = height / 2;    float car2X;    float car2Y;    float car3X;    float car3Y;    boolean lights = false;    PImage img;    car() {        img = loadImage("turbo.png");        car2X = 0;        ellipseMode(CENTER);        blue = color(0, 0, 230);        red = color(255, 0, 0);        green = color(0, 255, 0);    }    void mainCar() {        carModel(carX, carY, red);        movement();        if (carX > 1100) {            carX = -200;        }        drawKeys();        light();    }    void secondCar() {        car2Y = carY + 200;        car2X = car2X + 6;        carModel(car2X, car2Y, blue);        movement();        if (car2X > 1800) {            car2X = -300;        }    }    void thirdCar() {        car3Y = carY - 200;        car3X = car3X + 3;        carModel(car3X, car3Y, green);        movement();        if (car3X > 1500) {            car3X = -200;        }    }    void carModel(float carX, float carY, int r) {        fill(r);        // bottom part        rect(carX - 100, carY, 300, 100);        // sides of top part        triangle(carX - 60, carY, carX - 20, carY, carX - 20, carY - 80);        triangle(carX + 100, carY, carX + 140, carY, carX + 100, carY - 80);        // middle of top part        rect(carX - 20, carY - 80, 120, 80);        // bumper        fill(65);        rect(carX + 190, carY + 65, 30, 40);        // wheels        fill(255);        ellipse(carX - 50, carY + 100, 75, 75);        ellipse(carX + 150, carY + 100, 75, 75);        // windows        fill(50, 55, 100);        rect(carX - 20, carY - 75, 58, 75);        rect(carX + 42, carY - 75, 58, 75);        triangle(carX - 55, carY, carX - 20, carY, carX - 20, carY - 75);        triangle(carX + 100, carY, carX + 135, carY, carX + 100, carY - 75);    }    void movement() {        x = x + 1;        carY = 300 + 10 * sin(radians(x / 0.8f));    }    void light() {        if (lights) {            fill(255, 204, 0);            rect(carX + 200, carY + 25, 500, 25);        }    }    void drawKeys() {        if (keyPressed) {            if (key == d || key == D) {                carX = carX + 5;            }        }        if (keyPressed) {            if (key ==  ) {                carX = carX + 20;                image(img, 200, 200, 600, 200);            }        }        if (keyPressed) {            if (key == a || key == A) {                carX = carX - 2;            }        }        if (keyPressed) {            if (key == l || key == L) {                lights = !lights;            }        }    }}',correct
'car3X + 3',correct
'rect(carX + 42, carY - 75, 58, 75)',correct
'float carY = height / 2;',correct
'car3Y = carY - 200;',correct
'background(0)',correct
'stripes[i] = new stripes(i * 75)',correct
'if (car2X > 1800) {    car2X = -300;}',correct
'rect(stripeX, stripeY - 25, 50, 25);',correct
'void movement() {    x = x + 1;    carY = 300 + 10 * sin(radians(x / 0.8f));}',correct
'action',correct
'rect(carX - 100, carY, 300, 100)',correct
'{    if (key == l || key == L) {        lights = !lights;    }}',correct
'carX - 2',correct
'void carModel(float carX, float carY, int r) {    fill(r);    // bottom part    rect(carX - 100, carY, 300, 100);    // sides of top part    triangle(carX - 60, carY, carX - 20, carY, carX - 20, carY - 80);    triangle(carX + 100, carY, carX + 140, carY, carX + 100, carY - 80);    // middle of top part    rect(carX - 20, carY - 80, 120, 80);    // bumper    fill(65);    rect(carX + 190, carY + 65, 30, 40);    // wheels    fill(255);    ellipse(carX - 50, carY + 100, 75, 75);    ellipse(carX + 150, carY + 100, 75, 75);    // windows    fill(50, 55, 100);    rect(carX - 20, carY - 75, 58, 75);    rect(carX + 42, carY - 75, 58, 75);    triangle(carX - 55, carY, carX - 20, carY, carX - 20, carY - 75);    triangle(carX + 100, carY, carX + 135, carY, carX + 100, carY - 75);}',correct
'{    x = x + 1;    carY = 300 + 10 * sin(radians(x / 0.8f));}',correct
'new stripes(i * 75)',correct
'stripes(int start) {    stripeX = start;    stripeY = height / 2;}',correct
'if (keyPressed) {    if (key == a || key == A) {        carX = carX - 2;    }}',DecentralizedEventHandlingRule
'new car()',correct
'{    carX = carX + 20;    image(img, 200, 200, 600, 200);}',correct
'// windowsfill(50, 55, 100);',correct
'carModel(carX, carY, red);',correct
'ellipse(carX - 50, carY + 100, 75, 75)',correct
'// middle of top partrect(carX - 20, carY - 80, 120, 80);',correct
'action.secondCar();',correct
'key == l',correct
'if (stripeX < -50) {    stripeX = 1000;}',correct
'car2Y = carY + 200',correct
'class stripes {    float stripeX;    float stripeY;    stripes(int start) {        stripeX = start;        stripeY = height / 2;    }    void stripe() {        fill(255, 204, 0);        rect(stripeX, stripeY - 25, 50, 25);        rect(stripeX, stripeY + 175, 50, 25);        fill(80);        rect(stripeX, 0, 50, 100);        stripeX = stripeX - 7;        if (stripeX < -50) {            stripeX = 1000;        }    }}',correct
'void thirdCar() {    car3Y = carY - 200;    car3X = car3X + 3;    carModel(car3X, car3Y, green);    movement();    if (car3X > 1500) {        car3X = -200;    }}',correct
'car2X = -300',correct
'key == d',correct
'drawKeys();',correct
'if (keyPressed) {    if (key == d || key == D) {        carX = carX + 5;    }}',DecentralizedEventHandlingRule
'stripeY - 25',correct
'key == a',correct
'triangle(carX + 100, carY, carX + 135, carY, carX + 100, carY - 75);',correct
'car2Y = carY + 200;',correct
'{    if (key == d || key == D) {        carX = carX + 5;    }}',correct
'red = color(255, 0, 0)',correct
'{    img = loadImage("turbo.png");    car2X = 0;    ellipseMode(CENTER);    blue = color(0, 0, 230);    red = color(255, 0, 0);    green = color(0, 255, 0);}',correct
'if (key == l || key == L) {    lights = !lights;}',DecentralizedEventHandlingRule
'{    stripes[i].stripe();}',correct
'green = color(0, 255, 0);',correct
'{    carModel(carX, carY, red);    movement();    if (carX > 1100) {        carX = -200;    }    drawKeys();    light();}',correct
'carModel(carX, carY, red)',correct
'void drawKeys() {    if (keyPressed) {        if (key == d || key == D) {            carX = carX + 5;        }    }    if (keyPressed) {        if (key ==  ) {            carX = carX + 20;            image(img, 200, 200, 600, 200);        }    }    if (keyPressed) {        if (key == a || key == A) {            carX = carX - 2;        }    }    if (keyPressed) {        if (key == l || key == L) {            lights = !lights;        }    }}',correct
'int red;',correct
'background(0);',correct
'blue = color(0, 0, 230)',correct
'fill(50, 55, 100)',correct
'{    carX = -200;}',correct
'if (key == a || key == A) {    carX = carX - 2;}',DecentralizedEventHandlingRule
'10 * sin(radians(x / 0.8f))',correct
'triangle(carX + 100, carY, carX + 140, carY, carX + 100, carY - 80)',correct
'carX = carX + 20;',correct
'carX = -200;',correct
'rect(carX + 190, carY + 65, 30, 40);',correct
'movement();',correct
'int r',correct
'fill(80)',correct
'stripes[]',correct
'car3X = car3X + 3;',correct
'x + 1',correct
'carX + 42',correct
'carX - 100',correct
'image(img, 200, 200, 600, 200)',correct
'-50',correct
'fill(r);',correct
'i++',correct
'new stripes[15]',correct
'triangle(carX + 100, carY, carX + 140, carY, carX + 100, carY - 80);',correct
'car3Y = carY - 200',correct
'stripes.length',correct
'ellipseMode(CENTER)',correct
'carModel(car2X, car2Y, blue)',correct
'carX = carX + 5;',correct
'carY + 25',correct
'light();',correct
'stripeX = 1000;',correct
'stripes[i] = new stripes(i * 75);',correct
'{    if (key ==  ) {        carX = carX + 20;        image(img, 200, 200, 600, 200);    }}',correct
'void',correct
'rect(stripeX, 0, 50, 100)',correct
'float carX',correct
'{    fill(255, 204, 0);    rect(stripeX, stripeY - 25, 50, 25);    rect(stripeX, stripeY + 175, 50, 25);    fill(80);    rect(stripeX, 0, 50, 100);    stripeX = stripeX - 7;    if (stripeX < -50) {        stripeX = 1000;    }}',correct
'float carY',correct
'carY - 200',correct
'action = new car()',correct
'stripeY = height / 2;',correct
'stripeY = height / 2',correct
'carX + 190',correct
'stripeX = start',correct
'stripes[] stripes = new stripes[15];',correct
'{    if (key == a || key == A) {        carX = carX - 2;    }}',correct
'action.secondCar()',correct
'action.thirdCar()',correct
'0.8f',correct
'key == a || key == A',correct
'car3X = -200',correct
'green = color(0, 255, 0)',correct
'img',correct
'x / 0.8f',correct
'{    lights = !lights;}',correct
'carModel(car3X, car3Y, green);',correct
'carY = height / 2',correct
'stripeY + 175',correct
'blue = color(0, 0, 230);',correct
'// wheelsfill(255);',correct
'carX > 1100',correct
'{    stripeX = 1000;}',correct
'x = x + 1;',correct
'car',correct
'img = loadImage("turbo.png");',correct
'rect(carX + 190, carY + 65, 30, 40)',correct
'carX = -200',correct
'void setup() {    action = new car();    for (int i = 0; i < stripes.length; i++) {        stripes[i] = new stripes(i * 75);    }}',correct
'car action;',correct
'ellipse(carX + 150, carY + 100, 75, 75);',correct
'ellipse(carX + 150, carY + 100, 75, 75)',correct
'if (lights) {    fill(255, 204, 0);    rect(carX + 200, carY + 25, 500, 25);}',correct
'stripes = new stripes[15]',correct
'// sides of top parttriangle(carX - 60, carY, carX - 20, carY, carX - 20, carY - 80);',correct
'ellipse(carX - 50, carY + 100, 75, 75);',correct
'rect(carX - 20, carY - 75, 58, 75)',correct
'rect(carX + 200, carY + 25, 500, 25)',correct
'width / 2',correct
'rect(stripeX, stripeY - 25, 50, 25)',correct
'carX = carX - 2;',correct
'"turbo.png"',correct
'carX = width / 2',correct
'carX - 20',correct
'carModel',ShortVariable
